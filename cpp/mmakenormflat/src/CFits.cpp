/**
author: Andreas Ritter
created: 01/12/2007
last edited: 01/12/2007
compiler: g++ 4.0
basis machine: Ubuntu Linux 6.06
*/
#include "CFits.h"

CFits::CFits()
    : CAny()
{
  this->P_CS_LogFileName = new CString(DEBUGDIR);
  *P_CS_LogFileName += CString("logfile_CFits.log");
  //  this->P_F_LogFile = fopen(this->P_CS_LogFileName->Get(), "w");
  P_OFS_Log = new ofstream(this->P_CS_LogFileName->Get());
  /// NApertures
  this->I_NApertures = 1;

  this->ArrayInitialized = false;

  /// ClassName
  //this->ClassName = new char[255];
  this->ClassName = strdup("CFits");

  /// FileName
  this->P_CS_FileName  = new CString("\0");

  /// FileName
  this->P_CS_ErrFileName  = new CString("\0");

  /// DatabaseFileName
  this->P_CS_DatabaseFileName  = new CString("\0");

  /// NCols
  this->NCols = 10;

  /// NRows
  this->NRows = 10;

  /// DispAxis
  I_DispAxis = 1;

  /// Gain
  D_Gain = 1.;

  /// ReadOutNoise
  D_ReadOutNoise = 1.;

  /// OverSample
  I_OverSample = 10;

  /// MaxIterSF
  I_MaxIterSF = 8;

  /// MaxIterSky
  I_MaxIterSky = 12;

  /// MaxIterSig
  I_MaxIterSig = 3;

  /// PixArray
  this->P_D_A2_PixArray = new Array<double, 2>(this->NRows, this->NCols);
  *this->P_D_A2_PixArray = 0.;

  /// ProfArray
  this->P_D_A2_ProfArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_ProfArray) = 0.;

  /// ErrArray
  this->P_D_A2_ErrArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_ErrArray) = 0.;

  /// RecSkyArray
  this->P_D_A2_RecSkyArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecSkyArray) = 0.;
//  this->P_D_A2_RecSkyFitArray = new Array<double, 2>(this->NRows, this->NCols);
//  (*this->P_D_A2_RecSkyFitArray) = 0.;

  /// Reconstructed array
  this->P_D_A2_RecArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecArray) = 0.;

  /// Reconstructed array from Fit
  this->P_D_A2_RecFitArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecFitArray) = 0.;

  this->P_D_A2_RecSkyFitArray = new Array<double, 2>(this->NRows, this->NCols);
  *(this->P_D_A2_RecSkyFitArray) = 0.;/// NRows x NCols

  /// MaskArray
  this->P_I_A2_MaskArray = new Array<int, 2>(this->NRows, this->NCols);
  (*this->P_I_A2_MaskArray) = 1;

  /// Coeffs
  this->P_D_A2_Coeffs = new Array<double, 2>(this->I_NApertures, 3);
  *this->P_D_A2_Coeffs = 0.;

  /// Blaze Functions
  this->P_D_A2_Blaze = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Blaze = 0.;

  /// Blaze Functions from Fit
  this->P_D_A2_SP_Fit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_SP_Fit = 0.;

  /// extracted errors
  this->P_D_A2_LastExtracted = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_LastExtracted = 0.;

  /// extracted errors
  this->P_D_A2_Errors_Ec = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Errors_Ec = 0.;

  /// sky
  this->P_D_A2_Sky = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Sky = 0.;

  /// sky error
  this->P_D_A2_SkyError = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_SkyError = 0.;
  this->P_D_A2_SkyFitError = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_SkyFitError) = 0.;
  this->P_D_A2_SkyFit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_SkyFit) = 0.;
  this->P_D_A2_Errors_EcFit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_Errors_EcFit) = 0.;

  /// Wavelength
  this->P_D_A2_WLen = new Array<double, 2>(this->NRows, this->NCols);
  (*(this->P_D_A2_WLen)) = 0.;

  /// XCenters
  this->P_D_A2_XCenters = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_XCenters = 0.;

  /// XCenter
  this->P_D_A1_XCenter = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XCenter = 0.;

  /// YCenter
  this->P_D_A1_YCenter = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YCenter = 0.;

  /// XLow
  this->P_D_A1_XLow = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XLow = 0.;

  /// XHigh
  this->P_D_A1_XHigh = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XHigh = 0.;

  /// YLow
  this->P_D_A1_YLow = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YLow = 0.;

  /// YHigh
  this->P_D_A1_YHigh = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YHigh = 0.;

  /// Orders
  this->P_I_A1_Orders = new Array<int, 1>(this->I_NApertures);
  *this->P_I_A1_Orders = 0;

  /// NCoeffs
  this->P_I_A1_NCoeffs = new Array<int, 1>(this->I_NApertures);
  *this->P_I_A1_NCoeffs = 0;

  /// XMin
  P_D_A1_XMin = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XMin = 0.;

  /// XMax
  P_D_A1_XMax = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XMax = 0.;

  /// Functions
  /// realloc when database entry is read
  P_CS_A1_Functions = new Array<CString, 1>(this->I_NApertures);
  //  PP_CS_A1_Functions = (CString**)malloc(sizeof(CString*) * this->I_NApertures);
  //  for (int m = 0; m < I_NApertures; m++)
  //    PP_CS_A1_Functions[m] = new CString();

  this->TraceFunctionsCalculated = false;
  this->ProfileCalculated = false;
  this->ErrorsRead = false;

  this->ApplyDimension();

#ifdef __DEBUG_FITS_CONSTRUCTORS__
  cout << "CFits::CFits(): End: this = " << *this << endl;
  (*P_OFS_Log) << "CFits::CFits(): End: this = " << *this << endl;
#endif
}

/***********************************************************************/

CFits::CFits(const CString &fn, int nrow, int ncol)
    : CAny()
{
  this->P_CS_LogFileName = new CString(DEBUGDIR);
  *P_CS_LogFileName += CString("logfile_CFits.log");
  //this->P_F_LogFile = fopen(this->P_CS_LogFileName->Get(), "w");
  this->P_OFS_Log = new ofstream(this->P_CS_LogFileName->Get());

  this->ArrayInitialized = false;

  /// ClassName
  //this->ClassName = new char[255];
  this->ClassName = strdup("CFits");

  /// FileName
  this->P_CS_FileName = new CString();
  P_CS_FileName->Copy(fn);
#ifdef __DEBUG_FITS_CONSTRUCTORS__
  cout << "CFits.CFits(CString fn=" << fn.Get() << "): P_CS_FileName set to <" << this->P_CS_FileName->Get() << ">" << endl;
  (*P_OFS_Log) << "CFits.CFits(CString fn=" << fn.Get() << "): P_CS_FileName set to <" << this->P_CS_FileName->Get() << ">" << endl;
#endif

  /// ErrFileName
  this->P_CS_ErrFileName = new CString("\0");

  /// DatabaseFileName
  this->P_CS_DatabaseFileName  = new CString("\0");

  /// NApertures
  this->I_NApertures = 1;

  /// NCols
  this->NCols = ncol;

  /// NRows
  this->NRows = nrow;

  /// DispAxis
  I_DispAxis = 1;

  /// Gain
  D_Gain = 1.;

  /// ReadOutNoise
  D_ReadOutNoise = 1.;

  /// OverSample
  I_OverSample = 10;

  /// MaxIterSF
  I_MaxIterSF = 8;

  /// MaxIterSky
  I_MaxIterSky = 12;

  /// MaxIterSig
  I_MaxIterSig = 3;

  /// PixArray
  this->P_D_A2_PixArray = new Array<double, 2>(this->NRows, this->NCols);
  *this->P_D_A2_PixArray = 0.;

  /// ProfArray
  this->P_D_A2_ProfArray = new Array<double, 2>(this->NRows, this->NCols);
  *this->P_D_A2_ProfArray = 0.;

  /// ErrArray
  this->P_D_A2_ErrArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_ErrArray) = 0.;

  /// RecSkyArray
  this->P_D_A2_RecSkyArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecSkyArray) = 0.;

  /// Reconstructed array
  this->P_D_A2_RecArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecArray) = 0.;

  /// Reconstructed array from Fit
  this->P_D_A2_RecFitArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecFitArray) = 0.;

  /// MaskArray
  this->P_I_A2_MaskArray = new Array<int, 2>(this->NRows, this->NCols);
  (*this->P_I_A2_MaskArray) = 1;

  /// Coeffs
  this->P_D_A2_Coeffs = new Array<double, 2>(this->I_NApertures, 3);
  *this->P_D_A2_Coeffs = 0.;

  /// Blaze Functions
  this->P_D_A2_Blaze = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Blaze = 0.;

  /// Blaze Functions from Fit
  this->P_D_A2_SP_Fit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_SP_Fit = 0.;

  /// extracted Functions
  this->P_D_A2_LastExtracted = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_LastExtracted = 0.;

  /// extracted errors
  this->P_D_A2_Errors_Ec = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Errors_Ec = 0.;

  /// sky
  this->P_D_A2_Sky = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Sky = 0.;

  /// sky error
  this->P_D_A2_SkyError = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_SkyError = 0.;
  this->P_D_A2_SkyFitError = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_SkyFitError) = 0.;
  this->P_D_A2_SkyFit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_SkyFit) = 0.;
  this->P_D_A2_Errors_EcFit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_Errors_EcFit) = 0.;

  /// Wavelength
  this->P_D_A2_WLen = new Array<double, 2>(this->NRows, this->NCols);
  (*(this->P_D_A2_WLen)) = 0.;

  this->P_D_A2_RecSkyFitArray = new Array<double, 2>(this->NRows, this->NCols);
  *(this->P_D_A2_RecSkyFitArray) = 0.;/// NRows x NCols

  /// XCenters
  this->P_D_A2_XCenters = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_XCenters = 0.;

  /// XCenter
  this->P_D_A1_XCenter = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XCenter = 0.;

  /// YCenter
  this->P_D_A1_YCenter = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YCenter = 0.;

  /// XLow
  this->P_D_A1_XLow = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XLow = 0.;

  /// XHigh
  this->P_D_A1_XHigh = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XHigh = 0.;

  /// YLow
  this->P_D_A1_YLow = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YLow = 0.;

  /// YHigh
  this->P_D_A1_YHigh = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YHigh = 0.;

  /// Orders
  this->P_I_A1_Orders = new Array<int, 1>(this->I_NApertures);
  *this->P_I_A1_Orders = 0;

  /// NCoeffs
  this->P_I_A1_NCoeffs = new Array<int, 1>(this->I_NApertures);
  *this->P_I_A1_NCoeffs = 0;

  /// XMin
  this->P_D_A1_XMin = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XMin = 0.;

  /// XMax
  this->P_D_A1_XMax = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XMax = 0.;

  /// Functions
  /// realloc when database entry is read
  this->P_CS_A1_Functions = new Array<CString, 1>(this->I_NApertures);
  //  this->PP_CS_A1_Functions = (CString**)malloc(sizeof(CString*) * this->I_NApertures);
  //  for (int m = 0; m < I_NApertures; m++)
  //    PP_CS_A1_Functions[m] = new CString();


  this->TraceFunctionsCalculated = false;
  this->ProfileCalculated = false;
  this->ErrorsRead = false;

  this->ApplyDimension();

#ifdef __DEBUG_FITS_CONSTRUCTORS__
  cout << "CFits::CFits(): End: this = " << *this << endl;
  (*P_OFS_Log) << "CFits::CFits(): End: this = " << *this << endl;
#endif
}

/** **********************************************************/

CFits::CFits(const CFits &fit)
    : CAny()
{
  this->P_CS_LogFileName = new CString(DEBUGDIR);
  *P_CS_LogFileName += CString("logfile_CFits.log\0");
  //  this->P_F_LogFile = fopen(this->P_CS_LogFileName->Get(), "w");
  this->P_OFS_Log = new ofstream(this->P_CS_LogFileName->Get());

  this->ArrayInitialized = false;

  /// ClassName
  //this->ClassName = new char[255];
  this->ClassName = strdup("CFits");

  /// FileName
  this->P_CS_FileName = new CString();
  this->P_CS_FileName->Copy(fit.GetFileName());

  /// ErrFileName
  this->P_CS_ErrFileName = new CString();
  this->P_CS_ErrFileName->Copy(fit.GetErrFileName());

  /// DatabaseFileName
  this->P_CS_DatabaseFileName  = new CString("\0");

  /// NApertures
  this->I_NApertures = 1;

  /// NCols
  this->NCols = 10;

  /// NRows
  this->NRows = 10;

  /// DispAxis
  I_DispAxis = 1;

  /// Gain
  D_Gain = 1.;

  /// ReadOutNoise
  D_ReadOutNoise = 1.;

  /// OverSample
  I_OverSample = 10;

  /// MaxIterSF
  I_MaxIterSF = 8;

  /// MaxIterSky
  I_MaxIterSky = 12;

  /// MaxIterSig
  I_MaxIterSig = 3;

  /// PixArray
  this->P_D_A2_PixArray = new Array<double, 2>(this->NRows, this->NCols);
  *this->P_D_A2_PixArray = 0.;

  /// ProfArray
  this->P_D_A2_ProfArray = new Array<double, 2>(this->NRows, this->NCols);
  *this->P_D_A2_ProfArray = 0.;

  /// ErrArray
  this->P_D_A2_ErrArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_ErrArray) = 0.;

  /// RecSkyArray
  this->P_D_A2_RecSkyArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecSkyArray) = 0.;

  /// Reconstructed array
  this->P_D_A2_RecArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecArray) = 0.;

  /// Reconstructed array from Fit
  this->P_D_A2_RecFitArray = new Array<double, 2>(this->NRows, this->NCols);
  (*this->P_D_A2_RecFitArray) = 0.;

  /// MaskArray
  this->P_I_A2_MaskArray = new Array<int, 2>(this->NRows, this->NCols);
  (*this->P_I_A2_MaskArray) = 1;

  /// Coeffs
  Array<int, 1> *P_tempOrders = fit.Get_Orders();
  this->P_D_A2_Coeffs = new Array<double, 2>(this->I_NApertures, max(*P_tempOrders));
  *this->P_D_A2_Coeffs = 0.;
  delete(P_tempOrders);

  /// Blaze Functions
  this->P_D_A2_Blaze = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Blaze = 0.;

  /// Blaze Functions from Fit
  this->P_D_A2_SP_Fit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_SP_Fit = 0.;

  /// extracted Functions
  this->P_D_A2_LastExtracted = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_LastExtracted = 0.;

  /// extracted errors
  this->P_D_A2_Errors_Ec = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Errors_Ec = 0.;

  /// sky
  this->P_D_A2_Sky = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_Sky = 0.;

  /// sky error
  this->P_D_A2_SkyError = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_SkyError = 0.;
  this->P_D_A2_SkyFitError = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_SkyFitError) = 0.;
  this->P_D_A2_SkyFit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_SkyFit) = 0.;
  this->P_D_A2_Errors_EcFit = new Array<double, 2>(this->I_NApertures, this->NRows);
  *(this->P_D_A2_Errors_EcFit) = 0.;

  this->P_D_A2_RecSkyFitArray = new Array<double, 2>(this->NRows, this->NCols);
  *(this->P_D_A2_RecSkyFitArray) = 0.;/// NRows x NCols

  /// Wavelength
  this->P_D_A2_WLen = new Array<double, 2>(this->NRows, this->NCols);
  (*(this->P_D_A2_WLen)) = 0.;

  /// XCenters
  this->P_D_A2_XCenters = new Array<double, 2>(this->I_NApertures, this->NRows);
  *this->P_D_A2_XCenters = 0.;

  /// XCenter
  this->P_D_A1_XCenter = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XCenter = 0.;

  /// YCenter
  this->P_D_A1_YCenter = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YCenter = 0.;

  /// XLow
  this->P_D_A1_XLow = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XLow = 0.;

  /// XHigh
  this->P_D_A1_XHigh = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XHigh = 0.;

  /// YLow
  this->P_D_A1_YLow = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YLow = 0.;

  /// YHigh
  this->P_D_A1_YHigh = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_YHigh = 0.;

  /// Orders
  this->P_I_A1_Orders = new Array<int, 1>(this->I_NApertures);
  *this->P_I_A1_Orders = 0;

  /// NCoeffs
  this->P_I_A1_NCoeffs = new Array<int, 1>(this->I_NApertures);
  *this->P_I_A1_NCoeffs = 0;

  /// XMin
  this->P_D_A1_XMin = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XMin = 0.;

  /// XMax
  this->P_D_A1_XMax = new Array<double, 1>(this->I_NApertures);
  *this->P_D_A1_XMax = 0.;

  /// Functions
  /// realloc when database entry is read
  this->P_CS_A1_Functions = new Array<CString, 1>(this->I_NApertures);
  //this->PP_CS_A1_Functions = (CString**)malloc(sizeof(CString*) * this->I_NApertures);
  //for (int m = 0; m < I_NApertures; m++)
  //  PP_CS_A1_Functions[m] = new CString();

  this->TraceFunctionsCalculated = false;
  this->ProfileCalculated = false;
  this->ErrorsRead = false;

  this->ApplyDimension();

  if (!this->Copy(fit))
  {
#ifdef __DEBUG_FITS_CONSTRUCTORS__
    cout << "CFits::CFits(CFits): this->Copy(fit) retuned FALSE !!!!!!!!" << endl;
    (*P_OFS_Log) << "CFits::CFits(CFits): this->Copy(fit) retuned FALSE !!!!!!!!" << endl;
#endif

  }
#ifdef __DEBUG_FITS_CONSTRUCTORS__
  cout << "CFits::CFits(CFits=" << fit << "): End: this = " << *this << endl;
  (*P_OFS_Log) << "CFits::CFits(CFits=" << fit << "): End: this = " << *this << endl;
#endif
}

/** *******************************************************/

CFits::~CFits()
{
  delete this->P_CS_LogFileName;
  delete this->P_OFS_Log;
  delete this->P_CS_FileName;
  delete this->P_CS_ErrFileName;
  delete this->P_CS_DatabaseFileName;
  delete this->P_D_A2_PixArray;
  delete this->P_D_A2_ProfArray;
  delete this->P_D_A2_ErrArray;
  delete this->P_D_A2_RecSkyArray;
  delete this->P_D_A2_RecArray;
  delete this->P_D_A2_RecFitArray;
  delete this->P_I_A2_MaskArray;
  delete this->P_D_A2_Coeffs;
  delete this->P_D_A2_Blaze;
  delete this->P_D_A2_SP_Fit;
  delete this->P_D_A2_LastExtracted;
  delete this->P_D_A2_Errors_Ec;
  delete this->P_D_A2_Sky;
  delete this->P_D_A2_SkyError;
  delete this->P_D_A2_WLen;
  delete this->P_D_A2_XCenters;
  delete this->P_D_A1_XCenter;
  delete this->P_D_A1_YCenter;
  delete this->P_D_A1_XLow;
  delete this->P_D_A1_XHigh;
  delete this->P_D_A1_YLow;
  delete this->P_D_A1_YHigh;
  delete this->P_I_A1_Orders;
  delete this->P_I_A1_NCoeffs;
  delete this->P_D_A1_XMin;
  delete this->P_D_A1_XMax;
  delete this->P_CS_A1_Functions;
  delete this->P_D_A2_SkyFitError;
  delete this->P_D_A2_SkyFit;
  delete this->P_D_A2_Errors_EcFit;
  delete this->P_D_A2_RecSkyFitArray;/// NRows x NCols
  free(ClassName);
  //  delete[] this->ClassName;
}

/** *******************************************************/

bool CFits::ClassInvariant() const
{
  CString FitsStr(".fits");

  /// FileName
#ifdef __DEBUG_FITS_CLASSINVARIANT__
  cout << "CFits::ClassInvariant(this->P_CS_FileName = <" << *this->P_CS_FileName << ">): FitsStr set to <" << FitsStr << ">" << endl;
  (*this->P_OFS_Log) << "CFits::ClassInvariant(this->P_CS_FileName = <" << *this->P_CS_FileName << ">): FitsStr set to <" << FitsStr << ">" << endl;
#endif
  if (this->P_CS_FileName->GetLength() == 0)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): this->P_CS_FileName(=<" << *this->P_CS_FileName << ">).GetLength(=" << this->P_CS_FileName->GetLength() << ") == 0 => Returning FALSE!" << endl;
    (*this->P_OFS_Log) << "CFits::ClassInvariant(): this->P_CS_FileName(=<" << *this->P_CS_FileName << ">).GetLength(=" << this->P_CS_FileName->GetLength() << ") == 0 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /** ErrFileName
#ifdef __DEBUG_FITS_CLASSINVARIANT__
  cout << "CFits::ClassInvariant(this->P_CS_ErrFileName = <" << *this->P_CS_ErrFileName << ">): FitsStr set to <" << FitsStr << ">" << endl;
  (*this->P_OFS_Log) << "CFits::ClassInvariant(this->P_CS_ErrFileName = <" << *this->P_CS_ErrFileName << ">): FitsStr set to <" << FitsStr << ">" << endl;
#endif
  if (this->P_CS_ErrFileName->GetLength() == 0)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): this->P_CS_ErrFileName(=<" << *this->P_CS_ErrFileName << ">).GetLength(=" << this->P_CS_ErrFileName->GetLength() << ") == 0 => Returning FALSE!" << endl;
    (*this->P_OFS_Log) << "CFits::ClassInvariant(): this->P_CS_ErrFileName(=<" << *this->P_CS_ErrFileName << ">).GetLength(=" << this->P_CS_ErrFileName->GetLength() << ") == 0 => Returning FALSE!" << endl;
#endif
    return false;
  }**/

  /** DatabaseFileName
  if (this->P_CS_DatabaseFileName->GetLength() != 0)
  {
    if (!this->AccessDatabaseFile())
    {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
      cout << "CFits::ClassInvariant(): this->P_DatabaseFileName(=<" << *this->P_CS_DatabaseFileName << ">).GetLength(=" << this->P_CS_FileName->GetLength() << ") != 0 && !Access() => Returning FALSE!" << endl;
      (*P_OFS_Log) << "CFits::ClassInvariant(): this->P_DatabaseFileName(=<" << *this->P_CS_DatabaseFileName << ">).GetLength(=" << this->P_CS_FileName->GetLength() << ") != 0 && !Access() => Returning FALSE!" << endl;
#endif
      return false;
    }
  }**/

  if (this->P_CS_FileName->LastStrPos(FitsStr) != this->P_CS_FileName->GetLength() - FitsStr.GetLength())
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(this->P_CS_FileName = <" << *this->P_CS_FileName << ">): P_CS_FileName->LastStrPos( FitsStr=" << FitsStr << ")=" << this->P_CS_FileName->LastStrPos(FitsStr) << " != this->P_CS_FileName->GetLength(=" << this->P_CS_FileName->GetLength() << ") - FitsStr.GetLength()=" << FitsStr.GetLength() << " => Returning FALSE!" << endl;
    (*this->P_OFS_Log) << "CFits::ClassInvariant(this->P_CS_FileName = <" << *this->P_CS_FileName << ">): P_CS_FileName->LastStrPos( FitsStr=" << FitsStr << ")=" << this->P_CS_FileName->LastStrPos(FitsStr) << " != this->P_CS_FileName->GetLength(=" << this->P_CS_FileName->GetLength() << ") - FitsStr.GetLength()=" << FitsStr.GetLength() << " => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// NCols
  if (this->NCols < 1)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): NCols(=" << this->NCols << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): NCols(=" << this->NCols << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// NRows
  if (this->NRows < 1)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): NRows(=" << this->NRows << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): NRows(=" << this->NRows << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// PixArray
  if (this->P_D_A2_PixArray->rows() != this->NRows)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): PixArray.rows(=" << P_D_A2_PixArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): PixArray.rows(=" << P_D_A2_PixArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (this->P_D_A2_PixArray->cols() != this->NCols)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): PixArray.cols(=" << P_D_A2_PixArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): PixArray.cols(=" << P_D_A2_PixArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// ProfArray
  if (this->P_D_A2_ProfArray->rows() != this->NRows)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): ProfArray.rows(=" << P_D_A2_ProfArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): ProfArray.rows(=" << P_D_A2_ProfArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (this->P_D_A2_ProfArray->cols() != this->NCols)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): ProfArray.cols(=" << P_D_A2_ProfArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): ProfArray.cols(=" << P_D_A2_ProfArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// ErrArray
  if (this->P_D_A2_ErrArray->rows() != this->NRows)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): ErrArray.rows(=" << P_D_A2_ErrArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): ErrArray.rows(=" << P_D_A2_ErrArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (this->P_D_A2_ErrArray->cols() != this->NCols)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): ErrArray.cols(=" << P_D_A2_ErrArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): ErrArray.cols(=" << P_D_A2_ErrArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// RecSkyArray
  if (this->P_D_A2_RecSkyArray->rows() != this->NRows)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): RecSkyArray.rows(=" << P_D_A2_RecSkyArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): RecSkyArray.rows(=" << P_D_A2_RecSkyArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (this->P_D_A2_RecSkyArray->cols() != this->NCols)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): RecSkyArray.cols(=" << P_D_A2_RecSkyArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): RecSkyArray.cols(=" << P_D_A2_RecSkyArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// RecArray
  if (this->P_D_A2_RecArray->rows() != this->NRows)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): RecArray.rows(=" << P_D_A2_RecArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): RecArray.rows(=" << P_D_A2_RecArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (this->P_D_A2_RecArray->cols() != this->NCols)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): RecArray.cols(=" << P_D_A2_RecArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): RecArray.cols(=" << P_D_A2_RecArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// RecFitArray
  if (this->P_D_A2_RecFitArray->rows() != this->NRows)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): RecFitArray.rows(=" << P_D_A2_RecFitArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): RecFitArray.rows(=" << P_D_A2_RecFitArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (this->P_D_A2_RecFitArray->cols() != this->NCols)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): RecFitArray.cols(=" << P_D_A2_RecFitArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): RecFitArray.cols(=" << P_D_A2_RecFitArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  if (this->P_D_A2_RecSkyFitArray->rows() != this->NRows)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): RecSkyFitArray.rows(=" << P_D_A2_RecSkyFitArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): RecSkyFitArray.rows(=" << P_D_A2_RecSkyFitArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (this->P_D_A2_RecSkyFitArray->cols() != this->NCols)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): RecSkyFitArray.cols(=" << P_D_A2_RecSkyFitArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): RecSkyFitArray.cols(=" << P_D_A2_RecSkyFitArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// MaskArray
  if (this->P_I_A2_MaskArray->rows() != this->NRows)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): MaskArray.rows(=" << P_I_A2_MaskArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): MaskArray.rows(=" << P_I_A2_MaskArray->rows() << " != NRows(=" << this->NRows << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (this->P_I_A2_MaskArray->cols() != this->NCols)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): MaskArray.cols(=" << P_I_A2_MaskArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): MaskArray.cols(=" << P_I_A2_MaskArray->cols() << " != NCols(=" << this->NCols << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// NApertures
  if (this->I_NApertures < 1)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): NApertures(=" << this->I_NApertures << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): NApertures(=" << this->I_NApertures << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// DispAxis
  if (this->I_DispAxis < 1 || this->I_DispAxis > 2)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): DispAxis(=" << this->I_DispAxis << ") < 1 || > 2 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): DispAxis(=" << this->I_DispAxis << ") < 1 || > 2 => Returning FALSE!" << endl;
#endif
    return false;
  }


  /// Gain
  if (this->D_Gain < 0.)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): Gain(=" << this->D_Gain << ") < 0 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): Gain(=" << this->D_Gain << ") < 0 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// ReadOutNoise
  if (this->D_ReadOutNoise < 0.)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): ReadOutNoise(=" << this->D_ReadOutNoise << ") < 0 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): ReadOutNoise(=" << this->D_ReadOutNoise << ") < 0 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// OverSample
  if (this->I_OverSample < 1.)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): OverSample(=" << this->I_OverSample << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): OverSample(=" << this->I_OverSample << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// MaxIterSF
  if (this->I_MaxIterSF < 1.)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): MaxIterSF(=" << this->I_MaxIterSF << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): MaxIterSF(=" << this->I_MaxIterSF << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// MaxIterSky
  if (this->I_MaxIterSky < 1.)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): MaxIterSky(=" << this->I_MaxIterSky << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): MaxIterSky(=" << this->I_MaxIterSky << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// MaxIterSig
  if (this->I_MaxIterSky < 1.)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): MaxIterSF(=" << this->I_MaxIterSig << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): MaxIterSF(=" << this->I_MaxIterSig << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// XLow
  if (P_D_A1_XLow->size() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): XLow->size(=" << this->P_D_A1_XLow->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): XLow->size(=" << this->P_D_A1_XLow->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// XHigh
  if (P_D_A1_XHigh->size() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): XHigh->size(=" << this->P_D_A1_XHigh->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): XHigh->size(=" << this->P_D_A1_XHigh->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// YLow
  if (P_D_A1_YLow->size() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): YLow->size(=" << this->P_D_A1_YLow->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): YLow->size(=" << this->P_D_A1_YLow->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// YHigh
  if (P_D_A1_YHigh->size() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): YHigh->size(=" << this->P_D_A1_YHigh->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): YHigh->size(=" << this->P_D_A1_YHigh->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// XMin
  if (P_D_A1_XMin->size() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): XMin->size(=" << this->P_D_A1_XMin->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): XMin->size(=" << this->P_D_A1_XMin->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// YMax
  if (P_D_A1_XMax->size() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): XMax->size(=" << this->P_D_A1_XMax->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): XMax->size(=" << this->P_D_A1_XMax->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// Orders
  if (P_I_A1_Orders->size() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): Orders->size(=" << this->P_I_A1_Orders->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): Orders->size(=" << this->P_I_A1_Orders->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// NCoeffs
  if (P_I_A1_NCoeffs->size() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): NCoeffs->size(=" << this->P_I_A1_NCoeffs->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): NCoeffs->size(=" << this->P_I_A1_NCoeffs->size() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// Coeffs
  if (P_D_A2_Coeffs->rows() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): Coeffs->rows(=" << this->P_D_A2_Coeffs->rows() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): Coeffs->rows(=" << this->P_D_A2_Coeffs->rows() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (P_D_A2_Coeffs->cols() < 1)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): Coeffs->cols(=" << this->P_D_A2_Coeffs->cols() << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): Coeffs->cols(=" << this->P_D_A2_Coeffs->cols() << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// XCenters
  if (P_D_A2_XCenters->rows() != this->I_NApertures)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): XCenters->rows(=" << this->P_D_A2_XCenters->rows() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): XCenters->rows(=" << this->P_D_A2_XCenters->rows() << ") != NApertures(=" << this->I_NApertures << ") => Returning FALSE!" << endl;
#endif
    return false;
  }
  if (P_D_A2_XCenters->cols() < 1)
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): XCenters->cols(=" << this->P_D_A2_XCenters->cols() << ") < 1 => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): XCenters->cols(=" << this->P_D_A2_XCenters->cols() << ") < 1 => Returning FALSE!" << endl;
#endif
    return false;
  }

  /// Functions
  for (int m = 0; m < this->I_NApertures; m++)
  {
    /*    if ((*this->P_CS_A1_Functions)(m) == NULL)
        {
    #ifdef __DEBUG_FITS_CLASSINVARIANT__
          cout << "CFits::ClassInvariant: P_CS_A1_Functions[" << m << "] == NULL => Returning FALSE" << endl;
          (*P_OFS_Log) << "CFits::ClassInvariant: P_CS_A1_Functions[" << m << "] == NULL => Returning FALSE" << endl;
    #endif
          return false;
      }*/
    if (!((*this->P_CS_A1_Functions)(m)).ClassInvariant())
    {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
      cout << "CFits::ClassInvariant: PP_CS_A1_Functions[" << m << "]->ClassInvariant() retuned FALSE => Returning FALSE" << endl;
      (*P_OFS_Log) << "CFits::ClassInvariant: PP_CS_A1_Functions[" << m << "]->ClassInvariant() retuned FALSE => Returning FALSE" << endl;
#endif
      return false;
    }
  }

  /// Access(FileName)
  if (!this->Access())
  {
#ifdef __DEBUG_FITS_CLASSINVARIANT__
    cout << "CFits::ClassInvariant(): Access() returned FALSE => Returning FALSE!" << endl;
    (*P_OFS_Log) << "CFits::ClassInvariant(): Access() returned FALSE => Returning FALSE!" << endl;
#endif
    return false;
  }

  return true;
}

/***********************************************************/

bool CFits::EqualValue(const CAny &any) const
{
  double D_Limit = 1.e-10;
  if (this->Equal(any))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of this and p_fit are EQUAL => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of this and p_fit are EQUAL => returning FALSE" << endl;
#endif
    return false;
  }
  CFits *p_fit = const_cast<CFits*>(dynamic_cast<const CFits*>(&any));
  if (p_fit == NULL)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of p_fit == NULL => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of p_fit == NULL => returning FALSE" << endl;
#endif
    return false;
  }

  /// ClassInvariant
  if (!ClassInvariant() || !(p_fit->ClassInvariant()))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: this->ClassInvariant() or p_fit->ClassInvariant() returned FALSE => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: this->ClassInvariant() or p_fit->ClassInvariant() returned FALSE => returning FALSE" << endl;
#endif
    return false;
  }

  /// FileName
  CString tempFileName = p_fit->GetFileName();
  if (!P_CS_FileName->EqualValue( tempFileName ))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: FileName's are not equal => RETURNING FALSE!!!" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: FileName's are not equal => RETURNING FALSE!!!" << endl;
#endif
    return false;
  }

  /// ErrFileName
  CString tempErrFileName = p_fit->GetErrFileName();
  if (!P_CS_ErrFileName->EqualValue( tempErrFileName ))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: ErrFileName's are not equal => RETURNING FALSE!!!" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: ErrFileName's are not equal => RETURNING FALSE!!!" << endl;
#endif
    return false;
  }

  /// DatabaseFileName
  CString tempdfn = p_fit->GetDatabaseFileName();
  if (!P_CS_DatabaseFileName->EqualValue( tempdfn ))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: DatabaseFileName's are not equal => RETURNING FALSE!!!" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: DatabaseFileName's are not equal => RETURNING FALSE!!!" << endl;
#endif
    return false;
  }

  /// NCols
  if (this->NCols != p_fit->GetNCols())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: this->NCols and p_fit->NCols are not equal => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: this->NCols and p_fit->NCols are not equal => returning FALSE" << endl;
#endif
    return false;
  }

  /// NRows
  if (this->NRows != p_fit->GetNRows())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: this->NRows and p_fit->NRows are not equal => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: this->NRows and p_fit->NRows are not equal => returning FALSE" << endl;
#endif
    return false;
  }

  /// PixArray
  if ((const_cast<CFits*>(this)->P_D_A2_PixArray) == &(const_cast<CFits*>(p_fit)->GetPixArray()))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of this->PixArray and p_fit->GetPixArray() are the same => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of this->PixArray and p_fit->GetPixArray() are the same => returning FALSE" << endl;
#endif
    return false;
  }
  if (max(where(fabs((*P_D_A2_PixArray) - p_fit->GetPixArray()) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->PixArray != p_fit->GetPixArray() => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->PixArray != p_fit->GetPixArray() => returning FALSE" << endl;
#endif
    return false;
  }

  /// ProfArray
  if ((const_cast<CFits*>(this)->P_D_A2_ProfArray) == &(const_cast<CFits*>(p_fit)->GetProfArray()))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of this->ProfArray and p_fit->GetProfArray() are the same => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of this->ProfArray and p_fit->GetProfArray() are the same => returning FALSE" << endl;
#endif
    return false;
  }
  if (max(where(fabs((*P_D_A2_ProfArray) - p_fit->GetProfArray()) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->ProfArray != p_fit->GetProfArray() => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->ProfArray != p_fit->GetProfArray() => returning FALSE" << endl;
#endif
    return false;
  }

  /// ErrArray
  if ((const_cast<CFits*>(this)->P_D_A2_ErrArray) == &(const_cast<CFits*>(p_fit)->GetErrArray()))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of this->ErrArray and p_fit->GetErrArray() are the same => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of this->ErrArray and p_fit->GetErrArray() are the same => returning FALSE" << endl;
#endif
    return false;
  }
  if (max(where(fabs((*P_D_A2_ErrArray) - p_fit->GetErrArray()) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->ErrArray != p_fit->GetErrArray() => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->ErrArray != p_fit->GetErrArray() => returning FALSE" << endl;
#endif
    return false;
  }

  /// RecSkyArray
  if ((const_cast<CFits*>(this)->P_D_A2_RecSkyArray) == &(const_cast<CFits*>(p_fit)->GetRecSkyArray()))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of this->RecSkyArray and p_fit->GetRecSkyArray() are the same => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of this->RecSkyArray and p_fit->GetRecSkyArray() are the same => returning FALSE" << endl;
#endif
    return false;
  }
  if (max(where(fabs((*P_D_A2_RecSkyArray) - p_fit->GetRecSkyArray()) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->RecSkyArray != p_fit->GetRecSkyArray() => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->RecSkyArray != p_fit->GetRecSkyArray() => returning FALSE" << endl;
#endif
    return false;
  }

  /// RecArray
  if ((const_cast<CFits*>(this)->P_D_A2_RecArray) == &(const_cast<CFits*>(p_fit)->GetRecArray()))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of this->RecArray and p_fit->GetRecArray() are the same => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of this->RecArray and p_fit->GetRecArray() are the same => returning FALSE" << endl;
#endif
    return false;
  }
  if (max(where(fabs((*P_D_A2_RecArray) - p_fit->GetRecArray()) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->RecArray != p_fit->GetRecArray() => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->RecArray != p_fit->GetRecArray() => returning FALSE" << endl;
#endif
    return false;
  }

  /// RecFitArray
  if ((const_cast<CFits*>(this)->P_D_A2_RecFitArray) == &(const_cast<CFits*>(p_fit)->GetRecFitArray()))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of this->RecFitArray and p_fit->GetRecFitArray() are the same => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of this->RecFitArray and p_fit->GetRecFitArray() are the same => returning FALSE" << endl;
#endif
    return false;
  }
  if (max(where(fabs((*P_D_A2_RecFitArray) - p_fit->GetRecFitArray()) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->RecFitArray != p_fit->GetRecFitArray() => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->RecFitArray != p_fit->GetRecFitArray() => returning FALSE" << endl;
#endif
    return false;
  }

  /// MaskArray
  if ((const_cast<CFits*>(this)->P_I_A2_MaskArray) == &(const_cast<CFits*>(p_fit)->GetMaskArray()))
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue:: adresses of this->MaskArray and p_fit->GetMaskArray() are the same => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue:: adresses of this->MaskArray and p_fit->GetMaskArray() are the same => returning FALSE" << endl;
#endif
    return false;
  }
  if (max(where(fabs((*P_I_A2_MaskArray) - p_fit->GetMaskArray()) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->MaskArray != p_fit->GetMaskArray() => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->MaskArray != p_fit->GetMaskArray() => returning FALSE" << endl;
#endif
    return false;
  }

  /// NApertures
  if (this->I_NApertures != p_fit->Get_NApertures())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->I_NApertures(=" << this->I_NApertures << ") != p_fit->Get_NApertures(=" << p_fit->Get_NApertures() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->I_NApertures(=" << this->I_NApertures << ") != p_fit->Get_NApertures(=" << p_fit->Get_NApertures() << ") => returning FALSE" << endl;
#endif
    return false;
  }

  /// DispAxis
  if (this->I_DispAxis != p_fit->Get_DispAxis())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->I_DispAxis(=" << this->I_DispAxis << ") != p_fit->Get_DispAxis(=" << p_fit->Get_DispAxis() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->I_DispAxis(=" << this->I_DispAxis << ") != p_fit->Get_DispAxis(=" << p_fit->Get_DispAxis() << ") => returning FALSE" << endl;
#endif
    return false;
  }

  /// Gain
  if (this->D_Gain != p_fit->Get_Gain())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->D_Gain(=" << this->D_Gain << ") != p_fit->Get_Gain(=" << p_fit->Get_Gain() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->D_Gain(=" << this->D_Gain << ") != p_fit->Get_Gain(=" << p_fit->Get_Gain() << ") => returning FALSE" << endl;
#endif
    return false;
  }

  /// ReadOutNoise
  if (this->D_ReadOutNoise != p_fit->Get_ReadOutNoise())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->D_ReadOutNoise(=" << this->D_ReadOutNoise << ") != p_fit->Get_ReadOutNoise(=" << p_fit->Get_ReadOutNoise() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->D_ReadOutNoise(=" << this->D_ReadOutNoise << ") != p_fit->Get_ReadOutNoise(=" << p_fit->Get_ReadOutNoise() << ") => returning FALSE" << endl;
#endif
    return false;
  }

  /// OverSample
  if (this->I_OverSample != p_fit->Get_OverSample())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->I_OverSample(=" << this->I_OverSample << ") != p_fit->Get_OverSample(=" << p_fit->Get_OverSample() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->I_OverSample(=" << this->I_OverSample << ") != p_fit->Get_OverSample(=" << p_fit->Get_OverSample() << ") => returning FALSE" << endl;
#endif
    return false;
  }

  /// MaxIterSF
  if (this->I_MaxIterSF != p_fit->Get_MaxIterSF())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->I_MaxIterSF(=" << this->I_MaxIterSF << ") != p_fit->Get_MaxIterSF(=" << p_fit->Get_MaxIterSF() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->I_MaxIterSF(=" << this->I_MaxIterSF << ") != p_fit->Get_MaxIterSF(=" << p_fit->Get_MaxIterSF() << ") => returning FALSE" << endl;
#endif
    return false;
  }

  /// MaxIterSky
  if (this->I_MaxIterSky != p_fit->Get_MaxIterSky())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->I_MaxIterSky(=" << this->I_MaxIterSky << ") != p_fit->Get_MaxIterSky(=" << p_fit->Get_MaxIterSky() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->I_MaxIterSky(=" << this->I_MaxIterSky << ") != p_fit->Get_MaxIterSky(=" << p_fit->Get_MaxIterSky() << ") => returning FALSE" << endl;
#endif
    return false;
  }

  /// MaxIterSig
  if (this->I_MaxIterSig != p_fit->Get_MaxIterSig())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->I_MaxIterSig(=" << this->I_MaxIterSig << ") != p_fit->Get_MaxIterSig(=" << p_fit->Get_MaxIterSig() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->I_MaxIterSig(=" << this->I_MaxIterSig << ") != p_fit->Get_MaxIterSig(=" << p_fit->Get_MaxIterSig() << ") => returning FALSE" << endl;
#endif
    return false;
  }

  /// D_SaturationLevel;
  if (this->D_SaturationLevel != p_fit->Get_SaturationLevel())
  {
    #ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->D_SaturationLevel(=" << this->D_SaturationLevel << ") != p_fit->Get_SaturationLevel(=" << p_fit->Get_SaturationLevel() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->D_SaturationLevel(=" << this->D_SaturationLevel << ") != p_fit->Get_SaturationLevel(=" << p_fit->Get_SaturationLevel() << ") => returning FALSE" << endl;
    #endif
    return false;
  }

  /// D_ApertureFWHM;
  if (this->D_ApertureFWHM != p_fit->Get_ApertureFWHM())
  {
    #ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->D_SaturationLevel(=" << this->D_SaturationLevel << ") != p_fit->Get_SaturationLevel(=" << p_fit->Get_SaturationLevel() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->D_SaturationLevel(=" << this->D_SaturationLevel << ") != p_fit->Get_SaturationLevel(=" << p_fit->Get_SaturationLevel() << ") => returning FALSE" << endl;
    #endif
    return false;
  }

  /// D_SignalThreshold;
  if (this->D_SignalThreshold != p_fit->Get_SignalThreshold())
  {
    #ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->D_SignalThreshold(=" << this->D_SignalThreshold << ") != p_fit->Get_SignalThreshold(=" << p_fit->Get_SignalThreshold() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->D_SignalThreshold(=" << this->D_SignalThreshold << ") != p_fit->Get_SignalThreshold(=" << p_fit->Get_SignalThreshold() << ") => returning FALSE" << endl;
    #endif
    return false;
  }

  /// I_MaxNumberOfAperturesToBeFound;
  if (this->I_MaxNumberOfAperturesToBeFound != p_fit->Get_MaxNumberOfAperturesToBeFound())
  {
    #ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->I_MaxNumberOfAperturesToBeFound(=" << this->I_MaxNumberOfAperturesToBeFound << ") != p_fit->Get_MaxNumberOfAperturesToBeFound(=" << p_fit->Get_MaxNumberOfAperturesToBeFound() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->I_MaxNumberOfAperturesToBeFound(=" << this->I_MaxNumberOfAperturesToBeFound << ") != p_fit->Get_MaxNumberOfAperturesToBeFound(=" << p_fit->Get_MaxNumberOfAperturesToBeFound() << ") => returning FALSE" << endl;
    #endif
    return false;
  }

  /// XCenters
  Array<double, 2> *P_tempxcenters = p_fit->Get_XCenters();
  if (P_D_A2_XCenters->size() != P_tempxcenters->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A2_XCenters(=" << *(this->P_D_A2_XCenters) << ")->size(=" << this->P_D_A2_XCenters->size() << ") != p_fit->Get_XCenters(=" << *P_tempxcenters << ").size(=" << P_tempxcenters->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A2_XCenters(=" << *(this->P_D_A2_XCenters) << ")->size(=" << this->P_D_A2_XCenters->size() << ") != p_fit->Get_XCenters(=" << *P_tempxcenters << ").size(=" << P_tempxcenters->size() << ") => returning FALSE" << endl;
#endif
    delete(P_tempxcenters);
    return false;
  }

  if (max(where(fabs((*this->P_D_A2_XCenters) - (*P_tempxcenters)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A2_XCenters(=" << *(this->P_D_A2_XCenters) << ") != p_fit->Get_XCenters(=" << *P_tempxcenters << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A2_XCenters(=" << *(this->P_D_A2_XCenters) << ") != p_fit->Get_XCenters(=" << *P_tempxcenters << ") => returning FALSE" << endl;
#endif
    delete(P_tempxcenters);
    return false;
  }
  delete(P_tempxcenters);

  /// XCenter
  Array<double, 1> *P_tempxcenter = p_fit->Get_XCenter();
  if (P_D_A1_XCenter->size() != P_tempxcenter->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XCenter(=" << *(this->P_D_A1_XCenter) << ")->size(=" << this->P_D_A1_XCenter->size() << ") != p_fit->Get_XCenter(=" << *P_tempxcenter << ").size(=" << P_tempxcenter->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XCenter(=" << *(this->P_D_A1_XCenter) << ")->size(=" << this->P_D_A1_XCenter->size() << ") != p_fit->Get_XCenter(=" << *P_tempxcenter << ").size(=" << P_tempxcenter->size() << ") => returning FALSE" << endl;
#endif
    delete(P_tempxcenter);
    return false;
  }

  if (max(where(fabs((*this->P_D_A1_XCenter) - (*P_tempxcenter)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XCenter(=" << *(this->P_D_A1_XCenter) << ") != p_fit->Get_XCenter(=" << *P_tempxcenter << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XCenter(=" << *(this->P_D_A1_XCenter) << ") != p_fit->Get_XCenter(=" << *P_tempxcenter << ") => returning FALSE" << endl;
#endif
    delete(P_tempxcenters);
    return false;
  }
  delete(P_tempxcenters);

  /// YCenter
  Array<double, 1> *P_tempycenter = p_fit->Get_YCenter();
  if (P_D_A1_YCenter->size() != P_tempycenter->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_YCenter(=" << *(this->P_D_A1_YCenter) << ")->size(=" << this->P_D_A1_YCenter->size() << ") != p_fit->Get_YCenter(=" << *P_tempycenter << ").size(=" << P_tempycenter->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_YCenter(=" << *(this->P_D_A1_YCenter) << ")->size(=" << this->P_D_A1_YCenter->size() << ") != p_fit->Get_YCenter(=" << *P_tempycenter << ").size(=" << P_tempycenter->size() << ") => returning FALSE" << endl;
#endif
    delete(P_tempycenter);
    return false;
  }

  if (max(where(fabs((*this->P_D_A1_YCenter) - (*P_tempycenter)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_YCenter(=" << *(this->P_D_A1_YCenter) << ") != p_fit->Get_YCenter(=" << *P_tempycenter << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_YCenter(=" << *(this->P_D_A1_YCenter) << ") != p_fit->Get_YCenter(=" << *P_tempycenter << ") => returning FALSE" << endl;
#endif
    delete(P_tempycenter);
    return false;
  }
  delete(P_tempycenter);

  /// NCoeffs
  Array<int, 1> *P_tempncoeffs = p_fit->Get_NCoeffs();
  if (P_I_A1_NCoeffs->size() != P_tempncoeffs->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_I_A1_NCoeffs(=" << *(this->P_I_A1_NCoeffs) << ")->size(=" << this->P_I_A1_NCoeffs->size() << ") != p_fit->Get_NCoeffs(=" << *P_tempncoeffs << ").size(" << P_tempncoeffs->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_I_A1_NCoeffs(=" << *(this->P_I_A1_NCoeffs) << ")->size(=" << this->P_I_A1_NCoeffs->size() << ") != p_fit->Get_NCoeffs(=" << *P_tempncoeffs << ").size(" << P_tempncoeffs->size() << ") => returning FALSE" << endl;
#endif
    delete(P_tempncoeffs);
    return false;
  }

  if (max(where(abs((*P_I_A1_NCoeffs) - (*P_tempncoeffs)) < 1, 0, 1)) > 0)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_I_A1_NCoeffs(=" << *(this->P_I_A1_NCoeffs) << ") != p_fit->Get_NCoeffs(=" << *P_tempncoeffs << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_I_A1_NCoeffs(=" << *(this->P_I_A1_NCoeffs) << ") != p_fit->Get_NCoeffs(=" << *P_tempncoeffs << ") => returning FALSE" << endl;
#endif
    delete(P_tempncoeffs);
    return false;
  }
  delete(P_tempncoeffs);

  /// Coeffs
  Array<double, 2> *P_tempcoeffs = p_fit->Get_Coeffs();
  if (P_D_A2_Coeffs->size() != P_tempcoeffs->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A2_Coeffs(=" << *(this->P_D_A2_Coeffs) << ")->size(=" << P_D_A2_Coeffs->size() << ") != p_fit->Get_Coeffs(=" << *P_tempcoeffs << ").size(=" << P_tempcoeffs->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A2_Coeffs(=" << *(this->P_D_A2_Coeffs) << ")->size(=" << this->P_D_A2_Coeffs->size() << ") != p_fit->Get_Coeffs(=" << *P_tempcoeffs << ").size(=" << P_tempcoeffs->size() << ") => returning FALSE" << endl;
#endif
    delete(P_tempcoeffs);
    return false;
  }

  if (max(where(fabs((*P_D_A2_Coeffs) - (*P_tempcoeffs)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A2_Coeffs(=" << *(this->P_D_A2_Coeffs) << ") != p_fit->Get_Coeffs(=" << *P_tempcoeffs << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A2_Coeffs(=" << *(this->P_D_A2_Coeffs) << ") != p_fit->Get_Coeffs(=" << *P_tempcoeffs << ") => returning FALSE" << endl;
#endif
    delete(P_tempcoeffs);
    return false;
  }
  delete(P_tempcoeffs);

  /// XMin
  Array<double, 1> *P_tempxmin = p_fit->Get_XMin();
  if (P_D_A1_XMin->size() != P_tempxmin->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XMin(=" << *(this->P_D_A1_XMin) << ")->size(=" << this->P_D_A1_XMin->size() << ") != p_fit->Get_XMin(=" << *P_tempxmin << ").size(=" << P_tempxmin->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XMin(=" << *(this->P_D_A1_XMin) << ")->size(=" << this->P_D_A1_XMin->size() << ") != p_fit->Get_XMin(=" << *P_tempxmin << ").size(=" << P_tempxmin->size() << ") => returning FALSE" << endl;
#endif
    delete(P_tempxmin);
    return false;
  }

  if (max(where(fabs((*P_D_A1_XMin) - (*P_tempxmin)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XMin(=" << *(this->P_D_A1_XMin) << ") != p_fit->Get_XMin(=" << *P_tempxmin << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XMin(=" << *(this->P_D_A1_XMin) << ") != p_fit->Get_XMin(=" << *P_tempxmin << ") => returning FALSE" << endl;
#endif
    delete(P_tempxmin);
    return false;
  }
  delete(P_tempxmin);

  /// XMax
  Array<double, 1> *P_tempxmax = p_fit->Get_XMax();
  if (P_D_A1_XMax->size() != P_tempxmax->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XMax(=" << *(this->P_D_A1_XMax) << ")->size(=" << this->P_D_A1_XMax->size() << ") != p_fit->Get_XMax(=" << *P_tempxmax << ").size(=" << P_tempxmax->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XMax(=" << *(this->P_D_A1_XMax) << ")->size(=" << this->P_D_A1_XMax->size() << ") != p_fit->Get_XMax(=" << *P_tempxmax << ").size(=" << P_tempxmax->size() << ") => returning FALSE" << endl;
#endif
    delete(P_tempxmax);
    return false;
  }

  if (max(where(fabs((*P_D_A1_XMax) - (*P_tempxmax)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XMax(=" << *(this->P_D_A1_XMax) << ") != p_fit->Get_XMax(=" << *P_tempxmax << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XMax(=" << *(this->P_D_A1_XMax) << ") != p_fit->Get_XMax(=" << *P_tempxmax << ") => returning FALSE" << endl;
#endif
    delete(P_tempxmax);
    return false;
  }
  delete(P_tempxmax);

  /// XLow
  Array<double, 1> *P_templow(p_fit->Get_XLow());
  if (P_D_A1_XLow->size() != P_templow->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XLow(=" << *(this->P_D_A1_XLow) << ")->size(=" << this->P_D_A1_XLow->size() << ") != p_fit->Get_XLow(=" << *P_templow << ").size(=" << P_templow->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XLow(=" << *(this->P_D_A1_XLow) << ")->size(=" << this->P_D_A1_XLow->size() << ") != p_fit->Get_XLow(=" << *P_templow << ").size(=" << P_templow->size() << ") => returning FALSE" << endl;
#endif
    delete(P_templow);
    return false;
  }

  if (max(where(fabs((*P_D_A1_XLow) - (*P_templow)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XLow(=" << *(this->P_D_A1_XLow) << ") != p_fit->Get_XLow(=" << *P_templow << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XLow(=" << *(this->P_D_A1_XLow) << ") != p_fit->Get_XLow(=" << *P_templow << ") => returning FALSE" << endl;
#endif
    delete(P_templow);
    return false;
  }
  delete(P_templow);

  /// XHigh
  Array<double, 1> *P_temphigh(p_fit->Get_XHigh());
  if (P_D_A1_XHigh->size() != P_temphigh->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XHigh(=" << *(this->P_D_A1_XHigh) << ")->size(=" << this->P_D_A1_XHigh->size() << ") != p_fit->Get_XHigh(=" << *P_temphigh << ").size(=" << P_temphigh->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XHigh(=" << *(this->P_D_A1_XHigh) << ")->size(=" << this->P_D_A1_XHigh->size() << ") != p_fit->Get_XHigh(=" << *P_temphigh << ").size(=" << P_temphigh->size() << ") => returning FALSE" << endl;
#endif
    delete(P_temphigh);
    return false;
  }

  if (max(where(fabs((*P_D_A1_XHigh) - (*P_temphigh)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_XHigh(=" << *(this->P_D_A1_XHigh) << ") != p_fit->Get_XHigh(=" << *P_temphigh << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_XHigh(=" << *(this->P_D_A1_XHigh) << ") != p_fit->Get_XHigh(=" << *P_temphigh << ") => returning FALSE" << endl;
#endif
    delete(P_temphigh);
    return false;
  }
  delete(P_temphigh);

  /// YLow
  P_templow = p_fit->Get_YLow();
  if (P_D_A1_YLow->size() != P_templow->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_YLow(=" << *(this->P_D_A1_YLow) << ")->size(=" << this->P_D_A1_YLow->size() << ") != p_fit->Get_YLow(=" << *P_templow << ").size(=" << P_templow->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_YLow(=" << *(this->P_D_A1_YLow) << ")->size(=" << this->P_D_A1_YLow->size() << ") != p_fit->Get_YLow(=" << *P_templow << ").size(=" << P_templow->size() << ") => returning FALSE" << endl;
#endif
    delete(P_templow);
    return false;
  }

  if (max(where(fabs((*P_D_A1_YLow) - (*P_templow)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_YLow(=" << *(this->P_D_A1_YLow) << ") != p_fit->Get_YLow(=" << *P_templow << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_YLow(=" << *(this->P_D_A1_YLow) << ") != p_fit->Get_YLow(=" << *P_templow << ") => returning FALSE" << endl;
#endif
    delete(P_templow);
    return false;
  }
  delete(P_templow);

  /// YHigh
  P_temphigh = p_fit->Get_YHigh();
  if (P_D_A1_YHigh->size() != P_temphigh->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_YHigh(=" << *(this->P_D_A1_YHigh) << ")->size(=" << this->P_D_A1_YHigh->size() << ") != p_fit->Get_YHigh(=" << *P_temphigh << ").size(=" << P_temphigh->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_YHigh(=" << *(this->P_D_A1_YHigh) << ")->size(=" << this->P_D_A1_YHigh->size() << ") != p_fit->Get_YHigh(=" << *P_temphigh << ").size(=" << P_temphigh->size() << ") => returning FALSE" << endl;
#endif
    delete(P_temphigh);
    return false;
  }

  if (max(where(fabs((*P_D_A1_YHigh) - (*P_temphigh)) < D_Limit, 0, 1)) > 0.1)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_D_A1_YHigh(=" << *(this->P_D_A1_YHigh) << ") != p_fit->Get_YHigh(=" << *P_temphigh << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_D_A1_YHigh(=" << *(this->P_D_A1_YHigh) << ") != p_fit->Get_YHigh(=" << *P_temphigh << ") => returning FALSE" << endl;
#endif
    delete(P_temphigh);
    return false;
  }
  delete(P_temphigh);

  /// Orders
  Array<int, 1> *P_temporders = p_fit->Get_Orders();
  if (P_I_A1_Orders->size() != P_temporders->size())
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_I_A1_Orders(=" << *(this->P_I_A1_Orders) << ")->size(=" << this->P_I_A1_Orders->size() << ") != p_fit->Get_Orders(=" << *P_temporders << ").size(" << P_temporders->size() << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_I_A1_Orders(=" << *(this->P_I_A1_Orders) << ")->size(=" << this->P_I_A1_Orders->size() << ") != p_fit->Get_Orders(=" << *P_temporders << ").size(" << P_temporders->size() << ") => returning FALSE" << endl;
#endif
    delete(P_temporders);
    return false;
  }
  if (max(where(abs((*P_I_A1_Orders) - (*P_temporders)) < 1, 0, 1)) > 0)
  {
#ifdef __DEBUG_FITS_EQUALVALUE__
    cout << "CFits::EqualValue: this->P_I_A1_Orders(=" << *(this->P_I_A1_Orders) << ") != p_fit->Get_Orders(=" << *P_temporders << ") => returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::EqualValue: this->P_I_A1_Orders(=" << *(this->P_I_A1_Orders) << ") != p_fit->Get_Orders(=" << *P_temporders << ") => returning FALSE" << endl;
#endif
    delete(P_temporders);
    return false;
  }
  delete(P_temporders);

  /// Functions
  Array<CString, 1> *P_tempfunctions = p_fit->Get_Functions();
  for (int m = 0; m < this->I_NApertures; m++)
  {
    /*    if ((*this->P_CS_A1_Functions)(m) == NULL)
        {
    #ifdef __DEBUG_FITS_EQUALVALUE__
          cout << "CFits::EqualValue: this->PP_CS_A1_Functions[" << m << "] == NULL => returning FALSE" << endl;
          (*P_OFS_Log) << "CFits::EqualValue: this->PP_CS_A1_Functions[" << m << "] == NULL => returning FALSE" << endl;
    #endif
          return false;
      }
        if ((p_fit->Get_Functions())(m) == NULL)
        {
    #ifdef __DEBUG_FITS_EQUALVALUE__
          cout << "CFits::EqualValue: p_fit->Get_Functions()[" << m << "] == NULL => returning FALSE" << endl;
          (*P_OFS_Log) << "CFits::EqualValue: p_fit->Get_Functions()[" << m << "] == NULL => returning FALSE" << endl;
    #endif
          return false;
      }*/
    if (!(((*this->P_CS_A1_Functions)(m)).EqualValue((*P_tempfunctions)(m))))
    {
#ifdef __DEBUG_FITS_EQUALVALUE__
      cout << "CFits::EqualValue: this->PP_CS_A1_Functions[" << m << "](=" << (*this->P_CS_A1_Functions)(m) << ") != p_fit->Get_Functions()[" << m << "] = " << (*P_tempfunctions)(m) << ") => returning FALSE" << endl;
      (*P_OFS_Log) << "CFits::EqualValue: this->PP_CS_A1_Functions[" << m << "](=" << (*this->P_CS_A1_Functions)(m) << ") != p_fit->Get_Functions()[" << m << "] = " << (*P_tempfunctions)(m) << ") => returning FALSE" << endl;
#endif
      delete(P_tempfunctions);
      return false;
    }
  }
  delete(P_tempfunctions);

  return true;
}

/**
 *
 *
 **/
bool CFits::ApplyDimension()
{
  if (this->NCols < 1)
  {
    cout << "CFits::ApplyDimension: this->NCols(=" << this->NCols << ") < 1 => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::ApplyDimension: this->NCols(=" << this->NCols << ") < 1 => Returning FALSE" << endl;
    return false;
  }
  if (this->NRows < 1)
  {
    cout << "CFits::ApplyDimension: this->NRows(=" << this->NRows << ") < 1 => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::ApplyDimension: this->NRows(=" << this->NRows << ") < 1 => Returning FALSE" << endl;
    return false;
  }
#ifdef __DEBUG_FITS_APPLYDIMENSION__
  cout << "CFits::ApplyDimension: NCols = " << this->NCols << ", NRows = " << this->NRows << endl;
#endif
  if (!(this->ArrayInitialized))
  {
    #ifdef __DEBUG_FITS_APPLYDIMENSION__
      cout << "CFits::ApplyDimension: Arrays not initialised yet" << endl;
    #endif
    P_D_A2_PixArray->resize(this->NRows, this->NCols);
    P_D_A2_ProfArray->resize(this->NRows, this->NCols);
    P_D_A2_ErrArray->resize(this->NRows, this->NCols);
    P_D_A2_RecSkyArray->resize(this->NRows, this->NCols);
    P_D_A2_RecArray->resize(this->NRows, this->NCols);
    P_D_A2_RecFitArray->resize(this->NRows, this->NCols);
    this->P_D_A2_RecSkyFitArray->resize(this->NRows, this->NCols);
    P_I_A2_MaskArray->resize(this->NRows, this->NCols);
    *P_I_A2_MaskArray = 1;
    this->P_D_A2_XCenters->resize(this->I_NApertures, this->NRows);
    this->P_D_A1_XCenter->resize(this->I_NApertures);
    this->P_D_A1_YCenter->resize(this->I_NApertures);
    /// Blaze
    this->P_D_A2_Blaze->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_SP_Fit->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_LastExtracted->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_Errors_Ec->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_Sky->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_SkyError->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_SkyFitError->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_SkyFit->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_Errors_EcFit->resize(this->I_NApertures, this->NRows);
    this->P_D_A2_WLen->resize(this->NRows, this->NCols);
  }
  else
  {
    #ifdef __DEBUG_FITS_APPLYDIMENSION__
      cout << "CFits::ApplyDimension: Arrays initialised" << endl;
    #endif
    int oldrows = this->P_D_A2_PixArray->rows();
    int oldcols = this->P_D_A2_PixArray->cols();
    #ifdef __DEBUG_FITS_APPLYDIMENSION__
      cout << "CFits::ApplyDimension: oldrows = " << oldrows << ", oldcols = " << oldcols << endl;
    #endif
    this->ResizeAndPreserve((*(this->P_D_A2_PixArray)), this->NRows, this->NCols);
    this->ResizeAndPreserve((*(this->P_D_A2_ProfArray)),this->NRows, this->NCols);
    this->ResizeAndPreserve((*(this->P_D_A2_ErrArray)),this->NRows, this->NCols);
    this->ResizeAndPreserve((*(this->P_D_A2_RecSkyArray)),this->NRows, this->NCols);
    this->ResizeAndPreserve((*(this->P_D_A2_RecArray)),this->NRows, this->NCols);
    this->ResizeAndPreserve((*(this->P_D_A2_RecFitArray)),this->NRows, this->NCols);
    this->ResizeAndPreserve((*(this->P_I_A2_MaskArray)),this->NRows, this->NCols);
    this->ResizeAndPreserve((*(this->P_D_A2_RecSkyFitArray)),this->NRows, this->NCols);
    this->ResizeAndPreserve((*(this->P_D_A1_XCenter)),this->I_NApertures);
    this->ResizeAndPreserve((*(this->P_D_A1_YCenter)),this->I_NApertures);
    /// Blaze
    this->ResizeAndPreserve((*(this->P_D_A2_Blaze)), this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_SP_Fit)),this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_LastExtracted)),this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_Errors_Ec)),this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_Sky)),this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_SkyError)),this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_SkyFitError)),this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_SkyFit)),this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_Errors_EcFit)),this->I_NApertures, this->NRows);
    this->ResizeAndPreserve((*(this->P_D_A2_WLen)),this->NRows, this->NCols);
    if (oldrows < this->P_D_A2_PixArray->rows())
    {
      #ifdef __DEBUG_FITS_APPLYDIMENSION__
        cout << "CFits::ApplyDimension: oldrows < P_D_A2_PixArray->rows()=" << this->P_D_A2_PixArray->rows() << endl;
      #endif
      (*P_D_A2_PixArray)(Range(oldrows, this->P_D_A2_PixArray->rows() - 1), Range::all()) = 0.;
      (*P_D_A2_WLen)(Range(oldrows, this->P_D_A2_WLen->rows() - 1), Range::all()) = 0.;
      (*P_D_A2_ProfArray)(Range(oldrows, this->P_D_A2_ProfArray->rows() - 1), Range::all()) = 0.;
      (*P_D_A2_ErrArray)(Range(oldrows, this->P_D_A2_ErrArray->rows() - 1), Range::all()) = 0.;
      (*P_D_A2_RecSkyArray)(Range(oldrows, this->P_D_A2_RecSkyArray->rows() - 1), Range::all()) = 0.;
      (*P_D_A2_RecArray)(Range(oldrows, this->P_D_A2_RecArray->rows() - 1), Range::all()) = 0.;
      (*P_D_A2_RecFitArray)(Range(oldrows, this->P_D_A2_RecFitArray->rows() - 1), Range::all()) = 0.;
      (*P_I_A2_MaskArray)(Range(oldrows, this->P_I_A2_MaskArray->rows() - 1), Range::all()) = 1;
      (*(this->P_D_A2_RecSkyFitArray))(Range(oldrows, this->NRows-1), Range::all()) = 0.;
      /// Blaze
      (*P_D_A2_Blaze)(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
      (*P_D_A2_SP_Fit)(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
      (*P_D_A2_LastExtracted)(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
      (*P_D_A2_Errors_Ec)(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
      (*P_D_A2_Sky)(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
      (*P_D_A2_SkyError)(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
      (*(this->P_D_A2_SkyFitError))(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
      (*(this->P_D_A2_SkyFit))(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
      (*(this->P_D_A2_Errors_EcFit))(Range::all(), Range(oldrows, this->NRows-1)) = 0.;
    }
    if (oldcols < this->P_D_A2_PixArray->cols())
    {
      #ifdef __DEBUG_FITS_APPLYDIMENSION__
        cout << "CFits::ApplyDimension: oldcols < P_D_A2_PixArray->cols()=" << this->P_D_A2_PixArray->cols() << endl;
      #endif
      (*P_D_A2_PixArray)(Range::all(), Range(oldcols, this->P_D_A2_PixArray->cols() - 1)) = 0.;
      (*P_D_A2_ProfArray)(Range::all(), Range(oldcols, this->P_D_A2_ProfArray->cols() - 1)) = 0.;
      (*P_D_A2_ErrArray)(Range::all(), Range(oldcols, this->P_D_A2_ErrArray->cols() - 1)) = 0.;
      (*P_D_A2_RecSkyArray)(Range::all(), Range(oldcols, this->P_D_A2_RecSkyArray->cols() - 1)) = 0.;
      (*P_D_A2_RecArray)(Range::all(), Range(oldcols, this->P_D_A2_RecArray->cols() - 1)) = 0.;
      (*P_D_A2_RecFitArray)(Range::all(), Range(oldcols, this->P_D_A2_RecFitArray->cols() - 1)) = 0.;
      (*(this->P_D_A2_RecSkyFitArray))(Range::all(), Range(oldcols, this->NCols-1)) = 0.;
      (*P_I_A2_MaskArray)(Range::all(), Range(oldcols, this->P_I_A2_MaskArray->cols() - 1)) = 1;
    }
    oldrows = this->P_D_A2_XCenters->rows();
    oldcols = this->P_D_A2_XCenters->cols();
    this->ResizeAndPreserve((*(this->P_D_A2_XCenters)),this->I_NApertures, this->NRows);
    if (oldrows < this->I_NApertures)
    {
      #ifdef __DEBUG_FITS_APPLYDIMENSION__
        cout << "CFits::ApplyDimension: oldrows < I_NApertures=" << this->I_NApertures << endl;
      #endif
      (*this->P_D_A2_XCenters)(Range(oldrows, this->I_NApertures - 1), Range::all()) = 0.;
      (*this->P_D_A1_XCenter)(Range(oldrows, this->I_NApertures - 1)) = 0.;
      (*this->P_D_A1_YCenter)(Range(oldrows, this->I_NApertures - 1)) = 0.;
    }
    if (oldcols < this->NRows){
      #ifdef __DEBUG_FITS_APPLYDIMENSION__
        cout << "CFits::ApplyDimension: oldcols < NRows=" << this->NRows << endl;
      #endif
      (*P_D_A2_XCenters)(Range::all(), Range(oldcols, this->NRows - 1)) = 0.;
    }
    #ifdef __DEBUG_FITS_APPLYDIMENSION__
      cout << "CFits::ApplyDimension: P_D_A2_XCenters set to " << *P_D_A2_XCenters << endl;
      (*P_OFS_Log) << "CFits::ApplyDimension: P_D_A2_XCenters set to " << *P_D_A2_XCenters << endl;
    #endif

  }
  this->ArrayInitialized = true;

  return true;
}

/** ***********************************************************/

bool CFits::ForceCopy(const CFits &CF_ToCopy){
  return this->DoCopy(CF_ToCopy);
}

/** ***********************************************************/

bool CFits::DoCopy(const CFits &CF_ToCopy){
  /// Check input
  if (Equal(CF_ToCopy))
  {
    cout << "CFits::DoCopy: Equal(p_fit) == TRUE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Equal(p_fit) == TRUE => Returning FALSE" << endl;
    return false;
  }

  /// Copy values of input to this

  /// ClassName
  ClassName = strdup("CFits");

  /// FileName
  CString tempString = CF_ToCopy.GetFileName();
  //CString tempString = const_cast<CFits*>(&CF_ToCopy)->GetFileName();
  this->P_CS_FileName->Copy(tempString);

  /// ErrFileName
  CString tempStringE = CF_ToCopy.GetErrFileName();
  //CString tempStringE = const_cast<CFits*>(&CF_ToCopy)->GetErrFileName();
  this->P_CS_ErrFileName->Copy(tempStringE);

  /// DatabaseFileName
  CString tempStringA = CF_ToCopy.GetDatabaseFileName();
  //CString tempStringA = const_cast<CFits*>(&CF_ToCopy)->GetDatabaseFileName();
  this->P_CS_DatabaseFileName->Copy(tempStringA);

  /// NApertures
//  cout << "CFits::DoCopy(): CF_ToCopy.Get_NApertures returns <<<<<<<<<<<<" << CF_ToCopy.Get_NApertures() << ">>>>>>>>>>>>" << endl;
  if (!this->Set_NApertures(CF_ToCopy.Get_NApertures()))
  {
    cout << "CFits::DoCopy: Set_NApertures(CF_ToCopy.Get_NApertures(=" << CF_ToCopy.Get_NApertures() << ")) returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_NApertures(CF_ToCopy.Get_NApertures(=" << CF_ToCopy.Get_NApertures() << ")) returned FALSE => Returning FALSE" << endl;
    return false;
  }
#ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->I_NApertures set to <<<<<<<<<<<<" << this->I_NApertures << ">>>>>>>>>>>>" << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->I_NApertures set to <<<<<<<<<<<<" << this->I_NApertures << ">>>>>>>>>>>>" << endl;
#endif
  /// NCols
  this->NCols = CF_ToCopy.GetNCols();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->NCols set to " << this->NCols << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->NCols set to " << this->NCols << endl;
  #endif

  /// NRows
  this->NRows = CF_ToCopy.GetNRows();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->NCols set to " << this->NCols << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->NRows set to " << this->NRows << endl;
  #endif

  /// DispAxis
  this->I_DispAxis = CF_ToCopy.Get_DispAxis();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->I_DispAxis set to " << this->I_DispAxis << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->I_DispAxis set to " << this->I_DispAxis << endl;
  #endif

  /// Gain
  this->D_Gain = CF_ToCopy.Get_Gain();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->D_Gain set to " << this->D_Gain << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->D_Gain set to " << this->D_Gain << endl;
  #endif

  /// ReadOutNoise
  this->D_ReadOutNoise = CF_ToCopy.Get_ReadOutNoise();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->D_ReadOutNoise set to " << this->D_ReadOutNoise << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->D_ReadOutNoise set to " << this->D_ReadOutNoise << endl;
  #endif

  /// OverSample
  this->I_OverSample = CF_ToCopy.Get_OverSample();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->I_OverSample set to " << this->I_OverSample << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->I_OverSample set to " << this->I_OverSample << endl;
  #endif

  /// MaxIterSF
  this->I_MaxIterSF = CF_ToCopy.Get_MaxIterSF();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->I_MaxIterSF set to " << this->I_MaxIterSF << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->I_MaxIterSF set to " << this->I_MaxIterSF << endl;
  #endif

  /// MaxIterSky
  this->I_MaxIterSky = CF_ToCopy.Get_MaxIterSky();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->I_MaxIterSky set to " << this->I_MaxIterSky << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->I_MaxIterSky set to " << this->I_MaxIterSky << endl;
  #endif

  /// MaxIterSig
  this->I_MaxIterSig = CF_ToCopy.Get_MaxIterSig();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->I_MaxIterSig set to " << this->I_MaxIterSig << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->I_MaxIterSig set to " << this->I_MaxIterSig << endl;
  #endif

  /// SaturationLevel
  this->D_SaturationLevel = CF_ToCopy.Get_SaturationLevel();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->D_SaturationLevel set to " << this->D_SaturationLevel << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->D_SaturationLevel set to " << this->D_SaturationLevel << endl;
  #endif

  /// ApertureFWHM
  this->D_ApertureFWHM = CF_ToCopy.Get_ApertureFWHM();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->D_ApertureFWHM set to " << this->D_ApertureFWHM << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->D_ApertureFWHM set to " << this->D_ApertureFWHM << endl;
  #endif

  /// SignalThreshold
  this->D_SignalThreshold = CF_ToCopy.Get_SignalThreshold();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->D_SignalThreshold set to " << this->D_SignalThreshold << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->D_SignalThreshold set to " << this->D_SignalThreshold << endl;
  #endif

  /// MaxNumberOfAperturesToBeFound
  this->I_MaxNumberOfAperturesToBeFound = CF_ToCopy.Get_MaxNumberOfAperturesToBeFound();
  #ifdef __DEBUG_FITS_COPY__
  cout << "CFits::DoCopy(): this->I_MaxNumberOfAperturesToBeFound set to " << this->I_MaxNumberOfAperturesToBeFound << endl;
  (*P_OFS_Log) << "CFits::DoCopy(): this->I_MaxNumberOfAperturesToBeFound set to " << this->I_MaxNumberOfAperturesToBeFound << endl;
  #endif


  /// ApplyDimension
  this->ApplyDimension();

  /// PixArray
  Array<double, 2> tempPixArr(const_cast<CFits*>(&CF_ToCopy)->GetPixArray());
  (*(this->P_D_A2_PixArray)) = tempPixArr;
  tempPixArr.resize(0,0);

  /// ProfArray
  Array<double, 2> tempProfArr(const_cast<CFits*>(&CF_ToCopy)->GetProfArray());
  (*(this->P_D_A2_ProfArray)) = tempProfArr;
  tempProfArr.resize(0,0);

  /// ErrArray
  Array<double, 2> tempErrArr(const_cast<CFits*>(&CF_ToCopy)->GetErrArray());
  (*(this->P_D_A2_ErrArray)) = tempErrArr;
  tempErrArr.resize(0,0);

  /// RecSkyArray
  Array<double, 2> tempSkyArr(const_cast<CFits*>(&CF_ToCopy)->GetRecSkyArray());
  (*(this->P_D_A2_RecSkyArray)) = tempSkyArr;
  tempSkyArr.resize(0,0);

  /// RecArray
  Array<double, 2> tempRecArr(const_cast<CFits*>(&CF_ToCopy)->GetRecArray());
  (*(this->P_D_A2_RecArray)) = tempRecArr;
  tempRecArr.resize(0,0);

  /// RecFitArray
  Array<double, 2> tempRecFitArr(const_cast<CFits*>(&CF_ToCopy)->GetRecFitArray());
  (*(this->P_D_A2_RecFitArray)) = tempRecFitArr;
  tempRecFitArr.resize(0,0);

  /// MaskArray
  Array<int, 2> tempMaskArr(const_cast<CFits*>(&CF_ToCopy)->GetMaskArray());
  (*(this->P_I_A2_MaskArray)) = tempMaskArr;
  tempMaskArr.resize(0,0);

  /// XLow
  Array<double, 1> *P_templow = CF_ToCopy.Get_XLow();
  if (!this->Set_XLow(*P_templow))
  {
    cout << "CFits::DoCopy: Set_XLow(CF_ToCopy.Get_XLow(=" << *P_templow << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_XLow(CF_ToCopy.Get_XLow(=" << *P_templow << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_templow);
    return false;
  }
//  templow.resize(0);

  /// XHigh
  Array<double, 1> *P_temphigh = CF_ToCopy.Get_XHigh();
  if (!this->Set_XHigh(*P_temphigh))
  {
    cout << "CFits::DoCopy: Set_XHigh(CF_ToCopy.Get_XHigh(=" << *P_temphigh << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_XHigh(CF_ToCopy.Get_XHigh(=" << *P_temphigh << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_temphigh);
    return false;
  }
//  temphigh.resize(0);

  /// YLow
  P_templow = CF_ToCopy.Get_YLow();
  if (!this->Set_YLow(*P_templow))
  {
    cout << "CFits::DoCopy: Set_YLow(CF_ToCopy.Get_YLow(=" << *P_templow << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_YLow(CF_ToCopy.Get_YLow(=" << *P_templow << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_templow);
    return false;
  }
  delete(P_templow);

  /// XHigh
  P_temphigh = CF_ToCopy.Get_YHigh();
  if (!this->Set_YHigh(*P_temphigh))
  {
    cout << "CFits::DoCopy: Set_YHigh(CF_ToCopy.Get_YHigh(=" << *P_temphigh << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_YHigh(CF_ToCopy.Get_YHigh(=" << *P_temphigh << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_temphigh);
    return false;
  }
  delete(P_temphigh);

  /// XMin
  Array<double, 1> *P_tempxmin = CF_ToCopy.Get_XMin();
  if (!this->Set_XMin(*P_tempxmin))
  {
    cout << "CFits::DoCopy: Set_XMin(CF_ToCopy.Get_XMin(=" << *P_tempxmin << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_XMin(CF_ToCopy.Get_XMin(=" << *P_tempxmin << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_tempxmin);
    return false;
  }
  delete(P_tempxmin);

  /// XMax
  Array<double, 1> *P_tempxmax = CF_ToCopy.Get_XMax();
  if (!this->Set_XMax(*P_tempxmax))
  {
    cout << "CFits::DoCopy: Set_XMax(CF_ToCopy.Get_XMax(=" << *P_tempxmax << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_XMax(CF_ToCopy.Get_XMax(=" << *P_tempxmax << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_tempxmax);
    return false;
  }
  delete(P_tempxmax);

  /// Orders
  Array<int, 1> *P_temporders = CF_ToCopy.Get_Orders();
  if (!this->Set_Orders(*P_temporders))
  {
    cout << "CFits::DoCopy: Set_Orders(CF_ToCopy.Get_Orders(=" << *P_temporders << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_Orders(CF_ToCopy.Get_Orders(=" << *P_temporders << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_temporders);
    return false;
  }
  delete(P_temporders);

  /// Coeffs
  //  this->P_D_A2_Coeffs->resize(this->I_NApertures, max(*this->P_I_A1_Orders));
  Array<double, 2> *P_tempcoeffs = CF_ToCopy.Get_Coeffs();
  if (!this->Set_Coeffs(*P_tempcoeffs))
  {
    cout << "CFits::DoCopy: Set_Coeffs(tempcoeffs(=" << *P_tempcoeffs << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_Coeffs(tempcoeffs(=" << *P_tempcoeffs << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_tempcoeffs);
    return false;
  }
  delete(P_tempcoeffs);

  /// NCoeffs
  Array<int, 1> *P_tempncoeffs = CF_ToCopy.Get_NCoeffs();
  if (!this->Set_NCoeffs(*P_tempncoeffs))
  {
    cout << "CFits::DoCopy: Set_NCoeffs(CF_ToCopy.Get_NCoeffs(=" << CF_ToCopy.Get_NCoeffs() << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_NCoeffs(CF_ToCopy.Get_NCoeffs(=" << CF_ToCopy.Get_NCoeffs() << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_tempncoeffs);
    return false;
  }
  delete(P_tempncoeffs);

  /// XCenters
  Array<double, 2> *P_tempxcenters = CF_ToCopy.Get_XCenters();
  if (!this->Set_XCenters(*P_tempxcenters))
  {
    cout << "CFits::DoCopy: Set_XCenters(CF_ToCopy.Get_XCenters(=" << *P_tempxcenters << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_XCenters(CF_ToCopy.Get_XCenters(=" << *P_tempxcenters << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_tempxcenters);
    return false;
  }
  delete(P_tempxcenters);

  /// XCenter
  Array<double, 1> *P_tempxcenter = CF_ToCopy.Get_XCenter();
  if (!this->Set_XCenter(*P_tempxcenter))
  {
    cout << "CFits::DoCopy: Set_XCenter(CF_ToCopy.Get_XCenter(=" << *P_tempxcenter << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_XCenter(CF_ToCopy.Get_XCenter(=" << *P_tempxcenter << ")) retuned FALSE => Returning FALSE" << endl;
    delete(P_tempxcenter);
    return false;
  }
  delete(P_tempxcenter);

  /// YCenter
  Array<double, 1> *P_tempycenter = CF_ToCopy.Get_YCenter();
  if (!this->Set_YCenter(*P_tempycenter))
  {
    cout << "CFits::DoCopy: Set_YCenter(CF_ToCopy.Get_YCenter(=" << *P_tempycenter << ")) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: Set_YCenter(CF_ToCopy.Get_YCenter(=" << *P_tempycenter << ")) retuned FALSE => Returning FALSE" << endl;
    return false;
  }
  delete(P_tempycenter);

  /// Functions
  Array<CString, 1> *P_tempfunctions = CF_ToCopy.Get_Functions();
  if (this->P_CS_A1_Functions->size() != P_tempfunctions->size())
  {
    cout << "CFits::DoCopy: ERROR: size of P_CS_A1_Functions(=" << P_CS_A1_Functions->size() << ") != size of tempfunctions(=" << P_tempfunctions->size() << ")" << endl;
    (*P_OFS_Log) << "CFits::DoCopy: ERROR: size of P_CS_A1_Functions(=" << P_CS_A1_Functions->size() << ") != size of tempfunctions(=" << P_tempfunctions->size() << ")" << endl;
    delete(P_tempfunctions);
    return false;
  }
  (*this->P_CS_A1_Functions) = (*P_tempfunctions);
  delete(P_tempfunctions);
  /*  for (int m = 0; m < this->I_NApertures; m++)
  {
  if (this->PP_CS_A1_Functions[m] == NULL)
  {
  this->PP_CS_A1_Functions[m] = new CString();
}
  if (CF_ToCopy.Get_Functions()[m] == NULL)
  {
  cout << "CFits::DoCopy: CF_ToCopy.PP_CS_A1_Functions[" << m << "] == NULL => Returning FALSE" << endl;
  return false;
}
  if (!this->PP_CS_A1_Functions[m]->Copy(*(CF_ToCopy.Get_Functions()[m])))
  {
  cout << "CFits::DoCopy: this->PP_CS_A1_Functions[" << m << "]->Copy(CF_ToCopy.PP_CS_A1_Functions[" << m << "]=" << *(CF_ToCopy.Get_Functions()[m]) << " retuned FALSE => Returning FALSE" << endl;
  return false;
}
}*/
  cout << "CFits::DoCopy(): this->I_MaxIterSky set to " << this->I_MaxIterSky << endl;
  cout << "CFits::DoCopy(): Finished" << endl;
  return true;
}

/** ***********************************************************/

bool CFits::Copy(const CAny &any)
{
  const CFits *p_fit = dynamic_cast<const CFits*>(&any);
  if (p_fit == NULL)
  {
    cout << "CFits::Copy: any == NULL => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Copy: any == NULL => Returning FALSE" << endl;
    return false;
  }
  if (!(p_fit->ClassInvariant()))
  {
    cout << "CFits::Copy: p_fit->ClassInvariant returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Copy: p_fit->ClassInvariant returned FALSE => Returning FALSE" << endl;
    return false;
  }

  return this->DoCopy(*p_fit);
}

/** *********************************************************/

CFits& CFits::operator=(CFits &fit)
{
  this->Copy( fit );

  return *this;
}

/**
  subtract PixArray from one CFits instance from this one
**/
CFits& CFits::operator-=(CFits &fit){
  if (this->NRows != fit.GetNRows())
    exit (EXIT_FAILURE);
  if (this->NCols != fit.GetNCols())
    exit (EXIT_FAILURE);

  (*this->P_D_A2_PixArray) = (*this->P_D_A2_PixArray) - fit.GetPixArray();

  return *this;
}

/**
subtract D_A2_Sub from this->P_D_A2_PixArray
**/
CFits& CFits::operator-=(const Array<double, 2> &D_A2_Sub){
  if (this->NRows != D_A2_Sub.rows())
    exit (EXIT_FAILURE);
  if (this->NCols != D_A2_Sub.cols())
    exit (EXIT_FAILURE);

  (*this->P_D_A2_PixArray) = (*this->P_D_A2_PixArray) - D_A2_Sub;

  return *this;
}

/**
subtract D_Sub from this->P_D_A2_PixArray
**/
CFits& CFits::operator-=(double D_Sub){
  (*this->P_D_A2_PixArray) = (*this->P_D_A2_PixArray) - D_Sub;
  return *this;
}

/**
  add PixArray from one CFits instance to this one
**/
CFits& CFits::operator+=(CFits &fit){
  if (this->NRows != fit.GetNRows())
    exit (EXIT_FAILURE);
  if (this->NCols != fit.GetNCols())
    exit (EXIT_FAILURE);
  (*this->P_D_A2_PixArray) = (*this->P_D_A2_PixArray) + fit.GetPixArray();

  return *this;
}

/**
  multiply PixArray from one CFits instance to this one
**/
CFits& CFits::operator*=(CFits &fit){
  if (this->NRows != fit.GetNRows())
    exit (EXIT_FAILURE);
  if (this->NCols != fit.GetNCols())
    exit (EXIT_FAILURE);
  (*this->P_D_A2_PixArray) = (*this->P_D_A2_PixArray) * fit.GetPixArray();

  return *this;
}

/**
  divide PixArray from this by fit.GetPixArray()
**/
CFits& CFits::operator/=(CFits &fit){
  if (this->NRows != fit.GetNRows())
    exit (EXIT_FAILURE);
  if (this->NCols != fit.GetNCols())
    exit (EXIT_FAILURE);
  (*this->P_D_A2_PixArray) = (*this->P_D_A2_PixArray) / fit.GetPixArray();

  return *this;
}


/** *********************************************************

bool CFits::operator==(const CFits &fit) const
{
  string tempstr;
  fit.GetClassName( tempstr );
  return (this->P_CS_FileName == fit.GetFileName() && this->ClassName == tempstr);
}

/************************************************************

bool CFits::operator<(const CFits &dat) const
{
  return (*this <= dat && !(*this == dat));
}

/***********************************************************/

bool CFits::SetFileName(const CString &fn)
{
  if (!fn.ClassInvariant())
  {
    cout << "CFits::SetFileName: fn(=" << fn << ").ClassInvariant returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetFileName: fn(=" << fn << ").ClassInvariant returned FALSE => Returning FALSE" << endl;
    return false;
  }
  return this->P_CS_FileName->Copy(fn);
}

/***********************************************************/

bool CFits::SetErrFileName(const CString &fn)
{
  if (!fn.ClassInvariant())
  {
    cout << "CFits::SetErrFileName: fn(=" << fn << ").ClassInvariant returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetErrFileName: fn(=" << fn << ").ClassInvariant returned FALSE => Returning FALSE" << endl;
    return false;
  }
  return this->P_CS_ErrFileName->Copy(fn);
}

/***********************************************************/

bool CFits::SetDatabaseFileName(const CString &fn)
{
  if (!fn.ClassInvariant())
  {
    cout << "CFits::SetFileName: fn(=" << fn << ").ClassInvariant returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetFileName: fn(=" << fn << ").ClassInvariant returned FALSE => Returning FALSE" << endl;
    return false;
  }
  return this->P_CS_DatabaseFileName->Copy(fn);
}

/** ********************************************************/

bool CFits::SetNCols(int nco)
{
#ifdef __DEBUG_FITS_SET__
  cout << "CFits::SetNCols(nco = " << nco << ") started" << endl;
  (*P_OFS_Log) << "CFits::SetNCols(nco = " << nco << ") started" << endl;
#endif
  if (nco < 1)
  {
    cout << "CFits::SetNCols: nco(=" << nco << ") < 1 => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetNCols: nco(=" << nco << ") < 1 => Returning FALSE" << endl;
    return false;
  }
  this->NCols = nco;
  if (!this->ApplyDimension())
  {
    cout << "CFits::SetNCols: this->ApplyDimension returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetNCols: this->ApplyDimension returned FALSE => Returning FALSE" << endl;
    return false;
  }
  return true;
}

/** ****************************************************** **/

bool CFits::SetNRows(int nro)
{
  if (nro < 1)
  {
    cout << "CFits::SetNRows: nro(=" << nro << ") < 1 => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetNRows: nro(=" << nro << ") < 1 => Returning FALSE" << endl;
    return false;
  }
  this->NRows = nro;
  cout << "CFits::SetNRows: this->NRows set to " << this->NRows << ": Starting ApplyDimension" << endl;
  if (!this->ApplyDimension())
  {
    cout << "CFits::SetNRows: this->ApplyDimension returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetNRows: this->ApplyDimension returned FALSE => Returning FALSE" << endl;
    return false;
  }

  return true;
}

/** ****************************************************** **/

bool CFits::Set_DispAxis(int I_DispAxis_In)
{
  if (I_DispAxis_In < 1 || I_DispAxis_In > 2)
  {
    cout << "CFits::Set_DispAxis: I_DispAxis_In(=" << I_DispAxis_In << ") < 1 || > 2 => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_DispAxis: I_DispAxis_In(=" << I_DispAxis_In << ") < 1 || > 2 => Returning FALSE" << endl;
    return false;
  }
  this->I_DispAxis = I_DispAxis_In;
  return true;
}

/** ****************************************************** **/

bool CFits::Set_NApertures(int I_NApertures_In)
{
  if (I_NApertures_In < 1)
  {
    cout << "CFits::Set_NApertures: I_NApertures_In(=" << I_NApertures_In << ") < 1 => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_NApertures: I_NApertures_In(=" << I_NApertures_In << ") < 1 => Returning FALSE" << endl;
    return false;
  }
  this->I_NApertures = I_NApertures_In;

#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: Setting this->I_NApertures to I_NApertures_In = " << I_NApertures_In << "!!!!!!!!!!!!!!!!!!!!" << endl;
  (*P_OFS_Log) << "CFits::Set_NApertures: Setting this->I_NApertures to I_NApertures_In = " << I_NApertures_In << "!!!!!!!!!!!!!!!!!!!!" << endl;
#endif

  /// Resize Arrays belonging to apertures
  /// Coeffs
  int oldrows = this->P_D_A2_Coeffs->rows();
  this->P_D_A2_Coeffs->resizeAndPreserve(this->I_NApertures, this->P_D_A2_Coeffs->cols());
  if (oldrows < this->P_D_A2_Coeffs->rows())
    (*this->P_D_A2_Coeffs)(Range(oldrows, this->P_D_A2_Coeffs->rows() - 1), Range::all()) = 0.;
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: 1. oldrows = " << oldrows << endl;
#endif

  /// NCoeffs
  oldrows = this->P_I_A1_NCoeffs->rows();
  this->P_I_A1_NCoeffs->resizeAndPreserve(this->I_NApertures);
  if (oldrows < this->P_I_A1_NCoeffs->rows())
    (*this->P_I_A1_NCoeffs)(Range(oldrows, this->P_I_A1_NCoeffs->rows() - 1)) = 0;
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: 2. oldrows = " << oldrows << endl;
#endif

  /// XCenters
  oldrows = P_D_A2_XCenters->rows();
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: 3. oldrows = " << oldrows << ", this->I_NApertures = " << I_NApertures << ", this->P_D_A2_XCenters->cols() = " << this->P_D_A2_XCenters->cols() << endl;
#endif
  this->ResizeAndPreserve(*P_D_A2_XCenters, this->I_NApertures, this->P_D_A2_XCenters->cols());
  if (oldrows < this->I_NApertures)
    (*this->P_D_A2_XCenters)(Range(oldrows, this->I_NApertures - 1), Range::all()) = 0.;
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: 3. oldrows = " << oldrows << endl;
#endif

  /// XCenter
  oldrows = P_D_A1_XCenter->size();
  this->P_D_A1_XCenter->resizeAndPreserve(this->I_NApertures);
  if (oldrows < this->I_NApertures)
    (*this->P_D_A1_XCenter)(Range(oldrows, this->I_NApertures - 1)) = 0.;
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: 4. oldrows = " << oldrows << endl;
#endif

  /// YCenter
  oldrows = P_D_A1_YCenter->size();
  this->P_D_A1_YCenter->resizeAndPreserve(this->I_NApertures);
  if (oldrows < this->I_NApertures)
    (*this->P_D_A1_YCenter)(Range(oldrows, this->I_NApertures - 1)) = 0.;
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: 5. oldrows = " << oldrows << endl;
#endif

  /// XHigh
  int oldsize = this->P_D_A1_XHigh->size();
  this->P_D_A1_XHigh->resizeAndPreserve(this->I_NApertures);
  if (oldsize < this->P_D_A1_XHigh->size())
    (*this->P_D_A1_XHigh)(Range(oldsize, this->P_D_A1_XHigh->size() - 1)) = 0.;
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: 1. oldsize = " << oldsize << endl;
#endif

  /// XLow
  oldsize = this->P_D_A1_XLow->size();
  this->P_D_A1_XLow->resizeAndPreserve(this->I_NApertures);
  if (oldsize < this->P_D_A1_XLow->size())
    (*this->P_D_A1_XLow)(Range(oldsize, this->P_D_A1_XLow->size() - 1)) = 0.;
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: 2. oldsize = " << oldsize << endl;
  cout << "CFits::Set_NApertures: this->P_D_A1_XLow set to " << *this->P_D_A1_XLow << endl;
  (*P_OFS_Log) << "CFits::Set_NApertures: this->P_D_A1_XLow set to " << *this->P_D_A1_XLow << endl;
#endif

  /// YHigh
  oldsize = this->P_D_A1_YHigh->size();
  this->P_D_A1_YHigh->resizeAndPreserve(this->I_NApertures);
  if (oldsize < this->P_D_A1_YHigh->size())
    (*this->P_D_A1_YHigh)(Range(oldsize, this->P_D_A1_YHigh->size() - 1)) = 0.;

  /// YLow
  oldsize = this->P_D_A1_YLow->size();
  this->P_D_A1_YLow->resizeAndPreserve(this->I_NApertures);
  if (oldsize < this->P_D_A1_YLow->size())
    (*this->P_D_A1_YLow)(Range(oldsize, this->P_D_A1_YLow->size() - 1)) = 0.;
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: this->P_D_A1_YLow set to " << *this->P_D_A1_YLow << endl;
  (*P_OFS_Log) << "CFits::Set_NApertures: this->P_D_A1_YLow set to " << *this->P_D_A1_YLow << endl;
#endif

  /// YMin
  oldsize = this->P_D_A1_XMin->size();
  this->P_D_A1_XMin->resizeAndPreserve(this->I_NApertures);
  if (oldsize < this->P_D_A1_XMin->size())
    (*this->P_D_A1_XMin)(Range(oldsize, this->P_D_A1_XMin->size() - 1)) = 0.;

  /// YMax
  oldsize = this->P_D_A1_XMax->size();
  this->P_D_A1_XMax->resizeAndPreserve(this->I_NApertures);
  if (oldsize < this->P_D_A1_XMax->size())
    (*this->P_D_A1_XMax)(Range(oldsize, this->P_D_A1_XMax->size() - 1)) = 0.;

  /// Orders
  oldsize = this->P_I_A1_Orders->size();
  Array<int, 1> tempIntArr(oldsize);
  tempIntArr = (*P_I_A1_Orders);
  this->P_I_A1_Orders->resize(this->I_NApertures);
  if (oldsize < this->P_I_A1_Orders->size())
  {
    (*this->P_I_A1_Orders)(Range(0, oldsize - 1)) = tempIntArr;
    (*this->P_I_A1_Orders)(Range(oldsize, this->P_I_A1_Orders->size() - 1)) = 0;
  }
  else
  {
    (*this->P_I_A1_Orders) = tempIntArr(Range(0, this->P_I_A1_Orders->size() - 1));
  }
  /// Functions
  oldsize = this->P_CS_A1_Functions->size();
  Array<CString, 1> cs_a1_temp(oldsize);
  cs_a1_temp = (*this->P_CS_A1_Functions);
  this->P_CS_A1_Functions->resize(this->I_NApertures);
  (*P_CS_A1_Functions) = CString(" ");
  if (oldsize < this->P_CS_A1_Functions->size())
    (*this->P_CS_A1_Functions)(Range(0, oldsize-1)) = cs_a1_temp;
  else
    (*this->P_CS_A1_Functions) = cs_a1_temp(Range(0, this->I_NApertures-1));
  cs_a1_temp.resize(0);
  //  this->PP_CS_A1_Functions = (CString**)realloc(PP_CS_A1_Functions, this->I_NApertures * sizeof(CString*));
  //  for (int m = oldsize; m < this->I_NApertures; m++)
  //    this->PP_CS_A1_Functions[m] = new CString();
  /// Blaze
  this->P_D_A2_Blaze->resize(this->I_NApertures, this->NRows);
  this->P_D_A2_SP_Fit->resize(this->I_NApertures, this->NRows);
  this->P_D_A2_LastExtracted->resize(this->I_NApertures, this->NRows);
  this->P_D_A2_Errors_Ec->resize(this->I_NApertures, this->NRows);
  this->P_D_A2_Sky->resize(this->I_NApertures, this->NRows);
  this->P_D_A2_SkyError->resize(this->I_NApertures, this->NRows);
  this->P_D_A2_SkyFitError->resize(this->I_NApertures, this->NRows);
  this->P_D_A2_SkyFit->resize(this->I_NApertures, this->NRows);
  this->P_D_A2_Errors_EcFit->resize(this->I_NApertures, this->NRows);
//  this->P_D_A2_WLen->resize(this->NRows, this->NCols);
#ifdef __DEBUG_FITS_SET_NAPERTURES__
  cout << "CFits::Set_NApertures: task finished" << endl;
#endif
  return true;
}

/** ****************************************************** **/

bool CFits::Set_XHigh(const Array<double, 1>& D_A1_In)
{
  /// Check input
  if (D_A1_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_XHigh: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_XHigh: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A1_XHigh) = D_A1_In;

  return true;
}

/** ****************************************************** **/

bool CFits::Set_XLow(const Array<double, 1>& D_A1_In)
{
  /// Check input
  if (D_A1_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_XLow: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_XLow: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A1_XLow) = D_A1_In;
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::Set_XLow: this->P_D_A1_XLow set to " << *this->P_D_A1_XLow << endl;
  (*P_OFS_Log) << "CFits::Set_XLow: this->P_D_A1_XLow set to " << *this->P_D_A1_XLow << endl;
#endif
  return true;
}

/** ****************************************************** **/

bool CFits::Set_YHigh(const Array<double, 1>& D_A1_In)
{
  /// Check input
  if (D_A1_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_YHigh: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_YHigh: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A1_YHigh) = D_A1_In;

  return true;
}

/** ****************************************************** **/

bool CFits::Set_YLow(const Array<double, 1>& D_A1_In)
{
  cout << "CFits::Set_YLow: old this->P_D_A1_YLow = " << *this->P_D_A1_YLow << endl;
//  return false;
  /// Check input
  if (D_A1_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_YLow: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_YLow: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A1_YLow) = D_A1_In;
//#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::Set_YLow: this->P_D_A1_YLow set to " << *this->P_D_A1_YLow << endl;
  (*P_OFS_Log) << "CFits::Set_YLow: this->P_D_A1_YLow set to " << *this->P_D_A1_YLow << endl;
//#endif

  return true;
}

/** ****************************************************** **/

bool CFits::Set_XMax(const Array<double, 1>& D_A1_In)
{
  /// Check input
  if (D_A1_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_XMax: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_XMax: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A1_XMax) = D_A1_In;

  return true;
}

/** ****************************************************** **/

bool CFits::Set_XMin(const Array<double, 1>& D_A1_In)
{
  /// Check input
  if (D_A1_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_XMin: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_XMin: D_A1_In.rows(=" << D_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A1_XMin) = D_A1_In;

  return true;
}

/** ****************************************************** **/

bool CFits::Set_Coeffs(const Array<double, 2>& D_A2_In)
{
  /// Check input
  if (D_A2_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_Coeffs: D_A2_In.rows(=" << D_A2_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_Coeffs: D_A2_In.rows(=" << D_A2_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }
  if (D_A2_In.cols() < 1)
  {
    cout << "CFits::Set_Coeffs: D_A2_In.cols(=" << D_A2_In.cols() << ") < 1 => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_Coeffs: D_A2_In.cols(=" << D_A2_In.cols() << ") < 1 => Returning FALSE" << endl;
    return false;
  }

  this->P_D_A2_Coeffs->resize(this->I_NApertures, D_A2_In.cols());
  (*this->P_D_A2_Coeffs) = D_A2_In;

  return true;
}

/** ****************************************************** **/

bool CFits::Set_XCenters(const Array<double, 2>& D_A2_In)
{
  /// Check input
  if (D_A2_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_XCenters: D_A2_In.rows(=" << D_A2_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_XCenters: D_A2_In.rows(=" << D_A2_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }
  if (D_A2_In.cols() < this->NRows)
  {
    cout << "CFits::Set_XCenters: D_A2_In.rows(=" << D_A2_In.rows() << ") < this->NRows(=" << this->NRows << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_XCenters: D_A2_In.rows(=" << D_A2_In.rows() << ") < this->NRows(=" << this->NRows << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A2_XCenters) = D_A2_In;
#ifdef __DEBUG_FITS_SET_XCenters__
  cout << "CFits::Set_XCenters: D_A2_In(=" << D_A2_In << ") copied to this->P_D_A2_XCenters(=" << *P_D_A2_XCenters << ")" << endl;
  (*P_OFS_Log) << "CFits::Set_XCenters: D_A2_In(=" << D_A2_In << ") copied to this->P_D_A2_XCenters(=" << *P_D_A2_XCenters << ")" << endl;
#endif

  return true;
}

/** ****************************************************** **/

bool CFits::Set_XCenter(const Array<double, 1>& D_A1_In)
{
  /// Check input
  if (D_A1_In.size() != this->I_NApertures)
  {
    cout << "CFits::Set_XCenter: D_A1_In.size(=" << D_A1_In.size() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_XCenter: D_A1_In.size(=" << D_A1_In.size() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A1_XCenter) = D_A1_In;
#ifdef __DEBUG_FITS_SET_XCenters__
  cout << "CFits::Set_XCenter: D_A1_In(=" << D_A1_In << ") copied to this->P_D_A1_XCenter(=" << *P_D_A1_XCenter << ")" << endl;
#endif

  return true;
}

/** ****************************************************** **/

bool CFits::Set_YCenter(const Array<double, 1>& D_A1_In)
{
  /// Check input
  if (D_A1_In.size() != this->I_NApertures)
  {
    cout << "CFits::Set_YCenter: D_A1_In.size(=" << D_A1_In.size() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_YCenter: D_A1_In.size(=" << D_A1_In.size() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_D_A1_YCenter) = D_A1_In;
#ifdef __DEBUG_FITS_SET_XCenters__
  cout << "CFits::Set_YCenter: D_A1_In(=" << D_A1_In << ") copied to this->P_D_A1_YCenter(=" << *P_D_A1_YCenter << ")" << endl;
#endif

  return true;
}

/** ****************************************************** **/

bool CFits::Set_Orders(const Array<int, 1>& I_A1_In)
{
  /// Check input
  if (I_A1_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_Orders: I_A1_In.rows(=" << I_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_Orders: I_A1_In.rows(=" << I_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_I_A1_Orders) = I_A1_In;
  this->P_D_A2_Coeffs->resizeAndPreserve(this->I_NApertures, max(*this->P_I_A1_Orders));

  return true;
}

/** ****************************************************** **/

bool CFits::Set_NCoeffs(const Array<int, 1>& I_A1_In)
{
  /// Check input
  if (I_A1_In.rows() != this->I_NApertures)
  {
    cout << "CFits::Set_NCoeffs: I_A1_In.rows(=" << I_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_NCoeffs: I_A1_In.rows(=" << I_A1_In.rows() << ") != this->I_NApertures(=" << this->I_NApertures << ") => Returning FALSE" << endl;
    return false;
  }

  (*this->P_I_A1_NCoeffs) = I_A1_In;

  return true;
}

/** ****************************************************** **/

//bool CFits::Set_Functions(const CString** PP_CS_A1_Functions_In)
bool CFits::Set_Functions(const Array<CString, 1> CS_A1_Functions_In)
{
  if (P_CS_A1_Functions->size() != CS_A1_Functions_In.size())
  {
    cout << "CFits::Set_Functions: ERROR: P_CS_A1_Functions->size(=" << P_CS_A1_Functions->size() << ") != CS_A1_Functions_In.size(=" << CS_A1_Functions_In.size() << ")" << endl;
    (*P_OFS_Log) << "CFits::Set_Functions: ERROR: P_CS_A1_Functions->size(=" << P_CS_A1_Functions->size() << ") != CS_A1_Functions_In.size(=" << CS_A1_Functions_In.size() << ")" << endl;
    return false;
  }
  /*  for (int m = 0; m < this->I_NApertures; m++)
    {
      if (PP_CS_A1_Functions_In[m] == NULL)
      {
        cout << "CFits::Set_Functions: PP_CS_A1_Functions_In[" << m << "] == NULL => Returning FALSE!!!" << endl;
        return false;
      }
      if (!this->PP_CS_A1_Functions[m]->Copy(*(PP_CS_A1_Functions_In[m])))
      {
        cout << "CFits::Set_Functions: PP_CS_A1_Functions[" << m << "].Copy(*(PP_CS_A1_Functions_In[m])) returned FALSE => Returning FALSE!!!" << endl;
        return false;
      }
  }*/
  (*this->P_CS_A1_Functions) = CS_A1_Functions_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_SubArray(Array<double, 1> &D_A1_InOut, Array<int, 1> &I_A1_Indices_In, Array<double, 1> &D_A1_In) const
{
  if (D_A1_InOut.size() < D_A1_In.size())
  {
    cout << "CFits::Set_SubArray(double): D_A1_InOut.size(=" << D_A1_InOut.size() << ") < D_A1_In.size(=" << D_A1_In.size() << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_SubArray(double): D_A1_InOut.size(=" << D_A1_InOut.size() << ") < D_A1_In.size(=" << D_A1_In.size() << ") => Returning FALSE" << endl;
    return false;
  }
  if (D_A1_In.size() != I_A1_Indices_In.size())
  {
    cout << "CFits::Set_SubArray(double): D_A1_In.size(=" << D_A1_In.size() << ") != I_A1_Indices_In.size(=" << I_A1_Indices_In.size() << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_SubArray(double): D_A1_In.size(=" << D_A1_In.size() << ") != I_A1_Indices_In.size(=" << I_A1_Indices_In.size() << ") => Returning FALSE" << endl;
    return false;
  }
  Array<double, 1>::iterator pdm1 = const_cast<Array<double, 1>*>(&D_A1_In)->begin();
  Array<int, 1>::iterator pend = I_A1_Indices_In.end();
  Array<int, 1>::iterator pind = const_cast<Array<int, 1>*>(&I_A1_Indices_In)->begin();
  for (; pind != pend; ++pdm1, ++pind)
    D_A1_InOut(*pind) = *pdm1;
  return true;
}

/** *********************************************************/

bool CFits::Set_SubArray(Array<int, 1> &I_A1_InOut, Array<int, 1> &I_A1_Indices_In, Array<int, 1> &I_A1_In) const
{
  if (I_A1_InOut.size() < I_A1_In.size())
  {
    cout << "CFits::Set_SubArray(int): I_A1_InOut.size(=" << I_A1_InOut.size() << ") < I_A1_In.size(=" << I_A1_In.size() << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_SubArray(int): I_A1_InOut.size(=" << I_A1_InOut.size() << ") < I_A1_In.size(=" << I_A1_In.size() << ") => Returning FALSE" << endl;
    return false;
  }
  if (I_A1_In.size() != I_A1_Indices_In.size())
  {
    cout << "CFits::Set_SubArray(int): I_A1_In.size(=" << I_A1_In.size() << ") != I_A1_Indices_In.size(=" << I_A1_Indices_In.size() << ") => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_SubArray(int): I_A1_In.size(=" << I_A1_In.size() << ") != I_A1_Indices_In.size(=" << I_A1_Indices_In.size() << ") => Returning FALSE" << endl;
    return false;
  }
  Array<int, 1>::iterator pdm1 = const_cast<Array<int, 1>*>(&I_A1_In)->begin();
  Array<int, 1>::iterator pend = I_A1_Indices_In.end();
  Array<int, 1>::iterator pind = const_cast<Array<int, 1>*>(&I_A1_Indices_In)->begin();
  for (; pind != pend; ++pdm1, ++pind)
    I_A1_InOut(*pind) = *pdm1;
  return true;
}

/** *********************************************************/

bool CFits::Set_SubArray(Array<double, 2> &D_A2_InOut, Array<int, 2> &I_A2_Indices_In, Array<double, 2> &D_A2_In) const
{
  if (I_A2_Indices_In.cols() < 4){
    cout << "CFits::Set_SubArray: ERROR: I_A2_Indices_In.cols() < 4" << endl;
    return false;
  }
  int I_Row_InOut, I_Row_In, I_Col_InOut, I_Col_In;
//  D_A2_InOut.resize(I_NRows, I_NCols);
  for (int l = 0; l < I_A2_Indices_In.extent(firstDim); l++){
    I_Row_InOut = I_A2_Indices_In(l,0);
    I_Col_InOut = I_A2_Indices_In(l,1);
    I_Row_In = I_A2_Indices_In(l,2);
    I_Col_In = I_A2_Indices_In(l,3);
    if (I_Row_InOut >= D_A2_InOut.rows()){
      cout << "CFits::Set_SubArray: ERROR: I_Row_InOut(= " << I_Row_InOut << ") >= D_A2_InOut.rows()=" << D_A2_InOut.rows() << endl;
      return false;
    }
    if (I_Col_InOut >= D_A2_InOut.cols()){
      cout << "CFits::Set_SubArray: ERROR: I_Col_InOut(= " << I_Col_InOut << ") >= D_A2_InOut.cols()=" << D_A2_InOut.cols() << endl;
      return false;
    }
    if (I_Row_In >= D_A2_In.rows()){
      cout << "CFits::Set_SubArray: ERROR: I_Row_In(= " << I_Row_In << ") >= D_A2_In.rows()=" << D_A2_In.rows() << endl;
      return false;
    }
    if (I_Col_In >= D_A2_In.cols()){
      cout << "CFits::Set_SubArray: ERROR: I_Col_In(= " << I_Col_In << ") >= D_A2_In.cols()=" << D_A2_In.cols() << endl;
      return false;
    }
    D_A2_InOut(I_Row_InOut, I_Col_InOut) = D_A2_In(I_Row_In, I_Col_In);
  }
  return true;
}

/** *********************************************************/

bool CFits::Set_SubArray(Array<int, 2> &I_A2_InOut, Array<int, 2> &I_A2_Indices_In, Array<int, 2> &I_A2_In) const
{
  if (I_A2_Indices_In.cols() < 4){
    cout << "CFits::Set_SubArray: ERROR: I_A2_Indices_In.cols() < 4" << endl;
    return false;
  }
  int I_Row_InOut, I_Row_In, I_Col_InOut, I_Col_In;
//  I_A2_InOut.resize(I_NRows, I_NCols);
  for (int l = 0; l < I_A2_Indices_In.extent(firstDim); l++){
    I_Row_InOut = I_A2_Indices_In(l,0);
    I_Col_InOut = I_A2_Indices_In(l,1);
    I_Row_In = I_A2_Indices_In(l,2);
    I_Col_In = I_A2_Indices_In(l,3);
    if (I_Row_InOut >= I_A2_InOut.rows()){
      cout << "CFits::Set_SubArray: ERROR: I_Row_InOut(= " << I_Row_InOut << ") >= I_A2_InOut.rows()=" << I_A2_InOut.rows() << endl;
      return false;
    }
    if (I_Col_InOut >= I_A2_InOut.cols()){
      cout << "CFits::Set_SubArray: ERROR: I_Col_InOut(= " << I_Col_InOut << ") >= I_A2_InOut.cols()=" << I_A2_InOut.cols() << endl;
      return false;
    }
    if (I_Row_In >= I_A2_In.rows()){
      cout << "CFits::Set_SubArray: ERROR: I_Row_In(= " << I_Row_In << ") >= I_A2_In.rows()=" << I_A2_In.rows() << endl;
      return false;
    }
    if (I_Col_In >= I_A2_In.cols()){
      cout << "CFits::Set_SubArray: ERROR: I_Col_In(= " << I_Col_In << ") >= I_A2_In.cols()=" << I_A2_In.cols() << endl;
      return false;
    }
    I_A2_InOut(I_Row_InOut, I_Col_InOut) = I_A2_In(I_Row_In, I_Col_In);
  }
  return true;
}

/** *********************************************************/

bool CFits::Set_SubArray(Array<double, 2> &D_A2_InOut, Array<int, 2> &I_A2_Indices_In, Array<double, 1> &D_A1_In) const
{
  if (I_A2_Indices_In.cols() < 2){
    cout << "CFits::Set_SubArray: ERROR: I_A2_Indices_In.cols() < 2" << endl;
    return false;
  }
  int I_Row_InOut, I_Row_In, I_Col_InOut, I_Col_In;
//  D_A2_InOut.resize(I_NRows, I_NCols);
  for (int l = 0; l < I_A2_Indices_In.extent(firstDim); l++){
    I_Row_InOut = I_A2_Indices_In(l,0);
    I_Col_InOut = I_A2_Indices_In(l,1);
    if (I_Row_InOut >= D_A2_InOut.rows()){
      cout << "CFits::Set_SubArray: ERROR: I_Row_InOut(= " << I_Row_InOut << ") >= D_A2_InOut.rows()=" << D_A2_InOut.rows() << endl;
      return false;
    }
    if (I_Col_InOut >= D_A2_InOut.cols()){
      cout << "CFits::Set_SubArray: ERROR: I_Col_InOut(= " << I_Col_InOut << ") >= D_A2_InOut.cols()=" << D_A2_InOut.cols() << endl;
      return false;
    }
    D_A2_InOut(I_Row_InOut, I_Col_InOut) = D_A1_In(l);
  }
  return true;
}

/** *********************************************************/

bool CFits::Set_SubArray(Array<int, 2> &I_A2_InOut, Array<int, 2> &I_A2_Indices_In, Array<int, 1> &I_A1_In) const
{
  if (I_A2_Indices_In.cols() < 2){
    cout << "CFits::Set_SubArray: ERROR: I_A2_Indices_In.cols() < 2" << endl;
    return false;
  }
  int I_Row_InOut, I_Row_In, I_Col_InOut, I_Col_In;
//  I_A2_InOut.resize(I_NRows, I_NCols);
  for (int l = 0; l < I_A2_Indices_In.extent(firstDim); l++){
    I_Row_InOut = I_A2_Indices_In(l,0);
    I_Col_InOut = I_A2_Indices_In(l,1);
    if (I_Row_InOut >= I_A2_InOut.rows()){
      cout << "CFits::Set_SubArray: ERROR: I_Row_InOut(= " << I_Row_InOut << ") >= I_A2_InOut.rows()=" << I_A2_InOut.rows() << endl;
      return false;
    }
    if (I_Col_InOut >= I_A2_InOut.cols()){
      cout << "CFits::Set_SubArray: ERROR: I_Col_InOut(= " << I_Col_InOut << ") >= I_A2_InOut.cols()=" << I_A2_InOut.cols() << endl;
      return false;
    }
    I_A2_InOut(I_Row_InOut, I_Col_InOut) = I_A1_In(l);
  }
  return true;
}

/** *********************************************************/

bool CFits::Set_Gain(double D_Gain_In)
{
#ifdef __DEBUG_FITS__
  cout << "CFits::Set_Gain(D_Gain_In=" << D_Gain_In << ") started" << endl;
#endif
  if (D_Gain_In <= 0.)
  {
    cout << "CFits::Set_Gain(): ERROR: D_Gain_In(=" << D_Gain_In << ") <= 0." << endl;
    (*P_OFS_Log) << "CFits::Set_Gain(): ERROR: D_Gain_In(=" << D_Gain_In << ") <= 0." << endl;
    return false;
  }
  this->D_Gain = D_Gain_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_ReadOutNoise(double D_ReadOutNoise_In)
{
  if (D_ReadOutNoise_In < 0.)
  {
    cout << "CFits::Set_ReadOutNoise: ERROR: D_ReadOutNoise_In(=" << D_ReadOutNoise_In << ") < 0. => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_ReadOutNoise: ERROR: D_ReadOutNoise_In(=" << D_ReadOutNoise_In << ") < 0. => Returning FALSE" << endl;
    return false;
  }
  this->D_ReadOutNoise = D_ReadOutNoise_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_SaturationLevel(double D_SaturationLevel_In)
{
  if (D_SaturationLevel_In < 0.)
  {
    cout << "CFits::Set_SaturationLevel: ERROR: D_SaturationLevel_In(=" << D_SaturationLevel_In << ") < 0. => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_SaturationLevel: ERROR: D_SaturationLevel_In(=" << D_SaturationLevel_In << ") < 0. => Returning FALSE" << endl;
    return false;
  }
  this->D_SaturationLevel = D_SaturationLevel_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_ApertureFWHM(double D_ApertureFWHM_In)
{
  if (D_ApertureFWHM_In < 0.)
  {
    cout << "CFits::Set_ApertureFWHM: ERROR: D_ApertureFWHM_In(=" << D_ApertureFWHM_In << ") < 0. => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_ApertureFWHM: ERROR: D_ApertureFWHM_In(=" << D_ApertureFWHM_In << ") < 0. => Returning FALSE" << endl;
    return false;
  }
  this->D_ApertureFWHM = D_ApertureFWHM_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_SignalThreshold(double D_SignalThreshold_In)
{
  if (D_SignalThreshold_In < 0.)
  {
    cout << "CFits::Set_SignalThreshold: ERROR: D_SignalThreshold_In(=" << D_SignalThreshold_In << ") < 0. => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_SignalThreshold: ERROR: D_SignalThreshold_In(=" << D_SignalThreshold_In << ") < 0. => Returning FALSE" << endl;
    return false;
  }
  this->D_SignalThreshold = D_SignalThreshold_In;
  return true;
}

/** **********************************************************/

bool CFits::Set_MaxNumberOfAperturesToBeFound(int I_MaxNumberOfAperturesToBeFound_In){
  if (I_MaxNumberOfAperturesToBeFound_In < 1)
    return false;
  this->I_MaxNumberOfAperturesToBeFound = I_MaxNumberOfAperturesToBeFound_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_OverSample(int I_OverSample_In)
{
  if (I_OverSample_In < 1.)
  {
    cout << "CFits::Set_OverSample: I_OverSample_In(=" << I_OverSample_In << ") < 1. => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_OverSample: I_OverSample_In(=" << I_OverSample_In << ") < 1. => Returning FALSE" << endl;
    return false;
  }
  this->I_OverSample = I_OverSample_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_MaxIterSF(int I_MaxIterSF_In)
{
  if (I_MaxIterSF_In < 1.)
  {
    cout << "CFits::Set_MaxIterSF: I_MaxIterSF_In(=" << I_MaxIterSF_In << ") < 1. => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_MaxIterSF: I_MaxIterSF_In(=" << I_MaxIterSF_In << ") < 1. => Returning FALSE" << endl;
    return false;
  }
  this->I_MaxIterSF = I_MaxIterSF_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_MaxIterSky(int I_MaxIterSky_In)
{
  if (I_MaxIterSky_In < 1.)
  {
    cout << "CFits::Set_MaxIterSky: I_MaxIterSky_In(=" << I_MaxIterSky_In << ") < 1. => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_MaxIterSky: I_MaxIterSky_In(=" << I_MaxIterSky_In << ") < 1. => Returning FALSE" << endl;
    return false;
  }
  this->I_MaxIterSky = I_MaxIterSky_In;
  return true;
}

/** *********************************************************/

bool CFits::Set_MaxIterSig(int I_MaxIterSig_In)
{
  if (I_MaxIterSig_In < 1.)
  {
    cout << "CFits::Set_MaxIterSig: I_MaxIterSig_In(=" << I_MaxIterSig_In << ") < 1. => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Set_MaxIterSig: I_MaxIterSig_In(=" << I_MaxIterSig_In << ") < 1. => Returning FALSE" << endl;
    return false;
  }
  this->I_MaxIterSig = I_MaxIterSig_In;
  return true;
}

/** *********************************************************/

int CFits::GetNCols() const
{
  return this->NCols;
}

/** *********************************************************/

int CFits::GetNRows() const
{
  return this->NRows;
}

/** ********************************************************/

CString& CFits::GetFileName() const
{
  return (*(new CString(*(this->P_CS_FileName))));
}

/** ********************************************************/

CString& CFits::GetErrFileName() const
{
  return (*(new CString(*(this->P_CS_ErrFileName))));
}

/** ********************************************************/

CString& CFits::GetDatabaseFileName() const
{
  return (*(new CString(*(this->P_CS_DatabaseFileName))));
  //  return(*P_TempFileName);
}

/** ********************************************************/

Array<double, 2>& CFits::GetPixArray()
{
  return (*(this->P_D_A2_PixArray));
}

/** ********************************************************/

Array<double, 2>& CFits::GetProfArray()
{
  return (*(this->P_D_A2_ProfArray));
}

/** ********************************************************/

Array<double, 2>& CFits::GetErrArray()
{
  return (*(this->P_D_A2_ErrArray));
}

/** ********************************************************/

Array<double, 2>& CFits::GetRecSkyArray()
{
  return (*(this->P_D_A2_RecSkyArray));
}

/** ********************************************************/

Array<double, 2>& CFits::GetRecArray()
{
  return (*(this->P_D_A2_RecArray));
}

/** ********************************************************/

Array<double, 2>& CFits::GetRecFitArray()
{
  return (*(this->P_D_A2_RecFitArray));
}

/** ********************************************************/

Array<int, 2>& CFits::GetMaskArray()
{
  return (*(this->P_I_A2_MaskArray));
}

/** ********************************************************/

Array<double, 2>& CFits::GetSpec()
{
  return (*(this->P_D_A2_Blaze));
}

/** ********************************************************/

Array<double, 2>& CFits::GetSpecFit()
{
  return (*(this->P_D_A2_SP_Fit));
}

/** ********************************************************/

Array<double, 2>& CFits::GetLastExtracted()
{
  return (*(this->P_D_A2_LastExtracted));
}

/** ********************************************************/

Array<double, 2>& CFits::GetErrorsEc()
{
  return (*(this->P_D_A2_Errors_Ec));
}

/** ********************************************************/

Array<double, 2>& CFits::GetSky()
{
  return (*(this->P_D_A2_Sky));
}

/** ********************************************************/

Array<double, 2>& CFits::GetSkyError()
{
  return (*(this->P_D_A2_SkyError));
}

Array<double, 2>& CFits::GetSkyFitError(){
  return (*(this->P_D_A2_SkyFitError));
}

Array<double, 2>& CFits::GetSkyFit(){
  return (*(this->P_D_A2_SkyFit));
}

Array<double, 2>& CFits::GetErrorsEcFit(){
  return (*(this->P_D_A2_Errors_EcFit));
}

Array<double, 2>& CFits::GetRecSkyFitArray(){
  return (*(this->P_D_A2_RecSkyFitArray));
}

/** ****************************************************** **/

Array<double, 2>& CFits::GetWavelengths(){ /// NApertures x NRows
  return (*(this->P_D_A2_WLen));
}

/** ****************************************************** **/

int CFits::Get_DispAxis() const
{
  return this->I_DispAxis;
}

/** ****************************************************** **/

int CFits::Get_NApertures() const
{
  return this->I_NApertures;
}

/** ****************************************************** **/

Array<double, 1>* CFits::Get_XHigh() const
{
  return (new Array<double, 1>(this->P_D_A1_XHigh->copy()));
}

/** ****************************************************** **/

Array<double, 1>* CFits::Get_XLow() const
{
  return (new Array<double, 1>(this->P_D_A1_XLow->copy()));
}

/** ****************************************************** **/

Array<double, 1>* CFits::Get_YHigh() const
{
  return (new Array<double, 1>(this->P_D_A1_YHigh->copy()));
}

/** ****************************************************** **/

blitz::Array< double, 1 >* CFits::Get_YLow() const
{
  return (new Array<double, 1>(this->P_D_A1_YLow->copy()));
}

/** ****************************************************** **/

Array<double, 1>* CFits::Get_XMax() const
{
  return (new Array<double, 1>(this->P_D_A1_XMax->copy()));
}

/** ****************************************************** **/

Array<double, 1>* CFits::Get_XMin() const
{
  return (new Array<double, 1>(this->P_D_A1_XMin->copy()));
}

/** ****************************************************** **/

Array<double, 2>* CFits::Get_Coeffs() const
{
  return (new Array<double, 2>(this->P_D_A2_Coeffs->copy()));
}

/** ****************************************************** **/

Array<double, 2>* CFits::Get_XCenters() const
{
  //Array<double, 2> *P_D_A2_Temp = new Array<double, 2>();
  //(*P_D_A2_Temp) = this->P_D_A2_XCenters->copy();
  return (new Array<double, 2>(this->P_D_A2_XCenters->copy()));
}

/** ****************************************************** **/

Array<double, 2>* CFits::Get_XCentersPointer()
{
  //Array<double, 2> *P_D_A2_Temp = new Array<double, 2>();
  //(*P_D_A2_Temp) = this->P_D_A2_XCenters->copy();
  return (this->P_D_A2_XCenters);
}

/** ****************************************************** **/

Array<double, 1>* CFits::Get_XCenter() const
{
  //Array<double, 2> *P_D_A2_Temp = new Array<double, 2>();
  //(*P_D_A2_Temp) = this->P_D_A2_XCenters->copy();
  return (new Array<double, 1>(this->P_D_A1_XCenter->copy()));
}

/** ****************************************************** **/

Array<double, 1>* CFits::Get_YCenter() const
{
  //Array<double, 2> *P_D_A2_Temp = new Array<double, 2>();
  //(*P_D_A2_Temp) = this->P_D_A2_XCenters->copy();
  return (new Array<double, 1>(this->P_D_A1_YCenter->copy()));
}

/** ****************************************************** **/

Array<int, 1>* CFits::Get_Orders() const
{
  return (new Array<int, 1>(this->P_I_A1_Orders->copy()));
}

/** ****************************************************** **/

Array<int, 1>* CFits::Get_NCoeffs() const
{
  return (new Array<int, 1>(this->P_I_A1_NCoeffs->copy()));
}

/** ****************************************************** **/

//CString** CFits::Get_Functions() const
Array<CString, 1>* CFits::Get_Functions() const
{
  /*  CString **PP_CS_A1_Functions_Temp = (CString**)malloc(sizeof(CString*) * this->I_NApertures);
    for (int m = 0; m < this->I_NApertures; m++)
    {
      PP_CS_A1_Functions_Temp[m] = new CString();
      if (this->PP_CS_A1_Functions[m] != NULL)
        PP_CS_A1_Functions_Temp[m]->Copy(*(this->PP_CS_A1_Functions[m]));
      else
        cout << "CFits::Get_Functions: PP_CS_A1_Functions[" << m << "] == NULL!!!!!!!!!!!!!!!!!!" << endl;
    }
    return PP_CS_A1_Functions;*/
  Array<CString, 1> *P_CS_A1_Functions_Temp = new Array<CString, 1>(this->I_NApertures);
  (*P_CS_A1_Functions_Temp) = (*this->P_CS_A1_Functions);
  return P_CS_A1_Functions_Temp;
}

/** ****************************************************** **/

double CFits::Get_Gain() const
{
  return this->D_Gain;
}

/** ****************************************************** **/

double CFits::Get_ReadOutNoise() const
{
  return this->D_ReadOutNoise;
}

/** ****************************************************** **/

double CFits::Get_SaturationLevel() const
{
  return this->D_SaturationLevel;
}

/** ****************************************************** **/

double CFits::Get_ApertureFWHM() const
{
  return this->D_ApertureFWHM;
}

/** ****************************************************** **/

double CFits::Get_SignalThreshold() const
{
  return this->D_SignalThreshold;
}

/** *********************************************************/

int CFits::Get_MaxNumberOfAperturesToBeFound() const
{
  return this->I_MaxNumberOfAperturesToBeFound;
}

/** ****************************************************** **/

int CFits::Get_OverSample() const
{
  return this->I_OverSample;
}

/** ****************************************************** **/

int CFits::Get_MaxIterSF() const
{
  return this->I_MaxIterSF;
}

/** ****************************************************** **/

int CFits::Get_MaxIterSky() const
{
  return this->I_MaxIterSky;
}

/** ****************************************************** **/

int CFits::Get_MaxIterSig() const
{
  return this->I_MaxIterSig;
}

/**
function int CountLines(const CString &fnc: inout)
Returns number of lines of file <fnc>.
 **/
long CFits::CountLines(const CString &fnc) const
{
  CString CS("");
  return CS.CountLines(fnc);
  /**
#ifdef __DEBUG_FITS__
  //  fprintf(logfile,"CFits::CountLines: method started\n");
#endif
  FILE *ffile;
  long nelements;
  char oneword[255];
  char fname[255];
  char *line;
  strcpy(fname, fnc.Get());

#ifdef __DEBUG_FITS__
  printf("CFits::CountLines: function started\n");
#endif
  ffile = fopen(fname, "r");
  if (ffile == NULL)
  {
    cout << "CFits::CountLines: Failed to open file fname (=<" << fname << ">)" << endl;
#ifdef __DEBUG_FITS_PISKUNOV__
    (*P_OFS_Log) << "CFits::CountLines: Failed to open file fname (=<" << fname << ">)" << endl;
    exit (EXIT_FAILURE);
#endif
    //return 0;
  }
#ifdef __DEBUG_FITS__
  printf("CFits::CountLines: File fname(=<%s>) opened\n", fname);
#endif

  nelements = 0;
  // --- read file <fname> named <ffile>
  do
  {
    line = fgets(oneword, 255, ffile);
    if (line != NULL)
    {
#ifdef __DEBUG_FITS__
      //      printf("CFits::CountLines: oneword = <%s>\n", oneword);
#endif
      // --- count lines
      nelements++;
    }
  }
  while (line != NULL);
#ifdef __DEBUG_FITS__
  printf("CFits::CountLines: File fname(=<%s>) contains %d data lines\n",fname,nelements);
#endif
  // --- close input file
  fclose(ffile);
#ifdef __DEBUG_FITS__
  printf("CFits::CountLines: File fname (=<%s>) closed\n", fname);
#endif
  return nelements;
  **/
}

/**
function int CountDataLines(const CString &fnc: inout)
Returns number of lines which do not start with '#' of file <fnc>.
 **/
long CFits::CountDataLines(const CString &fnc) const
{
  CString CS("");
  return CS.CountDataLines(fnc);
  /**
#ifdef __DEBUG_FITS__
  //  fprintf(logfile,"CFits::CountDataLines: method started\n");
#endif
  FILE *ffile;
  long nelements;
  char oneword[255];
  char fname[255];
  char *line;
  strcpy(fname, fnc.Get());

#ifdef __DEBUG_FITS__
  printf("CFits::CountDataLines: function started\n");
#endif
  ffile = fopen(fname, "r");
  if (ffile == NULL)
  {
    cout << "CFits::CountDataLines: Failed to open file fname (=<" << fname << ">)" << endl;
#ifdef __DEBUG_FITS_PISKUNOV__
    (*P_OFS_Log) << "CFits::CountDataLines: Failed to open file fname (=<" << fname << ">)" << endl;
    exit (EXIT_FAILURE);
#endif
    //return 0;
  }
#ifdef __DEBUG_FITS__
  printf("CFits::CountDataLines: File fname(=<%s>) opened\n", fname);
#endif

  nelements = 0;
  // --- read file <fname> named <ffile>
  do
  {
    line = fgets(oneword, 255, ffile);
    if (line != NULL && line[0] != '#')
    {
#ifdef __DEBUG_FITS__
      //      printf("CFits::CountDataLines: oneword = <%s>\n", oneword);
#endif
      // --- count lines
      nelements++;
    }
  }
  while (line != NULL);
#ifdef __DEBUG_FITS__
  printf("CFits::CountDataLines: File fname(=<%s>) contains %d data lines\n",fname,nelements);
#endif
  // --- close input file
  fclose(ffile);
#ifdef __DEBUG_FITS__
  printf("CFits::CountDataLines: File fname (=<%s>) closed\n", fname);
#endif
  return nelements;
  **/
}

/**
 function int CountCols(const CString &fnc: inout)
 Returns number of columns of file <fnc>.
 **/
long CFits::CountCols(const CString &CS_FileName_In, const CString &CS_Delimiter) const{
  CString CS("");
  return CS.CountCols(CS_FileName_In, CS_Delimiter);
  /**
  long L_Cols = 0;
  long L_OldCols = 0;
  CString templine(" ");
  int I_NLines = this->CountLines(CS_FileName_In);
//    openr,lun,filename,/get_lun
  FILE *ffile;
  long I_Row;
  char oneword[255];
  char fname[255];
  char *line;
  char tempchar[255];
  tempchar[0] = '\n';
  tempchar[1] = '\0';
  strcpy(fname, CS_FileName_In.Get());
  CString CS_Line;
  char *chr_cstring;

#ifdef __DEBUG_FITS_COUNTCOLS__
  printf("CFits::CountCols: function started\n");
#endif
  ffile = fopen(fname, "r");
  if (ffile == NULL)
  {
    cout << "CFits::CountCols: Failed to open file fname (=<" << fname << ">)" << endl;
#ifdef __DEBUG_FITS_COUNTCOLS__
    (*P_OFS_Log) << "CFits::CountCols: Failed to open file fname (=<" << fname << ">)" << endl;
    exit (EXIT_FAILURE);
#endif
    //return 0;
  }
#ifdef __DEBUG_FITS_COUNTCOLS__
  printf("CFits::CountCols: File fname(=<%s>) opened\n", fname);
#endif

  I_Row = 0;
  // --- read file <fname> named <ffile>
  int I_Pos;
  CString *P_CS_Temp;
  do
  {
    line = fgets(oneword, 255, ffile);
    if (line != NULL)
    {
      // --- count lines
      if (!CS_Line.Set(line)){
        cout << "CFits::CountCols: ERROR: CS_Line.Set(line) returned FALSE." << endl;
        return false;
      }
      I_Pos = CS_Line.CharPos('\n');
#ifdef __DEBUG_FITS_COUNTCOLS__
      cout << "CFits::CountCols: I_Row = " << I_Row << ": I_Pos(tempchar) set to " << I_Pos << endl;
#endif
      if (I_Pos >= 0){
        chr_cstring = CS_Line.Get();
        chr_cstring[I_Pos] = '\0';
//        P_CS_Temp = CS_Line.SubString(0,CS_Line.StrPos(tempchar)-1);
        CS_Line = CString(chr_cstring);
#ifdef __DEBUG_FITS_COUNTCOLS__
        cout << "CFits::CountCols: I_Row = " << I_Row << ": CS_Line set to <" << CS_Line << ">" << endl;
#endif
//        delete(P_CS_Temp);
      }
      I_Pos = CS_Line.StrPos(CString("#"));
      if (I_Pos != 0){
        L_Cols = 0;
        while (CS_Line.StrPos(CS_Delimiter) >= 0){
//          while (CS_Line.StrPos(CS_Delimiter) == 0){
//            CString *P_CS_Line = CS_Line.SubString(1);
//            CS_Line.Set(*P_CS_Line);
//            delete(P_CS_Line);
//          }
          L_Cols++;
#ifdef __DEBUG_FITS_COUNTCOLS__
          cout << "CFits::CountCols: I_Row = " << I_Row << ": L_Cols set to " << L_Cols << endl;
#endif
          I_Pos = CS_Line.StrPos(CS_Delimiter);
#ifdef __DEBUG_FITS_COUNTCOLS__
          cout << "CFits::CountCols: I_Row = " << I_Row << ": I_Pos set to " << I_Pos << endl;
#endif
          P_CS_Temp = CS_Line.SubString(I_Pos+1);
#ifdef __DEBUG_FITS_COUNTCOLS__
          cout << "CFits::CountCols: I_Row = " << I_Row << ": P_CS_Temp set to <" << *P_CS_Temp << ">" << endl;
#endif
          P_CS_Temp->TrimChar(CS_Delimiter,2);
#ifdef __DEBUG_FITS_COUNTCOLS__
          cout << "CFits::CountCols: I_Row = " << I_Row << ": P_CS_Temp set to <" << *P_CS_Temp << ">" << endl;
#endif
          CS_Line = *P_CS_Temp;
#ifdef __DEBUG_FITS_COUNTCOLS__
          cout << "CFits::CountCols: I_Row = " << I_Row << ": CS_Line set to <" << CS_Line << ">" << endl;
#endif
          delete(P_CS_Temp);
        }
        L_Cols++;
#ifdef __DEBUG_FITS_COUNTCOLS__
        cout << "CFits::CountCols: I_Row = " << I_Row << ": L_Cols set to " << L_Cols << endl;
#endif
      }
      if (L_Cols > L_OldCols){
          L_OldCols = L_Cols;
#ifdef __DEBUG_FITS_COUNTCOLS__
          cout << "CFits::CountCols: L_Cols = " << L_Cols << endl;
#endif
      }
      I_Row++;
    }
  }
  while (line != NULL);
#ifdef __DEBUG_FITS__
  printf("CFits::CountCols: File fname(=<%s>) contains %d data lines\n",fname,I_Row);
#endif
  // --- close input file
  fclose(ffile);
#ifdef __DEBUG_FITS__
  printf("CFits::CountCols: File fname (=<%s>) closed\n", fname);
#endif
  return L_OldCols;
**/
}

/*int CFits::AddHeader(const CString &CS_HeaderFileName_In)
{
  fitsfile *P_FitsFile;
  FILE     *P_HeaderFile;
  int      Count,Status;
  int      FirstLinesRemoved = 0;
  int      BitPix, NElements;
  int      AnyNul, Extend, Simple, Pos, TempInt;
  int      NAxis, Width, LowInt, HighInt;
  double   TempDbl;
  long     PCount, GCount, NLines, TempLong;
  long     NAxes[2];
  long     FPixel, i, j;
  //  float * Array;
  float    NullVal;
  char     StrBuf[256];
//  char     *P_CS_FileName;
//  char     *P_HeaderFileName;
  char     *P_Pos;
  char     OneWord[255], LineCharArr[255], TempCharArr[255];
  CString  CS_Line, CS_TempLine, CS_HeaderKeyWord, CS_HeaderKeyWordValue, CS_HeaderKeyWordComment;
  char     *P_Line, *P_TempLine, *P_HeaderKeyWord, *P_HeaderKeyWordValue, *P_HeaderKeyWordComment;
  char     *P_TempStr;

//  char *P_TempFitsFile = "/yoda/ses/sigGem_20061010-0012/sigGem/sigGem_science20061010-0012_botzfxs_ec_bld_003tn_rb.fits";
//  char *P_TempHeaderFile = "/yoda/ses/sigGem_20061010-0012/sigGem/sigGem_science20061010-0012_botzfxs_ec_bld_003tn_head.text.new";

/*  if (argc < 2)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Not enough parameters specified!\n");
    printf("CFits::AddHeaderToFitsFile: USAGE:\n\n");
    printf(" addheadertofitsfile(char* P_CS_FileName, char* P_HeaderFileName)\n\n");
    //    argv = (char**)malloc(sizeof(char*) * 2);
    argv[1] = (char*)malloc(sizeof(char) * strlen(P_TempFitsFile));
    argv[2] = (char*)malloc(sizeof(char) * strlen(P_TempFitsFile));
    argc = 3;
    strcpy(argv[1], P_TempFitsFile);
    strcpy(argv[2], P_TempHeaderFile);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
    printf("CFits::AddHeaderToFitsFile: argv[1] =<%s>\n", argv[1]);
    printf("CFits::AddHeaderToFitsFile: argv[2] =<%s>\n", argv[2]);
#endif

  }
*/
/*
  // --- allocate memory for Pointer variables
  P_HeaderKeyWord = (char*)malloc(sizeof(char) * 255);
  if (P_HeaderKeyWord == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_HeaderKeyWord" << endl;
    return false;
  }

  P_HeaderKeyWordValue = (char*)malloc(sizeof(char) * 255);
  if (P_HeaderKeyWordValue == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_HeaderKeyWordValue" << endl;
    return false;
  }

  P_HeaderKeyWordComment = (char*)malloc(sizeof(char) * 255);
  if (P_HeaderKeyWordComment == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_HeaderKeyWordComment" << endl;
    return false;
  }

/*  P_CS_FileName = (char*)malloc(sizeof(char) * 255);
  if (P_CS_FileName == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_CS_FileName" << endl;
    return false;
  }
  strcpy(P_CS_FileName, argv[1]);

  P_HeaderFileName = (char*)malloc(sizeof(char) * 255);
  if (P_HeaderFileName == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_HeaderFileName" << endl;
    return false;
  }
  strcpy(P_HeaderFileName, argv[2]);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
  cout << "CFits::AddHeaderToFitsFile: P_CS_FileName = <" << *P_CS_FileName << ">" << endl;
  printf("CFits::AddHeaderToFitsFile: P_HeaderFileName = <" << *P_HeaderFileName << ">" << endl;
#endif
*/
/*
  P_Line = (char*)malloc(sizeof(char) * 255);
  if (P_Line == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_Line" << endl;
    return false;
  }

  P_TempLine = (char*)malloc(sizeof(char) * 255);
  if (P_TempLine == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_TempLine" << endl;
    return false;
  }

  P_TempStr = (char*)malloc(sizeof(char) * 255);
  if (P_TempStr == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_TempStr" << endl;
    return false;
  }

  // --- open fits file
  Status=0;

  fits_open_file(&P_FitsFile, this->P_CS_FileName->Get(), READWRITE, &Status);
  fits_read_imghdr(P_FitsFile, 2, &Simple , &BitPix, &NAxis, NAxes, &PCount, &GCount, &Extend, &Status);
  if (Status !=0)
  {
    cout << "CFits::AddHeaderToFitsFile: Error " << Status << " in file " << this->P_CS_FileName->Get() << endl;
    return false;
  }

  // --- Count lines of HeaderFile
  NLines = CountCols( CS_HeaderFileName_In );

  // --- open file <P_HeaderFile> with name <P_HeaderFileName> for reading
  P_HeaderFile = fopen(CS_HeaderFileName_In.Get(), "r");
  if (P_HeaderFile == NULL)
  {
    cout << "CFits::AddHeaderToFitsFile: Failed to open file P_HeaderFile (=<" << CS_HeaderFileName_In << ">)" << endl;
    exit (EXIT_FAILURE);
  }

  for (i = 0; i < NLines; i++)
  {
    // --- Read Line
    P_Line = fgets(OneWord, 200, P_HeaderFile);
    if (P_Line != NULL)
    {
      //strcpy(LineCharArr, P_Line);
      CS_Line.Set(P_Line);

      // --- Look for first HeaderKeyWord
      if (FirstLinesRemoved == 0)
      {
        //while((CS_HeaderFileName_In.CharPosInCharArr(LineCharArr, '=') == -1 || CS_HeaderFileName_In.CharPosInCharArr(LineCharArr, '/') == -1) && P_Line != NULL)// && (strchr(P_Line, '=') == NULL || strchr(P_Line, '/') == NULL))
        while((CS_Line.CharPos('=') == -1 || CS_Line.CharPos('/') == -1) && !CS_Line.EqualValue(new CString("")))// && (strchr(P_Line, '=') == NULL || strchr(P_Line, '/') == NULL))
        {
          P_Line = fgets(OneWord, 200, P_HeaderFile);
          if (P_Line != NULL)
          {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
            cout << "CFits::AddHeaderToFitsFile.while: P_Line =<" << P_Line << ">" << endl;
#endif
//            strcpy(LineCharArr, P_Line);
            CS_Line.Set(P_Line);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
            cout << "CFits::AddHeaderToFitsFile.while: P_Line = <" << P_Line << ">" << endl;
            cout << "CFits::AddHeaderToFitsFile.while: LineCharArr = <" << CS_Line << ">" << endl;
            cout << "CFits::AddHeaderToFitsFile.while: CharPosInCharArr(LineCharArr, '=') = " << CS_Line.CharPos('=') << endl;
            cout << "CFits::AddHeaderToFitsFile.while: CharPosInCharArr(LineCharArr, '/') = " << CS_Line.CharPos('/') << endl;
#endif
          }
          //      exit(0);
        }
        FirstLinesRemoved = 1;
      }
      if (P_Line != NULL)
      {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
        cout << "CFits::AddHeaderToFitsFile: P_Line =<" << P_Line << ">" << endl;
#endif
//        strcpy(P_TempLine, P_Line);
        CS_Line.Set(P_Line);

        // --- Count Elements in P_Line
        NElements = 0;
        P_HeaderKeyWord = strtok(P_Line," =\t\n\0");
        //CS_HeaderKeyWord.Set(strtok(P_Line," =\t\n\0"));
        if (P_HeaderKeyWord != NULL)
        {
          while (P_HeaderKeyWord != NULL)
          {
            P_HeaderKeyWord = strtok(NULL, "/\t\n\0");
            NElements++;
          }
        }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
        cout << "CFits::AddHeaderToFitsFile: NElements = " << NElements << endl;
#endif

        // --- Read HeaderKeyWord
        strcpy(P_Line, P_TempLine);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
        cout << "CFits::AddHeaderToFitsFile: P_Line =<" << P_Line << ">" << endl;
#endif
        free(P_HeaderKeyWord);
        P_HeaderKeyWord = strtok(P_Line,"=\t\n\0");
        if (P_HeaderKeyWord != NULL)
        {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
          cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord =<" << P_HeaderKeyWord << ">" << endl;
#endif
          // --- Trim HeaderKeyWord
          P_HeaderKeyWord = CS_HeaderFileName_In.TrimChar(P_HeaderKeyWord, 2);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
          cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord =<" << P_HeaderKeyWord << ">" << endl;
#endif
          // --- look if trimmed HeaderKeyWord is empty
          //        while (strcmp(P_HeaderKeyWord, "") == 0 && P_HeaderKeyWord != NULL)
          //        {
          // -- reread HeaderKeyWord
          //          P_HeaderKeyWord = strtok(P_Line,"=\t\n\0");
          // #ifdef __DEBUG_MADDHEADERTOFITSFILE__
          //          printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord =<%s>\n", P_HeaderKeyWord);
          // #endif
          // --- Trim reread HeaderKeyWord
          //          P_HeaderKeyWord = StrTrim(P_HeaderKeyWord, 2);
          // #ifdef __DEBUG_MADDHEADERTOFITSFILE__
          //          printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord =<%s>\n", P_HeaderKeyWord);
          // #endif
          //      }
          if (P_HeaderKeyWord != NULL)
          {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
            cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord = <" << *P_HeaderKeyWord << ">" << endl;
#endif
            // --- Read HeaderKeyWordValue
            if (strlen(P_HeaderKeyWord) > 6 && strcmp(SubString(P_HeaderKeyWord, 0, 6), "COMMENT") == 0)
            {
              if (strlen(P_HeaderKeyWordValue) > 0)
              {
                free (P_HeaderKeyWordValue);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWordValue set free" << endl;
#endif
              }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
              cout << "CFits::AddHeaderToFitsFile: P_TempLine = <" << P_TempLine << ">" << endl;
#endif
              P_HeaderKeyWordValue = SubString(P_TempLine, 8, strlen(P_TempLine));
              P_HeaderKeyWordValue = StrTrimChar(P_HeaderKeyWordValue, '\n', 1);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
              cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWordValue =<" << P_HeaderKeyWordValue << ">" << endl;
#endif
              // --- Append HeaderComment to Fits file
              //fits_write_date(P_FitsFile, &Status);
              fits_write_comment(P_FitsFile, P_HeaderKeyWordValue, &Status);
              //fits_write_key_null(P_FitsFile, P_HeaderKeyWord, P_HeaderKeyWordValue, &Status);
              if (Status !=0)
              {
                cout << "CFits::AddHeaderToFitsFile: Error " << Status << " while trying to add P_HeaderKeyWord <" << P_HeaderKeyWord << "> to file <" << P_CS_FileName << ">" << endl;
                return false;
              }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
              cout << "CFits::AddHeaderToFitsFile: HeaderComment <" << P_HeaderKeyWordValue << "> inserted" << endl;
#endif
//              exit(0);
            }// end if (strcmp(P_HeaderKeyWord, "COMMENT") == 0)
            else
            {
              P_HeaderKeyWordValue = "";
              while (P_HeaderKeyWordValue != NULL && strcmp(P_HeaderKeyWordValue, "") == 0)
              {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                cout << "CFits::AddHeaderToFitsFile: P_Line = <" << P_Line << ">" << endl;
#endif
                P_HeaderKeyWordValue = strtok(NULL,"/\t\n\0");
                if (P_HeaderKeyWordValue != NULL)
                {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWordValue =<" << P_HeaderKeyWordValue << ">" << endl;
#endif
                  // --- Trim HeaderKeyWordValue
                  P_HeaderKeyWordValue = StrTrimChar(P_HeaderKeyWordValue, ' ', 2);
                  P_HeaderKeyWordValue = StrTrimChar(P_HeaderKeyWordValue, '\'', 2);
                  P_HeaderKeyWordValue = StrTrimChar(P_HeaderKeyWordValue, ' ', 2);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  cout << "CFits::AddHeaderToFitsFile: Trimmed P_HeaderKeyWordValue =<" << P_HeaderKeyWordValue << ">" << endl;
#endif
                }
              }// end while (strcmp(P_HeaderKeyWordValue, "") == 0 && P_HeaderKeyWordValue != NULL)
              if (P_HeaderKeyWordValue != NULL)
              {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWordValue =<" << P_HeaderKeyWordValue << ">" << endl;
#endif
                P_HeaderKeyWordValue = StrTrim(P_HeaderKeyWordValue, 2);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                cout << "CFits::AddHeaderToFitsFile: Trimmed P_HeaderKeyWordValue =<" << P_HeaderKeyWordValue << ">" << endl;
#endif
                P_TempStr = "";
                P_HeaderKeyWordComment = "";
                while (P_HeaderKeyWordComment != NULL && strcmp(P_HeaderKeyWordComment, P_TempStr) == 0)
                {
                  P_HeaderKeyWordComment = strtok(NULL,"\t\n\0");
                  if (P_HeaderKeyWordComment != NULL)
                  {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWordComment =<" << P_HeaderKeyWordComment << ">" << endl;
#endif
                  P_HeaderKeyWordComment = StrTrim(P_HeaderKeyWordComment, 2);
                  P_HeaderKeyWordComment = StrTrimChar(P_HeaderKeyWordComment, '\'', 2);
                  P_HeaderKeyWordComment = StrTrim(P_HeaderKeyWordComment, 2);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  cout << "CFits::AddHeaderToFitsFile: Trimmed P_HeaderKeyWordComment =<" << P_HeaderKeyWordComment << ">" << endl;
#endif
                  }
                }// end while (strcmp(P_HeaderKeyWordComment, "") == 0 && P_HeaderKeyWordComment != NULL)
                strcpy(TempCharArr, P_HeaderKeyWordValue);
                if (StrPosInCharArr(LineCharArr, "'") >= 0)  // String
                {
                  fits_write_key(P_FitsFile, TSTRING, P_HeaderKeyWord, P_HeaderKeyWordValue, P_HeaderKeyWordComment, &Status);
                  if (Status !=0)
                  {
                    cout << "CFits::AddHeaderToFitsFile: Error " << Status << " while trying to add P_HeaderKeyWord <" << P_HeaderKeyWord << "> to file " << P_CS_FileName << endl;
                    return false;
                  }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord <" << P_HeaderKeyWord << "> with STRING Value <" << P_HeaderKeyWordValue << "> added to FitsFile" << P_CS_FileName << endl;
#endif
                }
                else if (StrPosInCharArr(TempCharArr, ".") >= 0) // Double
                {
                  TempDbl = atof(P_HeaderKeyWordValue);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord <" << P_HeaderKeyWord << "> with DOUBLE Value of P_HeaderKeyWordValue(=<" << P_HeaderKeyWordValue << ">) TempDbl = <" << TempDbl << "> added to FitsFile " << P_CS_FileName << endl;
#endif
                  fits_write_key(P_FitsFile, TDOUBLE, P_HeaderKeyWord, &TempDbl, P_HeaderKeyWordComment, &Status);
                  if (Status !=0)
                  {
                    cout << "CFits::AddHeaderToFitsFile: Error " << Status << " while trying to add P_HeaderKeyWord <" << P_HeaderKeyWord << "> to file " << P_CS_FileName << endl;
                    return false;
                  }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord <" << P_HeaderKeyWord << "> with DOUBLE Value <" << P_HeaderKeyWordValue << "> added to FitsFile " << P_CS_FileName << endl;
#endif
                }
                else// Integer and Boolean
                {
                  if (CharPosInCharArr(TempCharArr, 'T') == 0)
                  {
                    TempInt = 1;
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                    cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord <" << P_HeaderKeyWord << "> with BOOLEAN Value of P_HeaderKeyWordValue(=<" << P_HeaderKeyWordValue << ">) TempInt = <" << TempInt << "> added to FitsFile " << P_CS_FileName << endl;
#endif
                    fits_write_key(P_FitsFile, TLOGICAL, P_HeaderKeyWord, &TempInt, P_HeaderKeyWordComment, &Status);
                  }
                  else if (CharPosInCharArr(TempCharArr, 'F') == 0)
                  {
                    TempInt = 0;
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                    cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord <" << P_HeaderKeyWord << "> with BOOLEAN Value of P_HeaderKeyWordValue(=<" << P_HeaderKeyWordValue << ">) TempInt = <" << TempInt << "> added to FitsFile " << P_CS_FileName << endl;
#endif
                    fits_write_key(P_FitsFile, TLOGICAL, P_HeaderKeyWord, &TempInt, P_HeaderKeyWordComment, &Status);
                  }
                  else
                  {
                    TempLong = atol(P_HeaderKeyWordValue);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                    cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord <" << P_HeaderKeyWord << "> with LONG Value of P_HeaderKeyWordValue(=<" << P_HeaderKeyWordValue << ">) TempLong = <" << TempLong << "> added to FitsFile " << P_CS_FileName << endl;
#endif
                    fits_write_key(P_FitsFile, TLONG, P_HeaderKeyWord, &TempLong, P_HeaderKeyWordComment, &Status);
                  }
                  if (Status !=0)
                  {
                    cout << "CFits::AddHeaderToFitsFile: Error " << Status << " while trying to add P_HeaderKeyWord <" << P_HeaderKeyWord << "> to file " << P_CS_FileName << endl;
                    return false;
                  }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  cout << "CFits::AddHeaderToFitsFile: P_HeaderKeyWord <" << P_HeaderKeyWord << "> with LONG Value <" << P_HeaderKeyWordValue << "> added to FitsFile " << P_CS_FileName << endl;
#endif
                }
              }// end if (P_HeaderKeyWordValue != NULL)
            }// end else if (strcmp(P_HeaderKeyWord, "COMMENT") != 0)
          }// if (P_HeaderKeyWord != NULL)
        }// end else if (strchr(P_Line, '=') != NULL)
      }// end if (P_Line != NULL)
      else
      {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
        cout << "CFits::AddHeaderToFitsFile: P_Line == NULL" << endl;
#endif
      }
    }// end if (P_Line != NULL)
    else
    {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
      cout << "CFits::AddHeaderToFitsFile: P_Line == NULL" << endl;
#endif
    }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
    cout << endl << endl << "CFits::AddHeaderToFitsFile: P_Line read" << endl << endl;
#endif

  }// end for (i = 0; i < NLines; i++)

  fclose(P_HeaderFile);
  fits_close_file(P_FitsFile, &Status);

  if (Status !=0)
  {
    cout << "MPiskunov.ReadApertureData: Error " << Status << " in file " << P_CS_FileName << endl;
    exit(0);
  }

//  TestBasis();

  return 1;
}
*/

/*****************************************************************/
/*  Sub method for CubicSpline, Legendre, and Chebyshev    */
/*       */
/*****************************************************************/
double CFits::GetNormalized(const double XVal, const double XMin, const double XMax) const
{
  double Normalized;
  Normalized = ((2 * XVal) - (XMax + XMin)) / (XMax - XMin);
#ifdef __DEBUG_FITS_GET__
  printf("CFits::GetNormalized: XVal = %.7f, Normalized = %.7f\n", XVal, Normalized);
#endif
  return Normalized;
}

/*****************************************************************/
/*  Sub method for LinearSpline and CubicSpline    */
/*       */
/*****************************************************************/
double CFits::GetA(const double XVal, const double XMin, const double XMax, const int Order) const
{
  double A;
  A = (GetJ(XVal, XMin, XMax, Order) + 1.) - GetS(XVal, XMin, XMax, Order);
#ifdef __DEBUG_FITS_GET__
  printf("CFits::GetA: XVal = %.7f, A = %.7f\n", XVal, A);
#endif
  return A;
}

/*****************************************************************/
/*  Sub method for LinearSpline and CubicSpline    */
/*       */
/*****************************************************************/
double CFits::GetB(const double XVal, const double XMin, const double XMax, const int Order) const
{
  double B;
  B = GetS(XVal, XMin, XMax, Order) - GetJ(XVal, XMin, XMax, Order);
#ifdef __DEBUG_FITS_GET__
  printf("CFits::GetB: XVal = %.7f, A = %.7f\n", XVal, B);
#endif
  return B;
}

/*****************************************************************/
/* Sub method for LinearSpline and CubicSpline     */
/*       */
/*****************************************************************/
long CFits::GetJ(const double XVal, const double XMin, const double XMax, const int Order) const
{
  long J;
  double S;
  S = GetS(XVal, XMin, XMax, Order);
  J = (long)S;
#ifdef __DEBUG_FITS_GET__
  printf("CFits::GetJ: XVal = %.7f, S = %.7f, J = %d\n", XVal, S, J);
#endif
  return J;
}

/** **************************************************/
/** Sub method for LinearSpline and CubicSpline      */
/**                                                  */
/** **************************************************/
double CFits::GetS(const double XVal, const double XMin, const double XMax, const int Order) const
{
  double S;
  S = (XVal - XMin) / (XMax - XMin) * Order;//(GetJ(XVal, XMin, XMax) + 1.) - GetS(XVal, XMin, XMax);
#ifdef __DEBUG_FITS_GET__
  printf("CFits::GetS: XVal = %.7f, S = %.7f\n", XVal, S);
#endif
  return S;
}

/** **************************************************/
/**       */
/**       */
/** **************************************************/
bool CFits::LinearSpline(Array<double, 1> &D_A1_XCenters_Out,
                         const Array<double, 1> &D_A1_Coeffs_In,
                         double D_XCenter_In,
                         double D_YCenter_In,
                         double D_YMin_In,
                         double D_YMax_In,
                         double D_XLow_In,
                         double D_XHigh_In,
                         int I_Order_In,
                         int I_NCols_In)
{
  for (int m = 0; m < this->NRows; m++)
  {
    int n = GetJ(0. - D_YCenter_In + (double)m, D_YMin_In, D_YMax_In, I_Order_In);

    D_A1_XCenters_Out(m) = D_XCenter_In + (D_A1_Coeffs_In(n) * GetA(0. - D_YCenter_In + (double)m, D_YMin_In, D_YMax_In, I_Order_In)) + (D_A1_Coeffs_In(n+1) * GetB(0. - D_YCenter_In + m, D_YMin_In, D_YMax_In, I_Order_In));
    if (D_A1_XCenters_Out(m) < 0. - D_XLow_In)
      D_A1_XCenters_Out(m) = 0. - D_XLow_In;
    if (D_A1_XCenters_Out(m) > I_NCols_In - D_XHigh_In)
      D_A1_XCenters_Out(m) = I_NCols_In - D_XHigh_In;
  }
  return true;
}

/** **************************************************/
/**       */
/**       */
/** **************************************************/
bool CFits::CubicSpline(Array<double, 1> &D_A1_XCenters_Out,
                        const Array<double, 1> &D_A1_Coeffs_In,
                        double D_XCenter_In,
                        double D_YCenter_In,
                        double D_YMin_In,
                        double D_YMax_In,
                        double D_XLow_In,
                        double D_XHigh_In,
                        int I_Order_In,
                        int I_NCols_In)
{
  //  long i, j, k;
  int m, o;
  double D_Normalized;
  Array<double, 1> D_A1_ZArr(4);

  printf("CFits::CubicSpline: D_A1_XCenters_Out.size() returned %d\n", D_A1_XCenters_Out.size());

  for (m = 0; m < this->NRows; m++)
  {
    D_Normalized = GetNormalized((double)m - D_YMin_In, D_YMin_In, D_YMax_In);
#ifdef __DEBUG_FITS_TRACEFUNC__
    cout << "CFits::CubicSpline: m = " << m << ": D_Normalized = " << D_Normalized << endl;
    (*P_OFS_Log) << "CFits::CubicSpline: m = " << m << ": D_Normalized = " << D_Normalized << endl;
#endif
    /*y = sum from i=0 to 3 {c_{i+j} * z_i}
      z_0 = a**3
      z_1 = 1 + 3 * a * (1 + a * b)
      z_2 = 1 + 3 * b * (1 + a * b)
      z_3 = b**3*/
    D_A1_ZArr(0) = pow(GetA(m, D_YMin_In, D_YMax_In, I_Order_In), 3);
    D_A1_ZArr(1) = 1. + (3. * GetA(m, D_YMin_In, D_YMax_In, I_Order_In) * (1. + (GetA(m, D_YMin_In, D_YMax_In, I_Order_In) * GetB(m, D_YMin_In, D_YMax_In, I_Order_In))));
    D_A1_ZArr(2) = 1. + (3. * GetB(m, D_YMin_In, D_YMax_In, I_Order_In) * (1. + (GetA(m, D_YMin_In, D_YMax_In, I_Order_In) * GetB(m, D_YMin_In, D_YMax_In, I_Order_In))));
    D_A1_ZArr(3) = pow(GetB(m, D_YMin_In, D_YMax_In, I_Order_In), 3);
#ifdef __DEBUG_FITS_TRACEFUNC__
    cout << "CFits::CubicSpline: P_ZArr(0) = " << D_A1_ZArr(0) << ", P_ZArr(1) = " << D_A1_ZArr(1) << ", P_ZArr(2) = " << D_A1_ZArr(2) << ", P_ZArr(3) = " << D_A1_ZArr(3) << endl;
    (*P_OFS_Log) << "CFits::CubicSpline: P_ZArr(0) = " << D_A1_ZArr(0) << ", P_ZArr(1) = " << D_A1_ZArr(1) << ", P_ZArr(2) = " << D_A1_ZArr(2) << ", P_ZArr(3) = " << D_A1_ZArr(3) << endl;
#endif
    D_A1_XCenters_Out(m) = D_XCenter_In;
    for (o = 0; o < 4; o++)
    {
      D_A1_XCenters_Out(m) += D_A1_Coeffs_In(o + GetJ(0. - D_YCenter_In + m, D_YMin_In, D_YMax_In, I_Order_In)) * D_A1_ZArr(o);
    }
    if (D_A1_XCenters_Out(m) < 0. - D_XLow_In)
      D_A1_XCenters_Out(m) = 0. - D_XLow_In;
    if (D_A1_XCenters_Out(m) > I_NCols_In - D_XHigh_In)
      D_A1_XCenters_Out(m) = I_NCols_In - D_XHigh_In;
  }// end for (i = 0; i < XMax; i++)
  D_A1_ZArr.resize(0);
  return true;
}

/** **************************************************/
/**       */
/**       */
/** **************************************************/
bool CFits::ChebyLegend(Array<double, 1> &D_A1_XCenters_Out,
                        double *P_D_YMin_Out,
                        double *P_D_YMax_Out,
                        const Array<double, 1> &D_A1_Coeffs_In,
                        double D_XCenter_In,
                        double D_YCenter_In,
                        double D_YMin_In,
                        double D_YMax_In,
                        double D_XLow_In,
                        double D_XHigh_In,
                        int I_Order_In,
                        int I_NCols_In,
                        const CString &CS_Function_In)
{
  CString CS_Legendre("legendre");
  CString CS_Chebyshev("chebyshev");
  //  firstIndex i;
  //  secondIndex j;
//  long L_Z;
  int m, n;
  double D_Normalized;
  bool B_XMax_Set = false;
  bool B_Begin_Found = false;
  Array<double, 1> D_A1_ZArr(3);

  #ifdef __DEBUG_FITS_TRACEFUNC__
    cout << "CFits::ChebyLegend: started: CS_Function_In = " << CS_Function_In << ", D_XCenter_In = " << D_XCenter_In << ", D_YCenter_In = " << D_YCenter_In << ", D_YMin_In = " << D_YMin_In << ", D_YMax_In = " << D_YMax_In << ", D_XLow_In = " << D_XLow_In << ", D_XHigh_In = " << D_XHigh_In << ", I_Order_In = " << I_Order_In << ", Coeffs = " << D_A1_Coeffs_In << endl;
    cout << "CFits::ChebyLegend: D_A1_XCenters_Out.size() returned " << D_A1_XCenters_Out.size() << endl;
    (*P_OFS_Log) << "CFits::ChebyLegend: started: CS_Function_In = " << CS_Function_In << ", D_XCenter_In = " << D_XCenter_In << ", D_YMin_In = " << D_YMin_In << ", D_YMax_In = " << D_YMax_In << ", D_XLow_In = " << D_XLow_In << ", D_XHigh_In = " << D_XHigh_In << ", I_Order_In = " << I_Order_In << ", Coeffs = " << D_A1_Coeffs_In << endl;
    (*P_OFS_Log) << "CFits::ChebyLegend: D_A1_XCenters_Out.size() returned " << D_A1_XCenters_Out.size() << endl;
  #endif

  if (D_A1_XCenters_Out.size() < D_YMax_In - D_YMin_In + 1.)
  {
    cout << "CFits::ChebyLegend: D_YMax_In = " << D_YMax_In << ", D_YMin_In = " << D_YMin_In << endl;
    cout << "CFits::ChebyLegend: D_A1_XCenters_Out.size(=" << D_A1_XCenters_Out.size() << ") < D_YMax_In(=" << D_YMax_In << ") - D_YMin_In(=" << D_YMin_In << ") + 1 = " << D_YMax_In - D_YMin_In + 1. << " => Returning FALSE" << endl;
    return false;
  }

  /// m: Pixel No of 2nd dim (x-direction, independent variable)
  *P_D_YMin_Out = 0.;
  *P_D_YMax_Out = this->NRows-1.;
  for (m = 0; m < this->NRows; m++)
  {
    D_Normalized = GetNormalized(m, D_YMin_In, D_YMax_In);
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::ChebyLegend: m = " << m << ": D_Normalized set to " << D_Normalized << endl;
      (*P_OFS_Log) << "CFits::ChebyLegend: m = " << m << ": D_Normalized set to " << D_Normalized << endl;
    #endif
    D_A1_XCenters_Out(m) = D_XCenter_In;
    for (n = 0; n < I_Order_In; n++)
    {
      if (n == 0)
      {
        D_A1_ZArr(0) = 0.;
        D_A1_ZArr(1) = 0.;
        D_A1_ZArr(2) = 1.;
      }
      else if (n == 1)
      {
        D_A1_ZArr(0) = 0;
        D_A1_ZArr(1) = 1;
        D_A1_ZArr(2) = D_Normalized;
      }
      else
      {
        D_A1_ZArr(0) = D_A1_ZArr(1);
        D_A1_ZArr(1) = D_A1_ZArr(2);
        if (CS_Function_In.EqualValue(CS_Chebyshev))
        {
          D_A1_ZArr(2) = (2. * D_Normalized * D_A1_ZArr(1)) - D_A1_ZArr(0);
          #ifdef __DEBUG_FITS_TRACEFUNC__
            cout << "CFits::ChebyLegend: CS_Function = <" << CS_Function_In.Get() << "> == 'chebyshev' : D_A1_ZArr(2) = " << D_A1_ZArr(2) << endl;
            (*P_OFS_Log) << "CFits::ChebyLegend: CS_Function = <" << CS_Function_In.Get() << "> == 'chebyshev' : D_A1_ZArr(2) = " << D_A1_ZArr(2) << endl;
          #endif
        }
        else if (CS_Function_In.EqualValue(CS_Legendre))
        {
          //Y = sum from i=1!!! to order {c_i * x_i}
          D_A1_ZArr(2) = ((((2. * ((double)n + 1.)) - 3.) * D_Normalized * D_A1_ZArr(1)) - (((double)n - 1.) * D_A1_ZArr(0))) / (double)n;
          #ifdef __DEBUG_FITS_TRACEFUNC__
            cout << "CFits::ChebyLegend: CS_Function = <" << CS_Function_In.Get() << "> == 'legendre' : D_A1_ZArr(2) = " << D_A1_ZArr(2) << endl;
            (*P_OFS_Log) << "CFits::ChebyLegend: CS_Function = <" << CS_Function_In.Get() << "> == 'legendre' : D_A1_ZArr(2) = " << D_A1_ZArr(2) << endl;
          #endif
        }
        else
        {
          #ifdef __DEBUG_FITS_TRACEFUNC__
            cout << "CFits::ChebyLegend: Cannot associate CS_Function = <" << CS_Function_In.Get() << "> to '" << CS_Chebyshev.Get() << "' of '" << CS_Legendre.Get() << "'" << endl;
            (*P_OFS_Log) << "CFits::ChebyLegend: Cannot associate CS_Function = <" << CS_Function_In.Get() << "> to '" << CS_Chebyshev.Get() << "' of '" << CS_Legendre.Get() << "'" << endl;
          #endif
          return false;
        }
      }
      //Y = sum from i=1!!! to order {c_i * x_i}
      D_A1_XCenters_Out(m) += D_A1_Coeffs_In(n) * D_A1_ZArr(2);
      #ifdef __DEBUG_FITS_TRACEFUNC__
        cout << "CFits::ChebyLegend: D_A1_XCenters_Out(m=" << m << ") set to += D_A1_Coeffs_In(n=" << n << ")=" << D_A1_Coeffs_In(n) << " * D_A1_ZArr(2)=" << D_A1_ZArr(2) << " = " << D_A1_XCenters_Out(m) << endl;
        (*P_OFS_Log) << "CFits::ChebyLegend: D_A1_XCenters_Out(m=" << m << ") set to += D_A1_Coeffs_In(n=" << n << ")=" << D_A1_Coeffs_In(n) << " * D_A1_ZArr(2)=" << D_A1_ZArr(2) << " =" << D_A1_XCenters_Out(m) << endl;
      #endif
    }// end for (n = 0; n < Order; n++)
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::ChebyLegend: D_XLow_In = " << D_XLow_In << endl;
      (*P_OFS_Log) << "CFits::ChebyLegend: D_XLow_In = " << D_XLow_In << endl;
      cout << "CFits::ChebyLegend: I_NCols_In(=" << I_NCols_In <<") - D_XHigh_In(=" << D_XHigh_In << ") = " << I_NCols_In - D_XHigh_In << endl;
      (*P_OFS_Log) << "CFits::ChebyLegend: I_NCols_In(=" << I_NCols_In <<") - D_XHigh_In(=" << D_XHigh_In << ") = " << I_NCols_In - D_XHigh_In << endl;
    #endif
    if (D_A1_XCenters_Out(m) < 0. - D_XLow_In || D_A1_XCenters_Out(m) > I_NCols_In - D_XHigh_In){
      if (!B_Begin_Found){
        (*P_D_YMin_Out) = m;
        #ifdef __DEBUG_FITS_TRACEFUNC__
          cout << "CFits::ChebyLegend: P_D_YMin_Out set to " << *P_D_YMin_Out << endl;
          (*P_OFS_Log) << "CFits::ChebyLegend: P_D_YMin_Out set to " << *P_D_YMin_Out << endl;
        #endif
      }
      else{
        if (!B_XMax_Set){
          (*P_D_YMax_Out) = m;
          B_XMax_Set = true;
          #ifdef __DEBUG_FITS_TRACEFUNC__
            cout << "CFits::ChebyLegend: B_XMax_Set set to TRUE: P_D_YMax_Out set to " << *P_D_YMax_Out << endl;
            (*P_OFS_Log) << "CFits::ChebyLegend: B_XMax_Set set to TRUE: P_D_YMax_Out set to " << *P_D_YMax_Out << endl;
          #endif
        }
      }
      //      D_A1_XCenters_Out(m) = 0. - D_XLow_In;
    }
    else
      B_Begin_Found = true;
  }// end for (i = 0; i < XMax; i++)
  D_A1_ZArr.resize(0);
  return true;
}

/*****************************************************************/
/*       */
/*       */
/*****************************************************************/
bool CFits::Legendre(Array<double, 1> &D_A1_XCenters_Out,
                     double *P_D_YMin_Out,
                     double *P_D_YMax_Out,
                     const Array<double, 1> &D_A1_Coeffs_In,
                     double D_XCenter_In,
                     double D_YCenter_In,
                     double D_YMin_In,
                     double D_YMax_In,
                     double D_XLow_In,
                     double D_XHigh_In,
                     int I_Order_In,
                     int I_NCols_In)
{
  CString CS_Legendre("legendre");

#ifdef __DEBUG_FITS_LEGENDRE__
  cout << "CFits::Legendre: starting  (ChebyLegend(D_A1_XCenters_Out=" << D_A1_XCenters_Out << ", D_A1_Coeffs_In=" << D_A1_Coeffs_In << ", D_XCenter_In=" << D_XCenter_In << ", D_YCenter_In=" << D_YCenter_In << ", D_YMin_In=" << D_YMin_In << ", D_YMax_In=" << D_YMax_In << ", D_XLow_In=" << D_XLow_In << ", D_XHigh_In=" << D_XHigh_In << ", I_Order_In=" << I_Order_In << ", I_NCols_In=" << I_NCols_In << ", CS_Legendre=" << CS_Legendre << "));" << endl;
#endif
  return (ChebyLegend(D_A1_XCenters_Out,
                      P_D_YMin_Out,
                      P_D_YMax_Out,
                      D_A1_Coeffs_In,
                      D_XCenter_In,
                      D_YCenter_In,
                      D_YMin_In,
                      D_YMax_In,
                      D_XLow_In,
                      D_XHigh_In,
                      I_Order_In,
                      I_NCols_In,
                      CS_Legendre));
}

/*****************************************************************/
/*       */
/*       */
/*****************************************************************/
bool CFits::Chebyshev(Array<double, 1> &D_A1_XCenters_Out,
                      double *P_D_YMin_Out,
                      double *P_D_YMax_Out,
                      const Array<double, 1> &D_A1_Coeffs_In,
                      double D_XCenter_In,
                      double D_YCenter_In,
                      double D_YMin_In,
                      double D_YMax_In,
                      double D_XLow_In,
                      double D_XHigh_In,
                      int I_Order_In,
                      int I_NCols_In)
{
  CString CS_Chebyshev("chebyshev");
  return (ChebyLegend(D_A1_XCenters_Out,
                      P_D_YMin_Out,
                      P_D_YMax_Out,
                      D_A1_Coeffs_In,
                      D_XCenter_In,
                      D_YCenter_In,
                      D_YMin_In,
                      D_YMax_In,
                      D_XLow_In,
                      D_XHigh_In,
                      I_Order_In,
                      I_NCols_In,
                      CS_Chebyshev));
}

/** ***************************************************/
/**       */
/**       */
/** ***************************************************
bool CFits::FindAndTraceApertures()
{
  return this->FindAndTraceApertures(3);
}

/** ***************************************************/
/**       */
/**       */
/** ***************************************************/
bool CFits::FindAndTraceApertures(int I_In_NTermsGaussFit,
                                  int I_In_PolyFitOrder,
                                  int I_In_MinLength,
                                  int I_In_MaxLength,
                                  int I_In_NLost,
                                  std::string S_ThreshZero_Out){
  return FindAndTraceApertures(I_In_NTermsGaussFit,
                               I_In_PolyFitOrder,
                               I_In_MinLength,
                               I_In_MaxLength,
                               I_In_NLost,
                               1,
                               1,
                               S_ThreshZero_Out);
}

bool CFits::FindAndTraceApertures(int I_In_NTermsGaussFit,
                                  int I_In_PolyFitOrder,
                                  int I_In_MinLength,
                                  int I_In_MaxLength,
                                  int I_In_NLost,
                                  int I_Step,
                                  int I_NSum,
                                  std::string S_ThreshZero_Out){
  if (int(this->D_ApertureFWHM * 2.) + 1 <= I_In_NTermsGaussFit){
    cout << "CFits::FindAndTraceApertures: WARNING: this-> D_ApertureFWHM too small for GaussFit -> Try lower I_In_NTermsGaussFit!" << endl;
//    return false;
  }
//  int I_PolyFitOrder = 3;
  int I_ApertureNumber = 0;
  int I_StartIndex;
  int I_FirstWideSignal;
  int I_FirstWideSignalEnd;
  int I_FirstWideSignalStart;
  int I_Length, I_LastRowWhereApertureWasFound, I_ApertureLost, I_Row_Bak;
  int I_ApertureLength;
  int I_NInd;
  double D_Max;
  bool B_ApertureFound, B_AperturesInArray;
  bool B_STOP = false;
  Array<double, 1> *P_D_A1_IndexCol = this->DIndGenArr(this->P_D_A2_PixArray->cols());
  Array<double, 1> *P_D_A1_IndexRow = this->DIndGenArr(this->P_D_A2_PixArray->rows());
  Array<double, 1> D_A1_X(10);
  Array<double, 1> D_A1_Y(10);
  Array<double, 1> D_A1_MeasureErrors(10);
  Array<double, 1> D_A1_Guess(I_In_NTermsGaussFit);
  Array<double, 1> D_A1_GaussFit_Coeffs(I_In_NTermsGaussFit);
  Array<double, 1> D_A1_GaussFit_Coeffs_Bak(I_In_NTermsGaussFit);
  Array<int, 1> I_A1_Signal(P_D_A2_PixArray->cols());
  Array<double, 1> D_A1_ApertureCenter(this->P_D_A2_PixArray->rows());
  Array<int, 1> I_A1_ApertureCenterInd(this->P_D_A2_PixArray->rows());
  Array<double, 1> D_A1_ApertureCenterIndex(this->P_D_A2_PixArray->rows());
  Array<int, 1> I_A1_ApertureCenterIndex(this->P_D_A2_PixArray->rows());
  Array<double, 1> D_A1_ApertureCenterPos(1);
  Array<double, 1> *P_D_A1_PolyFitCoeffs = new Array<double, 1>(I_In_PolyFitOrder);
  Array<int, 1> I_A1_IndSignal(2);
  #ifdef __DEBUG_FITS_FINDANDTRACE__
    cout << "CFits::FindAndTraceApertures: started" << endl;
    Array<double, 2> D_A2_PixArrayNew(this->NRows, this->NCols);
    D_A2_PixArrayNew = 0.;
  #endif
  Array<int, 1> I_A1_Ind(1);
  Array<int, 1> I_A1_Where(1);

  Array<CString, 1> CS_A1_KeyWords_GaussFit(4);
  void **PP_Args_GaussFit = (void**)malloc(sizeof(void*) * 4);
  CS_A1_KeyWords_GaussFit = CString(" ");

//  CS_A1_KeyWords_GaussFit(0) = CString("ESTIMATES");

  CS_A1_KeyWords_GaussFit(1) = CString("MEASURE_ERRORS");
  CS_A1_KeyWords_GaussFit(2) = CString("NTERMS");
  CS_A1_KeyWords_GaussFit(3) = CString("NODERIVATIVE");

  /// Set all pixels below D_SignalThreshold to 0.
  (*P_D_A2_PixArray) = where((*P_D_A2_PixArray) < D_SignalThreshold, 0., (*P_D_A2_PixArray));
//  #ifdef __DEBUG_FITS_FINDANDTRACE__
  if (S_ThreshZero_Out.length() > 1)
    this->WriteFits(this->P_D_A2_PixArray, CString(S_ThreshZero_Out.c_str()));
//  #endif

  /// resize all class-aperture-definition parameters to 1
  this->Set_NApertures(1);
//  this->P_D_A1_XCenter->resize(1);
//  this->P_D_A1_XHigh->resize(1);
//  this->P_D_A1_XLow->resize(1);
//  this->P_D_A1_YCenter->resize(1);
//  this->P_D_A1_YHigh->resize(1);
//  this->P_D_A1_YLow->resize(1);
//  this->P_I_A1_Orders->resize(1);
//  this->P_I_A1_NCoeffs->resize(1);
  this->P_D_A2_Coeffs->resize(1, I_In_PolyFitOrder+1);
//  this->P_CS_A1_Functions->resize(1);
  this->I_NApertures = 0;
  int I_MinWidth = int(1.2 * this->D_ApertureFWHM);
  if (I_MinWidth < I_In_NTermsGaussFit)
    I_MinWidth = I_In_NTermsGaussFit;
  double D_MaxTimesApertureWidth = 4.;
  Array<double, 2> D_A2_PixArrayTemp(this->NRows, this->NCols);
  D_A2_PixArrayTemp = (*(this->P_D_A2_PixArray));
  
  /// Search for Apertures
  B_AperturesInArray = true;
///  while(B_AperturesInArray){
    I_LastRowWhereApertureWasFound = 0;
    D_A1_ApertureCenter = 0.;
    D_A1_ApertureCenterIndex = 0.;
    D_A1_ApertureCenterPos = 0.;
    I_A1_ApertureCenterInd = 0;
    I_A1_ApertureCenterIndex = 0;
    int I_Start = (I_NSum / 2) - 1;
    int I_RowStart, I_RowEnd, I_RowCenter;
    if (I_Start < 0)
      I_Start = 0;
    Array<double, 1> D_A1_RowSum(this->P_D_A2_PixArray->cols());
    for (int i_Row = I_Start; i_Row < this->P_D_A2_PixArray->rows(); i_Row+=I_Step){
      /// Look for first local maximum wider than 2 * D_ApertureFWHM
///      I_A1_Signal = where((*P_D_A2_PixArray)(i_Row, Range::all()) > 0., 1, 0);
///      if (!this->CountPixGTZero(I_A1_Signal)){
///        cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": ERROR: this->CountPixGTZero(I_A1_Signal=" << I_A1_Signal << ") returned FALSE => Returning FALSE" << endl;
///        return false;
///      }
      I_RowStart = i_Row - (I_NSum / 2);
      if (I_RowStart < 0)
        I_RowStart = 0;
      I_RowEnd = i_Row + (I_NSum / 2);
      if (I_RowEnd >= this->P_D_A2_PixArray->rows())
        I_RowEnd = this->P_D_A2_PixArray->rows() - 1;
      I_RowCenter = I_RowStart + ((I_RowEnd - I_RowStart) / 2);
      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
        D_A1_RowSum(i_col) = sum(D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col)) / (I_RowEnd - I_RowStart + 1);
      }
//      #ifdef __DEBUG_FITS_FINDANDTRACE__
//        cout << "CFits::FindAndTraceApertures: 1. i_Row = " << i_Row << ": D_A1_RowSum = " << D_A1_RowSum << endl; 
//      #endif
      D_A1_RowSum = where(D_A1_RowSum < (double(I_NSum) / 2.), 0, D_A1_RowSum);
      #ifdef __DEBUG_FITS_FINDANDTRACE__
        cout << "CFits::FindAndTraceApertures: 1. i_Row = " << i_Row << ": I_RowStart = " << I_RowStart << ", I_RowEnd = " << I_RowEnd << ", I_RowCenter = " << I_RowCenter << endl;
//        cout << "CFits::FindAndTraceApertures: 1.a i_Row = " << i_Row << ": D_A1_RowSum = " << D_A1_RowSum << endl; 
      #endif
      I_StartIndex = 0;
      B_ApertureFound = false;
      while (!B_ApertureFound){
//        #ifdef __DEBUG_FITS_FINDANDTRACE__
//          cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": D_A1_RowSum = " << D_A1_RowSum << endl; 
//        #endif

        I_A1_Signal = where(D_A1_RowSum > 0., 1, 0);
        #ifdef __DEBUG_FITS_FINDANDTRACE__
          cout << "CFits::FindAndTraceApertures: I_A1_Signal = " << I_A1_Signal << endl;
          cout << "I_MinWidth = " << I_MinWidth << endl;
          cout << "I_StartIndex = " << I_StartIndex << endl;
        #endif
        if (!this->CountPixGTZero(I_A1_Signal)){
          cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": ERROR: this->CountPixGTZero(I_A1_Signal=" << I_A1_Signal << ") returned FALSE => Returning FALSE" << endl;
          return false;
        }
        #ifdef __DEBUG_FITS_FINDANDTRACE__
          cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": I_A1_Signal = " << I_A1_Signal << endl;
        #endif
        I_FirstWideSignal = this->FirstIndexWithValueGEFrom(I_A1_Signal, I_MinWidth, I_StartIndex);
        #ifdef __DEBUG_FITS_FINDANDTRACE__
          cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": I_FirstWideSignal found at index " << I_FirstWideSignal << ", I_StartIndex = " << I_StartIndex << endl;
        #endif
        if (I_FirstWideSignal > 0){
          I_FirstWideSignalStart = this->LastIndexWithZeroValueBefore(I_A1_Signal, I_FirstWideSignal) + 1;
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: while: 1. i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": I_FirstWideSignalStart = " << I_FirstWideSignalStart << endl;
          #endif
          I_FirstWideSignalEnd = this->FirstIndexWithZeroValueFrom(I_A1_Signal, I_FirstWideSignal) - 1;
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": I_FirstWideSignalEnd = " << I_FirstWideSignalEnd << endl;
          #endif
          if (I_FirstWideSignalStart < 0){
            #ifdef __DEBUG_FITS_FINDANDTRACE__
              cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: No start of aperture found -> Going to next Aperture." << endl;
            #endif
            if (I_FirstWideSignalEnd < 0){
              cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": 1. WARNING: No end of aperture found -> Going to next row." << endl;
              break;
            }
            else{
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": End of first wide signal found at index " << I_FirstWideSignalEnd << endl;
              #endif
              /// Set start index for next run
              I_StartIndex = I_FirstWideSignalEnd+1;
            }
          }
          else{ /// Fit Gaussian and Trace Aperture
            if (I_FirstWideSignalEnd < 0){
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": 2. WARNING: No end of aperture found -> Going to next row." << endl;
                cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": I_Row_Bak = " << I_Row_Bak << endl;
                cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": B_ApertureFound = " << B_ApertureFound << endl;
              #endif
              B_STOP = true;
              break;
            }
            else{
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": End of first wide signal found at index " << I_FirstWideSignalEnd << endl;
              #endif

              if ((I_FirstWideSignalEnd - I_FirstWideSignalStart + 1) > (this->D_ApertureFWHM * D_MaxTimesApertureWidth)){
                I_FirstWideSignalEnd = I_FirstWideSignalStart + int(D_MaxTimesApertureWidth * this->D_ApertureFWHM);
              }

              /// Set start index for next run
              I_StartIndex = I_FirstWideSignalEnd+1;
            }
            I_Length = I_FirstWideSignalEnd - I_FirstWideSignalStart + 1;

            if (I_In_NTermsGaussFit == 0){/// look for maximum only
              D_A1_ApertureCenter = 0.;
              B_ApertureFound = true;
              I_LastRowWhereApertureWasFound = I_RowCenter;
              I_A1_Where.resize(I_FirstWideSignalEnd - I_FirstWideSignalStart + 1);
              I_A1_Where = where(fabs(D_A1_RowSum - max(D_A1_RowSum(Range(I_FirstWideSignalStart, I_FirstWideSignalEnd)))) < 0.00001, 1, 0);
              if (!this->GetIndex(I_A1_Where, I_NInd, I_A1_Ind)){
                cout << "CFits::FindAndTraceApertures: while: ERROR: GetIndex(I_A1_Where=" << I_A1_Where << ") returned FALSE => Returning FALSE" << endl;
                return false;
              }
              D_A1_ApertureCenter(I_RowCenter) = I_FirstWideSignalStart + I_A1_Ind(0);
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Aperture found at " << D_A1_ApertureCenter(I_RowCenter) << endl;
              #endif

              /// Set signal to zero
              for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
              }
              D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
              for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
              }
            }
            else{
              if (I_Length <= I_In_NTermsGaussFit){
                #ifdef __DEBUG_FITS_FINDANDTRACE__
                  cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: Width of aperture <= " << I_In_NTermsGaussFit << "-> abandoning aperture" << endl;
                #endif

                /// Set signal to zero
                for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                  (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                }
                D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                  D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                }
              }
              else{
                /// populate Arrays for GaussFit
                D_A1_X.resize(I_Length);
                D_A1_Y.resize(I_Length);
                D_A1_MeasureErrors.resize(I_Length);

                D_A1_X = (*P_D_A1_IndexCol)(Range(I_FirstWideSignalStart, I_FirstWideSignalEnd));
                D_A1_Y = D_A1_RowSum(Range(I_FirstWideSignalStart, I_FirstWideSignalEnd));
                D_A1_Y = where(D_A1_Y < 0.000001, 1., D_A1_Y);
                #ifdef __DEBUG_FITS_FINDANDTRACE__
                  cout << "CFits::FindAndTraceApertures: 1. D_A1_Y set to " << D_A1_Y << endl;
                #endif
                D_A1_MeasureErrors = sqrt(fabs(D_A1_Y));

                /// Guess values for GaussFit
                D_A1_Guess(0) = max(D_A1_Y);
                D_A1_Guess(1) = double((I_FirstWideSignalEnd - I_FirstWideSignalStart)) / 2.;
                D_A1_Guess(2) = this->D_ApertureFWHM / 2.35482;
                PP_Args_GaussFit[0] = &D_A1_Guess;
                PP_Args_GaussFit[1] = &D_A1_MeasureErrors;
                PP_Args_GaussFit[2] = &I_In_NTermsGaussFit;

                D_A1_GaussFit_Coeffs = 0.;

                #ifdef __DEBUG_FITS_FINDANDTRACE__
                  cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": D_A1_X = " << D_A1_X << ", D_A1_Y = " << D_A1_Y << endl;
                #endif

                if (!this->GaussFit(D_A1_X,
                                    D_A1_Y,
                                    D_A1_GaussFit_Coeffs,
                                    CS_A1_KeyWords_GaussFit,
                                    PP_Args_GaussFit)){
                  #ifdef __DEBUG_FITS_FINDANDTRACE__
                    cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: GaussFit FAILED -> abandoning aperture" << endl;
                  #endif

                  /// Set start index for next run
                  I_StartIndex = I_FirstWideSignalEnd+1;

                  for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                    (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                  }
                  D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                  for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                    D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                  }
                }
                else{
                  #ifdef __DEBUG_FITS_FINDANDTRACE__
                    cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": D_A1_GaussFit_Coeffs = " << D_A1_GaussFit_Coeffs << endl;
                    if (D_A1_GaussFit_Coeffs(0) < this->D_SaturationLevel/5.){
                      cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: Signal less than 20% of saturation level" << endl;
                    }
                    if (D_A1_GaussFit_Coeffs(0) > this->D_SaturationLevel){
                      cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: Signal appears to be saturated" << endl;
                    }
                    if ((D_A1_GaussFit_Coeffs(1) < double(I_FirstWideSignalStart) + (double(I_Length)/4.)) || (D_A1_GaussFit_Coeffs(1) > double(I_FirstWideSignalStart) + (double(I_Length) * 3./4.))){
                      cout << "CFits::FindAndTraceApertures: while: Warning: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Center of Gaussian far away from middle of signal" << endl;
                    }
                  #endif
                  if ((D_A1_GaussFit_Coeffs(1) < double(I_FirstWideSignalStart)) || (D_A1_GaussFit_Coeffs(1) > double(I_FirstWideSignalEnd))){
                    #ifdef __DEBUG_FITS_FINDANDTRACE__
                      cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Warning: Center of Gaussian too far away from middle of signal -> abandoning aperture" << endl;
                    #endif
                    /// Set signal to zero
                    for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                      (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                    }
                    D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                    for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                      D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                    }
                    

                    /// Set start index for next run
                    I_StartIndex = I_FirstWideSignalEnd+1;
                  }
                  else{
                    if ((D_A1_GaussFit_Coeffs(2) < this->D_ApertureFWHM / 4.) || (D_A1_GaussFit_Coeffs(2) > this->D_ApertureFWHM)){
                      #ifdef __DEBUG_FITS_FINDANDTRACE__
                        cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: FWHM = " << D_A1_GaussFit_Coeffs(2) << " outside range -> abandoning aperture" << endl;
                      #endif
                      /// Set signal to zero
                      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                        (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                      }
                      D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                        D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                      }
                      #ifdef __DEBUG_FITS_FINDANDTRACE__
                        cout << "CFits::FindAndTraceApertures: while: B_ApertureFound = " << B_ApertureFound << ": 1. Signal set to zero from I_FirstWideSignalStart = " << I_FirstWideSignalStart << " to I_FirstWideSignalEnd = " << I_FirstWideSignalEnd << endl;
                        cout << "CFits::FindAndTraceApertures: while: 1. D_A2_PixArrayTemp(i_Row = " << i_Row << ", Range(I_FirstWideSignalStart = " << I_FirstWideSignalStart << ", I_FirstWideSignalEnd = " << I_FirstWideSignalEnd << ")) set to " << D_A2_PixArrayTemp(i_Row, Range(I_FirstWideSignalStart, I_FirstWideSignalEnd)) << endl;
                      #endif
                      /// Set start index for next run
                      I_StartIndex = I_FirstWideSignalEnd+1;
                    }
                    else{
                      D_A1_ApertureCenter = 0.;
                      B_ApertureFound = true;
                      I_LastRowWhereApertureWasFound = I_RowCenter;
                      D_A1_ApertureCenter(I_RowCenter) = D_A1_GaussFit_Coeffs(1);
                      #ifdef __DEBUG_FITS_FINDANDTRACE__
                        cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Aperture found at " << D_A1_ApertureCenter(I_RowCenter) << endl;
                      #endif
                      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                        (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                      }
                      D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                        D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                      }
                    }
                  }/// end else if ((D_A1_GaussFit_Coeffs(1) > double(I_FirstWideSignalStart)) && (D_A1_GaussFit_Coeffs(1) < double(I_FirstWideSignalEnd)))
                }/// else else if (GaussFit returned TRUE)
              }/// end else if (I_Length >= 4)
            }/// end else if GaussFit
          }/// end else if (I_FirstWideSignalStart > 0)
        }/// end if (I_FirstWideSignal > 0)
        else{
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: while: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": No Aperture found in row " << I_RowCenter << ", trying next row step" << endl;
          #endif
          if ((i_Row + I_Step) > this->P_D_A2_PixArray->rows()-1)
            B_AperturesInArray = false;
          break;
        }/// end else if (I_FirstWideSignal < 0)
      }/// end while (!B_ApertureFound)

      if (B_ApertureFound){
        /// Trace Aperture
	int I_Length = 1;
        I_ApertureLost = 0;
        #ifdef __DEBUG_FITS_FINDANDTRACE__
          cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Starting to trace aperture" << endl;
        #endif
        D_A1_GaussFit_Coeffs_Bak = D_A1_GaussFit_Coeffs;
        I_Row_Bak = I_RowCenter;
        while(B_ApertureFound && (I_ApertureLost < I_In_NLost) && (i_Row < this->P_D_A2_PixArray->rows() - 1) && I_Length < I_In_MaxLength){
          i_Row+=I_Step;
          I_RowStart += I_Step;
          if (I_RowStart >= this->NRows)
            break;
          I_RowEnd += I_Step;
          if (I_RowEnd >= this->NRows)
            I_RowEnd = this->NRows-1;
          I_RowCenter = I_RowStart + ((I_RowEnd - I_RowStart) / 2);
          for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
            D_A1_RowSum(i_col) = sum(D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col)) / (I_RowEnd - I_RowStart + 1);
          }
//          #ifdef __DEBUG_FITS_FINDANDTRACE__
//            cout << "CFits::FindAndTraceApertures: 2. i_Row = " << i_Row << ": D_A1_RowSum = " << D_A1_RowSum << endl; 
//          #endif
          D_A1_RowSum = where(D_A1_RowSum < (double(I_NSum) / 2.), 0, D_A1_RowSum);
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: 2. i_Row = " << i_Row << ": I_RowStart = " << I_RowStart << ", I_RowEnd = " << I_RowEnd << ", I_RowCenter = " << I_RowCenter << endl;
//            cout << "CFits::FindAndTraceApertures: 2.a i_Row = " << i_Row << ": D_A1_RowSum = " << D_A1_RowSum << endl; 
          #endif
          I_Length += I_RowCenter - I_Row_Bak;
          if (I_In_NTermsGaussFit == 0){/// look for maximum only
            B_ApertureFound = true;
            I_LastRowWhereApertureWasFound = I_Row_Bak;
            //I_FirstWideSignalStart
            D_Max = max(D_A1_RowSum(Range(I_FirstWideSignalStart - int(this->D_ApertureFWHM), I_FirstWideSignalEnd + int(this->D_ApertureFWHM))));
            #ifdef __DEBUG_FITS_FINDANDTRACE__
              cout << "CFits::FindAndTraceApertures: D_Max = " << D_Max << endl;
            #endif
            if (D_Max < this->D_SignalThreshold){
              I_ApertureLost++;
            }
            else{
              int I_MaxPos = I_FirstWideSignalStart - int(this->D_ApertureFWHM);
              for (int i_x = I_FirstWideSignalStart - int(this->D_ApertureFWHM); i_x < I_FirstWideSignalEnd + int(this->D_ApertureFWHM); i_x++){
                if (fabs(D_A1_RowSum(i_x) - D_Max) < 0.00001)
                  I_MaxPos = i_x;
              }
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: I_MaxPos = " << I_MaxPos << endl;
              #endif
              int I_FirstWideSignalWidth = I_FirstWideSignalEnd - I_FirstWideSignalStart + 1;
              I_FirstWideSignalStart = I_MaxPos - (I_FirstWideSignalWidth / 2);
              I_FirstWideSignalEnd = I_MaxPos + (I_FirstWideSignalWidth / 2);
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: I_FirstWideSignalStart = " << I_FirstWideSignalStart << endl;
                cout << "CFits::FindAndTraceApertures: I_FirstWideSignalEnd = " << I_FirstWideSignalEnd << endl;
              #endif
              I_A1_Where.resize(I_FirstWideSignalEnd - I_FirstWideSignalStart + 1);
              I_A1_Where = where(fabs(D_A1_RowSum(Range(I_FirstWideSignalStart, I_FirstWideSignalEnd)) - D_Max) < 0.00001, 1, 0);
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: I_A1_Where = " << I_A1_Where << endl;
              #endif
              if (!this->GetIndex(I_A1_Where, I_NInd, I_A1_Ind)){
                cout << "CFits::FindAndTraceApertures: ERROR: GetIndex(I_A1_Where=" << I_A1_Where << ") returned FALSE => Returning FALSE" << endl;
                return false;
              }
              D_A1_ApertureCenter(I_RowCenter) = I_FirstWideSignalStart + I_A1_Ind(0);
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Aperture found at " << D_A1_ApertureCenter(I_RowCenter) << endl;
              #endif
              if (D_A1_ApertureCenter(I_RowCenter) < D_A1_ApertureCenter(I_LastRowWhereApertureWasFound)){
                I_FirstWideSignalStart--;
                I_FirstWideSignalEnd--;
              }
              if (D_A1_ApertureCenter(I_RowCenter) > D_A1_ApertureCenter(I_LastRowWhereApertureWasFound)){
                I_FirstWideSignalStart++;
                I_FirstWideSignalEnd++;
              }
              for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
              }
              D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
              for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
              }
            }
          }
          else{
            I_FirstWideSignalStart = int(D_A1_GaussFit_Coeffs_Bak(1) - 1.6 * D_A1_GaussFit_Coeffs_Bak(2));
            I_FirstWideSignalEnd = int(D_A1_GaussFit_Coeffs_Bak(1) + 1.6 * D_A1_GaussFit_Coeffs_Bak(2)) + 1;
            D_Max = max(D_A1_RowSum(Range(I_FirstWideSignalStart - int(this->D_ApertureFWHM), I_FirstWideSignalEnd + int(this->D_ApertureFWHM))));
            #ifdef __DEBUG_FITS_FINDANDTRACE__
              cout << "CFits::FindAndTraceApertures: D_Max = " << D_Max << endl;
            #endif
            int I_MaxPos = I_FirstWideSignalStart - int(this->D_ApertureFWHM);
            for (int i_x = I_FirstWideSignalStart - int(this->D_ApertureFWHM); i_x < I_FirstWideSignalEnd + int(this->D_ApertureFWHM); i_x++){
              if (fabs(D_A1_RowSum(i_x) - D_Max) < 0.00001)
                I_MaxPos = i_x;
            }
            #ifdef __DEBUG_FITS_FINDANDTRACE__
              cout << "CFits::FindAndTraceApertures: I_MaxPos = " << I_MaxPos << endl;
            #endif
            int I_FirstWideSignalWidth = I_FirstWideSignalEnd - I_FirstWideSignalStart + 1;
            I_FirstWideSignalStart = I_MaxPos - (I_FirstWideSignalWidth / 2);
            I_FirstWideSignalEnd = I_MaxPos + (I_FirstWideSignalWidth / 2);
            #ifdef __DEBUG_FITS_FINDANDTRACE__
              cout << "CFits::FindAndTraceApertures: I_FirstWideSignalStart = " << I_FirstWideSignalStart << endl;
              cout << "CFits::FindAndTraceApertures: I_FirstWideSignalEnd = " << I_FirstWideSignalEnd << endl;
            #endif
            if (I_FirstWideSignalStart < 0. || I_FirstWideSignalEnd >= this->NCols){
              #ifdef __DEBUG_FITS_FINDANDTRACE__
                cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": start or end of aperture outside CCD -> Aperture lost" << endl;
              #endif
              /// Set signal to zero
              if (I_FirstWideSignalStart < 0)
                I_FirstWideSignalStart = 0;
              if (I_FirstWideSignalEnd >= this->NCols)
                I_FirstWideSignalEnd = this->NCols - 1;
              for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
              }
              D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
              for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
              }
              I_ApertureLost++;
            }
            else{
              I_Length = I_FirstWideSignalEnd - I_FirstWideSignalStart + 1;

              if (I_Length <= I_In_NTermsGaussFit){
                #ifdef __DEBUG_FITS_FINDANDTRACE__
                  cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Warning: Width of Aperture <= " << I_In_NTermsGaussFit << " -> Lost Aperture" << endl;
                #endif
                /// Set signal to zero
                  for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                    (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                  }
                  D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                  for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                    D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                  }
                  I_ApertureLost++;
              }
              else{
                D_A1_X.resize(I_Length);
                D_A1_Y.resize(I_Length);
                D_A1_MeasureErrors.resize(I_Length);

                D_A1_X = (*P_D_A1_IndexCol)(Range(I_FirstWideSignalStart, I_FirstWideSignalEnd));
                D_A1_Y = D_A1_RowSum(Range(I_FirstWideSignalStart, I_FirstWideSignalEnd));
                I_A1_IndSignal.resize(D_A1_Y.size());
                I_A1_IndSignal = where(D_A1_Y < (double(I_Step) / 2.), 0, 1);
                #ifdef __DEBUG_FITS_FINDANDTRACE__
                  cout << "CFits::FindAndTraceApertures: I_MinWidth = " << I_MinWidth << ": I_A1_IndSignal = " << I_A1_IndSignal << endl;
                #endif
                if (sum(I_A1_IndSignal) < I_MinWidth){
                  /// Set signal to zero
                  for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                    (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                  }
                  D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                  for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                    D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                  }
                  I_ApertureLost++;
                  #ifdef __DEBUG_FITS_FINDANDTRACE__
                    cout << "CFits::FindAndTraceApertures: Signal not wide enough => Aperture lost" << endl;
                  #endif
                }
                else{
                  D_A1_Y = where(D_A1_Y < 0.00000001, 1., D_A1_Y);
                  #ifdef __DEBUG_FITS_FINDANDTRACE__
                    cout << "CFits::FindAndTraceApertures: 2. D_A1_Y set to " << D_A1_Y << endl;
                  #endif
                  D_A1_MeasureErrors = sqrt(fabs(D_A1_Y));
                  D_A1_Guess = D_A1_GaussFit_Coeffs_Bak;

                  PP_Args_GaussFit[0] = &D_A1_Guess;
                  PP_Args_GaussFit[1] = &D_A1_MeasureErrors;

                  D_A1_GaussFit_Coeffs = 0.;
                  #ifdef __DEBUG_FITS_FINDANDTRACE__
                    cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": D_A1_X = " << D_A1_X << ": D_A1_Y = " << D_A1_Y << endl;
                  #endif

                  if (!this->GaussFit(D_A1_X,
                             D_A1_Y,
                             D_A1_GaussFit_Coeffs,
                             CS_A1_KeyWords_GaussFit,
                             PP_Args_GaussFit)){
                    #ifdef __DEBUG_FITS_FINDANDTRACE__
                      cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Warning: GaussFit FAILED" << endl;
                    #endif
                    /// Set signal to zero
                      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                        (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                      }
                      D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                        D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                      }
                      
                    I_ApertureLost++;
          //          return false;
                  }
                  else{
                    #ifdef __DEBUG_FITS_FINDANDTRACE__
                      cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": D_A1_GaussFit_Coeffs = " << D_A1_GaussFit_Coeffs << endl;
                      if (D_A1_GaussFit_Coeffs(0) < this->D_SaturationLevel/5.){
                        cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: Signal less than 20% of saturation level" << endl;
                      }
                      if (D_A1_GaussFit_Coeffs(0) > this->D_SaturationLevel){
                        cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: Signal appears to be saturated" << endl;
                      }
                    #endif
        //          if ((D_A1_GaussFit_Coeffs(1) < double(I_FirstWideSignalStart) - (double(I_Length)/4.)) || (D_A1_GaussFit_Coeffs(1) > double(I_FirstWideSignalStart) + (double(I_Length) * 3./4.))){
        //            cout << "CFits::FindAndTraceApertures: Warning: i_Row = " << i_Row << ": Center of Gaussian far away from middle of signal" << endl;
        //          }
                    if ((D_A1_GaussFit_Coeffs(1) < D_A1_GaussFit_Coeffs_Bak(1) - (double(I_Step)/2.)) || (D_A1_GaussFit_Coeffs(1) > D_A1_GaussFit_Coeffs_Bak(1) + (double(I_Step)/2.))){
                      #ifdef __DEBUG_FITS_FINDANDTRACE__
                        cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Warning: Center of Gaussian too far away from middle of signal -> abandoning aperture" << endl;
                      #endif
                      /// Set signal to zero
                      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                        (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                      }
                      D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                      for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                        D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                      }
                      I_ApertureLost++;
                    }
                    else{
                      if ((D_A1_GaussFit_Coeffs(2) < this->D_ApertureFWHM / 4.) || (D_A1_GaussFit_Coeffs(2) > this->D_ApertureFWHM)){
                        #ifdef __DEBUG_FITS_FINDANDTRACE__
                          cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": WARNING: FWHM = " << D_A1_GaussFit_Coeffs(2) << " outside range -> abandoning aperture" << endl;
                        #endif
                        /// Set signal to zero
                        for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                          (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                        }
                        D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                        for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                          D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                        }
                        #ifdef __DEBUG_FITS_FINDANDTRACE__
                          cout << "CFits::FindAndTraceApertures: 2. Signal set to zero from I_FirstWideSignalStart = " << I_FirstWideSignalStart << " to I_FirstWideSignalEnd = " << I_FirstWideSignalEnd << endl;
                        #endif
                        I_ApertureLost++;
                      }
                      else{
                        I_ApertureLost = 0;
                        B_ApertureFound = true;
                        D_A1_ApertureCenter(I_RowCenter) = D_A1_GaussFit_Coeffs(1);
                        #ifdef __DEBUG_FITS_FINDANDTRACE__
                          cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": Aperture found at " << D_A1_ApertureCenter(I_RowCenter) << endl;
                        #endif
                        D_A1_GaussFit_Coeffs_Bak = D_A1_GaussFit_Coeffs;
                        I_LastRowWhereApertureWasFound = I_RowCenter;
                      }
                    }/// end else if ((D_A1_GaussFit_Coeffs(1) >= D_A1_Guess(1) - 1.) && (D_A1_GaussFit_Coeffs(1) <= D_A1_Guess(1) + 1.))
                  }/// end else if (this->GaussFit(D_A1_X, D_A1_Y, D_A1_GaussFit_Coeffs, CS_A1_KeyWords_GaussFit, PP_Args_GaussFit))
                  for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                    (*(this->P_D_A2_PixArray))(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                  }
                  D_A1_RowSum(Range(I_FirstWideSignalStart+1, I_FirstWideSignalEnd-1)) = 0.;
                  for (int i_col=0; i_col<this->P_D_A2_PixArray->cols(); i_col++){
                    D_A2_PixArrayTemp(Range(I_RowStart, I_RowEnd), i_col) = D_A1_RowSum(i_col);
                  }
                }/// end else if (sum(I_A1_Signal) >= I_MinWidth){
              }/// end if (I_Length > 3)
            }/// end else if (I_ApertureStart >= 0. && I_ApertureEnd < this->NCols)
          }/// end else if GaussFit
        }///end while(B_ApertureFound && (I_ApertureLost < 3) && i_Row < this->P_D_A2_PixArray->rows() - 2))

        /// Fit Polynomial to traced aperture positions
        I_A1_ApertureCenterIndex = where(D_A1_ApertureCenter > 0., 1, 0);
        #ifdef __DEBUG_FITS_FINDANDTRACE__
          cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": I_A1_ApertureCenterIndex = " << I_A1_ApertureCenterIndex << endl;
        #endif
        if (!this->GetIndex(I_A1_ApertureCenterIndex, 
                            I_ApertureLength, 
                            I_A1_ApertureCenterInd)){
          cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": ERROR: this->GetIndex(I_A1_ApertureCenterIndex=" << I_A1_ApertureCenterIndex << ", I_ApertureLength, I_A1_ApertureCenterInd) returned FALSE -> Returning FALSE" << endl;
          return false;
        }
        cout << "CFits::FindAndTraceApertures: I_ApertureNumber = " << I_ApertureNumber << ": I_ApertureLength = " << I_ApertureLength << endl;
//        return false;
//        if ((I_ApertureLength >= 20)){//} <= I_In_MaxLength) && (I_ApertureLength >= I_In_MinLength)){
        if (I_ApertureLength >= I_In_MinLength){
	  #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": I_A1_ApertureCenterInd = " << I_A1_ApertureCenterInd << endl;
          #endif
          if (!this->GetSubArrCopy(*P_D_A1_IndexRow,
                                   I_A1_ApertureCenterInd, 
                                   D_A1_ApertureCenterIndex)){
            cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": ERROR: this->GetSubArrCopy(*P_D_A1_IndexRow = " << *P_D_A1_IndexRow << ", I_A1_ApertureCenterInd = " << I_A1_ApertureCenterInd << ", D_A1_ApertureCenterIndex) returned FALSE -> returning FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": D_A1_ApertureCenterIndex = " << D_A1_ApertureCenterIndex << endl;
          #endif

          if (!this->GetSubArrCopy(D_A1_ApertureCenter,
                                   I_A1_ApertureCenterInd,
                                   D_A1_ApertureCenterPos)){
            cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": ERROR: this->GetSubArrCopy(D_A1_ApertureCenter = " << D_A1_ApertureCenter << ", I_A1_ApertureCenterInd = " << I_A1_ApertureCenterInd << ", D_A1_ApertureCenterIndex) returned FALSE -> returning FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": D_A1_ApertureCenterPos = " << D_A1_ApertureCenterPos << endl;
          #endif

          /// Fit Polynomial
//          if (I_ApertureNumber == 425){
//            cout << "CFits::FindAndTraceApertures: I_ApertureNumber = " << I_ApertureNumber << ": D_A1_ApertureCenterIndex = " << D_A1_ApertureCenterIndex << ", D_A1_ApertureCenterPos = " << D_A1_ApertureCenterPos << ", I_In_PolyFitOrder = " << I_In_PolyFitOrder <<  endl;
//          }
          if (!this->PolyFit(D_A1_ApertureCenterIndex, D_A1_ApertureCenterPos, I_In_PolyFitOrder, P_D_A1_PolyFitCoeffs)){
            cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": ERROR: PolyFit returned FALSE -> Returning FALSE" << endl;
            return false;
          }
//          #ifdef __DEBUG_FITS_FINDANDTRACE__
//          if (I_ApertureNumber == 424){
//            cout << "CFits::FindAndTraceApertures: i_Row = " << i_Row << ": I_ApertureNumber = " << I_ApertureNumber << ": *P_D_A1_PolyFitCoeffs = " << *P_D_A1_PolyFitCoeffs << endl;
//            return false;
//          }
//            for (int i = 0; i < D_A1_ApertureCenterIndex.size(); i++){
//              D_A2_PixArrayNew(int(D_A1_ApertureCenterIndex(i)), int(D_A1_ApertureCenterPos(i))) = 60000.;
//            }
//          #endif

          I_ApertureNumber++;
          this->Set_NApertures(I_NApertures+1);
//          this->ResizeAndPreserve(*(this->P_D_A1_XCenter), I_ApertureNumber);
//          this->ResizeAndPreserve(*(this->P_D_A1_XHigh), I_ApertureNumber);
//          this->ResizeAndPreserve(*(this->P_D_A1_XLow), I_ApertureNumber);
//          this->ResizeAndPreserve(*(this->P_D_A1_YCenter), I_ApertureNumber);
//          this->ResizeAndPreserve(*(this->P_D_A1_YHigh), I_ApertureNumber);
//          this->ResizeAndPreserve(*(this->P_D_A1_YLow), I_ApertureNumber);
//          this->ResizeAndPreserve(*(this->P_I_A1_Orders), I_ApertureNumber);
//          this->ResizeAndPreserve(*(this->P_I_A1_NCoeffs), I_ApertureNumber);
//          this->ResizeAndPreserve(*(this->P_D_A2_Coeffs), I_ApertureNumber, I_In_PolyFitOrder+1);
//          this->ResizeAndPreserve(*(this->P_CS_A1_Functions), I_ApertureNumber);

          (*this->P_D_A1_XCenter)(I_ApertureNumber-1) = D_A1_ApertureCenterPos(int(D_A1_ApertureCenterIndex.size()/2.));
          (*this->P_D_A1_YCenter)(I_ApertureNumber-1) = D_A1_ApertureCenterIndex(int(D_A1_ApertureCenterIndex.size()/2.));
          (*this->P_D_A1_YHigh)(I_ApertureNumber-1) = D_A1_ApertureCenterIndex(int(D_A1_ApertureCenterIndex.size()-1)) - (*this->P_D_A1_YCenter)(I_ApertureNumber-1);
          (*this->P_D_A1_YLow)(I_ApertureNumber-1) = D_A1_ApertureCenterIndex(0) - (*this->P_D_A1_YCenter)(I_ApertureNumber-1);
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: P_D_A1_PolyFitCoeffs = " << *P_D_A1_PolyFitCoeffs << endl;
          #endif
          (*this->P_D_A2_Coeffs)(I_ApertureNumber-1, Range::all()) = (*P_D_A1_PolyFitCoeffs)(Range::all());
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: P_D_A2_Coeffs(I_ApertureNumber-1= " << I_ApertureNumber - 1 << ", *) = " << (*P_D_A2_Coeffs)(I_ApertureNumber-1, Range::all()) << endl;
          #endif
//          if ((I_ApertureNumber-1) == 424)
//            return false;
          (*this->P_I_A1_NCoeffs)(I_ApertureNumber-1) = I_In_PolyFitOrder+1;
          (*this->P_I_A1_Orders)(I_ApertureNumber-1) = I_In_PolyFitOrder;
          (*this->P_CS_A1_Functions)(I_ApertureNumber-1) = CString("polynomial");
          #ifdef __DEBUG_FITS_FINDANDTRACE__
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_D_A1_XCenter = " << (*this->P_D_A1_XCenter)(I_ApertureNumber-1) << endl;
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_D_A1_YCenter = " << (*this->P_D_A1_YCenter)(I_ApertureNumber-1) << endl;
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_D_A1_YLow = " << (*this->P_D_A1_YLow)(I_ApertureNumber-1) << endl;
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_D_A1_YHigh = " << (*this->P_D_A1_YHigh)(I_ApertureNumber-1) << endl;
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_I_A1_NCoeffs = " << (*this->P_I_A1_NCoeffs)(I_ApertureNumber-1) << endl;
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_I_A1_Orders = " << (*this->P_I_A1_Orders)(I_ApertureNumber-1) << endl;
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_D_A2_Coeffs = " << (*this->P_D_A2_Coeffs)(I_ApertureNumber-1, Range::all()) << endl;
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_CS_A1_Functions = " << (*this->P_CS_A1_Functions)(I_ApertureNumber-1) << endl;
            #endif
            cout << "CFits::FindAndTraceApertures: I_ApertureNumber-1 = " << I_ApertureNumber-1 << ": P_D_A2_Coeffs = " << (*this->P_D_A2_Coeffs)(I_ApertureNumber-1, Range::all()) << endl;






//          return true;
        }
        i_Row = I_Row_Bak - 1;
  //      return true;
      }/// end if (B_ApertureFound)


//      return false;


    }/// end for(i_Row = 0; i_Row < this->P_D_A2_PixArray->rows(); i_Row++)
///  }/// end while B_AperturesInArray

  #ifdef __DEBUG_FITS_FINDANDTRACE__
    CString CS_FileNameTrace(" ");
    CString *P_CS_NewFileName = this->P_CS_FileName->SubString(0,P_CS_FileName->LastStrPos(CString("."))-1);
    CS_FileNameTrace = *P_CS_NewFileName + CString("_trace.fits");
    CString CS_FileNameStep(" ");
    CS_FileNameStep = *P_CS_NewFileName + CString("_step.fits");
    *P_CS_NewFileName += CString("_out.fits");
    this->SetFileName(*P_CS_NewFileName);
    this->WriteArray();
    delete(P_CS_NewFileName);
    CFits CF_Out;
    CF_Out.SetNCols(this->NCols);
    CF_Out.SetNRows(this->NRows);
    CF_Out.SetFileName(CS_FileNameTrace);
    *(CF_Out.P_D_A2_PixArray) = D_A2_PixArrayNew;
    CF_Out.WriteArray();
    CF_Out.SetFileName(CS_FileNameStep);
    *(CF_Out.P_D_A2_PixArray) = D_A2_PixArrayTemp;
    CF_Out.WriteArray();
  #endif
  delete(P_D_A1_IndexCol);
  delete(P_D_A1_IndexRow);
  delete(P_D_A1_PolyFitCoeffs);
  this->Set_NApertures(I_ApertureNumber);
  return true;
}


bool CFits::FindAndTraceApertures(const int I_NApertures_In,
                                  const double D_Threshold_In,
                                  const int I_NSum,
                                  const int I_Step,
                                  const double D_SigmaReject_In,
                                  const double D_FWHM_In,
                                  const int I_PolyFitOrder_In,
                                  std::string S_ThreshZero_Out){
  Array<double, 2> D_A2_PixArray(this->NRows, this->NCols);
  D_A2_PixArray = (*(this->P_D_A2_PixArray));
  D_A2_PixArray -= D_Threshold_In;
  D_A2_PixArray = where(D_A2_PixArray < 0., 0, D_A2_PixArray);
  if (S_ThreshZero_Out.length() > 1)
    this->WriteFits(&D_A2_PixArray, CString(S_ThreshZero_Out));
  
  int I_Row = int(I_NSum / 2);
  int I_RowStart = 0;
  int I_RowEnd = I_NSum - 1;
  Array<double, 1> D_A1_Row(this->NCols);
  Array<double, 2> D_A2_StepArray(I_NSum, this->NCols);
  Array<double, 1> D_A1_StepColArray(I_NSum);
  Array<double, 3> D_A3_ApCen(I_NApertures_In, this->NRows / I_Step, 2);
  Array<double, 1> *P_D_A1_X = this->DIndGenArr(this->NCols);
  Array<double, 1> D_A1_EY(this->NCols);
  Array<double,1> D_A1_Guess(4);
  Array<double, 1> D_A1_GaussCoeffs(4);
  Array<double, 1> D_A1_EGaussCoeffs(4);
  double D_Mean = 0.;
  double D_StdDev = 0.;
  double D_GaussSigma = D_FWHM_In / 2.3548;
  int i_step = 0;
  do{
    D_A2_StepArray = D_A2_PixArray(Range(I_RowStart, I_RowEnd), Range::all());
    for (int i_col=0; i_col<this->NCols; i_col++){
      D_A1_StepColArray = D_A2_StepArray(Range::all(), i_col);
      D_Mean = mean(D_A1_StepColArray);
      D_StdDev = this->StdDev(D_A1_StepColArray);
      D_A1_StepColArray = where(fabs(D_A1_StepColArray - D_Mean) > (D_SigmaReject_In * D_StdDev), D_Mean, D_A1_StepColArray);
      D_A2_StepArray(Range::all(), i_col) = D_A1_StepColArray;
    }
    D_A2_PixArray(Range(I_RowStart, I_RowEnd), Range::all()) = D_A2_StepArray;
    for (int i_col=0; i_col<this->NCols; i_col++){
      D_A1_Row(i_col) = this->Median(D_A2_StepArray(Range::all(), i_col));
    }
    
    for (int i_ap=0; i_ap < I_NApertures_In; i_ap++){
      int I_FirstWideSignalStart = 0;
      bool B_FirstWideSignalFound = false;
      do{
        B_FirstWideSignalFound = true;
        for (int i_pix=I_FirstWideSignalStart; i_pix<I_FirstWideSignalStart+(2. * D_FWHM_In); i_pix++){
          if (D_A1_Row(i_pix) < D_Threshold_In)
            B_FirstWideSignalFound = false;
        }
        if (!B_FirstWideSignalFound)
          I_FirstWideSignalStart++;
      } while ((!B_FirstWideSignalFound) && (I_FirstWideSignalStart < (this->NCols - 1)));
      cout << "CFits::FindAndTraceAps: First wide signal found at I_FirstWideSignalStart = " << I_FirstWideSignalStart << endl;
      int I_FirstWideSignalEnd = I_FirstWideSignalStart;
      bool B_FirstWideSignalEndFound = false;
      do{
        if (D_A1_Row(I_FirstWideSignalEnd) < D_Threshold_In)
          B_FirstWideSignalEndFound = true;
        else
          I_FirstWideSignalEnd++;
      } while ((!B_FirstWideSignalEndFound) && (I_FirstWideSignalEnd < (this->NCols - 1)));
      cout << "CFits::FindAndTraceAps: End of first wide signal found at I_FirstWideSignalEnd = " << I_FirstWideSignalEnd << endl;
      D_A1_EY = sqrt(D_A1_Row);
      D_A1_EY = where(D_A1_EY < 1., 1., D_A1_EY);
      D_A1_Guess(0) = D_Threshold_In;
      D_A1_Guess(1) = max(D_A1_Row(Range(I_FirstWideSignalStart, I_FirstWideSignalEnd)));
      D_A1_Guess(2) = double(I_FirstWideSignalStart) + (double(I_FirstWideSignalEnd - I_FirstWideSignalStart) / 2.);
      D_A1_Guess(3) = D_GaussSigma;
      D_A1_GaussCoeffs = 0.;
      D_A1_EGaussCoeffs = 0.;
      if (!MPFitGauss(*P_D_A1_X,
                      D_A1_Row,
                      D_A1_EY,
                      D_A1_Guess,
                      true,
                      false,
                      D_A1_GaussCoeffs,
                      D_A1_EGaussCoeffs)){
        cout << "CFits::FindAndTraceAps: ERROR: MPFitGauss returned FALSE" << endl;
        delete(P_D_A1_X);
        return false;
      }
      cout << "CFits::FindAndTraceAps: D_A1_GaussCoeffs = " << D_A1_GaussCoeffs << endl;
      D_A3_ApCen(i_ap, i_step, 1) = D_A1_GaussCoeffs(2);
      D_A3_ApCen(i_ap, i_step, 0) = double(I_Row);
      D_A1_Row(Range(I_FirstWideSignalStart, I_FirstWideSignalEnd)) = 0.;
      D_A2_PixArray(Range(I_RowStart, I_RowEnd), Range(I_FirstWideSignalStart, I_FirstWideSignalEnd)) = 0.;
    }
    
    I_Row += I_Step;
    I_RowStart += I_Step;
    I_RowEnd += I_Step;
    if (I_RowEnd >= this->NRows){
      I_RowEnd = this->NRows - 1;
      I_RowStart = this->NRows - I_NSum;
      I_Row = I_RowStart + ((I_RowEnd - I_RowStart) / 2);
    }
    D_A2_StepArray.resize(I_RowEnd - I_RowStart + 1, this->NCols);
    i_step++;
  } while (I_RowEnd < (this->NRows - 1) && (i_step < D_A3_ApCen.cols()));

  Array<double, 1> *P_D_A1_PolyFitCoeffs = new Array<double, 1>(I_PolyFitOrder_In+1);
  this->Set_NApertures(I_NApertures_In);
  delete(P_D_A1_X);
  P_D_A1_X = this->DIndGenArr(this->NRows);
  for (int i_ap=0; i_ap<I_NApertures_In; i_ap++){
    if (!this->PolyFit(D_A3_ApCen(i_ap, Range::all(), 0), 
                       D_A3_ApCen(i_ap, Range::all(), 1),
                       I_PolyFitOrder_In,
                       P_D_A1_PolyFitCoeffs)){
      cout << "CFits::FindAndTraceAps: ERROR: PolyFit returned FALSE" << endl;
      return false;
    }
    Array<double, 1> *P_D_A1_Y = this->Poly(*P_D_A1_X, *P_D_A1_PolyFitCoeffs);
    (*(this->P_I_A1_NCoeffs))(i_ap) = I_PolyFitOrder_In+1;
    cout << "CFits::FindAndTraceAps: P_D_A2_Coeffs->cols() = " << this->P_D_A2_Coeffs->cols() << endl;
    (*(this->P_D_A2_Coeffs))(i_ap, Range::all()) = (*P_D_A1_PolyFitCoeffs);
    (*(this->P_I_A1_Orders))(i_ap) = I_PolyFitOrder_In;
    (*(this->P_CS_A1_Functions))(i_ap) = CString("polynomial");
    (*(this->P_D_A1_YCenter))(i_ap) = double(int(this->NRows / 2));
    (*(this->P_D_A1_YLow))(i_ap) = 0. - (*(this->P_D_A1_YCenter))(i_ap);
    (*(this->P_D_A1_YHigh))(i_ap) = double(this->NRows) - (*(this->P_D_A1_YCenter))(i_ap) - 1.;
    (*(this->P_D_A2_XCenters))(i_ap, Range::all()) = *P_D_A1_Y;
    (*(this->P_D_A1_XCenter))(i_ap) = (*P_D_A1_Y)((*(this->P_D_A1_YCenter))(i_ap));
    delete(P_D_A1_Y);
  }
  
  
  (*(this->P_D_A2_PixArray)) = D_A2_PixArray;
  this->SetFileName(CString("testout.fits"));
  this->WriteArray();
  delete(P_D_A1_X);
  return true;
}


/** ***************************************************/
/**       */
/**       */
/** ***************************************************/
bool CFits::CalcTraceFunction(int I_Aperture_In)
//double *P_CenterArr,
//const double *P_CoeffArr,
//const double XMin,
//const double XMax,
//const int Order,
//const char* P_Function) const
{
  //  Array<CString, 1> CS_A1_Functions(5);
  int i;
  double *P_D_YMin = new double();
  double *P_D_YMax = new double();
  Array<double, 1> D_A1_TempCen = (*this->P_D_A2_XCenters)(I_Aperture_In, Range::all());
  Array<double, 1> D_A1_TempCoef = (*this->P_D_A2_Coeffs)(I_Aperture_In, Range(0,(*this->P_I_A1_NCoeffs)(I_Aperture_In)-1));

  #ifdef __DEBUG_FITS_TRACEFUNC__
    cout << "CFits::CalcTraceFunction: (*this->P_CS_A1_Functions)(I_Aperture_In=" << I_Aperture_In << ") = " << (*this->P_CS_A1_Functions)(I_Aperture_In) << endl;
    cout << "CFits::CalcTraceFunction: (*this->P_I_A1_Orders)(I_Aperture_In=" << I_Aperture_In << ") = " << (*this->P_I_A1_Orders)(I_Aperture_In) << endl;
  #endif
  if ((*this->P_CS_A1_Functions)(I_Aperture_In).EqualValue(CString("legendre")))
  {
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Function = Legendre" << endl;
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Coeffs = " << D_A1_TempCoef << endl;
    #endif
    if (!Legendre(D_A1_TempCen,
                  P_D_YMin,
                  P_D_YMax,
                  D_A1_TempCoef,
                  (*this->P_D_A1_XCenter)(I_Aperture_In)+1.,
                  (*this->P_D_A1_YCenter)(I_Aperture_In)+1.,
                  int((*this->P_D_A1_YCenter)(I_Aperture_In)+(*this->P_D_A1_YLow)(I_Aperture_In))+1,
                  int((*this->P_D_A1_YCenter)(I_Aperture_In)+(*this->P_D_A1_YHigh)(I_Aperture_In))+1,
                  (*this->P_D_A1_XLow)(I_Aperture_In),
                  (*this->P_D_A1_XHigh)(I_Aperture_In),
                  (*this->P_I_A1_Orders)(I_Aperture_In),
                  this->NCols))
    {
      cout << "CFits::CalcTraceFunction: (*this->P_D_A1_YCenter)(I_Aperture_In) = " << (*this->P_D_A1_YCenter)(I_Aperture_In) << endl;
      cout << "CFits::CalcTraceFunction: (*this->P_D_A1_YLow)(I_Aperture_In) = " << (*this->P_D_A1_YLow)(I_Aperture_In) << endl;
      cout << "CFits::CalcTraceFunction: (*this->P_D_A1_YHigh)(I_Aperture_In) = " << (*this->P_D_A1_YHigh)(I_Aperture_In) << endl;
      cout << "CFits::CalcTraceFunction: ERROR: Legendre(...) returned FALSE!!!" << endl;
      (*P_OFS_Log) << "CFits::CalcTraceFunction: ERROR: Legendre(...) returned FALSE!!!" << endl;
      delete(P_D_YMin);
      delete(P_D_YMax);
      return false;
    }
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::CalcTraceFunction: Legendre: P_D_YMin set to " << *P_D_YMin << endl;
      cout << "CFits::CalcTraceFunction: Legendre: P_D_YMax set to " << *P_D_YMax << endl;
    #endif
    
    D_A1_TempCen -= 1.;
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::CalcTraceFunction: Legendre: D_A1_TempCen set to :" << endl;
      for (int ppp=0; ppp < D_A1_TempCen.size(); ppp++)
        cout << D_A1_TempCen(ppp) << endl;
    #endif
//return false;
///    (*this->P_D_A1_XMin)(I_Aperture_In) = (*P_D_YMin);
///    (*this->P_D_A1_XMax)(I_Aperture_In) = (*P_D_YMax);
///#ifdef __DEBUG_FITS_TRACEFUNC__
///    cout << "CFits::CalcTraceFunction: Legendre: P_D_A1_XMin(I_Aperture_In=" << I_Aperture_In << ") set to " << (*P_D_A1_XMin)(I_Aperture_In) << endl;
///    (*P_OFS_Log) << "CFits::CalcTraceFunction: Legendre: P_D_A1_XMin(I_Aperture_In=" << I_Aperture_In << ") set to " << (*P_D_A1_XMin)(I_Aperture_In) << endl;
///    cout << "CFits::CalcTraceFunction: Legendre: P_D_A1_XMax(I_Aperture_In=" << I_Aperture_In << ") set to " << (*P_D_A1_XMax)(I_Aperture_In) << endl;
///    (*P_OFS_Log) << "CFits::CalcTraceFunction: Legendre: P_D_A1_XMax(I_Aperture_In=" << I_Aperture_In << ") set to " << (*P_D_A1_XMin)(I_Aperture_In) << endl;
///#endif
    (*this->P_D_A2_XCenters)(I_Aperture_In,Range::all()) = D_A1_TempCen;
  }
  else if ((*this->P_CS_A1_Functions)(I_Aperture_In).EqualValue(CString("chebyshev")))
  {
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Function = Chebyshev" << endl;
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Coeffs = " << D_A1_TempCoef << endl;
    #endif
    //    for (int ppos = 0; ppos < 4; ppos++)
    //    {
    //      delete PP_Functions[ppos];
    //    }
    //    delete[] PP_Functions;
    if (!Chebyshev(D_A1_TempCen,
                   P_D_YMin,
                   P_D_YMax,
                   D_A1_TempCoef,
                   (*this->P_D_A1_XCenter)(I_Aperture_In)+1.,
                   (*this->P_D_A1_YCenter)(I_Aperture_In)+1.,
                   int((*this->P_D_A1_YCenter)(I_Aperture_In)+(*this->P_D_A1_YLow)(I_Aperture_In))+1,
                   int((*this->P_D_A1_YCenter)(I_Aperture_In)+(*this->P_D_A1_YHigh)(I_Aperture_In))+1,
                   (*this->P_D_A1_XLow)(I_Aperture_In),
                   (*this->P_D_A1_XHigh)(I_Aperture_In),
                   (*this->P_I_A1_Orders)(I_Aperture_In),
                   this->NCols))
    {
      cout << "CFits::CalcTraceFunction: ERROR: Chebyshev(...) returned FALSE!!!" << endl;
      (*P_OFS_Log) << "CFits::CalcTraceFunction: ERROR: Chebyshev(...) returned FALSE!!!" << endl;
      return false;
    }
///    (*this->P_D_A1_XMin)(I_Aperture_In) = (int)(*P_D_YMin);
///    (*this->P_D_A1_XMax)(I_Aperture_In) = (int)(*P_D_YMax);
    D_A1_TempCen -= 1.;
///#ifdef __DEBUG_FITS_TRACEFUNC__
///    cout << "CFits::CalcTraceFunction: Chebyshev: P_D_A1_XMin(I_Aperture_In=" << I_Aperture_In << ") set to " << (*P_D_A1_XMin)(I_Aperture_In) << endl;
///    (*P_OFS_Log) << "CFits::CalcTraceFunction: Chebyshev: P_D_A1_XMin(I_Aperture_In=" << I_Aperture_In << ") set to " << (*P_D_A1_XMin)(I_Aperture_In) << endl;
///    cout << "CFits::CalcTraceFunction: Chebyshev: P_D_A1_XMax(I_Aperture_In=" << I_Aperture_In << ") set to " << (*P_D_A1_XMax)(I_Aperture_In) << endl;
///    (*P_OFS_Log) << "CFits::CalcTraceFunction: Chebyshev: P_D_A1_XMax(I_Aperture_In=" << I_Aperture_In << ") set to " << (*P_D_A1_XMin)(I_Aperture_In) << endl;
///#endif
    (*this->P_D_A2_XCenters)(I_Aperture_In,Range::all()) = D_A1_TempCen;
  }
  else if ((*this->P_CS_A1_Functions)(I_Aperture_In).EqualValue(CString("linear")))
  {
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Function = spline1" << endl;
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Coeffs = " << D_A1_TempCoef << endl;
    #endif
    //    for (int ppos = 0; ppos < 4; ppos++)
    //    {
    //      delete PP_Functions[ppos];
    //    }
    //    delete[] PP_Functions;
    if (!LinearSpline(D_A1_TempCen,
                      D_A1_TempCoef,
                      (*this->P_D_A1_XCenter)(I_Aperture_In)+1.,
                      (*this->P_D_A1_YCenter)(I_Aperture_In)+1.,
                      int((*this->P_D_A1_YCenter)(I_Aperture_In)+(*this->P_D_A1_YLow)(I_Aperture_In))+1,
                      int((*this->P_D_A1_YCenter)(I_Aperture_In)+(*this->P_D_A1_YHigh)(I_Aperture_In))+1,
                      (*this->P_D_A1_XLow)(I_Aperture_In),
                      (*this->P_D_A1_XHigh)(I_Aperture_In),
                      (*this->P_I_A1_Orders)(I_Aperture_In),
                      this->NCols))
    {
      cout << "CFits::CalcTraceFunction: ERROR: LinearSpline(...) returned FALSE!!!" << endl;
      (*P_OFS_Log) << "CFits::CalcTraceFunction: ERROR: LinearSpline(...) returned FALSE!!!" << endl;
      delete(P_D_YMin);
      delete(P_D_YMax);
      return false;
    }
    D_A1_TempCen -= 1.;
    (*this->P_D_A2_XCenters)(I_Aperture_In,Range::all()) = D_A1_TempCen;
  }
  else if ((*this->P_CS_A1_Functions)(I_Aperture_In).EqualValue(CString("cubic")))
  {
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Function = spline3" << endl;
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Coeffs = " << D_A1_TempCoef << endl;
    #endif
    //    for (int ppos = 0; ppos < 4; ppos++)
    //    {
    //      delete PP_Functions[ppos];
    //    }
    //    delete[] PP_Functions;
    if (!CubicSpline(D_A1_TempCen,
                     D_A1_TempCoef,
                     (*this->P_D_A1_XCenter)(I_Aperture_In)+1.,
                     (*this->P_D_A1_YCenter)(I_Aperture_In)+1.,
                     int((*this->P_D_A1_YCenter)(I_Aperture_In)+(*this->P_D_A1_YLow)(I_Aperture_In))+1,
                     int((*this->P_D_A1_YCenter)(I_Aperture_In)+(*this->P_D_A1_YHigh)(I_Aperture_In))+1,
                     (*this->P_D_A1_XLow)(I_Aperture_In),
                     (*this->P_D_A1_XHigh)(I_Aperture_In),
                     (*this->P_I_A1_Orders)(I_Aperture_In),
                     this->NCols))
    {
      cout << "CFits::CalcTraceFunction: ERROR: CubicSpline(...) returned FALSE!!!" << endl;
      (*P_OFS_Log) << "CFits::CalcTraceFunction: ERROR: CubicSpline(...) returned FALSE!!!" << endl;
      delete(P_D_YMin);
      delete(P_D_YMax);
      return false;
    }
    D_A1_TempCen -= 1.;
    (*this->P_D_A2_XCenters)(I_Aperture_In,Range::all()) = D_A1_TempCen;
  }
  else /// Polynomial
  {
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Function = Polynomial" << endl;
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": Coeffs = " << D_A1_TempCoef << endl;
    #endif
///    D_A1_YCenB = *(this->Poly(D_A1_XRow, (*this->P_D_A2_Coeffs)(0,Range(0,(*this->P_I_A1_NCoeffs)(0)-1))));
    Array<double,1> D_A1_XRow(this->NRows);
    for (i=0; i < this->NRows; i++){
      D_A1_XRow(i) = double(i);
    }
    #ifdef __DEBUG_FITS_TRACEFUNC__
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": D_A1_TempCoef = " << D_A1_TempCoef << endl;
    #endif
    Array<double,1> *P_D_A1_TempCen = this->Poly(D_A1_XRow, D_A1_TempCoef);
    D_A1_TempCen = (*P_D_A1_TempCen);
    delete(P_D_A1_TempCen);
    (*this->P_D_A2_XCenters)(I_Aperture_In,Range::all()) = D_A1_TempCen;
    Array<double, 1> D_A1_XLow(this->P_D_A2_XCenters->cols());
    D_A1_XLow = D_A1_TempCen + (*(this->P_D_A1_XLow))(I_Aperture_In);
    Array<double, 1> D_A1_XHigh(this->P_D_A2_XCenters->cols());
    D_A1_XHigh = D_A1_TempCen + (*(this->P_D_A1_XHigh))(I_Aperture_In);
    Array<int, 1> I_A1_Where(this->P_D_A2_XCenters->cols());
    I_A1_Where = where(D_A1_XLow < 0., 0, 1);
    int I_NInd;
    Array<int, 1> *P_I_A1_WhereInd = this->GetIndex(I_A1_Where, I_NInd);
    *P_D_YMin = (*P_I_A1_WhereInd)(0);
    delete(P_I_A1_WhereInd);
    I_A1_Where = where(D_A1_XHigh < this->NCols, 1, 0);
    P_I_A1_WhereInd = this->GetIndex(I_A1_Where, I_NInd);
    *P_D_YMax = (*P_I_A1_WhereInd)(P_I_A1_WhereInd->size()-1);
    delete(P_I_A1_WhereInd);

    #ifdef __DEBUG_FITS_TRACEFUNC__
      /// Coefficients for the polynomial trace functions
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A2_Coeffs(I_Aperture_In,Range::all()) = " << (*P_D_A2_Coeffs)(I_Aperture_In,Range::all()) << endl;  /// NApertures x max(P_I_A1_NCoeffs)

      /// Centres of the apertures in x(cols)
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A2_XCenters(I_Aperture_In,Range::all()) set to " << (*P_D_A2_XCenters)(I_Aperture_In,Range::all()) << endl;/// NApertures x NRows

      /// lower aperture limit for every aperture (< 0.), cols
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A1_XLow(I_Aperture_In) set to " << (*P_D_A1_XLow)(I_Aperture_In) << endl;     /// NApertures

      /// higher aperture limit for every aperture (> 0.), cols
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A1_XHigh(I_Aperture_In) set to " << (*P_D_A1_XHigh)(I_Aperture_In) << endl;    /// NApertures

      /// lower aperture limit for every aperture (< 0.), rows
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A1_YLow set to(I_Aperture_In) " << (*P_D_A1_YLow)(I_Aperture_In) << endl;     /// NApertures

      /// higher aperture limit for every aperture (> 0.), rows
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A1_YHigh(I_Aperture_In) set to " << (*P_D_A1_YHigh)(I_Aperture_In) << endl;    /// NApertures

      /// center position in x (column) for every aperture
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A1_XCenter(I_Aperture_In) set to " << (*P_D_A1_XCenter)(I_Aperture_In) << endl; /// NApertures

      /// center position in y (row) for every aperture
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A1_YCenter(I_Aperture_In) set to " << (*P_D_A1_YCenter)(I_Aperture_In) << endl; /// NApertures

      /// aperture lower limit for determining the background
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A1_XMin(I_Aperture_In) set to " << (*P_D_A1_XMin)(I_Aperture_In) << endl;    /// NApertures

      /// aperture upper limit for determining the background
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_D_A1_XMax(I_Aperture_In) set to " << (*P_D_A1_XMax)(I_Aperture_In) << endl;    /// NApertures

      /// polynomial order of apterture trace function
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_I_A1_Orders(I_Aperture_In) set to " << (*P_I_A1_Orders)(I_Aperture_In) << endl;  /// NApertures

      /// number of coefficients for polynomial trace function
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_I_A1_NCoeffs(I_Aperture_In) set to " << (*P_I_A1_NCoeffs)(I_Aperture_In) << endl; /// NApertures

      /// Name of function used to trace the apertures
      ///  0: chebyshev
      ///  1: legendre
      ///  2: cubic
      ///  3: linear
      ///  4: polynomial
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": P_CS_A1_Functions(I_Aperture_In) set to " << (*P_CS_A1_Functions)(I_Aperture_In) << endl; /// NApertures
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": D_A1_TempCen set to " << D_A1_TempCen << endl;
      cout << "CFits::CalcTraceFunction: P_D_A2_XCenters->size() = " << P_D_A2_XCenters->size() << endl;
      cout << "CFits::CalcTraceFunction: I_Aperture_In = " << I_Aperture_In << ": (*this->P_D_A2_XCenters)(I_Aperture_In, Range::all()) set to " << (*this->P_D_A2_XCenters)(I_Aperture_In, Range::all()) << endl;
    #endif
  }
  if ((*P_D_YMin) - (*(this->P_D_A1_YCenter))(I_Aperture_In) > (*(this->P_D_A1_YLow))(I_Aperture_In))
    (*(this->P_D_A1_YLow))(I_Aperture_In) = (*P_D_YMin) - (*(this->P_D_A1_YCenter))(I_Aperture_In);
  if ((*P_D_YMax) - (*(this->P_D_A1_YCenter))(I_Aperture_In) < (*(this->P_D_A1_YHigh))(I_Aperture_In))
    (*(this->P_D_A1_YHigh))(I_Aperture_In) = (*P_D_YMax) - (*(this->P_D_A1_YCenter))(I_Aperture_In);
  #ifdef __DEBUG_FITS_TRACEFUNC__
    cout << "CFits::CalcTraceFunction: this->P_D_A1_YLow(" << I_Aperture_In << ") set to " << (*(this->P_D_A1_YLow))(I_Aperture_In) << endl;
    cout << "CFits::CalcTraceFunction: this->P_D_A1_YHigh(" << I_Aperture_In << ") set to " << (*(this->P_D_A1_YHigh))(I_Aperture_In) << endl;
  #endif
  D_A1_TempCen.resize(0);
  D_A1_TempCoef.resize(0);
  delete P_D_YMin;
  delete P_D_YMax;
  return true;
}

bool CFits::CalcTraceFunctions()
{
  for (int m = 0; m < this->I_NApertures; m++)
  {
    if (!this->CalcTraceFunction(m))
    {
      cout << "CFits::CalcTraceFunctions: CalcTraceFunction(m=" << m << ") returned FALSE => Returning FALSE" << endl;
      (*P_OFS_Log) << "CFits::CalcTraceFunctions: CalcTraceFunction(m=" << m << ") returned FALSE => Returning FALSE" << endl;
      return false;
    }
  }
  this->TraceFunctionsCalculated = true;
  return true;
}

/** **************************************************/
/**       */
/**       */
/** ***************************************************
int CFits::ReadApertureData(double *P_XArr, double **PP_PixelValue, const int Axis, const double Low, const double High, const double *P_CenterArr)
{
  fitsfile *P_FitsFile;
  int      Count,Status;
  long     NElements, NXElements, CenterPos;
  int BitPix;
  int AnyNul, Extend, Simple;
  int NAxis, Width, LowInt, HighInt;
  long PCount, GCount;
  long NAxes[2];
  long FPixel, i, j;
  float * Array;
  float NullVal;
  char StrBuf[256];
  double *P_X, **PP_PixVal;

  Status=0;
  LowInt = (int)Low;
  if (Low - LowInt > 0.00001)
    LowInt++;
  HighInt = (int)High;
  if (High - HighInt > 0.00001)
    HighInt++;
  Width = HighInt + LowInt + 2;

  fits_open_file(&P_FitsFile, P_CS_FileName, READWRITE, &Status);
  fits_read_imghdr(P_FitsFile, 2, &Simple , &BitPix, &NAxis, NAxes,
                   &PCount, &GCount, &Extend, &Status);
  if (Status !=0)
  {
    printf("MPiskunov.ReadApertureData: Error %d in file %s\n", Status, P_CS_FileName);
    exit(0);
  }

  NElements =  NAxes[0] * NAxes[1];
  Array = malloc(sizeof(float) * NElements);
  FPixel = 1;
  NullVal = 0.;
  fits_read_img(P_FitsFile, TFLOAT, FPixel, NElements,
                &NullVal, Array, &AnyNul, &Status);
  if (Status !=0)
  {
    printf("MPiskunov.ReadApertureData: Error %d in file %s\n", Status, P_CS_FileName);
    exit(0);
  }

  // Aperture parallel to columns
  if (Axis == 1)
    NXElements = NAxes[1];
  else
    NXElements = NAxes[0];
#ifdef __DEBUG_FITS__
  printf("MPiskunov.ReadApertureData: NXElements = %d\n", NXElements);
#endif

  //  PP_X = (double**)malloc(sizeof(double*) * NXElements);
  //  if (PP_X == NULL)
  //  {
  //    printf("MPiskunov.ReadApertureData: ERROR: Cannot allocate memory for PP_X!\n");
  //    exit(0);
  //}
  P_X = (double*)malloc(sizeof(double) * NXElements);
  if (P_X == NULL)
  {
    printf("MPiskunov.ReadApertureData: ERROR: Cannot allocate memory for P_X!\n");
    exit(0);
  }

  PP_PixVal = (double**)malloc(sizeof(double*) * NXElements);
  if (PP_PixVal == NULL)
  {
    printf("MPiskunov.ReadApertureData: ERROR: Cannot allocate memory for PP_PixVal!\n");
    exit(0);
  }
  for (j = 0; j < NXElements; j++)
  {
    //    PP_X[j] = (double*)malloc(sizeof(double));
    //    if (PP_X[j] == NULL)
    //    {
    //      printf("MPiskunov.ReadApertureData: ERROR: Cannot allocate memory for PP_X[j=%d]!\n", j);
    //      exit(0);
    //  }
    P_X[j] = j + 1;

    PP_PixVal[j] = (double*)malloc(sizeof(double) * Width);
    if (PP_PixVal[j] == NULL)
    {
      printf("MPiskunov.ReadApertureData: ERROR: Cannot allocate memory for PP_PixVal[j=%d]!\n", j);
      exit(0);
    }
    for (i = 0; i < Width; i++)
    {
      //      CenterPos = (long)(Center + P_CenterArr[j]);
      //      PP_PixVal[j][i] =;
    }
  }
  //--- set all negative pixels to 0
  Count=0;
  for (j=0; j<NElements; j++)
  {
    //    printf("MPiskunov.ReadApertureData: Array[j=%d] = %.7f\n", j, Array[j]);
    if ( Array[j] < 0.)
    {
      Array[j]=0.;
      Count++;
    }
  }
#ifdef __DEBUG_FITS__
  printf("MPiskunov.ReadApertureData: %d pixels set to 0\n", Count);
#endif

  fits_write_img(P_FitsFile, TFLOAT, FPixel, NElements,
                 Array, &Status);

  if (Status !=0)
  {
    printf("MPiskunov.ReadApertureData: Error %d in file %s\n", Status, P_CS_FileName);
    exit(0);
  }
  fits_close_file(P_FitsFile, &Status);
  free(Array);

  if (Status !=0)
  {
    printf("MPiskunov.ReadApertureData: Error %d in file %s\n", Status, P_CS_FileName);
    exit(0);
  }

  return 1;
}

/** ***********************************************************/

bool CFits::ReadDatabaseEntry()//const CString &CS_FileName_In)//, char** PP_DatabaseArr)
{
#ifdef __DEBUG_FITS_READAPERTURES__
  printf("CFits.ReadDatabaseEntry: function started\n");
#endif
  if (!this->ReadApertureDefinition(-1))
  {
    cout << "CFits:: ReadDatabaseEntry: this->ReadApertureDefinition(-1) retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits:: ReadDatabaseEntry: this->ReadApertureDefinition(-1) retuned FALSE => Returning FALSE" << endl;
    return false;
  }
  return true;
}

/** ***********************************************************/

bool CFits::WriteDatabaseEntry() const//const CString &CS_FileName_In)//, char** PP_DatabaseArr)
{
  #ifdef __DEBUG_FITS_WRITEAPERTURES__
  printf("CFits.WriteDatabaseEntry: function started\n");
  #endif

  Array<CString, 1>CS_A1_Functions(5);
  CS_A1_Functions(0).Set("chebyshev");
  CS_A1_Functions(1).Set("legendre");
  CS_A1_Functions(2).Set("cubic");
  CS_A1_Functions(3).Set("linear");
  CS_A1_Functions(4).Set("polynomial");

  CString *P_CS_FName = this->P_CS_FileName->SubString(this->P_CS_FileName->LastStrPos(CString("/"))+1, this->P_CS_FileName->LastStrPos(CString("."))-1);
  int I_Function = 0;
  int I_NParam = 0;

  FILE *P_DatabaseFile;
  P_DatabaseFile = fopen(this->P_CS_DatabaseFileName->Get(), "w");
  if (P_DatabaseFile == NULL)
  {
    cout << "CFits.WriteDatabaseEntry: Failed to open file CS_FileName_In (=<" << this->P_CS_DatabaseFileName->Get() << ">)" << endl;
    (*P_OFS_Log) << "CFits.WriteDatabaseEntry: Failed to open file CS_FileName_In (=<" << this->P_CS_DatabaseFileName->Get() << ">)" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_WRITEAPERTURES__
  cout << "CFits.WriteDatabaseEntry: File CS_FileName_In(=<" << this->P_CS_DatabaseFileName->Get() << ">) opened";
  #endif

  for (int i=0; i<this->P_D_A1_XCenter->size(); i++){
    fprintf(P_DatabaseFile, "begin aperture %s %d %.2f %.1f\n", P_CS_FName->GetPChar(), i+1, (*this->P_D_A1_XCenter)(i), (*this->P_D_A1_YCenter)(i));
    fprintf(P_DatabaseFile, "image %s\n", P_CS_FName->GetPChar());
    fprintf(P_DatabaseFile, "aperture %d\n", i+1);
    fprintf(P_DatabaseFile, "beam %d\n", i+1);
    fprintf(P_DatabaseFile, "center %.5f, %.0f\n", (*this->P_D_A1_XCenter)(i)+1, (*this->P_D_A1_YCenter)(i)+1);
    fprintf(P_DatabaseFile, "low %.5f, %.0f\n", (*this->P_D_A1_XLow)(i), (*this->P_D_A1_YLow)(i));
    fprintf(P_DatabaseFile, "high %.5f, %.0f\n", (*this->P_D_A1_XHigh)(i), (*this->P_D_A1_YHigh)(i));
    fprintf(P_DatabaseFile, "background\n");
    fprintf(P_DatabaseFile, "xmin %.5f\n", (*this->P_D_A1_XMin)(i));
    fprintf(P_DatabaseFile, "xmax %.5f\n", (*this->P_D_A1_XMax)(i));
    fprintf(P_DatabaseFile, "function %s\n", (*this->P_CS_A1_Functions)(i).GetPChar());
    fprintf(P_DatabaseFile, "order %d\n", (*this->P_I_A1_Orders)(i));
    fprintf(P_DatabaseFile, "sample %d:%d,%d:%d\n", (int)(*this->P_D_A1_XMin)(i), (int)(*this->P_D_A1_XLow)(i), (int)(*this->P_D_A1_XHigh)(i), (int)(*this->P_D_A1_XMax)(i));
    fprintf(P_DatabaseFile, "naverage -3\n");
    fprintf(P_DatabaseFile, "niterate 2\n");
    fprintf(P_DatabaseFile, "low_reject 3\n");
    fprintf(P_DatabaseFile, "high_reject 3\n");
    fprintf(P_DatabaseFile, "grow 0\n");
    fprintf(P_DatabaseFile, "axis 1\n");
    for (int j=0; j<=4; j++){
      if ((*this->P_CS_A1_Functions)(i).EqualValue(CS_A1_Functions(j))){
        I_Function = j+1;
      }
    }
    fprintf(P_DatabaseFile, "curve %d\n", 4+(*this->P_I_A1_NCoeffs)(i));
    fprintf(P_DatabaseFile, "%d\n", I_Function);
    fprintf(P_DatabaseFile, "%d\n", (*this->P_I_A1_Orders)(i));
    fprintf(P_DatabaseFile, "%d\n", int((*this->P_D_A1_YCenter)(i)+(*this->P_D_A1_YLow)(i)));
    fprintf(P_DatabaseFile, "%d\n", int((*this->P_D_A1_YCenter)(i)+(*this->P_D_A1_YHigh)(i)));
    for (int j=0; j<(*this->P_I_A1_NCoeffs)(i); j++){
      CString *P_CS_Coeff = P_CS_FName->DToA((*(this->P_D_A2_Coeffs))(i,j), 10);
      #ifdef __DEBUG_FITS_WRITEAPERTURES__
        cout << "WriteDatabaseEntry: P_CS_Coeff = " << *P_CS_Coeff << endl;
      #endif

      delete(P_CS_Coeff);
//      if (i == 424){
      #ifdef __DEBUG_FITS_WRITEAPERTURES__
        cout << "WriteDatabaseEntry: (*P_D_A2_Coeffs)(" << i << ", " << j << ") = " << (*P_D_A2_Coeffs)(i,j) << endl;
        printf("%.10f\n", (*this->P_D_A2_Coeffs)(i,j));
      #endif
//      }
      fprintf(P_DatabaseFile, "%.10f\n", (*this->P_D_A2_Coeffs)(i,j));
    }
//    if (i == 424){
//      fclose(P_DatabaseFile);
//      return false;
//    }
    fprintf(P_DatabaseFile,"\n");
  }
  fclose(P_DatabaseFile);

  return true;
}

/**
 *
 **/
bool CFits::ReadArray()
{
  int bitpix;
  int anynul, extend, simple;
  int naxis;
  long pcount, gcount;
  long naxes[2];
  long fpixel, nelements;
  int count,Status;
  double *p_Array;
  float nullval;
//  char strbuf[256];

  Status=0;
  fits_open_file(&P_FitsFile, this->P_CS_FileName->Get(), READONLY, &Status);
  fits_read_imghdr(P_FitsFile, 2, &simple , &bitpix, &naxis, naxes,
                   &pcount, &gcount, &extend, &Status);
  if (Status !=0)
  {
    printf("CFits::ReadArray: Error %d opening file %s\n", Status, this->P_CS_FileName->Get());
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::ReadArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::ReadArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  #ifdef __DEBUG_FITS_READARRAY__
    cout << "CFits::ReadArray: FitsFileName <" << this->P_CS_FileName->Get() << "> opened" << endl;
    (*P_OFS_Log) << "CFits::ReadArray: FitsFileName <" << this->P_CS_FileName->Get() << "> opened" << endl;
    cout << "CFits::ReadArray: FitsFileName contains <" << naxis  << "> dimensions" << endl;
    cout << "CFits::ReadArray: FitsFileName contains <" << naxes[1]  << "> rows!!!!!!! and <" << naxes[0] << "> columns!!!!!!!!! naxes = <" << naxes << ">" << endl;
    (*P_OFS_Log) << "CFits::ReadArray: FitsFileName contains <" << naxes[1]  << "> rows!!!!!!! and <" << naxes[0] << "> columns!!!!!!!!! naxes = <" << naxes << ">" << endl;
  #endif

  this->NCols = naxes[0];
  cout << "CFits::ReadArray: this->NCols set to <" << this->NCols << ">" << endl;
  if (naxis == 1){
    this->NRows = 1;
    nelements = naxes[0];
    cout << "CFits::ReadArray: naxis == 1: this->NRows set to <" << this->NRows << ">, nelements = " << nelements << endl;
  }
  else if (naxis == 2){
    this->SetNRows(naxes[1]);
    nelements =  naxes[0] * naxes[1];
    cout << "CFits::ReadArray: naxis == 2: this->NRows set to <" << this->NRows << ">, nelements = " << nelements << endl;
  }
  else{
    cout << "CFits::ReadArray: Fitsfile contains more than 2 dimensions: naxis = " << naxis << " => Returning FALSE" << endl;
    return false;
  }

  #ifdef __DEBUG_FITS_READARRAY__
    cout << "CFits::ReadArray: this->NCols set to <" << this->NCols << "> and this->NRows set to <" << this->NRows << ">, nelements = " << nelements << endl;
    (*P_OFS_Log) << "CFits::ReadArray: this->NCols set to <" << this->NCols << "> and this->NRows set to <" << this->NRows << ">, nelements = " << nelements << endl;
  #endif

  p_Array = (double*)malloc(sizeof(double) * nelements);
  fpixel = 1;
  nullval = 0.;
  fits_read_img(this->P_FitsFile, TDOUBLE, fpixel, nelements,
                &nullval, p_Array, &anynul, &Status);
  if (Status !=0)
  {
    cout << "CFits::ReadArray: Error " << Status << " reading file " << this->P_CS_FileName->Get() << endl;
    (*P_OFS_Log) << "CFits::ReadArray: Error " << Status << " reading file " << this->P_CS_FileName->Get() << endl;
    char* P_ErrMsg = (char*)malloc(sizeof(char) * 255);
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::ReadArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::ReadArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    free(P_ErrMsg);
    return false;
  }
  if (P_D_A2_PixArray != NULL)
    delete P_D_A2_PixArray;
  this->P_D_A2_PixArray = new Array<double,2>(p_Array, shape(this->NRows, this->NCols), duplicateData);
  // --- set all negative pixels to 0
  #ifdef __DEBUG_FITS_READARRAY__
    cout << "CFits::ReadArray: this->NCols = <" << this->NCols << ">, this->NRows = <" << this->NRows << ">, nelements = " << nelements << endl;
    (*P_OFS_Log) << "CFits::ReadArray: this->NCols = <" << this->NCols << ">, this->NRows = <" << this->NRows << ">, nelements = " << nelements << endl;
  #endif
  count = sum(where((*this->P_D_A2_PixArray) < 0., 1, 0));
  #ifdef __DEBUG_FITS_READARRAY__
    cout << "CFits::ReadArray: " << count << " pixels are lower than 0" << endl;
    (*P_OFS_Log) << "CFits::ReadArray: " << count << " pixels are lower than 0" << endl;
  #endif

  free(p_Array);
  //      fits_write_img(ffile, TFLOAT, fpixel, nelements,
  //                     p_Array, &Status);

  //      if (Status !=0)
  //        printf("Error %d in file %s\n", Status, FitsFileName);
  fits_close_file(this->P_FitsFile, &Status);

  #ifdef __DEBUG_FITS_READARRAY__
    cout << "CFits::ReadArray: FitsFileName <" << this->P_CS_FileName->Get() << "> closed" << endl;
  #endif

  if (Status !=0)
  {
    cout << "CFits::ReadArray: Error " << Status << " closing file " << this->P_CS_FileName->Get() << endl;
    (*P_OFS_Log) << "CFits::ReadArray: Error " << Status << " closing file " << this->P_CS_FileName->Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::ReadArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::ReadArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  return true;
}

/**
 *
 **/
bool CFits::ReadErrArray()
{
  int bitpix;
  int anynul, extend, simple;
  int naxis;
  long pcount, gcount;
  long naxes[2];
  long fpixel, nelements;
  int      count,Status;
  double *p_Array;
  float nullval;
//  char strbuf[256];

  Status=0;
  fits_open_file(&P_FitsFile, this->P_CS_ErrFileName->Get(), READONLY, &Status);
  fits_read_imghdr(P_FitsFile, 2, &simple , &bitpix, &naxis, naxes,
                   &pcount, &gcount, &extend, &Status);
  if (Status !=0)
  {
    printf("CFits::ReadErrArray: Error %d opening file %s\n", Status, this->P_CS_ErrFileName->Get());
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::ReadErrArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::ReadErrArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  #ifdef __DEBUG_FITS_READARRAY__
    cout << "CFits::ReadErrArray: FitsErrFileName <" << this->P_CS_ErrFileName->Get() << "> opened" << endl;
    (*P_OFS_Log) << "CFits::ReadErrArray: FitsErrFileName <" << this->P_CS_ErrFileName->Get() << "> opened" << endl;
    cout << "CFits::ReadErrArray: FitsErrFileName contains <" << naxes[1]  << "> rows!!!!!!! and <" << naxes[0] << "> columns!!!!!!!!! naxes = <" << naxes << ">" << endl;
    (*P_OFS_Log) << "CFits::ReadErrArray: FitsErrFileName contains <" << naxes[1]  << "> rows!!!!!!! and <" << naxes[0] << "> columns!!!!!!!!! naxes = <" << naxes << ">" << endl;
  #endif

  if (this->NCols != naxes[0]){
    cout << "CFits::ReadErrArray: ERROR: number of cols in FitsErrFileName = <" << naxes[0]  << "> != this->NCols(=" << this->NCols << ") => returning false" << endl;
    return false;
  }
  if (this->NRows != naxes[1]){
    cout << "CFits::ReadErrArray: ERROR: number of rows in FitsErrFileName = <" << naxes[1]  << "> != this->NRows(=" << this->NRows << ") => returning false" << endl;
    return false;
  }
  nelements =  naxes[0] * naxes[1];

  p_Array = (double*)malloc(sizeof(double) * nelements);
  fpixel = 1;
  nullval = 0.;
  fits_read_img(this->P_FitsFile, TDOUBLE, fpixel, nelements,
                &nullval, p_Array, &anynul, &Status);
  if (Status !=0)
  {
    cout << "CFits::ReadErrArray: Error " << Status << " reading file " << this->P_CS_ErrFileName->Get() << endl;
    (*P_OFS_Log) << "CFits::ReadErrArray: Error " << Status << " reading file " << this->P_CS_ErrFileName->Get() << endl;
    char* P_ErrMsg = (char*)malloc(sizeof(char) * 255);
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::ReadErrArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::ReadErrArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    free(P_ErrMsg);
    return false;
  }
  if (P_D_A2_ErrArray != NULL)
    delete P_D_A2_ErrArray;
  this->P_D_A2_ErrArray = new Array<double,2>(p_Array, shape(this->NRows, this->NCols), duplicateData);
  free(p_Array);
  // --- set all negative pixels to 0

  count = sum(where((*this->P_D_A2_PixArray) < 0., 1, 0));
  #ifdef __DEBUG_FITS_READARRAY__
    cout << "CFits::ReadErrArray: " << count << " pixels are lower than 0" << endl;
    (*P_OFS_Log) << "CFits::ReadErrArray: " << count << " pixels are lower than 0" << endl;
  #endif

  //      fits_write_img(ffile, TFLOAT, fpixel, nelements,
  //                     p_Array, &Status);

  //      if (Status !=0)
  //        printf("Error %d in file %s\n", Status, FitsErrFileName);
  fits_close_file(this->P_FitsFile, &Status);

  #ifdef __DEBUG_FITS_READARRAY__
    cout << "CFits::ReadErrArray: FitsErrFileName <" << this->P_CS_ErrFileName->Get() << "> closed" << endl;
  #endif
    
  if (Status !=0)
  {
    cout << "CFits::ReadErrArray: Error " << Status << " closing file " << this->P_CS_ErrFileName->Get() << endl;
    (*P_OFS_Log) << "CFits::ReadErrArray: Error " << Status << " closing file " << this->P_CS_ErrFileName->Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::ReadErrArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::ReadErrArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  this->ErrorsRead = true;
  return true;
}

/**
 * Task: Writes this->P_D_A2_PixArray to fitsfile
 *       this->P_FitsFile
 **/
  bool CFits::WriteArray() const
{
  return this->WriteFits(this->P_D_A2_PixArray, *(this->P_CS_FileName));
}

/**
 * Task: Writes this->P_D_A2_ErrArray to fitsfile
 *       this->P_FitsFile
 **/
  bool CFits::WriteErrArray() const
{
  return this->WriteFits(this->P_D_A2_ErrArray, *(this->P_CS_FileName));
}

/**
 * Task: Writes P_D_A2_Image_In to fitsfile
 *       CS_FileName_In
 **/
bool CFits::WriteFits(const Array<double,1>* P_D_A1_Image_In, const CString CS_FileName_In) const
{
  Array<double, 2> D_A2_Image(P_D_A1_Image_In->size(), 1);
  D_A2_Image(Range::all(), 0) = (*P_D_A1_Image_In);
  return this->WriteFits(&D_A2_Image, CS_FileName_In);
}

bool CFits::WriteFits(const Array<double,2>* P_D_A2_Image_In, const CString CS_FileName_In) const
{
  #ifdef __DEBUG_FITS_WRITEFITS__
    (*P_OFS_Log) << "CFits::WriteFits: started: CS_FileName_In = " << CS_FileName_In << endl;
  #endif
  fitsfile *P_Fits;
  int Status;
  long fpixel, nelements;
  float nullval;
  void *p_void;

  Status=0;
  remove(CS_FileName_In.Get());
  fits_create_file(&P_Fits, CS_FileName_In.Get(), &Status);//{
  if (Status !=0)
  {
    cout << "CFits::WriteFits: Error <" << Status << "> while creating file " << CS_FileName_In.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteFits: Error <" << Status << "> while creating file " << CS_FileName_In.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }

  ///  fits_write_img(this->P_FitsFile, TDOUBLE, fpixel, nelements,
  ///    p_void, &Status);
  long naxes[2] = {P_D_A2_Image_In->cols(), P_D_A2_Image_In->rows()};
  int naxis = 2;
  fits_create_img(P_Fits, DOUBLE_IMG, naxis, naxes, &Status);
  if (Status !=0)
  {
    cout << "CFits::WriteFits: Error <" << Status << "> while creating image " << CS_FileName_In.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteFits: Error <" << Status << "> while creating image " << CS_FileName_In.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  #ifdef __DEBUG_FITS_WRITEFITS__
    cout << "CFits::WriteFits: size of P_D_A2_Image_In = <" << P_D_A2_Image_In->rows() << "x" << P_D_A2_Image_In->cols() << ">" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: FitsFileName <" << CS_FileName_In.Get() << "> opened" << endl;
    cout << "CFits::WriteFits: size of P_D_A2_Image_In = <" << P_D_A2_Image_In->rows() << "x" << P_D_A2_Image_In->cols() << ">" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: size of P_D_A2_Image_In = <" << P_D_A2_Image_In->rows() << "x" << P_D_A2_Image_In->cols() << ">" << endl;
  #endif

  fpixel = 1;
  nullval = 0.;
  nelements = P_D_A2_Image_In->cols() * P_D_A2_Image_In->rows();

  p_void = (const_cast<Array<double, 2>*>(P_D_A2_Image_In))->data();// = new Array<double,2>(p_Array, shape(naxes[0], naxes[1]),
  #ifdef __DEBUG_FITS_WRITEFITS__
    cout << "CFits::WriteFits: p_void = <" << (*((double*)p_void)) << ">" << endl;
  #endif

  fits_write_img(P_Fits, TDOUBLE, fpixel, nelements, p_void, &Status);

  if (Status !=0)
  {
    cout << "CFits::WriteFits: Error " << Status << " while writing file " << CS_FileName_In.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteFits: Error " << Status << " while writing file " << CS_FileName_In.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }

  fits_close_file(P_Fits, &Status);
  cout << "CFits::WriteFits: FitsFileName <" << CS_FileName_In.Get() << "> closed" << endl;
  #ifdef __DEBUG_FITS_WRITEFITS__
    (*P_OFS_Log) << "CFits::WriteFits: FitsFileName <" << CS_FileName_In.Get() << "> closed" << endl;
  #endif
  if (Status !=0)
  {
    cout << "CFits::WriteFits: Error " << Status << " while closing file " << CS_FileName_In.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteFits: Error " << Status << " while closing file " << CS_FileName_In.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  return true;
}

/**
 * Task: Writes P_D_A2_Image_In to fitsfile
 *       CS_FileName_In
 **/
bool CFits::WriteFits(const Array<int,1>* P_I_A1_Image_In, const CString CS_FileName_In) const
{
  Array<int, 2> I_A2_Image(P_I_A1_Image_In->size(), 1);
  I_A2_Image(Range::all(), 0) = (*P_I_A1_Image_In);
  return this->WriteFits(&I_A2_Image, CS_FileName_In);
}

bool CFits::WriteFits(const Array<int,2>* P_I_A2_Image_In, const CString CS_FileName_In) const
{
  #ifdef __DEBUG_FITS_WRITEFITS__
    (*P_OFS_Log) << "CFits::WriteFits: started: CS_FileName_In = " << CS_FileName_In << endl;
  #endif
  fitsfile *P_Fits;
  int Status;
  long fpixel, nelements;
  float nullval;
  void *p_void;

  Status=0;
  remove(CS_FileName_In.Get());
  fits_create_file(&P_Fits, CS_FileName_In.Get(), &Status);//{

  if (Status !=0)
  {
    cout << "CFits::WriteFits: Error <" << Status << "> while creating file " << CS_FileName_In.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteFits: Error <" << Status << "> while creating file " << CS_FileName_In.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }

  ///  fits_write_img(this->P_FitsFile, TDOUBLE, fpixel, nelements,
  ///    p_void, &Status);
  long naxes[2] = {P_I_A2_Image_In->cols(), P_I_A2_Image_In->rows()};
  int naxis = 2;
  fits_create_img(P_Fits, SHORT_IMG, naxis, naxes, &Status);
  if (Status !=0)
  {
    cout << "CFits::WriteFits: Error <" << Status << "> while creating image " << CS_FileName_In.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteFits: Error <" << Status << "> while creating image " << CS_FileName_In.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  #ifdef __DEBUG_FITS_WRITEFITS__
    cout << "CFits::WriteFits: size of P_I_A2_Image_In = <" << P_I_A2_Image_In->rows() << "x" << P_I_A2_Image_In->cols() << ">" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: FitsFileName <" << CS_FileName_In.Get() << "> opened" << endl;
    cout << "CFits::WriteFits: size of P_I_A2_Image_In = <" << P_I_A2_Image_In->rows() << "x" << P_I_A2_Image_In->cols() << ">" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: size of P_I_A2_Image_In = <" << P_I_A2_Image_In->rows() << "x" << P_I_A2_Image_In->cols() << ">" << endl;
  #endif

  fpixel = 1;
  nullval = 0.;
  nelements = P_I_A2_Image_In->cols() * P_I_A2_Image_In->rows();

  p_void = (const_cast<Array<int, 2>*>(P_I_A2_Image_In))->data();// = new Array<double,2>(p_Array, shape(naxes[0], naxes[1]),
  #ifdef __DEBUG_FITS_READ__
    cout << "CFits::WriteFits: p_void = <" << (*((double*)p_void)) << ">" << endl;
  #endif

  fits_write_img(P_Fits, TINT, fpixel, nelements, p_void, &Status);

  if (Status !=0)
  {
    cout << "CFits::WriteFits: Error " << Status << " while writing file " << CS_FileName_In.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteFits: Error " << Status << " while writing file " << CS_FileName_In.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }

  fits_close_file(P_Fits, &Status);
  cout << "CFits::WriteFits: FitsFileName <" << CS_FileName_In.Get() << "> closed" << endl;
  #ifdef __DEBUG_FITS_WRITEFITS__
    (*P_OFS_Log) << "CFits::WriteFits: FitsFileName <" << CS_FileName_In.Get() << "> closed" << endl;
  #endif
  if (Status !=0)
  {
    cout << "CFits::WriteFits: Error " << Status << " while closing file " << CS_FileName_In.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteFits: Error " << Status << " while closing file " << CS_FileName_In.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteFits: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  return true;
}

bool CFits::WriteApHead(CString CS_FileName_Out) const{
  ofstream *P_ApHead = new ofstream(CS_FileName_Out.Get());
  CString CS_Line;
  CString *P_CS_Temp;
  *P_ApHead << "BANDID1 = 'spectrum - background none, weights variance, clean yes'" << endl;
  for (int m=0; m<this->I_NApertures; m++){
    CS_Line.Set("APNUM");
    P_CS_Temp = CS_Line.IToA(m+1);
    CS_Line.Add(*P_CS_Temp);
    CS_Line.Add(CString(" = '"));
    CS_Line.Add(*P_CS_Temp);
    CS_Line.Add(CString(" "));
    CS_Line.Add(*P_CS_Temp);
    delete(P_CS_Temp);
    CS_Line.Add(CString(" "));
    P_CS_Temp = CS_Line.DToA((*this->P_D_A1_XCenter)(m) + (*this->P_D_A1_XLow)(m),2);
    CS_Line.Add(*P_CS_Temp);
    CS_Line.Add(CString(" "));
    delete(P_CS_Temp);
    P_CS_Temp = CS_Line.DToA((*this->P_D_A1_XCenter)(m) + (*this->P_D_A1_XHigh)(m),2);
    CS_Line.Add(*P_CS_Temp);
    delete(P_CS_Temp);
    CS_Line.Add(CString("'"));

    *P_ApHead << CS_Line << endl;
  }
  delete(P_ApHead);
  return true;
}

/**
 *
 **/
bool CFits::Access() const
{
  return this->FitsAccess(*this->P_CS_FileName);
}

/**
 *
 **/
bool CFits::FitsAccess(const CString &fn) const
{
  fitsfile *ffile;
  int      Status;
  Status=0;
  fits_open_file(&ffile, fn.Get(), READONLY, &Status);
  if (Status !=0)
  {
    cout << "CFits::Access: Error " << Status << " in file " << fn.Get() << endl;
    (*P_OFS_Log) << "CFits::Access: Error " << Status << " in file " << fn.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::Access: <"<< P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Access: <"<< P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  fits_close_file(ffile, &Status);
  if (Status !=0)
  {
    cout << "CFits::Access: Error " << Status << " in file " << fn.Get() << endl;
    (*P_OFS_Log) << "CFits::Access: Error " << Status << " in file " << fn.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(Status, P_ErrMsg);
    cout << "CFits::Access: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::Access: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }
  return true;
}

/**
 *
 **/
bool CFits::FileAccess(const CString &fn) const
{
  CString CS("");
  return CS.FileAccess(fn);
/*  FILE *ffile;

  ffile = fopen(fn.Get(), "r");
  if (ffile == NULL)
  {
    cout << "CFits::FileAccess: Failed to open file fname (" << fn.Get() << ")" << endl;
    (*P_OFS_Log) << "CFits::FileAccess: Failed to open file fname (" << fn.Get() << ")" << endl;
    return false;
  }
  fclose(ffile);
  return true;*/
}

/**
 *
 **/
bool CFits::AccessDatabaseFile() const
{
  FILE *file;
  file = fopen(this->P_CS_DatabaseFileName->Get(), "r");
  if (file == NULL)
  {
    cout << "CFits.AccessDatabaseFile: Failed to open file this->DatabaseFileName (=<" << P_CS_DatabaseFileName->Get() << ">)" << endl;
    (*P_OFS_Log) << "CFits.AccessDatabaseFile: Failed to open file this->DatabaseFileName (=<" << P_CS_DatabaseFileName->Get() << ">)" << endl;
    return false;
  }
  fclose(file);
  return true;
}

/**
 Where
 **
Vector<int>* CFits::Where(const Vector<int> &vec, const _bz_VecExpr<_bz_VecExprConstant<int> > &expr) const
{
  int count = 0;//sum(where(expr, 0, 1));
  cout << "CFits::Where: vec(=" << vec << ") contains " << count << " Elements lt 0" << endl;
  cout << "CFits::Where: vec(=" << vec << ") contains " << count << " Elements lt 0" << endl;
  return NULL;
}

/**
  Methods from Piskunov
 **/
/**
  HamFlat
 **/
// bool CFits::HamFlat(double RdNoise, double Dark, double Gain)
// {
/*  pro hamflat, im, head, orders, blzcof, COLRANGE=colrange $
               , OSAMPLE=osample, FXWD=fxwd, SF_SMOOTH=sf_smooth $
               , SP_SMOOTH=sp_smooth, SWATH_WIDTH=swath_width, MASK=mask $
               , POLY=pol, PLOT=iplot, ORDER_WIDTH=order_width $
               , NOSCATTER=noscatter
;Reads in a raw CCD image, fixes chronically bad pixels, locates the order
;  positions, fits smooth curves to the counts in the image, divides by fit
;  to normalize image, saves result.
;Inputs:
    ; setfile (string) root of input filenames containing information common to
    ;   all observations made with a particular spectrograph setting. A complete
    ;   filename will be constructed by appending a standardized file extension.
;   The following file is expected to exist:
    ;   * setfile.ord - default order location coefficients (from HAMDORD)
;   The following files will be created by HAMFLAT:
    ;   * setfile.flt - normalized flat field image (assoc. var.).
    ;   * setfile.blz - blaze function polynomial fit coefficients (WDSKed).
; obsfile (string) root of input/output filenames containing information
;   specific to a given observation. A complete filename will be constructed
;   by appending a standardized file extension.
;   One of the following files is expected to exist (depending on ham_image):
;   * obsfile.fits - image in fits format (ham_image=0)
;   * obsfile.dsk - image in wdsk/rdsk format (ham_image=1)
;   The following file may be created by HAMFLAT:
;   * obsfile.ord - order location coefficients
;Outputs:
; im (array (ncol,nrow)) normalized version of the image in input OBSFILE.
;   Copy of im is written in setfile.flt.
;Notes:
; Previous version of hamflat, which fit along individual arcs, has been
;  renamed hamflat_arc.pro. The routines FITARCS, EXAFC, SMENDS, QUADEX,
;  NORMFLAT, and COLFIT are no longer used. MKSLITF is now used here, as
;  well as for optimal extraction of spectra.
;20-Oct-89 JAV  Create.
;18-Apr-92 JAV  Updated global variable list/interpretations. Fixed fits format
;        logic error. Implemented trace level. Fixed default order
;        location logic. Changed file extensions to lower case.
;29-Apr-92 JAV  Now clip baseline column of FITS images. Moved normalized flat
;        bad pixel logic from flatim.pro to here.
;06-Dec-94 CMJ  RDFITS call now has ClipBase set to 32 for McD Cass Echelle
;15-Dec=94 JAV  Value of clipbase now depends on ham_id. Currently 0, 1, or 32
;                for KPNO, Lick/Keck, and McDonald, respectively. Added logic
;                to handle KPNO specific requirements (clipbase, transpose).
;        Add bias frame subtraction for KPNO (ham_id=40). Extracted
;        image preprocessing to getimage.pro.
;03-Jun-99 JAV  Always pass biasfile='', even for KPNO flats. Modify offset
;        and trim parameters for KPNO flats, which are assumed to be
;        pretrimmed.
;06-Jun-99 JAV  Changed normalization algorithm from fits along individual
;        arcs to division by the slit function. Most of the changes
;          TestArray = testfits->MatrixATimesB(*P_ProductArr, *P_TempArray);
#ifdef _DEBUG_TESTAPP_
cout << "MTestApp::TestCFitsReformMult: TestArray = " << TestArray << endl;
#endif
t11 = true;
for (int m = 0; m < P_ProductArr->rows(); m++)
{
  for (int n = 0; n < P_ProductArr->cols(); n++)
  {
    if (m == n)
    {
      if (abs(TestArray(m, n) - 1.0) > 0.00001)
        t11 = false;
    }
    else
    {
      if (abs(TestArray(m, n)) > 0.00001)
        t11 = false;
    }
  }
}
if (t11)
  cout << "MTestApp::TestCFitsReformMult:                    t11(InvertGaussJ(P_ProductArr=" << *P_ProductArr << ", P_Array=" << *P_Array << ") = \"TRUE\" (expected) " << endl;
else
  cout << "MTestApp::TestCFitsReformMult:                    t11(InvertGaussJ(P_ProductArr=" << *P_ProductArr << ", P_Array=" << *P_Array << ") = \"FALSE\" (UNEXPECTED)" << endl;
olve calling different routines (sfnorm, rather than
;        exorc, exafc, fitarcs, and normflat).
if n_params() lt 3 then begin
  print,'syntax: hamflat,im,head,orders,blzcoef[,COLRANGE=colrange[,/PLOT]]'
  retall
  end*/
/** Force pixels to be positive to prevent negative or infinite flattened image
    pixels.**/
/*badp=where(im le 0,nbadp)             ;find pixels le 0
if nbadp gt 0 then begin              ;true: fix pixels
      im(badp)=1.0                    ;and fix them
      print,'HAMFLAT:' + strcompress(nbadp) $
                       + ' zero or negative pixels set to one.'
endif
*/
//   if (!this->SetZerosToUnity())
//   {
// // #ifdef __DEBUG_FITS_READ_SLITFUNC__
//     cout << "CFits::HamFlat: CombinedFlat.SetZerosToUnity() returned FALSE => Returning FALSE!" << endl;
// (*P_OFS_Log) << "CFits::HamFlat: CombinedFlat.SetZerosToUnity() returned FALSE => Returning FALSE!" << endl;
// // #endif
//     return false;
//   }

/** Extract frame information from the header**/
/*readn = sxpar(head, 'E_READN')
dark  = sxpar(head, 'E_BACKG')
gain  = sxpar(head, 'E_GAIN')
  */

/** Use slit functions to normalize flat (and fetch blaze function).**/
/*sfnorm, im, orders, blzcof=blzcof, dark=dark $
      , readn=readn, gain=gain, COLRANGE=colrange $
      , OSAMPLE=osample, FXWD=fxwd, SF_SMOOTH=sf_smooth $
      , SP_SMOOTH=sp_smooth, SWATH_WIDTH=swath_width, MASK=mask $
      , PLOT=iplot, POLY=pol, ORDER_WIDTH=order_width $
      , NOSCATTER=noscatter
*/
//  this->SFNorm(Orders, BlzCof, Dark, RdNoise, Gain, ColRange, OSample, FXWD, SF_Smooth, SP_Smooth, Swath_Width, Mask, IPlot, Pol, Order_Lower, Order_Upper, NoScatter)

/** Force positive pixels in normalized flat. **/
/*iwhr = where(im le 0, nwhr)                           ;look for bad pixels
if nwhr gt 0 then begin                               ;true: bad pixels exist
      print,'HAMFLAT: ' + strtrim(string(nwhr),2) $
                        + ' bad pixels in normalized flat set to unity.'
      im(iwhr) = 1.0                                      ;adjust bad pixels
  endif*/

//   cout << "CFits::HamFlat: Flat field image processed - returning to caller." << endl;
//   return true;

// }

/**
  HamOpt
 **/
// bool CFits::HamOpt(double RdNoise, double Dark, double Gain) const
// {
/*
  pro HamOpt, im, back, ycen, yslitf, slitf, bincen, s, u,  $
  ccd_gain, ccd_dark, ccd_rdnoise, $
  x_left_lim=cole0, x_right_lim=cole1
  ;
  ;  Optimal extraction routine for the Hamilton reduction package.
;  Inputs:
  ;     im - The current image being reduced.
  ;     back - Background array for the current *order* being extracted.
  ;            Background is stored in (ncol,2) array where back(*,0) is the
  ;            value in the center of the order and bacl(*,1) is the slop
  ;            per row.
  ;     ycen - A vector giving the center of the order for each column.
  ;     yslitf - Vector giving the oversampled relative pixel scale for slitf.
  ;     slitf - An array giving the oversampled slit function at a number of
  ;               swaths in the image.
  ;     bincen - The column of the bin centers for the slit functions.
;  Outputs:
  ;     s - The optimally extracted spectrum.
  ;     u - The uncertainty in s.
  ;
  ; 31-Mar-1998  CMJ, JAV  Written
  ; 26-Jan-2000  NP, removed common ham_aux, replaced with data from
  ;              inst_setup structure available in ham.common
  ;  9-Oct-2000  NP, added processing of 2D background
  ;

  if n_params() lt 11 then begin
  print,'Syntax is: HamOpt,im,back,ycen,yslitf,slitf,bincen,s,u'
  retall
  endif

  ncol = (size(im))(1)                          ;get number of columns in image
  nrow = (size(im))(2)                          ;get number of rows in image
  nbin = n_elements(bincen)         ;get number of bins
  nysf = n_elements(yslitf)         ;size of oversampled slitf
  if(not keyword_set(cole0)) then cole0 = 0      ;first column to extract
  if(not keyword_set(cole1)) then cole1 = ncol-1 ;last column to extract
  ncole = cole1 - cole0 +1          ;number of columns to extract
  s = fltarr(ncole)                                 ;init spectrum
  u = fltarr(ncole)                                 ;init uncertainty vector

  ; Linearly interpolate slitf onto columns.
  bincol = -0.5+findgen(ncole)/(ncole-1.)*nbin + cole0 ;column number in bin centers
  sf = interpolate(slitf, findgen(nysf) $
  , bincol, /grid)        ;slit function at each column
  osamp = (nysf-1.)/(yslitf(nysf-1)-yslitf(0))  ;calculate oversampling (pix)

  ; Now loop through columns and optimally extract spectra.
  ysfmin = min(yslitf, max=ysfmax)
  pbg = sqrt(ccd_dark + ccd_rdnoise^2.)
  for i = cole0, cole1 do begin
  ibeg = ceil(ycen(i)+ysfmin) > 0
  iend = floor(ycen(i)+ysfmax) < (nrow - 1)
  bgg = back(i,0) + back(i,1)*(findgen(iend - ibeg + 1) + ysfmin)
  ;    data = reform(im(i, ibeg:iend) - back(i))
  data = reform(im(i, ibeg:iend)) - bgg
  idata = findgen(iend - ibeg + 1) + ibeg - ycen(i)
  modl = interpolate(sf(*,i-cole0), (idata-ysfmin)*osamp)
  hamopt_c, data, modl, ccd_gain, pbg, int, sint, tot, stot
  s(i-cole0) = int
  u(i-cole0) = sint
  endfor
  end
*/
//   return false;
// }
/**
 SetZerosToUnity()
 **/
bool CFits::SetZerosToUnity()
{
  int count = 0;
  if (this->P_D_A2_PixArray == NULL)
  {
    cout << "CFits::SetZerosToUnity: this->P_D_A2_PixArray == NULL => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetZerosToUnity: this->P_D_A2_PixArray == NULL => Returning FALSE" << endl;
    return false;
  }
  if (!this->ClassInvariant())
  {
    cout << "CFits::SetZerosToUnity: this->ClassInvariant retuned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::SetZerosToUnity: this->ClassInvariant retuned FALSE => Returning FALSE" << endl;
    return false;
  }
  Array<int, 2> *P_IntArr = new Array<int, 2>(this->NRows, this->NCols);
  (*P_IntArr) = where(fabs(*(this->P_D_A2_PixArray)) < 0.00000000000000001, 1., 0.);
  for (int i = 0; i < this->NRows; i++)
  {
    for (int j = 0; j < this->NCols; j++)
    {
      if ((*P_IntArr)(i, j) == 1)
      {
        (*(this->P_D_A2_PixArray))(i, j) = 1.;
        count++;
      }
    }
  }
#ifdef __DEBUG_FITS__
  cout << "CFits::SetZerosToUnity: this->PixArray: " << count << " pixels set to 1. => returning TRUE" << endl;
#endif
  delete(P_IntArr);
  return true;
}

/**
 SFNorm
 Normalizes an echelle image of a flat field lamp using slit functions
 **/
// bool CFits::SFNorm() const
// {
/*  pro sfnorm, im, orc, blzcof=blazecurve, dark=dark, readn=readn $
              , gain=gain, COLRANGE=colrange, OSAMPLE=osample $
              , SF_SMOOTH=sf_smooth, SP_SMOOTH=sp_smooth, SWATH_WIDTH=swath_width $
              , MASK=mask, POLY=pol, PLOT=iplot, FXWD=fxwd $
              , ORDER_WIDTH=order_width, NOSCATTER=noscatter

;Use slit functions to normalize an echelle image of a flat field lamp.
;Inputs:
; im (array(ncol,nrow)) image from which orc and back were determined and
;   from which spectrum is to be extracted.
; orc (array(orcdeg,nord)) polynomial coefficients (from FORDS) that describe
;   the location of complete orders on the image.
; dxw float scalar, fractional width of the order to be normalized
;
;Outputs:
; blzcof (array(blzdeg,nord)) coefficients of (perhaps broken) polynomial
;   fit to extracted spectrum of flat lamp.
;Notes:
; Various diagnostic plots can be enabled by changing "if 0" to "if 1" below.
;History:
;05-Jun-1999 JAV  Adapted from getspec.pro
;26-Jan-2000 NP, removed common ham_aux, replaced with data from
;           inst_setup structure available in ham.common
;09-Apr-2001 NP, added parameters COLRANGE to handle partial orders,
;            OSAMPLE to control oversampling in MKSLITF, SWATH_WIDTH -
;            swath width used to determine the slit function in MKSLITF
;            SF_SMOOTH - to control the smoothness of the slit function
;            in MKSLITF. Also added the logic to handle MASK of bad pixels
;            The mask is supposed to have on ly two values: 1 for good and
;            0 for bad pixels. The flat field in the masked pixels is set to
;            1.

if n_params() lt 2 then begin
  print,'syntax: sfnorm,im,orc[,blzcof=blaze[,dark=dark[,readn=readn'
  print,'             [,gain=gain[,COLRANGE=colrange[,/PLOT]]]]]]'
  return
end

;Internal parameters.
nloop = 40                              ;number of rejection loops
bsiz = 0.001                            ;binsize for sigma histogram

;Define useful quantities.
sz = size(im)
ncol = sz(1)                            ;number of columns in image
nrow = sz(2)                            ;number of rows in image
sz = size(orc)
ncoef = sz(1)                           ;number of polynomial coefficients
if(sz(0) gt 1) then nord =  sz(2) $     ;number of full orders in orc
else                nord = 1

;Default order range span the whole image
if(not keyword_set(colrange)) then begin
  colrange=intarr(2,nord)
  colrange(1,*)=ncol-1
endif

;Default normalization width is the whole order
if(not keyword_set(fxwd))                  then exwd = replicate(0.5,2,nord) $
else if(min(fxwd) gt 0 and max(fxwd) le 1) then exwd = fxwd

;Construct xwd if only one walue is given
if(n_elements(exwd) eq 1) then begin
  exwd = replicate(exwd*0.5,2,nord)                   ;extraction widths
endif

;Initializations.
ix = findgen(ncol)                      ;column indicies
jx = lindgen(ncol)                      ;column indicies (as long integer)
orcend = dblarr(ncoef,nord+2)           ;init extended orcs
blazecurve = dblarr(ncol, nord)         ; optimally filtered blaze function

;Getarc needs order location coefficients (orc) on both sides of arc swath to
;  be extracted. In order to extract the lowest and highest orders specified
;  in orc, we need to extend orc one extra order on each end. We shall do so
;  by linearly extrapolating the last two orc on each end.
;Extend orc on the low end. Check that requested swath lies on image.

noff = 0
if(nord gt 1) then begin
  orclo = 2*orc(*,0) - orc(*,1)         ;extrapolate orc
  y = poly(ix, 0.5*(orclo+orc(*,0)))    ;low edge of arc
;    yoff = where(y lt 0,noff)             ;pixels off low edge
endif else begin
  orclo = [2,replicate(0.d0,n_elements(orc)-1)]
endelse

;Check whether extraction is likely to result in invalid indexing of im.
if noff gt 0 then begin                 ;check if on image
  print,'GETSPEC: Top order off image in columns [' $
        + strtrim(string(yoff(0)),2) + ',' $
        + strtrim(string(yoff(noff-1)),2) + '].'
endif

;Extend orc on the high end. Check that requested swath lies on image.

noff = 0
if(nord gt 1) then begin
  orchi = 2*orc(*,nord-1) - orc(*,nord-2)  ;extrapolate orc
  y = poly(ix, 0.5*(orchi+orc(*,nord-1)))  ;high edge of arc
;    yoff = where(y gt nrow-1,noff)          ;pixels off high edge
endif else begin
  orchi = [(size(im))(2)-2,replicate(0.d0,n_elements(orc)-1)]
endelse

;Check whether extraction is likely to result in invalid indexing of im.
if noff gt 0 then begin
  print,'GETSPEC: Bottom order off image in columns [' $
       + strtrim(string(yoff(0)),2) + ',' $
       + strtrim(string(yoff(noff-1)),2) + '].'
endif

;Define an order set (orcend) extended one extra order on either end.
for i = 1,nord do orcend(*,i) = orc(*,i-1)
orcend(*,0) = orclo
orcend(*,nord+1) = orchi

;Initializations.
x = dindgen(ncol) / (ncol - 1)        ;normalized abscissa
yprev = replicate(-1, ncol)           ;last column normalized

;Loop through the orders, fitting a slit function, optimally extracting
; the spectrum, fitting the extracted spectrum, and then using the fit
; and slit function to normalize the original flat. Regions not covered
; by the slit function are set to exactly 1.0.

if(not keyword_set(sf_smooth)) then sf_smooth=8.  ;default slit function smoothness

; Fit the scattered light. The approximation is returned in 2D array bg for each
; inter-order troff

;Status report.
print,'SFNORM: using mkscatter to evaluate the model for background.'
if(keyword_set(pol)) then begin
  print,'SFNORM: using '+strtirm(pol,2 )+'-order polynomial to fit ' $
       + 'the background.'
endif
if(keyword_set(noscatter)) then begin
  bg=dblarr(ncol,nord+1)
  ybg=fltarr(ncol,nord+1)
  xx=dindgen(ncol)
  for onum=1,nord-1 do begin
    ybg(*,onum)=(poly(xx,orc(*,onum-1))+poly(xx,orc(*,onum)))*0.5
  endfor
  ybg(*,   0)=2.*poly(xx,orc(*,     0))-ybg(*,     1)
  ybg(*,nord)=2.*poly(xx,orc(*,nord-1))-ybg(*,nord-1)
endif else begin
  mkscatter, im, orc, bg, ybg, colrange=colrange, LAMBDA_SF=sf_smooth $
           , SWATH_WIDTH=swath_width, OSAMPLE=osample, MASK=mask $
           , GAIN=gain, READN=readn, DATA=bg_data, POLY=pol $
           , ORDER_WIDTH=order_width, LAMBDA_sp=400.
endelse

;Status report.
print,'SFNORM: using slit functions to normalize flat.'

ofirst = 1                                        ;starting order
for onum=ofirst,nord do begin                     ;loop thru orders
  ncole = colrange(1,onum-1)-colrange(0,onum-1)+1 ;number of columns to extract
  cole0 = colrange(0,onum-1)                      ;first column to extract
  cole1 = colrange(1,onum-1)                      ;last column to extract

;Background must be subtracted for slit function logic to work but kept
;as part of the FF signal during normalization

  scatter_below  =  bg(*,onum-1)
  yscatter_below = ybg(*,onum-1)
  scatter_above  =  bg(*,onum)
  yscatter_above = ybg(*,onum)

  if nord le 10 then begin
    print, 'SFNORM: processing relative order ' $
          + strtrim(onum, 2) + '  of ' + strtrim(nord,2)
  endif else begin
    if (onum-1) mod 5 eq 0 then begin
      if(onum lt nord) then $
        print, 'SFNORM: processing relative orders ' $
              + strtrim(onum, 2) + '-' $
              + strtrim((nord)<(onum+4), 2) + '  of ' + strtrim(nord,2) $
      else $
        print, 'SFNORM: processing relative order ' $
              + strtrim(onum, 2) + ' (the last one)'
    endif
  endelse

;Use order fits to define range of pixels to consider.
  ixx = ix(cole0:cole1)
  ycen = poly(ix, orcend(*,onum))                                ;row at order center
  ymin = 0.5 * (ycen(cole0:cole1) + poly(ixx, orcend(*,onum-1))) ;trough below
  ymin = ceil(ymin)
  if min(ymin) lt 1 then ymin = ymin - min(ymin) + 1             ;helps the bottom order
  ymax = 0.5 * (ycen(cole0:cole1) + poly(ixx, orcend(*,onum+1))) ;trough above
  ymax = floor(ymax)
  if max(ymax) ge nrow-1 then ymax = ymax - max(ymax) + nrow - 2 ;helps the top order

;Define a fixed height area containing one spectral order
;    if(onum eq ofirst) then $
;      y_lower_lim = fix(min(ycen(cole0:cole1)-ymin)) $             ;Pixels below center line
;    else $
;      y_lower_lim = fix(min(ycen(cole0:cole1)-yprev(cole0:cole1))) + 1
  y_lower_lim = fix(min(ycen(cole0:cole1)-ymin))                 ;Pixels below center line
  y_upper_lim = fix(min(ymax-ycen(cole0:cole1)))                 ;Pixels above center line
  yc = fix(ycen)                                                 ;Integer pixel offsets
;for the center line

;Overlay order cross-cut profiles with subpixel shifts predicted from order
; location fits. Smooth the resulting oversampled slit function. For all but
; the first order, temporarily replace the original data values near the
; normalization boundary between modified and unmodified pixels. This is
; necessary because slit function construction extends back into parts of
; the image that have already been modified. As soon as the slit function
; has been calculated, restore the normalized data values.
  if onum gt ofirst then begin
    saven = im(isave)                               ;save normalized values
    im(isave) = saver                               ;restore raw values
  endif

;
;if max(ymax) lt nrow then begin ;logic to handle orders that stray off edge
;

  mkslitf, im, scatter_below, yscatter_below $
         , scatter_above, yscatter_above $
         , ycen, y_lower_lim, y_upper_lim $
         , yslitf, slitf, binc, onum $
         , x_left_lim=cole0, x_right_lim=cole1, PLOT=iplot $
         , LAMBDA_SF=sf_smooth, LAMBDA_SP=sp_smooth, blz=blz $
         , OSAMPLE=osample $
         , SWATH_WIDTH=swath_width, MASK=mask, GAIN=gain, READN=readn

  if onum gt ofirst then im(isave) = saven          ;normalized values again
  nbinc = n_elements(binc)                          ;number of slitf bins
  if keyword_set(iplot) then begin                  ;plot diagnostic
    plot, yslitf, slitf(*,0)>slitf(*,nbinc-1), /xsty, /yno
    for i=1, nbinc-1 do begin                       ;loop thru other bins
      oplot, yslitf, slitf(*,i), co=i+1             ;plot local slit funct
    endfor
;      junk = get_kbrd(1)
  endif

;Trim end pixels of slitf, since they are sometimes bad.
  ysfmin = min(yslitf, max=ysfmax)                  ;range of yslitf
  nysf = n_elements(yslitf)                         ;number of subpixels
  dysf = (ysfmax - ysfmin) / (nysf - 1)             ;subpixel size
  ntrim = ceil(1.0 / dysf)                          ;subpixels to trim
  yslitf = yslitf(ntrim:nysf-ntrim-1)               ;trim subpixel indexes
  slitf = slitf(ntrim:nysf-ntrim-1,*)               ;trim slit functions
  ysfmin = min(yslitf, max=ysfmax)                  ;range of yslitf
  nysf = n_elements(yslitf)                         ;number of subpixels

;Optimally extract the current order.
;Note that hamopt return trimmed arrays s(ncole), u(ncole) etc.

  s=blz(cole0:cole1)

;Fit the extracted spectrum with a (possibly broken) polynomial, iteratively
; rejecting any anomolous features in the spectrum.
  fit=median(s,5)                                    ;Reject bad columns
;    fit=middle(fit,8,ITER=nloop,EPS=readn/gain,/poly)  ;Use smoothed blaze
  fit=middle(fit,3.d0,EPS=readn/gain,ITER=nloop)     ;Use smoothed blaze
;    fit = s                                           ;Use the spectrum from slit_func
;Diagnostic plot of fit to extracted flat field order.
  if keyword_set(iplot) then begin
    plot, s, /yno, xsty=3, ysty=3, chars=1.4 $
        , xtit='Column Number' $
        , tit='Order '+strtrim(onum, 2)
    oplot, fit, co=3
;      empty                                   ;flush graphics buffer
;      junk = get_kbrd(1)
  endif

  blazecurve(cole0:cole1,onum-1) = fit       ;Save the fit

;stop

;Extract unnormalized data values near edge of new normalization boundary.
;These values will be needed temporarily, when the slit function for the
; next order is computed. Otherwise, the slit function for the next order
; will include already normalized pixels, which causes the low end of the
; slit function to be near zero.
  ysave = fix(ycen) + y_upper_lim                   ;last pixel to modify
  isave = [ jx + ncol * (ysave-2) $                 ;Indices of a few rows
          , jx + ncol * (ysave-1) $                 ;is a precaution against
          , jx + ncol *  ysave    ]                 ;double normalization
  saver = im(isave)                                 ;save raw data

;Use slit function and fit to order to normalize flat.
  if(cole0 gt 0) then begin                         ;skip the beginning of the order
    for icol=0,cole0-1 do begin                     ;loop thru image columns
      if(onum eq ofirst) then y0 = 0 $              ;starting row to change
      else                    y0 = ((yprev(icol)+1)>0)<(nrow-1)
      if(onum eq nord) then   y1 = nrow-1 $         ;ending row to change
      else                    y1 = ((yc(icol) + y_upper_lim)<(nrow-1))>0
      im(icol,y0:y1) = 1.0
    endfor
  endif

  for icol=cole0,cole1 do begin                     ;loop thru image columns
    if(exwd(0,onum-1) gt 1.5) then begin            ;starting row to change
      y0 = yc(icol) - exwd(0,onum-1)                ;exwd is in pixels
    endif else begin                                ;or a fraction
      y0 = yc(icol) - round(y_lower_lim*exwd(0,onum-1))
    endelse
    if(exwd(1,onum-1) gt 1.5) then begin            ;ending row to change
      y1 = yc(icol) + exwd(1,onum-1)               ;exwd is in pixels
    endif else begin                                ;or a fraction
      y1 = yc(icol) + round(y_lower_lim*exwd(1,onum-1))
    endelse
    iy = y0 + indgen(y1 - y0 + 1)                   ;list of rows to change
    yint = (iy - ycen(icol) - ysfmin) / dysf        ;interpolation grid

;Linearly interpolate slit functions onto desired rows in current column.
    isort = sort(abs(binc - icol))                  ;sort by distance
    if(n_elements(isort) le 1) then begin           ;For short partial orders
      ic0=isort                                     ;that may fit in one swath
      ic1=isort
      bc0=cole0
      bc1=cole1
    endif else begin
      ic0 = isort(0)                                ;index of closest bin
      ic1 = isort(1)                                ;index of next closest bin
      bc0 = binc(ic0)                               ;closest bin center
      bc1 = binc(ic1)                               ;next closest center
    endelse

    sf0 = interpolate(slitf(*,ic0), yint)           ;interpolate onto rows
    sf1 = interpolate(slitf(*,ic1), yint)           ;interpolate onto rows
    sf = sf0 + (sf1-sf0)/(bc1-bc0) * (icol-bc0)     ;extra/interpolate icol
    bgg =  ( scatter_above(icol) -  scatter_below(icol)) $
         / (yscatter_above(icol) - yscatter_below(icol)) $
         * (findgen(y1 - y0 + 1) + y0 - yscatter_below(icol)) $
         + scatter_below(icol)

;Diagnostic plot.
    if 0 and (icol mod 50 eq 0 or icol eq ncol-1) then begin
      plot, iy, im(icol,y0:y1), xsty=3, ysty=3 $
          , chars=1.4, ps=2 $
          , xtit='Row Number', ytit='ADU' $
          , tit='Order ' + strtrim(onum, 2) $
          +',  Column ' + strtrim(icol, 2)
      oplot, iy, sf * fit(icol-cole0) + bgg, co=2
      oplot, iy, bgg, co=4
      junk = get_kbrd(1)
    endif

;Normalize the current segment of the flat.
    if(keyword_set(mask)) then msk = mask(icol,y0:y1) $
    else                       msk = replicate(1B,y1-y0+1)

;If FF signal is less than 10000 (S/N<100) than there is no point in flatfielding
    low_signal = where(im(icol,y0:y1)*GAIN lt 10000, n_low_signal)
    if(n_low_signal gt 0) then msk(low_signal)=0B
    im(icol,y0:y1) = msk * im(icol,y0:y1) / (sf * fit(icol - cole0) + bgg) $
                     + (1B - msk)

;Fill any part we missed with 1.0, especially before initial order.
    if y0 gt (yprev(icol)+1) then im(icol,yprev(icol)+1:y0) = 1.0

;If done with last order, fill to final edge with 1.0.
    if onum eq nord and y1 lt nrow-1 then im(icol,y1+1:nrow-1) = 1.0

;Update border of modifications so far.
    yprev(icol) = y1

;End of normalization loop through columns.
  endfor

  if(cole1 lt ncol-1) then begin                    ;skip the end of the order
    for icol=cole1+1,ncol-1 do begin                ;loop thru image columns
      yc = fix(ycen(icol))                          ;order center in column
      if(onum eq ofirst) then y0 = 0 $              ;starting row to change
      else                    y0 = ((yprev(icol)+1)>0)<(nrow-1)
      if(onum eq nord) then   y1 = nrow-1 $         ;ending row to change
      else                    y1 = ((yc + y_upper_lim)<(nrow-1))>0
;        y0 = ((yprev(icol)+1)>0)<(nrow-1)             ;starting row to change
;        y1 = ((yc + y_upper_lim)<(nrow-1))>0          ;ending row to change
      im(icol,y0:y1) = 1.0
    endfor
  endif
;stop

;End of loop through orders.
endfor

return
end
  */
//   return false;
// }

/**
  MkSlitFunc
  Make Slit Function
 **/
bool CFits::MkSlitFunc(const Array<double, 1> &D_A1_ScatterBelow,  //: in
                       const Array<double, 1> &D_A1_XScatterBelow, //: in
                       const Array<double, 1> &D_A1_ScatterAbove,  //: in
                       const Array<double, 1> &D_A1_XScatterAbove, //: in
                       //                       Array<double, 1> &D_A1_XCenters,      ///: in //
                       //                       double &D_XLeftLim,                      ///: in //
                       //                       double &D_XRightLim,                     ///: in //
                       Array<double, 1> &D_A1_XSlitF,        //: out
                       Array<double, 2> &D_A2_SlitF,         //: out
                       Array<double, 1> &D_A1_BinCen,        //: out
                       const int I_IAperture_In,                   //: in
                       //                       int I_NArgs,                          //: in
                       const Array<CString, 1> &CS_A1_Args_In,           //: in
                       void *ArgV_In[])                  //: in
/**                     //PLOT        =
                       Y_LOWER_LIM = int             : in
                       Y_UPPER_LIM = int             : in
                       LAMBDA_SF   = double          : in
                       LAMBDA_SP   = int             : in
                       WING_SMOOTH_FACTOR = double   : in
                       SWATH_WIDTH = int             : in
                       BLZ         = Array<double, 1>: out
///                       MASK        = Array<double, 2>: in
                       CCD_GAIN    = double          : in
                       CCD_READN   = double          : in
                       NO_SCATTER  = void
                       TELLURIC    = int[0-none, 1-Piskunov, 2-mine]        : in
                       FILENAME    = CString         : in
                       XCOR_PROF   = int             : in
                       Y_PROF_START = int            : in 0 <= Y_PROF_START < this->NRows
                       Y_PROF_END  = int            : in Y_PROF_START < Y_PROF_END < this->NRows
**/
{
  /*
  pro mkslitf, m (array(ncol,nrow)), // image containing echelle spectrum
               scatter_below,
               yscatter_below,
               scatter_above,
               yscatter_above,
               ycen, // (vector(ncol)), row numbers of zero point for slit function
               y_lower_lim,
               y_upper_lim,
               yslitf, // (vector(nslitf)) subpixel row offsets for slitf,
               sflit, // (array(nslitf,nbin)), subpixel slit functions,
               bincen, // (vector(nbin)), column of bin centers,
               ord_num,
               PLOT=iplot,
               X_LEFT_LIM=x_left_lim,
               X_RIGHT_LIM=x_right_lim,
               LAMBDA_SF=lam_sf,
               LAMBDA_SP=lam_sp,
               SWATH_WIDTH=swath_width,
               BLZ=blz,
               OSAMPLE=osample,
               MASK=mask,
               GAIN=gain,
               READN=readn,
               NO_SCATTER=no_scatter,
               TELLURIC=telluric,
               FILENAME=filename
  ;Determines slit function along echelle order
  ;Input:
  ; im (array(ncol,nrow)) image containing echelle spectrum
  ; back (vector(ncol) vector containing background under the current order
  ; ymin (vector(ncol)) row numbers along bottom of region to map
  ; ycen (vector(ncol)) row numbers of zero point for slit function
  ; ymax (vector(ncol)) row numbers along top of region to map
  ;Output:
  ; yslitf (vector(nslitf)) subpixel row offsets for slitf
  ; sflit (array(nslitf,nbin)) subpixel slit functions
  ; bincen (vector(nbin)) column of bin centers
  ;History:
  ;18-Nov-96 Valenti  Wrote.
  ;21-Nov-97 Valenti  Adapted phx_slitf for use in echelle reduction package
  ;30-Mar-98 Valenti  Don't use polynomials to fit slit function. Instead
  ;                    median filter, then bin, then Gaussian smooth.
  ;05-May-98 CMJ      Back to using polynomials to fit slit function.  Seems
  ;                    to work OK with 18th order on the binned, median filtered
  ;                    slit function.
  ;13-Aug-98 CMJ      Put in logic to calculate both the smoothed medianed
  ;                    slit function and the polynomial one and choose between
  ;                    them based on standard deviations, giving the fit
  ;                    a little extra room for messiness.  I also force
  ;                    whatever method is chosen on the first time through to
  ;                    use throughout.  I have also increased the smoothing
  ;                    size for high resolution data.
  ;29-Nov-98 JAV      Check for rspec exactly zero and fudge it to be one,
  ;                    so as to avoid divide by zero and subsequent badness.
  ;08-Dec-98 JAV      Added an inital filtering of bad pixels in the oversampled
  ;                    slit function *before* binning. The rejection threshold
  ;                    is 3 times the mean absolute value of the difference
  ;                    between the oversampled (sf) and median filtered (medsf)
  ;                    slit functions. Indices of the good pixels are contained
  ;                    in "igd".
  ;09-Dec-98 CMJ      Added the conditional on binning the slit function back
  ;                    in to aviod inappropriate referencing of the variables.
  ;                    The result is some SF bins have no points in them, so
  ;                    added a later check which interpolates over these bins.
  ;06-Jun-99 JAV      Increased trace level of slit function type message from
  ;                    10 to 20 (suppressing the messages by default).
  ;30-Mar-01 NP       I will write down what I have done. I promise.
  */
  /**
    Array<double, 1> bincen   => Array<double, 1> D_A1_BinCen
  ! Array<double, 1> BLZ=blz = fltarr(ncol)  => Array<double, 1> *P_D_A1_BLZ
    FILENAME=filename
  ! double GAIN=gain=CCD_gain       => double D_CCDGain       ; Gain
    Array<long, 1>/int i      => Array<int, 1> I_A1_I / int I_I ;Points of row crossing
  ! long ib                   => int I_IB
  ! long ie                   => int I_IE
  ! Array<long, 1> ibeg      => Array<int, 1> I_A1_IBeg
  ! Array<double, 1> ibound  => Array<double, 1> D_A1_IBound
  ! int icen = yc(ib+j)     => int I_ICen
  ! Array<long, 1> iend      => Array<int, 1> I_A1_IEnd
  ! Array<double, 2> im              => CFits P_CF_Im
  ! int imask = 0                    => int I_IMask
//  ! Array<long, 1> imax      => Array<int, 1> I_A2_MinCenMax(*,2)
//  ! Array<long, 1> imin      => Array<int, 1> I_A2_MinCenMax(*,0)
    Array<double, 1> irow    => Array<double, 1> D_A1_ICol
  ! Array<long, 1> j0        => Array<int, 1> I_A1_J0
  ! Array<long, 1> j1        => Array<ing, 1> I_A1_J1
   ! Array<int, 1> jbad      => Array<int, 1> I_A1_JBad
    !int jgood               => int I_JGood
  ! long k0                 => int I_A2_MinCenMax(I_IB + n, 0)
  ! long k1                 => int I_A2_MinCenMax(I_IB + n, 2)
  ! double LAMBDA_SF=lam_sf              => double D_LambdaSF
  ! int LAMBDA_SP=lam_sp                 => int I_LambdaSP
  ! Array<double, 2> MASK=mask            => Array<double, 2> I_A2_Mask
  ! bytarr msk(nc,nysf) / = 0  => Array<double, 2> I_A2_Msk
  ! int nbad                 => int I_NBad
  ! int nbin                 => int I_NBin
  ! long nc                  => int I_NR
  ! int ncol                 => int P_CF_Im->NRows
  ! int ni                   => int I_NI    ;This is how many times this order crosses to the next column
  NO_SCATTER=no_scatter
  ! int nrow                        => int P_CF_Im->NCols
  ! long nsf                        => int I_NSF
  ! int nslitf                     => int I_NSlitF
  ! long nysf                       => int I_NXSF
  ! int ord_num                             => int IOrdNum
  PLOT=iplot
  ! double READN=readn=CCD_readn=0. => double D_CCDReadN      ; Readout noise
  ! int OSAMPLE=osample                  => int I_OverSample
  Array<double, 1> dy_scatter         => Array<double, 1> D_A1_DXScatter
  Array<double, 1> yscatter_below     => Array<double, 1> D_A1_XScatterBelow
  Array<double, 1> yscatter_above     => Array<double, 1> D_A1_XScatterAbove
  Array<double, 1> scatter            => Array<double, 1> D_A1_Scatter
  Array<double, 1> scatter_above      => Array<double, 1> D_A1_ScatterAbove
  Array<double, 1> scatter_below      => Array<double, 1> D_A1_ScatterBelow
  ! Array<double, 2> sf(nc,nysf)      => Array<double, 2> D_A2_SlitFunc_Im_In
  ! Array<double, 2> sfbin            => Array<double, 2> D_A2_SFOut;
  ! Array<double, 1> sfpnt(nsf)       => Array<double, 1> D_A1_SFPnt
  ! Array<double, 1> sfsm             => Array<double, 1> D_A1_SFSM
  Array<double, 2> slitf
  ! Array<double, 1> ssf               => Array<double, 1> D_A1_SSF
  ! int SWATH_WIDTH=swath_width       => int I_SwathWidth
  Array<double, 1> tel                => Array<double, 1> D_A1_Tel
  TELLURIC=telluric
  ! long X_LEFT_LIM=x_left_lim        => int (int)((*this->P_D_A1_XMin)(I_IAperture_In))
  ! long X_RIGHT_LIM=x_right_lim       => int (int)((*this->P_D_A1_XMax)(I_IAperture_In))
  ! Array<int, 1> yc                   => Array<int, 1> I_A1_XC
  yscatter_below
  yscatter_above
  ! Array<double, 1> ysfpnt(nsf)      => Array<double, 1> D_A1_XSFPnt
  ! Array<double, 1> ycen(ncol)        => Array<double, 1> this->P_D_A2_XCenters(I_IAperture_In)
  ! Array<double, 1> ycene             => Array<double, 1> D_A1_XCentersE
  ! long y_lower_lim                   => int 0. - (*this->P_D_A1_XLow)(I_IAperture_In), this->P_D_A1_XLow(I_IAperture_In)
  ! long y_upper_lim                   => int (*this->P_D_A1_XHigh)(I_IAperture_In), this->P_D_A1_XHigh(I_IAperture_In)
  Array<double, 1> yslitf
  ! long yslitf0 = -y_lower_lim        => int I_XSlitFunc0
  ! long yslitf1 =  y_upper_lim        => int I_XSlitFunc1
   **/

  cout << "CFits::MkSlitFunc: Started: CS_A1_Args_In = " << CS_A1_Args_In << endl;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    (*P_OFS_Log) << "CFits::MkSlitFunc: Started: CS_A1_Args_In = " << CS_A1_Args_In << endl;
  #endif
//  cout << "CFits::MkSlitFunc: P_D_A2_PixArray = " << *P_D_A2_PixArray << endl;
//  return false;
  //  (*this->P_D_A1_XLow)(I_IAperture_In) = 0. - D_XLeftLim;
  //  (*this->P_D_A1_XHigh)(I_IAperture_In) = 0. + (*this->P_D_A1_XHigh)(I_IAperture_In);
  //  (*this->P_D_A2_PixArray)()

  int I_MaxIterSig_Temp = this->I_MaxIterSig;

  //  CFits *P_CF_Im = new CFits(*this);
  //  Array<double, 1> D_A1_BinCen;

  //  Array<double, 1> D_A1_ScatterBelow(this->GetNRows(), this->GetNCols());  //: in
  //  Array<double, 1> D_A1_XScatterBelow(this->GetNRows(), this->GetNCols()); //: in
  //  Array<double, 1> D_A1_ScatterAbove(this->GetNRows(), this->GetNCols());  //: in
  //  Array<double, 1> D_A1_XScatterAbove(this->GetNRows(), this->GetNCols()); //: in

  //  D_A1_ScatterBelow = 0.;
  //  D_A1_XScatterBelow = 0.;
  //  D_A1_ScatterAbove = 0.;
  //  D_A1_XScatterAbove = 0.;

  CString CS_SF_DebugFilesSuffix(" ");

  Array<double, 1> *P_D_A1_BLZ = new Array<double, 1>(1);
  (*P_D_A1_BLZ) = 0.;

  Array<double, 1> D_A1_DXScatter(1);
  D_A1_DXScatter = 0.;

  Array<int, 2> I_A2_IBinBoundY(1,1);
    I_A2_IBinBoundY = 0.;

  Array<double, 1> D_A1_ICol(1);
  D_A1_ICol = 0.;

  int I_IR0;
  I_IR0 = 0;

  int I_IR1;
  I_IR1 = 0;

  Array<int, 2> I_A2_Mask(1, 1);
  I_A2_Mask = 0;

  Array<double, 2> D_A2_Mask(1, 1);
  D_A2_Mask = 0.;

  Array<int, 2> I_A2_MaskApTemp(1, 1);
  I_A2_MaskApTemp = 0;

  Array<int, 2> I_A2_Msk(1, 1);
  I_A2_Msk = 0.;

  Array<double, 1> D_A1_SC(1);
  D_A1_SC = 0.;

  Array<double, 1> D_A1_Scatter(1);
  D_A1_Scatter = 0.;

//  Array<double, 2> D_A2_SFOut(1, 1);
//  D_A2_SFOut = 0.;

  Array<double, 1> D_A1_SF(1);
  D_A1_SF = 0.;

  Array<double, 2> D_A2_SlitFunc_Im_In(1, 1);
  D_A2_SlitFunc_Im_In = 0.;

  Array<double, 2> D_A2_CCD_Ap(2,2);
  D_A2_CCD_Ap = 0.;

  Array<double, 2> D_A2_Err(1, 1);
  D_A2_Err = 0.;
  Array<double, 2> D_A2_Err_AllRows(1, 1);
  D_A2_Err_AllRows = 0.;
  Array<int, 2> I_A2_Mask_AllRows(1, 1);
  I_A2_Mask_AllRows = 1;

  Array<double, 1> D_A1_Err(1);
  D_A1_Err = 0.;

//  Array<double, 1> D_A1_SFPnt(1);
//  D_A1_SFPnt = 0.;

  Array<double, 2> D_A2_SFSM(1,1);
  D_A2_SFSM = 0.;
  Array<double, 3> D_A3_SFSM(1,1,1);
  D_A3_SFSM = 0.;

//  Array<double, 1> D_A1_SFSM2(1);
//  D_A1_SFSM2 = 0.;

//  Array<double, 1> D_A1_SFSM2Temp(1);
//  D_A1_SFSM2Temp = 0.;

  Array<double, 2> D_A2_SlitFTemp(1,1);
  D_A2_SlitFTemp = 0.;

  Array<double, 1> D_A1_SP(1);
  D_A1_SP = 0.;
  Array<double, 2> D_A2_SP(1,1);
  D_A2_SP = 0.;
  Array<double, 2> D_A2_Errors_SP_Out(1,1);
  D_A2_Errors_SP_Out = 0.;
  Array<double, 2> D_A2_XCorProf(1,1);
  D_A2_XCorProf = 0.;
  bool B_Run_XCor = false;

  Array<double, 2> D_A2_Sky(1,1);
  Array<double, 2> D_A2_ErrSky(1,1);

  Array<double, 1> D_A1_SSF(1);
  D_A1_SSF = 0.;

  Array<double, 1> D_A1_Tel(1);
  D_A1_Tel = 0.;

  Array<double, 2> D_A2_Tel(1,1);
  D_A2_Tel = 0.;

  Array<double, 1> D_A1_Temp(1);
  D_A1_Temp = 0.;

  Array<double, 1> D_A1_TempArr(1);
  D_A1_TempArr = 0.;

  Array<double, 1> D_A1_TempArrA(1);
  D_A1_TempArrA = 0.;

  Array<double, 1> D_A1_TempArrB(1);
  D_A1_TempArrB = 0.;

  Array<double, 1> D_A1_TempArrC(1);
  D_A1_TempArrC = 0.;

  Array<double, 1> D_A1_TempArrD(1);
  D_A1_TempArrD = 0.;

  Array<double, 1> D_A1_XCenMXC(1);
  D_A1_XCenMXC = 0.;
//  Array<double, 1> D_A1_XCenMXC_TelTemp(1);
//  D_A1_XCenMXC_TelTemp = 0.;

  Array<double, 1> D_A1_XCentersE(1);
  D_A1_XCentersE = 0.;

  Array<double, 1> D_A1_XInt(1);
  D_A1_XInt = 0.;

//  Array<double, 1> D_A1_XSFPnt(1);
//  D_A1_XSFPnt = 0.;

  Array<double, 1> D_A1_XSlitFTemp(1);
  D_A1_XSlitFTemp = 0.;

  Array<int, 1> I_A1_I(1);
  I_A1_I = 0;

//  Array<int, 1> I_A1_IBeg(1);
//  I_A1_IBeg = 0;

//  Array<int, 1> I_A1_IEnd(1);
//  I_A1_IEnd = 0;

//  Array<int, 1> I_A1_IMax(1);
//  I_A1_IMax = 0;

//  Array<int, 1> I_A1_IMin(1);
//  I_A1_IMin = 0;

  Array<int, 1> I_A1_ISort(1);
  I_A1_ISort = 0;

  Array<int, 1> I_A1_ITel(1);
  I_A1_ITel = 0;

  Array<int, 1> I_A1_IX(1);
  I_A1_IX = 0;

//  Array<int, 1> I_A1_J0(1);
//  I_A1_J0 = 0;

//  Array<int, 1> I_A1_J1(1);
//  I_A1_J1 = 0;

//  Array<int, 1> I_A1_JBad(1);
//  I_A1_JBad = 0;

//  Array<int, 1> I_A1_Temp(1);
//  I_A1_Temp = 0;

//  Array<int, 1> I_A1_TempA(1);
//  I_A1_TempA = 0;

  Array<double, 2> D_A2_ErrTel(1);
  Array<double, 1> D_A1_ErrTel(1);
  Array<int, 1> I_A1_ErrInd(1);
  Array<double, 1> D_A1_ErrTelSub(1);
  Array<double, 2> D_A2_SF(1,1);
  Array<double, 1> D_A1_ErrSky(1);
  Array<double, 1> D_A1_ErrOut(1);
  D_A1_ErrOut = 0.;
  Array<double, 1> D_A1_ErrFit(1);
  Array<int, 2> I_A2_MinCenMax(this->NRows, 3);
  I_A2_MinCenMax = 0;
  int I_NPixCut_Left = 1;
  int I_NPixCut_Right = 1;

  CString *P_CS_Temp;
  CString CS_TempNum(" ");

  Array<CString, 1> CS_A1_Args_Median(3);
  CS_A1_Args_Median = CString(" ");
  CS_A1_Args_Median(0) = CString("NORMAL");
  void **PP_Args_Median = (void**)malloc(sizeof(void*) * 3);
  int I_Val_Normal = 1;
  double D_Val_ErrOutMedian;
  if (this->ErrorsRead){
    PP_Args_Median[0] = &I_Val_Normal;
    CS_A1_Args_Median(1) = CString("ERRORS_IN");
    CS_A1_Args_Median(2) = CString("ERR_OUT");
    PP_Args_Median[2] = &D_Val_ErrOutMedian;
  }

//  Array<int, 1> *P_I_A1_XC;

//  char* tmpstr = new char[5];

  int I_I = 0;
  int I_IB = 0;// = I_A1_IBeg(m);    /// Lower row
  int I_IE = 0;// = I_A1_IEnd(m);    /// Upper row
  int I_NR = 0;// = I_IE - I_IB + 1; /// Number of rows
//  int I_ICen = 0;
//  int I_K0 = 0;
//  int I_K1 = 0;
  int I_IMask = 0;
  int I_LambdaSP = 1;
  int I_NBins = 0;
  int I_NI = 0;
  int I_NSF = 0;
  int I_NSlitF = 0;
  int I_NTrim = 0;
  int I_NXSF = 0;
  int I_Pos = 0;
  int I_SwathWidth = 0;
//  int I_X0 = 0;
//  int I_X1 = 0;
  int I_XSlitFunc0 = 0;
  int I_XSlitFunc1 = 0;
  int I_Telluric = 0;
//  int irow = 0;
  int pos = 0;
  int pppos = 0;

  double D_BR0 = (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In);
//  cout << "CFits::MkSlitFunc: D_BR0 = " << D_BR0 << endl;
//  return false;
  double D_BR1 = (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In);
  double D_CCDGain = 1.;
  double D_CCDReadN = 0.;
  double D_DXSF = 0.;





  /// TODO: Make sure about that!
  double D_LambdaSF = 1. / this->I_OverSample;






  double D_WingSmoothFactor = 0.;
  double D_XSFMax = 0.;
  double D_XSFMin = 0.;
  double d_tmp = 0.;


  Array<double,1> D_A1_SF_Median(1);
  Array<double,1> D_A1_Sky(1);
  Array<double,1> D_A1_SPFit(1);
  Array<double,1> D_A1_SP_Out(1);
  Array<int, 2> I_A2_Mask_Tel(1,1);
  Array<int, 2> I_A2_Mask_TelTemp(1,1);
  Array<int, 1> I_A1_UseRow_Tel(1);
  Array<int, 1> I_A1_UseRow_TelTemp(1);
  Array<double, 2> D_A2_ErrIn_Tel(1,1);
  Array<double, 2> D_A2_Err_Temp(1,1);
  Array<double, 2> D_A2_SlitFuncOrig(1,1);
  Array<double, 2> D_A2_TempIm(1,1);
  Array<double, 1> D_A1_SFMax(1);
  double D_DevOld = 0.;
  double D_DevTemp = 0.;
  int nind_temp;
  Array<int,1> I_A1_IndA(1);
//  Array<double,2> D_A2_SlitFunc_Im_In_Max(1,1);
//  Array<double,2> D_A2_SlitFunc_Im_In_MaxTemp(1, 1);
  Array<double, 1> *P_D_A1_Col;
  Array<int, 1> *P_I_A1_Ind;
  Array<int, 1> *P_I_A1_Ind_Last;
  Array<int, 1> I_A1_UseRow_Tel_AllRows(1);
  Array<int, 1> I_A1_Ind_Temp(1);
  Array<int, 1> I_A1_SFMaxInd(1);
  int I_NGood;
  Array<int, 1> *P_I_A1_SFMaxInd;
//  Array<double, 2> D_A2_Ind_TempA(1, 1);
  int I_RunMax = 1;
  int I_Run_Tel = 0;
  Array<double, 2> D_A2_SlitFunc_Im_In_Tel(1,1);
  Array<double, 1> D_A1_Sky_Temp(1);
  Array<double, 2> D_A2_SFOld(1,1);
  double D_SFDev = 0.;
  Array<int, 2> I_A2_Mask_Temp(1,1);

  int tempppos = 0;
  int tempm = 0;
  int tempmt = 0;

  bool B_MaximaOnly = false;

  CString CS_Temp("Y_LOWER_LIM");
//  Array<double, 1> D_A1_TempXMin(this->NRows);
  Array<int, 1> *P_I_A1_Temp;

  Array<CString, 1> cs_a1(23);
  void **args = (void**)malloc(sizeof(void*) * 23);

///  cs_a1(pppos) = CString("NOISE");
///  pppos++;

  //  cs_a1(pppos) = CString("OVERSAMPLE");
  //  pppos++;
  firstIndex i;
  secondIndex j;

  /// Trace Functions
  if (!this->TraceFunctionsCalculated)
  {
    if (!this->CalcTraceFunctions())
    {
      cout << "CFits::MkSlitFunc: ERROR: this->CalcTraceFunctions() returned FALSE" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: this->CalcTraceFunctions() returned FALSE" << endl;
      return false;
    }
  }

  //  (*this->P_D_A2_XCenters)(I_IAperture_In, Range::all()) = D_A1_XCenters(Range::all());
  /**
  if(keyword_set(gain))  then $
    CCD_gain  = gain $
  else $
    CCD_gain=1.
  */
  ///CCD gain
  CS_Temp.Set("CCD_GAIN");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_CCDGain = *(double*)ArgV_In[I_Pos];
#ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: KeyWord_Set(CCD_GAIN): D_CCDGain set to " << D_CCDGain << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(CCD_GAIN): D_CCDGain set to " << D_CCDGain << endl;
#endif

  }

  /**
  if(keyword_set(readn)) then $
    CCD_readn = readn $
  else $
    CCD_readn=0.
  */
  ///Readout noise
  CS_Temp.Set("CCD_READN");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_CCDReadN = *(double*)ArgV_In[I_Pos];
#ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: KeyWord_Set(CCD_READN): D_CCDReadN set to " << D_CCDReadN << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(CCD_READN): D_CCDReadN set to " << D_CCDReadN << endl;
#endif

  }

  /**
  msk = 0
  imask = 0
  if(keyword_set(mask)) then begin
    sz = size(mask)
    if(sz(0) eq 2 and sz(1) eq ncol and sz(2) eq nrow) then $
      imask = 1 $
    else begin
      print,'MKSLITF: Your mask is defined but does not match your image'
      stop
    endelse
  endif
  */
  ///Mask
//  CS_Temp.Set("MASK");
//  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
//  {
//    I_A2_Mask = *(Array<double, 2>*)ArgV_In[I_Pos];
//    cout << "CFits::MkSlitFunc: KeyWord_Set(MASK): I_A2_Mask set to " << I_A2_Mask << endl;//.transpose(secondDim, firstDim) << endl;
// #ifdef __DEBUG_FITS_MKSLITFUNC__
//    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(MASK): I_A2_Mask set to " << I_A2_Mask << endl;//.transpose(secondDim, firstDim) << endl;
// #endif
//    if (I_A2_Mask.rows() != 1 && I_A2_Mask.cols() != 1 && I_A2_Mask(0,0) != 0)
//    {
//      if (I_A2_Mask.rows() != this->NRows ||
//          I_A2_Mask.cols() != this->NCols)
//      {
//        cout << "CFits::MkSlitFunc: ERROR: Im(" << this->NRows << " x " << this->NCols << ") and Mask(" << I_A2_Mask.rows() << " x " << I_A2_Mask.cols() << ") don't have the same sizes!!!" << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: Im(" << this->NRows << " x " << this->NCols << ") and Mask(" << I_A2_Mask.rows() << " x " << I_A2_Mask.cols() << ") don't have the same sizes!!!" << endl;
//        return false;
//      }
//      I_IMask = 1;
// #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: KeyWord_Set(MASK): I_IMask set to " << I_IMask << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(MASK): I_IMask set to " << I_IMask << endl;
// #endif

//    }
//  }


  CS_Temp.Set("BLZ");
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("BLZ"))) >= 0)
  {
    if (P_D_A1_BLZ != NULL)
      delete P_D_A1_BLZ;
    P_D_A1_BLZ = (Array<double, 1>*)ArgV_In[I_Pos];
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: KeyWord_Set(BLZ): P_D_A1_BLZ set to " << *P_D_A1_BLZ << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(BLZ): P_D_A1_BLZ set to " << *P_D_A1_BLZ << endl;
    #endif
  }
  if (I_Pos < 0 || (I_Pos >= 0 && P_D_A1_BLZ->size() == 1 && abs((*P_D_A1_BLZ)(0)) < 0.000001))
  {
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(BLZ): P_D_A1_BLZ initialized " << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(BLZ): P_D_A1_BLZ initialized " << endl;
    #endif
  }

  /**
  if(not keyword_set(lam_sf)) then $
    lambda_sf=1.$
  else $
    lambda_sf=lam_sf
  */
  CS_Temp.Set("LAMBDA_SF");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_Pos = " << I_Pos << endl;
    #endif
    D_LambdaSF = *(double*)ArgV_In[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SF): D_LambdaSF set to " << D_LambdaSF << endl;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SF): D_LambdaSF set to " << D_LambdaSF << endl;
    #endif
  }

  CS_Temp.Set("WING_SMOOTH_FACTOR");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_Pos = " << I_Pos << endl;
    #endif
    D_WingSmoothFactor = *(double*)ArgV_In[I_Pos];
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: KeyWord_Set(WING_SMOOTH_FACTOR): D_WingSmoothFactor set to " << D_WingSmoothFactor << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(WING_SMOOTH_FACTOR): D_WingSmoothFactor set to " << D_WingSmoothFactor << endl;
    #endif
  }

  /**
  if(not keyword_set(lam_sp)) then $
    lambda_sp=0  $
  else $
    lambda_sp=lam_sp
  */
  CS_Temp.Set("LAMBDA_SP");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_LambdaSP = *(int*)ArgV_In[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SP): I_LambdaSP set to " << I_LambdaSP << endl;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SP): I_LambdaSP set to " << I_LambdaSP << endl;
    #endif
  }

  int I_XCorProf = 0;
  CS_Temp.Set("XCOR_PROF");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_XCorProf = *(int*)ArgV_In[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(XCOR_PROF): I_XCorProf set to " << I_XCorProf << endl;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(XCOR_PROF): I_XCorProf set to " << I_XCorProf << endl;
    #endif
//    return false;
  }
  if (I_XCorProf > 0)
    B_Run_XCor = true;

  CS_Temp.Set("TELLURIC");
//  int I_Telluric_Temp = 0;
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_Telluric = *(int*)ArgV_In[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(Telluric): I_Telluric set to " << I_Telluric << endl;
    if (I_Telluric == 3)
      B_MaximaOnly = true;
    if (I_Telluric > 0){
      cs_a1(pppos) = CString("TELLURIC");
      args[pppos] = &I_Telluric;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "args[pppos=" << pppos << "] set to I_Telluric = " << *(int*)args[pppos] << endl;
      #endif
      pppos++;
    }
  }

  int I_YProfStart = -1;
  CS_Temp.Set("Y_PROF_START");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_YProfStart = *(int*)ArgV_In[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(Y_PROF_START): I_YProfStart set to " << I_YProfStart << endl;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(Y_PROF_START): I_YProfStart set to " << I_YProfStart << endl;
    #endif
    if (I_YProfStart < ((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In)))
      I_YProfStart = (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In);
  }
  else{
    I_YProfStart = (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In);
  }

  int I_YProfEnd = -1;
  CS_Temp.Set("Y_PROF_END");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_YProfEnd = *(int*)ArgV_In[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(Y_PROF_END): I_YProfEnd set to " << I_YProfEnd << endl;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(Y_PROF_START): I_YProfEnd set to " << I_YProfEnd << endl;
    #endif
    if (I_YProfEnd > ((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In)))
      I_YProfEnd = (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In);
  }
  else{
    I_YProfEnd = (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In);
  }
  
  ///Internal program parameters.

  Array<double, 1> D_A1_XCorProf_Out(this->NRows);
  D_A1_XCorProf_Out = 0.;
  if (I_XCorProf > 0){
    cs_a1(pppos) = CString("XCOR_PROF");
    args[pppos] = &I_XCorProf;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "args[pppos=" << pppos << "] set to I_XCorProf = " << *(int*)args[pppos] << endl;
    #endif
    pppos++;

    cs_a1(pppos) = CString("XCOR_PROF_OUT");
    args[pppos] = &D_A1_XCorProf_Out;
    pppos++;
  }

  cs_a1(pppos) = CString("LAMBDA_SF");
  pppos++;

  cs_a1(pppos) = CString("LAMBDA_SP");
  pppos++;

  cs_a1(pppos) = CString("WING_SMOOTH_FACTOR");
  pppos++;

  cs_a1(pppos) = CString("XLOW");
  pppos++;

  cs_a1(pppos) = CString("SP_OUT");
  pppos++;

///  cs_a1(pppos) = CString("USE_ROW");
///  pppos++;

  cs_a1(pppos) = CString("STOP");
  pppos++;

//  cs_a1(pppos) = CString("BAD");
//  pppos++;

  cs_a1(pppos) = CString("MASK");
  pppos++;

  if (I_Telluric > 1)
  {
    cs_a1(pppos) = CString("SKY");
    pppos++;
    cs_a1(pppos) = CString("SP_FIT");
    pppos++;
  }

  Array<double, 1> D_A1_Errors_SP_Out(1);

  if (this->ErrorsRead){
    cs_a1(pppos) = CString("ERRORS");
    pppos++;
    cs_a1(pppos) = CString("ERRORS_OUT");
    pppos++;
    cs_a1(pppos) = CString("ERRORS_SP_OUT");
    pppos++;
    if (I_Telluric > 1)
    {
      cs_a1(pppos) = CString("ERR_SKY");
      pppos++;
    }
  }
  cs_a1(pppos) = CString("I_BIN");
  pppos++;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: cs_a1 = " << cs_a1 << endl;
    cout << "CFits::MkSlitFunc: pppos = " << pppos << endl;
  #endif
//  return false;

  int I_Stop = 0;

  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: cs_a1 set to " << cs_a1 << endl;
  #endif

  int I_BinHeight;











  Array<double, 1> D_A1_XCenters(this->NRows);
//  Array<double, 1> D_A1_XCenters((*(this->P_D_A1_YHigh))(I_IAperture_In) - (*(this->P_D_A1_YLow))(I_IAperture_In)+1);
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A1_XCenters.size() = " << D_A1_XCenters.size() << endl;
  #endif
  /// Add 0.5 pixels to get real subpixels TODO: REALLY???????

  int I_Run_XCor = 0;



//do{
//  cout << "CFits::MkSlitFunc: Beginning of do-while loop: D_A1_XCorProf_Out = " << D_A1_XCorProf_Out << endl;
  D_A1_XCenters = (*(this->P_D_A2_XCenters))(I_IAperture_In, Range::all()) + 0.5;
//  cout << "CFits::MkSlitFunc: D_A1_XCenters = " << D_A1_XCenters << endl;
//  D_A1_XCenters(Range(I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_NBins-1, 1))) = D_A1_XCenters(Range(I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_NBins-1, 1))) + D_A1_XCorProf_Out;
//  D_A1_XCenters = (*(this->P_D_A2_XCenters))(I_IAperture_In, Range((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In), (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In))) + 0.5;
//  cout << "CFits::MkSlitFunc: D_A1_XCenters set to " << D_A1_XCenters << endl;
//  if (I_Run_XCor == 1){
//    cout << "CFits::MkSlitFunc: Beginning of do-while loop: D_A1_XCorProf_Out = " << D_A1_XCorProf_Out << endl;
//    return false;
//  }





  CS_Temp.Set("SWATH_WIDTH");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    /// If swath width is preset
    I_SwathWidth = *(int*)ArgV_In[I_Pos];
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_SwathWidth set to " << I_SwathWidth << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_SwathWidth set to " << I_SwathWidth << endl;
    #endif
    if (I_SwathWidth > (I_YProfEnd - I_YProfStart + 1)){
      I_SwathWidth = I_YProfEnd - I_YProfStart + 1;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_SwathWidth too large: I_SwathWidth set to " << I_SwathWidth << endl;
      #endif
    }
    if (I_SwathWidth != 0)
    {
      ///nbin = round((x_right_lim - x_left_lim + 1.) / swath_width)>1
      I_NBins = Round((I_YProfEnd - I_YProfStart + 1.)
                     / I_SwathWidth);
      if (I_NBins < 1)
                I_NBins = 1;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_NBin = Round(((*this->P_D_A1_YHigh)(I_IAperture_In)(=" << (*this->P_D_A1_YHigh)(I_IAperture_In) << ") - (*this->P_D_A1_YLow)(I_IAperture_In)(=" << (*this->P_D_A1_YLow)(I_IAperture_In) << ") + 1.) / I_SwathWidth(=" << I_SwathWidth << ")) set to " << I_NBins << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBins << endl;
      #endif
    }
  }
  if (I_Pos < 0 || (I_Pos >= 0 && I_SwathWidth == 0))
  { /// Estimate the Points of column crossing
    ///    i = uniq(long(ycen))                        ;Points of row crossing
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): D_A1_XCenters = " << D_A1_XCenters << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): D_A1_XCenters = " << D_A1_XCenters << endl;
    #endif
    Array<int, 1> *p_tempIntArrA = Fix(D_A1_XCenters(Range((*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In)), (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YLow)(I_IAperture_In)));
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): p_tempIntArrA = " << *p_tempIntArrA << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): p_tempIntArrA = " << *p_tempIntArrA << endl;
    #endif
    this->Uniq(*p_tempIntArrA, I_A1_I);
    delete p_tempIntArrA;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_A1_I set to " << I_A1_I << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_A1_I set to " << I_A1_I << endl;
    #endif

    ///This is how many times this order crosses to the next column
    ///    ni = n_elements(i)                          ;This is how many times this order crosses to the next row
    I_NI = I_A1_I.size();
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NI set to " << I_NI << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NI set to " << I_NI << endl;
    #endif

    /**
      if(ni gt 1) then begin                      ;Curved order crosses rows
        i = total(i(1:ni-1)-i(0:ni-2))/(ni-1)
        nbin = ((round(ncol/i) / 3)  > 3) < 20    ;number of swaths along the order
      endif else begin                            ;Perfectly aligned orders
        nbin = (ncol/400) > 3                     ;Still follow the changes in PSF
      endelse
    */
    ///Curved order crosses columns
    if (I_NI > 1)
    {
      I_I = sum(I_A1_I(Range(1, I_NI-1)) - I_A1_I(Range(0, I_NI - 2))) / (I_NI - 1);
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_I set to " << I_I << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_I set to " << I_I << endl;
      #endif

      /// number of swaths along the order
      I_NBins = Round((double)(I_YProfEnd - I_YProfStart + 1) / (double)I_I / 3.);
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_NBin = Round((double)this->NRows(=" << this->NRows << ") / (double)I_I(=" << I_I << ") / 3.) set to " << I_NBins << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_NBin = Round((double)this->NRows(=" << this->NRows << ") / (double)I_I(=" << I_I << ") / 3.) set to " << I_NBins << endl;
        cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_NBin set to " << I_NBins << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_NBin set to " << I_NBins << endl;
      #endif

    }
    else
    { /// Perfectly aligned orders
      /// Still follow the changes in PSF
      I_NBins = Round((double)(I_YProfEnd - I_YProfStart + 1) / 400.);
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") <= 1): I_NBin = int(this->NRows(=" << this->NRows << ") / 400.) set to " << I_NBins << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") <= 1): I_NBin = int(this->NRows(=" << this->NRows << ") / 400.) set to " << I_NBins << endl;
        cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") <= 1): I_NBin set to " << I_NBins << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") <= 1): I_NBin set to " << I_NBins << endl;
      #endif
    }
    int I_TempInta = int(3. * double(I_YProfEnd - I_YProfStart) / double(this->NRows));
    if (I_NBins < I_TempInta)
      I_NBins = I_TempInta;
    I_TempInta = int(20. * (I_YProfEnd - I_YProfStart + 1) / this->NRows);
    if (I_NBins > I_TempInta)
      I_NBins = I_TempInta;
    if (I_NBins < 1)
      I_NBins = 1;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBins << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBins << endl;
    #endif
//    return false;

    /**
      nbin = nbin * (x_right_lim $                ;Adjust for the true order length
             - x_left_lim + 1) / ncol
      yc = fix(ycen)
    */
    /// Adjust for the true order length
//    I_NBin = I_NBin * (int)((*this->P_D_A1_YHigh)(I_IAperture_In) - (*this->P_D_A1_YLow)(I_IAperture_In) + 1.) / this->NRows;
//    if (I_NBin < 1)
//      I_NBin = 1;
//#ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NBin = I_NBin * (int)((*this->P_D_A1_YHigh)(I_IAperture_In)(=" << (*this->P_D_A1_YHigh)(I_IAperture_In) << ") - (*this->P_D_A1_YLow)(I_IAperture_In)(=" << (*this->P_D_A1_YLow)(I_IAperture_In) << ") + 1.) / this->NRows(=" << this->NRows << ") set to " << I_NBin << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBin << endl;
//#endif
  } /// if (!(I_Pos = this->KeyWord_Set(const_cast<const CString**>(PP_CS_Args), I_NArgs, CS_Temp)))

  I_BinHeight = int((I_YProfEnd - I_YProfStart + 1) / I_NBins);
  if (I_NBins > 1)
    I_NBins = (2 * I_NBins) - 1;

  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << endl;
    cout << "CFits::MkSlitFunc: I_YProfStart = " << I_YProfStart << endl;
    cout << "CFits::MkSlitFunc: I_YProfEnd = " << I_YProfEnd << endl;
    cout << "CFits::MkSlitFunc: I_NBins set to " << I_NBins << endl;
  #endif
//  return false;


//  Array<int, 2> I_A2_IndexArrays(1,1);

//  Array<int, 2> I_A2_MinCenMax((*(this->P_D_A1_YHigh))(I_IAperture_In) - (*(this->P_D_A1_YLow))(I_IAperture_In)+1, 3);

  //I_A1_XC.resize(D_A1_XCenters.size());

  if (!this->CalcMinCenMax(I_IAperture_In, I_A2_MinCenMax)){
    cout << "CFits::MkSlitFunc: ERROR: CalcMinCenMax(" << I_IAperture_In << ") returned FALSE" << endl;
    return false;
  }
  
//  P_I_A1_XC = Fix(D_A1_XCenters);
//  I_A2_MinCenMax(Range::all(), 1) = (*P_I_A1_XC);
//  delete P_I_A1_XC;
//  #ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: I_A2_MinCenMax(Range::all(),1) set to " << I_A2_MinCenMax(Range::all(),1) << endl;
//    cout << "CFits::MkSlitFunc: I_A2_MinCenMax(Range::all(),1) set to " << I_A2_MinCenMax(Range::all(),1) << endl;
//  #endif


//  /// Find columns that contain spectrum.
//  ///  imin = yc - y_lower_lim                       ;bottom row of order
//  //I_A1_IMin.resize(I_A2_MinCenMax.rows());

//  #ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: D_A1_XCenters = " << D_A1_XCenters(Range((*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YLow)(I_IAperture_In), (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In))) << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XCenters = " << D_A1_XCenters(Range((*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YLow)(I_IAperture_In), (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In))) << endl;
//    cout << "CFits::MkSlitFunc: P_D_A1_XLow(I_IAperture_In) = " << (*P_D_A1_XLow)(I_IAperture_In) << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XLow(I_IAperture_In) = " << (*P_D_A1_XLow)(I_IAperture_In) << endl;
//  #endif
//  D_A1_TempXMin = D_A1_XCenters + (*this->P_D_A1_XLow)(I_IAperture_In);
//  P_I_A1_Temp = Fix(D_A1_TempXMin);
//  I_A2_MinCenMax(Range::all(), 0) = (*P_I_A1_Temp);// - I_NPixCut_Left;///(*P_I_A1_Temp); /// Left column of order
// //  I_A2_MinCenMax(Range::all(), 0) = (*P_I_A1_XC) + (int)(*this->P_D_A1_XLow)(I_IAperture_In);///(*P_I_A1_Temp); /// Left column of order
//  delete(P_I_A1_Temp);

// //  if (I_A1_IMin.size() != I_A2_MinCenMax.rows()){
// //    cout << "CFits::MkSlitFunc: ERROR: I_A1_IMin.size()=" << I_A1_IMin.size() << " != I_A2_MinCenMax.rows()=" << I_A2_MinCenMax.rows() << " => Returning FALSE" << endl;
// //    return false;
// //  }
// //  I_A1_IMin = I_A2_MinCenMax(Range::all(), 0); /// Left column of order
// //  I_A1_IMin = (*P_I_A1_XC) + (int)(*this->P_D_A1_XLow)(I_IAperture_In); /// Left column of order
// //  I_A1_ITempDiff = I_A1_ITemp - I_A1_IMin;
//   //      D_XLeftLim;
//  #ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: D_A1_XCenters = " << D_A1_XCenters << endl;
//    cout << "CFits::MkSlitFunc: P_D_A1_XLow(I_IAperture_In) = " << (*P_D_A1_XLow)(I_IAperture_In) << endl;
//    cout << "CFits::MkSlitFunc: P_D_A1_XHigh(I_IAperture_Heigh) = " << (*P_D_A1_XHigh)(I_IAperture_In) << endl;
// //    cout << "CFits::MkSlitFunc: I_A1_IMin set to " << I_A1_IMin << endl;
//    //cout << "CFits::MkSlitFunc: I_A1_ITemp - I_A1_ITempDiff set to " << I_A1_ITempDiff << endl;
// //    (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IMin set to " << I_A1_IMin << endl;
//  #endif

//  ///  imax = yc + y_upper_lim                       ;top row of order
//  //I_A1_IMax.resize(I_A2_MinCenMax.rows());
// ///  D_A1_TempXC = (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) + (*this->P_D_A1_XHigh)(I_IAperture_In);
// ///  Array<long, 1> *P_L_A1_Temp;
// ///  P_L_A1_Temp = Ceil(D_A1_TempXC); /// Right column of order
// ///  P_I_A1_Temp = FixLI(*P_L_A1_Temp);
// ///  I_A1_IMax = (*P_I_A1_Temp);
// ///  I_A2_MinCenMax(Range::all(), 2) = I_A2_MinCenMax(Range::all(), 0) + I_BinWidth - 1;
// //  Array<int, 1> I_A1_TempB(this->NRows);
// //  I_A1_TempB = where(I_A2_MinCenMax(Range::all(), 0) >= 0 && I_A2_MinCenMax(Range::all(), 2) < this->NCols, 1, 0);
// //  Array<int, 1> *P_I_A1_TempB;
// //  int I_NInd;
// //  P_I_A1_TempB = this->GetIndex(I_A1_TempB, I_NInd);
// //  Array<int, 1> I_A1_IMinS = this->GetSubArr(I_A1_IMin, *P_I_A1_TempB);
// //  Array<int, 1> I_A1_IMaxS = this->GetSubArr(I_A1_IMax, *P_I_A1_TempB);

// ///  cout << "MkSlitFunc: I_A2_MinCenMax set to " << I_A2_MinCenMax << endl;
// //  if (I_IAperture_In == 2)
// //    return false;

// //  int I_MinCenMax_Min = min(I_A1_IMaxS - I_A1_IMinS);
// //  int I_MinCenMax_Max = max(I_A1_IMaxS - I_A1_IMinS);
// //  cout << "MkSlitFunc: I_A2_MinCenMax set to " << I_A2_MinCenMax << endl;
// //  cout << "MkSlitFunc: I_MinCenMax_Min = " << I_MinCenMax_Min << endl;
// //  cout << "MkSlitFunc: I_MinCenMax_Max = " << I_MinCenMax_Max << endl;
// //  if (I_MinCenMax_Min != I_MinCenMax_Max){
// //    cout << "MkSlitFunc: ERROR: I_MinCenMax_Min(=" << I_MinCenMax_Min << ") != I_MinCenMax_Max(=" << I_MinCenMax_Max << ")" << endl;
// //    return false;
// //  }
// //  return false;
// //  I_A1_ITemp = I_A1_IMax;
// // #ifdef __DEBUG_FITS_MKSLITFUNC__
// //  cout << "CFits::MkSlitFunc: I_A1_IMax set to " << I_A1_IMax << endl;
// //  (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IMax set to " << I_A1_IMax << endl;
// // #endif
// ///  delete(P_I_A1_Temp);
// ///  delete(P_L_A1_Temp);
// //  delete(P_I_A1_TempB);


// ///  I_A1_IMax = (*P_I_A1_XC) + (*this->P_D_A1_XHigh)(I_IAperture_In); /// Right column of order
//  Array<double, 1> D_A1_IMax(I_A2_MinCenMax.rows());
//  D_A1_IMax = D_A1_XCenters+(*this->P_D_A1_XHigh)(I_IAperture_In);
//  P_I_A1_Temp = this->Fix(D_A1_IMax);
// //  I_A1_IMax = (*P_I_A1_Temp);// - I_NPixCut_Right; /// Right column of order
// //  D_A1_IMax.resize(0);
// //  I_A1_IMax = (*P_I_A1_XC) + (int)(*this->P_D_A1_XHigh)(I_IAperture_In); /// Right column of order
//  I_A2_MinCenMax(Range::all(), 2) = (*P_I_A1_Temp);
//  delete(P_I_A1_Temp);

// //  Array<int, 1> I_A1_WhereA(I_A2_MinCenMax.rows());
// //  I_A1_WhereA = where(I_A2_MinCenMax(Range::all(), 0) < 0, 1, 0);
// //  int I_NIndA = 0;
// //  Array<int, 1> *P_I_A1_Ind_WhereA = this->GetIndex(I_A1_WhereA, I_NIndA);
// //  if (I_NIndA > 0){
// //    for (int ii = 0; ii < P_I_A1_Ind_WhereA->size(); ii++)
// //      I_A2_MinCenMax((*P_I_A1_Ind_WhereA)(ii), 0) = 0;
// //  }
// //  delete(P_I_A1_Ind_WhereA);

// //  I_A1_WhereA = where(I_A2_MinCenMax(Range::all(), 2) >= NCols, 1, 0);
// //  I_NIndA = 0;
// //  P_I_A1_Ind_WhereA = this->GetIndex(I_A1_WhereA, I_NIndA);
// //  if (I_NIndA > 0){
// //    for (int ii = 0; ii < P_I_A1_Ind_WhereA->size(); ii++)
// //      I_A2_MinCenMax((*P_I_A1_Ind_WhereA)(ii), 0) = NCols-1;
// //  }
// //  delete(P_I_A1_Ind_WhereA);


//  Array<int, 1> I_A1_NPixLeft(I_A2_MinCenMax.rows());
//  I_A1_NPixLeft = I_A2_MinCenMax(Range::all(),1) - I_A2_MinCenMax(Range::all(),0);
//  Array<int, 1> I_A1_NPixRight(I_A2_MinCenMax.rows());
//  I_A1_NPixRight = I_A2_MinCenMax(Range::all(),2) - I_A2_MinCenMax(Range::all(),1);
//  cout << "CFits::MkSlitFunc: I_A1_NPixLeft(=" << I_A1_NPixLeft << endl;
//  cout << "CFits::MkSlitFunc: I_A1_NPixRight(=" << I_A1_NPixRight << endl;
//  Array<int, 1> I_A1_I_NPixX(I_A2_MinCenMax.rows());
//  I_A1_I_NPixX = I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0) + 1;
//  cout << "CFits::MkSlitFunc: I_A1_I_NPixX = " << I_A1_I_NPixX << endl;
//  cout << "CFits::MkSlitFunc: I_A2_MinCenMax(*, 0)  = " << I_A2_MinCenMax(Range::all(), 0) << endl;

//  int I_MaxPixLeft = max(I_A1_NPixLeft);
//  int I_MaxPixRight = max(I_A1_NPixRight);
//  int I_MinPixLeft = min(I_A1_NPixLeft);
//  int I_MinPixRight = min(I_A1_NPixRight);

//  if (I_MaxPixLeft > I_MinPixLeft)
//    I_A2_MinCenMax(Range::all(),0) = I_A2_MinCenMax(Range::all(),1) - I_MaxPixLeft + I_NPixCut_Left;

//  if (I_MaxPixRight > I_MinPixRight)
//    I_A2_MinCenMax(Range::all(),2) = I_A2_MinCenMax(Range::all(),1) + I_MaxPixRight - I_NPixCut_Right;
//  cout << "CFits::MkSlitFunc: I_A2_MinCenMax = " << I_A2_MinCenMax << endl;
//  return false;
//  return false;


//  I_A1_ITempDiff = I_A1_ITemp - I_A1_IMax;
// #ifdef __DEBUG_FITS_MKSLITFUNC__
//  cout << "CFits::MkSlitFunc: I_A1_IMax set to " << I_A1_IMax << endl;
//  cout << "CFits::MkSlitFunc: I_A1_ITemp - I_A1_IMax set to " << I_A1_ITempDiff << endl;
//  (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IMax set to " << I_A1_IMax << endl;
// #endif

  /// Calculate boundaries of distinct slitf regions.

  /// Boundaries of bins
  ///  ibound = (x_right_lim - x_left_lim) * $
  ///           findgen(nbin+1) / nbin + x_left_lim  ;boundaries of bins
  I_A2_IBinBoundY.resize(I_NBins,2);
  I_A2_IBinBoundY = 0;
  I_A2_IBinBoundY(0,0) = int((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In));// + 1
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: 1. I_A2_IBound(0,0) set to " << I_A2_IBinBoundY(0,0) << endl;
  #endif
  int I_BinHeight_Temp = I_BinHeight;
  while(I_A2_IBinBoundY(0,0) < 0){
    I_A2_IBinBoundY(0,0)++;
    (*(this->P_D_A1_YLow))(I_IAperture_In)++;
    I_BinHeight_Temp--;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_A2_IBinBoundY(0,0) < 0: I_A2_IBoundY(0,0) set to " << I_A2_IBinBoundY(0,0) << endl;
    #endif
  }
  while(I_A2_MinCenMax(I_A2_IBinBoundY(0,0), 0) < 0){
    I_A2_IBinBoundY(0,0)++;
    (*(this->P_D_A1_YLow))(I_IAperture_In)++;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(0,0), 0) < 0: I_A2_IBoundY(0,0) set to " << I_A2_IBinBoundY(0,0) << endl;
    #endif
    I_BinHeight_Temp--;
  }
  while(I_A2_MinCenMax(I_A2_IBinBoundY(0,0), 2) >= this->NCols){
    I_A2_IBinBoundY(0,0)++;
    (*(this->P_D_A1_YLow))(I_IAperture_In)++;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(0,0), 2) >= this->NCols: I_A2_IBoundY(0,0) set to " << I_A2_IBinBoundY(0,0) << endl;
    #endif
    I_BinHeight_Temp--;
  }
  I_A2_IBinBoundY(0,1) = I_A2_IBinBoundY(0,0) + I_BinHeight_Temp - 1;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: I_A2_IBoundY(0,1) set to " << I_A2_IBinBoundY(0,1) << endl;
  #endif
  while(I_A2_IBinBoundY(0,1) >= this->NRows){
    I_A2_IBinBoundY(0,1)--;
    (*(this->P_D_A1_YHigh))(I_IAperture_In)--;
    I_BinHeight_Temp--;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_A2_IBinBoundY(0,1) >= NRows: I_A2_IBoundY(0,1) set to " << I_A2_IBinBoundY(0,1) << endl;
    #endif
  }
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "I_A2_IBinBoundY = " << I_A2_IBinBoundY << endl;
    cout << "I_A2_MinCenMax = " << I_A2_MinCenMax << endl;
    cout << "I_NBins = " << I_NBins << endl;
  #endif
  while(I_A2_MinCenMax(I_A2_IBinBoundY(0,1), 0) < 0){
    I_A2_IBinBoundY(0,1)--;
    (*(this->P_D_A1_YHigh))(I_IAperture_In)--;
    I_BinHeight_Temp--;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(0,1), 0) < 0: I_A2_IBoundY(0,1) set to " << I_A2_IBinBoundY(0,1) << endl;
    #endif
  }
  while(I_A2_MinCenMax(I_A2_IBinBoundY(0,1), 2) >= this->NCols){
    I_A2_IBinBoundY(0,1)--;
    (*(this->P_D_A1_YHigh))(I_IAperture_In)--;
    I_BinHeight_Temp--;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(0,1), 0) >= NCols: I_A2_IBoundY(0,1) set to " << I_A2_IBinBoundY(0,1) << endl;
    #endif
  }
  for (int i_bin = 1; i_bin < I_NBins; i_bin++){
    I_BinHeight_Temp = I_BinHeight;
    I_A2_IBinBoundY(i_bin,0) = I_A2_IBinBoundY(i_bin-1,0) + int(double(I_BinHeight) / 2.);
    while(I_A2_IBinBoundY(i_bin,0) < 0){
      I_A2_IBinBoundY(i_bin,0)++;
      I_BinHeight_Temp--;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: i_bin=" << i_bin << ": I_A2_IBinBoundY(" << i_bin << ",0) < 0: I_A2_IBoundY(i_bin,0) set to " << I_A2_IBinBoundY(i_bin,0) << endl;
      #endif
    }
    while(I_A2_MinCenMax(I_A2_IBinBoundY(i_bin,0), 0) < 0){
      I_A2_IBinBoundY(i_bin,0)++;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(i_bin,0), 0) < 0: I_A2_IBoundY(" << i_bin << ",0) set to " << I_A2_IBinBoundY(i_bin,0) << endl;
      #endif
      I_BinHeight_Temp--;
    }
    while(I_A2_MinCenMax(I_A2_IBinBoundY(i_bin,0), 2) >= this->NCols){
      I_A2_IBinBoundY(i_bin,0)++;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(i_bin,0), 2) >= this->NCols: I_A2_IBoundY(" << i_bin << ",0) set to " << I_A2_IBinBoundY(i_bin,0) << endl;
      #endif
      I_BinHeight_Temp--;
    }
    I_A2_IBinBoundY(i_bin,1) = I_A2_IBinBoundY(i_bin,0) + I_BinHeight_Temp;
    while(I_A2_IBinBoundY(i_bin,1) >= this->NRows){
      I_A2_IBinBoundY(i_bin,1)--;
      (*(this->P_D_A1_YHigh))(I_IAperture_In)--;
      I_BinHeight_Temp--;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_A2_IBinBoundY(" << i_bin << ",1) >= this->NRows: I_A2_IBoundY(" << i_bin << ",1) set to " << I_A2_IBinBoundY(i_bin,1) << endl;
      #endif
    }
    while(I_A2_MinCenMax(I_A2_IBinBoundY(i_bin,1), 2) >= this->NCols){
      I_A2_IBinBoundY(i_bin,1)--;
      (*(this->P_D_A1_YHigh))(I_IAperture_In)--;
      I_BinHeight_Temp--;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(0,1), 2) >= this->NCols: I_A2_IBoundY(" << i_bin << ",1) set to " << I_A2_IBinBoundY(i_bin,1) << endl;
      #endif
    }
    while(I_A2_MinCenMax(I_A2_IBinBoundY(i_bin,1), 0) < 0){
      I_A2_IBinBoundY(i_bin,1)--;
      (*(this->P_D_A1_YHigh))(I_IAperture_In)--;
      I_BinHeight_Temp--;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(" << i_bin << ",1), 0) < 0: I_A2_IBoundY(" << i_bin << ",1) set to " << I_A2_IBinBoundY(i_bin,1) << endl;
      #endif
    }
  }
  I_A2_IBinBoundY(I_NBins-1, 1) = int((*(this->P_D_A1_YCenter))(I_IAperture_In)+(*(this->P_D_A1_YHigh))(I_IAperture_In));
  while(I_A2_IBinBoundY(I_NBins-1,1) >= this->NRows){
    I_A2_IBinBoundY(I_NBins-1,1)--;
    (*(this->P_D_A1_YHigh))(I_IAperture_In)--;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_A2_IBinBoundY(" << I_NBins-1 << ",1) >= NRows: I_A2_IBoundY(" << I_NBins-1 << ",1) set to " << I_A2_IBinBoundY(I_NBins-1,1) << endl;
    #endif
  }
  while(I_A2_MinCenMax(I_A2_IBinBoundY(0,1), 2) >= this->NCols){
//        I_A2_IBinBoundY(I_NBins,1)--;
    I_A2_IBinBoundY(0,1)--;
    (*(this->P_D_A1_YHigh))(I_IAperture_In)--;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_A2_MinCenMax(I_A2_IBinBoundY(0,1), 2) >= NCols: I_A2_IBoundY(0,1) set to " << I_A2_IBinBoundY(0,1) << endl;
    #endif
  }
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: I_A2_IBoundY set to " << I_A2_IBinBoundY << endl;
    CString CS_BoundFN(DEBUGDIR);
    CS_BoundFN.Add(CString("I_A2_IBound.dat"));
    this->WriteArrayToFile(I_A2_IBinBoundY, CS_BoundFN, CString("ascii"));
//  return false;
    cout << "CFits::MkSlitFunc: I_A2_IBound set to " << I_A2_IBinBoundY << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: I_A2_IBound set to " << I_A2_IBinBoundY << endl;
    cout << "CFits::MkSlitFunc: *P_D_A1_YHigh(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A1_YHigh)(I_IAperture_In) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: *P_D_A1_YHigh(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A1_YHigh)(I_IAperture_In) << endl;
    cout << "CFits::MkSlitFunc: *P_D_A1_YLow(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A1_YLow)(I_IAperture_In) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: *P_D_A1_YLow(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A1_YLow)(I_IAperture_In) << endl;
    cout << "CFits::MkSlitFunc: I_NBin = " << I_NBins << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: I_NBin = " << I_NBins << endl;
  #endif

  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: this->NRows = " << this->NRows << endl;
    cout << "CFits::MkSlitFunc: I_NBins = " << I_NBins << endl;
    cout << "CFits::MkSlitFunc: I_BinHeight = " << I_BinHeight << endl;
    cout << "CFits::MkSlitFunc: I_BinHeight_Temp = " << I_BinHeight_Temp << endl;
    cout << "CFits::MkSlitFunc: I_A2_IBinBoundY = " << I_A2_IBinBoundY << endl;
    cout << "CFits::MkSlitFunc: I_A2_MinCenMax = " << I_A2_MinCenMax << endl;
  #endif
  D_A3_SFSM.resize(I_A2_IBinBoundY(I_NBins-1, 1) - I_A2_IBinBoundY(0,0)+1, max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1, I_NBins);
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A3_SFSM = " << D_A3_SFSM.rows() << " x " << D_A3_SFSM.cols() << " x " << I_NBins << endl;
  #endif
  if (I_A2_IBinBoundY(0,0) != (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In)){
    cout << "CFits::MkSlitFunc: ERROR: I_A2_IBound(0,0)=" << I_A2_IBinBoundY(0,0) << " != (*(this->P_D_A1_YCenter))(I_IAperture_In)(=" << (*(this->P_D_A1_YCenter))(I_IAperture_In) << ") + (*(this->P_D_A1_YLow))(I_IAperture_In)(=" << (*(this->P_D_A1_YLow))(I_IAperture_In) << ") = " << (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In) << " => Returning FALSE" << endl;
    return false;
  }
  if (I_A2_IBinBoundY(I_NBins-1,1) != (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In)){
    cout << "CFits::MkSlitFunc: ERROR: I_A2_IBound(I_NBin-1,1)=" << I_A2_IBinBoundY(I_NBins-1,1) << " != (*(this->P_D_A1_YCenter))(I_IAperture_In)(=" << (*(this->P_D_A1_YCenter))(I_IAperture_In) << ") + (*(this->P_D_A1_YHigh))(I_IAperture_In)(=" << (*(this->P_D_A1_YHigh))(I_IAperture_In) << ") = " << (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In) << " => Returning FALSE" << endl;
    return false;
  }
//  D_A3_SFSM.resize((*(this->P_D_A1_YHigh))(I_IAperture_In) - (*(this->P_D_A1_YLow))(I_IAperture_In)+1, max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1, I_NBin);
  D_A3_SFSM = 0.;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1 = " << max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1 << endl;
//  return false;
    cout << "CFits::MkSlitFunc: D_A3_SFSM set to " << D_A3_SFSM << endl;
  #endif
  D_A2_SP.resize(D_A3_SFSM.rows(), I_NBins);
  D_A2_SP = 0.;
  D_A2_Errors_SP_Out.resize(D_A3_SFSM.rows(), I_NBins);
  D_A2_Errors_SP_Out = 0.;
  D_A2_Sky.resize(D_A3_SFSM.rows(), I_NBins);
  D_A2_Sky = 0.;
  D_A2_ErrSky.resize(D_A3_SFSM.rows(), I_NBins);
  D_A2_ErrSky = 0.;
//  if (I_XCorProf > 0){
//    D_A2_XCorProf.resize(D_A3_SFSM.rows(), I_NBins);
//    D_A2_XCorProf = 0.;
//  }

//return false;
  /// Beginning of each bin
  ///  ibeg = ceil(ibound(0:nbin-1))                 ;beginning of each bin
//  I_A1_IBeg.resize(I_NBin);
//  D_A1_Temp.resize(I_NBin);
//  if (I_A2_IBound.rows() <= I_NBin)
//  {
//    cout << "CFits::MkSlitFunc: ERROR: D_A1_IBound.size(=" << D_A1_IBound.size() << ") < I_NBin(=" << I_NBin << ")" << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_IBound.size(=" << D_A1_IBound.size() << ") < I_NBin(=" << I_NBin << ")" << endl;
//    return false;
//  }
//  D_A1_Temp = I_A2_IBound(Range(0, I_NBin-1), 0);
//  Array<long, 1> *p_ceil = this->Ceil(D_A1_Temp);
//  Array<int, 1> *p_iceil = FixLI(*p_ceil);
//  I_A1_IBeg = (*p_iceil);
//  delete p_iceil;
//  delete p_ceil;
//  #ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: I_A1_IBeg set to " << I_A1_IBeg << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IBeg set to " << I_A1_IBeg << endl;
//    cout << "CFits::MkSlitFunc: P_D_A1_YLow = " << *P_D_A1_YLow << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_YLow = " << *P_D_A1_YLow << endl;
//  #endif

  /// beginning of 1st bin
  ///  ibeg(0) = x_left_lim
//  I_A1_IBeg(0) = int((*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YLow)(I_IAperture_In));
//  #ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: I_A1_IBeg(0) set to " << I_A1_IBeg(0) << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IBeg(0) set to " << I_A1_IBeg(0) << endl;
//  #endif

  /// End of each bin
  ///  iend = floor(ibound(1:nbin))                  ;end of each bin
//  I_A1_IEnd.resize(I_NBin);
//  Array<int, 1> *p_tempIntArrB = Fix(D_A1_IBound(Range(1, I_NBin)));
//  I_A1_IEnd = (*p_tempIntArrB);
//  delete p_tempIntArrB;
//  #ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: I_A1_IEnd set to " << I_A1_IEnd << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IEnd set to " << I_A1_IEnd << endl;
//  #endif
  ///  iend(nbin-1) = x_right_lim
//  I_A1_IEnd(I_NBin - 1) = (int)((*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In));
//  #ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: I_A1_IEnd(I_NBin - 1 = " << I_NBin - 1 << ") set to " << I_A1_IEnd(I_NBin - 1) << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IEnd(I_NBin - 1 = " << I_NBin - 1 << ") set to " << I_A1_IEnd(I_NBin - 1) << endl;
//  #endif

  /// Center of each bin
  ///  bincen = 0.5*(ibeg + iend)                    ;center of each bin
  D_A1_BinCen.resize(I_NBins);
  D_A1_BinCen = 0.5 * (I_A2_IBinBoundY(Range::all(), 0) + I_A2_IBinBoundY(Range::all(),1));
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A1_BinCen set to " << D_A1_BinCen << endl;
//  return false;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_BinCen set to " << D_A1_BinCen << endl;
//    return false;
  #endif
//return false;
  /**
  ;Initialize default parameters and arrays.
  if(keyword_set(osample)) then osamp=osample $ ;slitf pixels / real pixel
  else osamp = 14
  */
  /// Initialize default parameters and arrays.
  /*  CS_Temp.Set("OVERSAMPLE");
    if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
    {
      /// SlitF pixels / real pixel
      I_OverSample = *(int*)ArgV_In[I_Pos];
  #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
  #endif
    }
    if (I_Pos < 0 || (I_Pos >= 0 && I_OverSample == 0))
    {
      I_OverSample = 14;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
  #endif
  }*/
  //  (*P_OFS_Log) << "CFits::MkSlitFunc: 2. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

  ///  irow = findgen(nrow)                          ;indices of all rows
  /// Indices of all columns
  D_A1_ICol.resize(this->NCols);
  D_A1_ICol = i;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A1_ICol set to " << D_A1_ICol << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_ICol set to " << D_A1_ICol << endl;
  #endif

  ///  ycene = ycen(x_left_lim:x_right_lim)
  D_A1_XCentersE.resize(int((*this->P_D_A1_YHigh)(I_IAperture_In) - (*this->P_D_A1_YLow)(I_IAperture_In) + 1.));
  D_A1_XCentersE = D_A1_XCenters(Range((int)((*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YLow)(I_IAperture_In)), (int)((*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In))));
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A1_XCentersE set to " << D_A1_XCentersE << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XCentersE set to " << D_A1_XCentersE << endl;
  #endif

  ///  nysf = y_upper_lim + y_lower_lim + 1L
  /// subpixel range required
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
  #endif


  ///TODO: SF = 7.2 pix -> 0.9-8.1 -> 9 pixels, not 7+1!!!
///  I_NXSF = I_BinWidth;//(int)((*this->P_D_A1_XHigh)(I_IAperture_In) - (*this->P_D_A1_XLow)(I_IAperture_In)) + 1;
  I_NXSF = I_A2_MinCenMax(0,2) - I_A2_MinCenMax(0,0) + 1;// - I_NPixCut_Left - I_NPixCut_Right;
//  I_NXSF = max(I_A1_NPix);// + 1;// - I_NPixCut_Left - I_NPixCut_Right;
//  I_NXSF = (int)((*this->P_D_A1_XHigh)(I_IAperture_In)) - (int)((*this->P_D_A1_XLow)(I_IAperture_In)) + 1;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: I_NXSF set to " << I_NXSF << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: I_NXSF set to " << I_NXSF << endl;
    cout << "CFits::MkSlitFunc: max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1 = " << max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1 << endl;
  ///  yslitf0 = -y_lower_lim                        ;minimum value for yslitf
  /// Minimum value for I_A1_XSlitFunc
    cout << "CFits::MkSlitFunc: Setting I_XSlitFunc0: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: Setting I_XSlitFunc0: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
  #endif

  I_XSlitFunc0 = (int)((*this->P_D_A1_XLow)(I_IAperture_In));
  double D_XLow = (*this->P_D_A1_XLow)(I_IAperture_In);
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: I_XSlitFunc0 set to " << I_XSlitFunc0 << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: I_XSlitFunc0 set to " << I_XSlitFunc0 << endl;
  #endif
//  I_A1_IMin = (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) + (*this->P_D_A1_XLow)(I_IAperture_In); /// Left row of order

  ///  yslitf1 =  y_upper_lim                        ;maximum value for yslitf
  /// Maximum value for I_A1_XSlitFunc
  I_XSlitFunc1 = (int)(*this->P_D_A1_XHigh)(I_IAperture_In);
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: I_XSlitFunc1 set to " << I_XSlitFunc1 << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: I_XSlitFunc1 set to " << I_XSlitFunc1 << endl;
  #endif

  ///  blz = fltarr(ncol)
  P_D_A1_BLZ->resize(this->NRows);
  (*P_D_A1_BLZ) = 0.;

  ///  for i=0, nbin-1 do begin                 ;loop thru sf regions
  /// Calculate slit functions within each bin

  ///if keyword_set(TELLURIC) then cs_a1(0) = CString("TELLURIC")
//  cs_a1(pppos) = CString("PROF_OUT");
//  pppos++;


  //  (*P_OFS_Log) << "CFits::MkSlitFunc: 3. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

  D_A2_CCD_Ap.resize(D_A3_SFSM.rows(), D_A3_SFSM.cols());

//  Array<double, 2> D_A2_ErrAll(D_A3_SFSM.rows(), D_A3_SFSM.cols());
  D_A2_Err_AllRows.resize(this->NRows, D_A3_SFSM.cols());
  I_A2_Mask_AllRows.resize(this->NRows, D_A3_SFSM.cols());
  I_A2_Mask_AllRows = 1;
  D_A2_Err_AllRows = 0.;

  for (int I_IBin = 0; I_IBin < I_NBins; I_IBin++) /// Loop thru sf regions
  {
    if (I_Telluric == 3)
      B_MaximaOnly = true;

    ///    ib = ibeg(i)
    if (I_IBin >= I_A2_IBinBoundY.rows())
    {
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_IBin(=" << I_IBin << ") >= I_A2_IBound.rows(=" << I_A2_IBinBoundY.rows() << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_IBin(=" << I_IBin << ") >= I_A2_IBound.rows(=" << I_A2_IBinBoundY.rows() << ")" << endl;
      return false;
    }
//    I_IB = I_A2_IBound(I_IBin,0);    /// Lower row
//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): Resizing D_A2_SlitFunc_Im_In: I_IB set to " << I_IB << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): I_A2_IBound(I_IBin,0) set to " << I_A2_IBound(I_IBin,0) << endl;
//    #endif
    ///    ie = iend(i)
//    I_IE = I_A2_IBound(I_IBin,1);    /// Upper row
//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): Resizing D_A2_SlitFunc_Im_In: I_IE set to " << I_IE << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): I_IE set to " << I_IE << endl;
//    #endif
    ///    nc = ie - ib + 1                       ;number of columns
    I_NR = I_A2_IBinBoundY(I_IBin,1) - I_A2_IBinBoundY(I_IBin,0) + 1; /// Number of rows (Y-Direction)
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): Resizing D_A2_SlitFunc_Im_In: I_NR set to " << I_NR << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): I_NR set to " << I_NR << endl;
    #endif

//    int I_BinWidth = I_NR;//int((*P_D_A1_XHigh)(I_IAperture_In) - (*P_D_A1_XLow)(I_IAperture_In)) + 2;
//    cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_BinWidth set to " << I_BinWidth << endl;

    /// Load slit function data into vectors
    ///    nsf = nc * nysf                                          ;# slit func points
//    I_NSF = I_NR * I_NXSF;    /// # slit func points
//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): I_NSF set to I_NR(=" << I_NR << ") * I_NXSF(=" << I_NXSF << ") = " << I_NSF << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): I_NSF set to I_NR(=" << I_NR << ") * I_NXSF(=" << I_NXSF << ") = " << I_NSF << endl;
//    #endif
    ///    j0 = lonarr(nc)
//    I_A1_J0.resize(I_NR);
//    I_A1_J0 = 0;
    ///    j1 = lonarr(nc)
//    I_A1_J1.resize(I_NR);
//    I_A1_J1 = 0;
//#ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A1_J0 and I_A1_J1 initialized to " << I_A1_J0.size() << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A1_J0 and I_A1_J1 initialized to " << I_A1_J0.size() << endl;
//#endif
    /*#ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): Resizing D_A2_SlitFunc_Im_In: I_NR = " << I_NR << ", I_NXSF = " << I_NXSF << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): Resizing D_A2_SlitFunc_Im_In: I_NR = " << I_NR << ", I_NXSF = " << I_NXSF << endl;
    #endif
    */
    /*    if (I_NR < 1)
          I_NR = 1;
        if (I_NXSF < 1)
          I_NXSF = 1;
    */
    ///    sf = fltarr(nc,nysf)
    D_A2_SlitFunc_Im_In.resize(I_NR, I_NXSF);
    D_A2_SlitFunc_Im_In = 0.;
    if (this->ErrorsRead){
      D_A2_Err.resize(I_NR, I_NXSF);
      D_A2_Err = 0.;
    }
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SlitFunc_Im_In initialized to " << D_A2_SlitFunc_Im_In.rows() << " x " << D_A2_SlitFunc_Im_In.cols() << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SlitFunc_Im_In initialized to " << D_A2_SlitFunc_Im_In.rows() << " x " << D_A2_SlitFunc_Im_In.cols() << endl;
    #endif

    ///    sfpnt = fltarr(nsf)
//    D_A1_SFPnt.resize(I_NSF);
//    D_A1_SFPnt = 0.;
//#ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A1_SFPnt initialized to " << D_A1_SFPnt.size() << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A1_SFPnt initialized to " << D_A1_SFPnt.size() << endl;
//#endif

    ///    ysfpnt = fltarr(nsf)
//    D_A1_XSFPnt.resize(I_NSF);
//    D_A1_XSFPnt = 0.;
//#ifdef __DEBUG_FITS_MKSLITFUNC__
//    cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A1_XSFPnt initialized to " << D_A1_XSFPnt.size() << endl;
//    (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A1_XSFPnt initialized to " << D_A1_XSFPnt.size() << endl;
//#endif

    ///    if(imask) then msk = bytarr(nc,nysf)
//    if (I_IMask)
    I_A2_Msk.resize(I_NR, I_NXSF);
//    else
//      I_A2_Msk.resize(1, 1);

    I_A2_Msk = 1;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): I_A2_Msk initialized to " << I_A2_Msk.rows() << " x " << I_A2_Msk.cols() << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): I_A2_Msk initialized to " << I_A2_Msk.rows() << " x " << I_A2_Msk.cols() << endl;
    #endif



    if (max(*P_I_A2_MaskArray) > 1){
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_IBin=" << I_IBin << ": ERROR: max(P_I_A2_MaskArray) > 1" << endl;
      return false;
    }

    if (I_A2_IBinBoundY(I_IBin, 0) >= I_A2_IBinBoundY(I_IBin, 1)){
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin=" << I_IBin << ", 0)=" << I_A2_IBinBoundY(I_IBin, 0) << " >= I_A2_IBound(I_IBin, 1)=" << I_A2_IBinBoundY(I_IBin, 1) << " => Returning FALSE" << endl;
      return false;
    }
    D_A1_XCenMXC.resize(I_A2_IBinBoundY(I_IBin,1) - I_A2_IBinBoundY(I_IBin,0) + 1);
    if (I_A2_IBinBoundY(I_IBin,1) >= P_D_A2_XCenters->cols())
    {
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,1)(=" << I_A2_IBinBoundY(I_IBin,1) << ") >= P_D_A2_XCenters->cols(=" << P_D_A2_XCenters->cols() << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,1)(=" << I_A2_IBinBoundY(I_IBin,1) << ") >= P_D_A2_XCenters->cols(=" << P_D_A2_XCenters->cols() << ")" << endl;
      return false;
    }
    if (I_A2_IBinBoundY(I_IBin,1) >= I_A2_MinCenMax.rows())
    {
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,1)(=" << I_A2_IBinBoundY(I_IBin,1) << ") >= I_A2_MinCenMax.rows(=" << I_A2_MinCenMax.rows() << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,1)(=" << I_A2_IBinBoundY(I_IBin,1) << ") >= I_A2_MinCenMax.rows(=" << I_A2_MinCenMax.rows() << ")" << endl;
      return false;
    }







    D_A1_XCenMXC = D_A1_XCenters(Range(I_A2_IBinBoundY(I_IBin,0), I_A2_IBinBoundY(I_IBin,1))) - I_A2_MinCenMax(Range(I_A2_IBinBoundY(I_IBin,0), I_A2_IBinBoundY(I_IBin,1)),1);
    #ifdef __DEBUG_FITS_MkSLITFUNC_FILES__
      CString CS_D_A1_XCenMXC(DEBUGDIR);
      CS_D_A1_XCenMXC += CString("D_A1_XCenMXC.dat");
      this->WriteArrayToFile(D_A1_XCenMXC, CS_D_A1_XCenMXC, CString("ascii"));
      CS_D_A1_XCenMXC.Set(DEBUGDIR);
      CS_D_A1_XCenMXC += CString("P_D_A2_XCenters.dat");
      this->WriteArrayToFile((*(this->P_D_A2_XCenters))(0,Range(I_A2_IBinBoundY(I_IBin,0), I_A2_IBinBoundY(I_IBin,1))), CS_D_A1_XCenMXC, CString("ascii"));
    #endif
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin(=" << I_NBins << "); I_IBin++): D_A1_XCenMXC set to " << D_A1_XCenMXC << endl;//.transpose(secondDim, firstDim) << endl;
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin(=" << I_NBin << "); I_IBin++): Starting SlitFunc: D_A2_SlitFunc_Im_In = Im_In = " << D_A2_SlitFunc_Im_In << endl;//.transpose(secondDim, firstDim) << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin(=" << I_NBin << "); I_IBin++): Starting SlitFunc: D_A2_SlitFunc_Im_In = Im_In = " << D_A2_SlitFunc_Im_In << endl;//.transpose(secondDim, firstDim) << endl;
    #endif
    /// loop thru rows in region
    ///    for j=0, nc-1 do begin              ;loop thru rows in region
//    I_A2_IndexArrays.resize(I_NR, 2);
//    Array<int, 1> I_A1_Pix_SF_Beg(I_NR);
//    Array<int, 1> I_A1_Pix_SF_End(I_NR);
//    Array<int, 1> I_A1_NPix_SF(I_NR);
    for (int n = 0; n < I_NR; n++)
    {

      //      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 4. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

      /// column closest to peak
      ///      icen = yc(ib+j)                   ;row closest to peak
      if (I_A2_IBinBoundY(I_IBin,0) + n >= I_A2_MinCenMax.rows())
      {
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") >= I_A1_XC.rows(=" << I_A2_MinCenMax.rows() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") >= I_A2_MinCenMax.rows(=" << I_A2_MinCenMax.rows() << ")" << endl;
        return false;
      }
//      I_ICen = I_A2_MinCenMax(I_IB + n, 1);///(*P_I_A1_XC)(I_IB + n);
//      #ifdef __DEBUG_FITS_MKSLITFUNC__
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_ICen set to I_A2_MinCenMax(I_IB(=" << I_IB << ") + n(=" << n << ") = " << I_IB + n << ",1) = " << I_ICen << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_ICen set to " << I_ICen << endl;
//      #endif

      /// lowest column to consider
      ///      k0 = icen + yslitf0               ;lowest row to consider
      //I_K0 = I_A2_MinCenMax(I_IB + n, 0);//I_ICen + I_XSlitFunc0;
//      I_K0 = I_A2_MinCenMax(I_IB + n, 0);///I_ICen + I_XSlitFunc0;
//      #ifdef __DEBUG_FITS_MKSLITFUNC__
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A2_MinCenMax(I_IB + n, 0) set to I_A2_MinCenMax(I_IB + n, 0) = " << I_A2_MinCenMax(I_IB + n, 0) << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A2_MinCenMax(I_IB + n, 0) set to " << I_A2_MinCenMax(I_IB + n, 0) << endl;
//      #endif

      /// highest column to consider
      ///      k1 = icen + yslitf1               ;highest row to consider
//      I_K1 = I_ICen + I_XSlitFunc1;
//      I_K1 = I_A2_MinCenMax(I_IB + n, 2);//I_ICen + I_XSlitFunc1;
//      #ifdef __DEBUG_FITS_MKSLITFUNC__
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A2_MinCenMax(I_IB + n, 2) set to I_A2_MinCenMax(I_IB + n, 2) = " << I_A2_MinCenMax(I_IB + n, 2) << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A2_MinCenMax(I_IB + n, 2) set to " << I_A2_MinCenMax(I_IB + n, 2) << endl;
//      #endif
//      I_A2_IndexArrays(n,0) = I_A2_MinCenMax(I_IB + n, 0);
//      I_A2_IndexArrays(n,1) = I_A2_MinCenMax(I_IB + n, 2);

      /// beginning of storage area
      ///      j0(j) = j*nysf                    ;begining of storage area
//      if (n >= I_A1_J0.size())
//      {
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: n(=" << n << ") != I_A1_J0.size(=" << I_A1_J0.size() << ")" << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: n(=" << n << ") != I_A1_J0.size(=" << I_A1_J0.size() << ")" << endl;
//        return false;
//      }
//      I_A1_J0(n) = n * I_NXSF;
//#ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A1_J0(n) set to n * I_NXSF(=" << I_NXSF << ") = " << I_A1_J0(n) << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A1_J0(n) set to n * I_NXSF(=" << I_NXSF << ") = " << I_A1_J0(n) << endl;
//#endif

      /// new logic (works at edge)
      ///      j1(j) = j0(j) + k1 - k0           ;new logic (works at edge)
//      I_A1_J1(n) = I_A1_J0(n) + I_A2_MinCenMax(I_IB + n, 2) - I_A2_MinCenMax(I_IB + n, 0);
//#ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A1_J1(n) set to " << I_A1_J1(n) << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A1_J1(n) set to " << I_A1_J1(n) << endl;
//#endif
      D_A1_SSF.resize(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) - I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) + 1);
      D_A1_Err.resize(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) - I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) + 1);
      D_A1_Err = (*(const_cast<CFits*>(this)->P_D_A2_ErrArray))(I_A2_IBinBoundY(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2)));
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkScatter: for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_Err set to " << D_A1_Err << endl;
      #endif
      if (max(abs(D_A1_Err)) < 0.00000001){
        cout << "CFits::MkScatter: ERROR: max(abs(D_A1_Err))=" << max(abs(D_A1_Err)) << " < 0.00000001 => Returning FALSE" << endl;
        return false;
      }
      ///      if(keyword_set(no_scatter)) then begin
      CS_Temp.Set("NO_SCATTER");
      if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0 && *(int*)ArgV_In[I_Pos] != 0)
      {
        ///        ssf = im(ib+j,k0:k1)
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ":  for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): KeyWord_Set(NO_SCATTER): P_D_A2_PixArray has " << P_D_A2_PixArray->rows() << " and " << P_D_A2_PixArray->cols() << endl;
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ":  for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): KeyWord_Set(NO_SCATTER): I_A2_MinCenMax(I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") = " << I_A2_IBinBoundY(I_IBin,0) + n << ", 0) = " << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) << endl;
        #endif
	D_A1_SSF = (*(const_cast<CFits*>(this)->P_D_A2_PixArray))(I_A2_IBinBoundY(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2)));
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): KeyWord_Set(NO_SCATTER): D_A1_SSF set to " << D_A1_SSF << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): KeyWord_Set(NO_SCATTER): D_A1_SSF set to " << D_A1_SSF << endl;
        #endif
//      return false;
      }///      endif else begin
      else
      {
        /// Interpolate background
        ///        dy_scatter =   (dindgen(nysf) + k0 - yscatter_below(ib+j)) $
        D_A1_DXScatter.resize(I_NXSF);
        D_A1_DXScatter = i;

        if (I_A2_IBinBoundY(I_IBin,0) + n >= D_A1_XScatterBelow.size())
        {
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") >= D_A1_XScatterBelow.size(=" << D_A1_XScatterBelow.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") >= D_A1_XScatterBelow.size(=" << D_A1_XScatterBelow.size() << ")" << endl;
          return false;
        }
        if (I_A2_IBinBoundY(I_IBin,0) + n >= D_A1_XScatterAbove.size())
        {
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") >= D_A1_XScatterAbove.size(=" << D_A1_XScatterAbove.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") >= D_A1_XScatterAbove.size(=" << D_A1_XScatterAbove.size() << ")" << endl;
          return false;
        }
        D_A1_DXScatter += (double)I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) - D_A1_XScatterBelow(I_A2_IBinBoundY(I_IBin,0) + n);
        ///                     / (yscatter_above(ib+j) - yscatter_below(ib+j))
        D_A1_DXScatter /= (D_A1_XScatterAbove(I_A2_IBinBoundY(I_IBin,0) + n)
                           - D_A1_XScatterBelow(I_A2_IBinBoundY(I_IBin,0) + n));
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_DXScatter set to " << D_A1_DXScatter << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_DXScatter set to " << D_A1_DXScatter << endl;
        #endif
        ///        scatter = (scatter_above(ib+j)-scatter_below(ib+j))* $
        D_A1_Scatter.resize(I_NXSF);
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_ScatterAbove(I_A2_IBound(I_IBin,0)+n) = " << D_A1_ScatterAbove(I_A2_IBinBoundY(I_IBin,0)+n) << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_ScatterAbove(I_A2_IBound(I_IBin,0)+n) = " << D_A1_ScatterAbove(I_A2_IBinBoundY(I_IBin,0)+n) << endl;
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_ScatterBelow(I_A2_IBound(I_IBin,0)+n) = " << D_A1_ScatterBelow(I_A2_IBinBoundY(I_IBin,0)+n) << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_ScatterBelow(I_A2_IBound(I_IBin,0)+n) = " << D_A1_ScatterBelow(I_A2_IBinBoundY(I_IBin,0)+n) << endl;
        #endif

        D_A1_Scatter = D_A1_ScatterAbove(I_A2_IBinBoundY(I_IBin,0) + n) - D_A1_ScatterBelow(I_A2_IBinBoundY(I_IBin,0) + n);
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
        #endif
        ///                  * dy_scatter+scatter_below(ib+j)
        if (D_A1_Scatter.size() != D_A1_DXScatter.size())
        {
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_Scatter.size(=" << D_A1_Scatter.size() << ") != D_A1_DXScatter.size(=" << D_A1_DXScatter.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_Scatter.size(=" << D_A1_Scatter.size() << ") != D_A1_DXScatter.size(=" << D_A1_DXScatter.size() << ")" << endl;
          return false;
        }
        D_A1_Scatter *= D_A1_DXScatter;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
        #endif
        D_A1_Scatter += D_A1_ScatterBelow(I_A2_IBinBoundY(I_IBin,0) + n);
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
        #endif

        /// compute normalized slit func
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: this->P_D_A2_PixArray(I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") = " << I_A2_IBinBoundY(I_IBin,0) + n << ", Range(I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) << "), I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ") = " << Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2)) << ") = " << (*this->P_D_A2_PixArray)(I_A2_IBinBoundY(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2))) << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: this->P_D_A2_PixArray(I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ") = " << I_A2_IBinBoundY(I_IBin,0) + n << ", Range(I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) << "), I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ") = " << Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2)) << ") = " << (*this->P_D_A2_PixArray)(I_A2_IBinBoundY(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2))) << endl;
        #endif
        /// compute normalized slit func
        ///        ssf = (im(ib+j,k0:k1) - scatter)
        if (D_A1_Scatter.size() != D_A1_SSF.size())
        {
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_Scatter.size(=" << D_A1_Scatter << ") != D_A1_SSF.size(=" << D_A1_SSF.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_Scatter.size(=" << D_A1_Scatter << ") != D_A1_SSF.size(=" << D_A1_SSF.size() << ")" << endl;
          return false;
        }
        if (D_A1_SSF.size() != I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) - I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) + 1)
        {
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_SSF.size(=" << D_A1_SSF.size() << ") != I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ") - I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) << ") + 1" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_SSF.size(=" << D_A1_SSF.size() << ") != I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ") - I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) << ") + 1" << endl;
          return false;
        }
        if (this->P_D_A2_PixArray->rows() <= I_A2_IBinBoundY(I_IBin,0) + n)
        {
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: this->P_D_A2_PixArray.rows(=" << P_D_A2_PixArray->rows() << ") <= I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: this->P_D_A2_PixArray.rows(=" << P_D_A2_PixArray->rows() << ") <= I_A2_IBound(I_IBin,0)(=" << I_A2_IBinBoundY(I_IBin,0) << ") + n(=" << n << ")" << endl;
          return false;
        }
        if (this->P_D_A2_PixArray->cols() <= I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2))
        {
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: this->P_D_A2_PixArray->cols(=" << this->P_D_A2_PixArray->cols() << ") <= I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: this->P_D_A2_PixArray->cols(=" << this->P_D_A2_PixArray->cols() << ") <= I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ")" << endl;
          return false;
        }
        D_A1_SSF = (*(const_cast<CFits*>(this)->P_D_A2_PixArray))(I_A2_IBinBoundY(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2))) - D_A1_Scatter;
//        if (this->ErrorsRead)
//          D_A1_Err = (*(const_cast<CFits*>(this)->P_D_A2_ErrArray))(I_A2_IBound(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2))) - D_A1_Scatter;

        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_SSF set to " << D_A1_SSF << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_SSF set to " << D_A1_SSF << endl;
        #endif
        ///      endelse
      }/// end if (SCATTER)
//return false;
      ///      sf(j,*) = ssf
//      if (D_A2_SlitFunc_Im_In.cols() != D_A1_SSF.size())
//      {
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_SlitFunc_Im_In.cols(=" << D_A2_SlitFunc_Im_In.cols() << ") != D_A1_SSF.size(=" << D_A1_SSF.size() << ")" << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_SlitFunc_Im_In.cols(=" << D_A2_SlitFunc_Im_In.cols() << ") != D_A1_SSF.size(=" << D_A1_SSF.size() << ")" << endl;
//        return false;
//      }








      if (P_I_A2_MaskArray->cols() <= I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2))
      {
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: P_I_A2_Mask->cols(=" << P_I_A2_MaskArray->cols() << ") <= I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: P_I_A2_Mask->cols(=" << P_I_A2_MaskArray->cols() << ") <= I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)(=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ")" << endl;
        return false;
      }
      if (I_A2_IBinBoundY(I_IBin,0)+n >= P_I_A2_MaskArray->rows())
      {
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,0)+n(=" << I_A2_IBinBoundY(I_IBin,0)+n << ") >= P_I_A2_MaskArray->rows(=" << P_I_A2_MaskArray->rows() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin,0)+n(=" << I_A2_IBinBoundY(I_IBin,0)+n << ") >= P_I_A2_MaskArray->rows(=" << P_I_A2_MaskArray->rows() << ")" << endl;
        return false;
      }
//      I_A1_NPix_SF(n) = D_A2_SlitFunc_Im_In.cols();
//      int I_SF_CenPos = max(I_A1_NPixLeft);
//      I_A1_Pix_SF_Beg(n) = I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0);// - I_A1_NPixLeft(n);
//      I_A1_Pix_SF_End(n) = I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2);//I_SF_CenPos + I_A1_NPixRight(n);
//      if (I_A1_Pix_SF_Beg(n) > 0){
//        I_A1_NPix_SF(n)--;
//        I_A2_Msk(n, 0) = 0;
//        if (this->ErrorsRead)
//          D_A2_Err(n, 0) = 1.;
//      }
//      if (I_A1_Pix_SF_End(n) < D_A2_SlitFunc_Im_In.cols()-1){
//        I_A1_NPix_SF(n)--;
//        I_A2_Msk(n, I_A2_Msk.cols()-1) = 0;
//        if (this->ErrorsRead)
//          D_A2_Err(n, D_A2_Err.cols()-1) = 1.;
//      }
//      if (D_A1_SSF.size() != I_A1_NPix_SF(n)){
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_SSF.size()=" << D_A1_SSF.size() << " != I_A1_NPix_SF(n)=" << I_A1_NPix_SF(n) << " => Returning FALSE" << endl;
//        return false;
//      }
      ///(I_A2_IBound(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)))
      D_A2_SlitFunc_Im_In(n, Range::all()) = D_A1_SSF;
//      if ((0.5 * I_IBin * I_BinHeight) + n >= D_A2_CCD_Ap.rows()){
      if (I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0, 0) + n >= D_A2_CCD_Ap.rows()){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): (*(this->P_D_A1_YCenter))(I_IAperture_In) = " << (*(this->P_D_A1_YCenter))(I_IAperture_In) << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): (*(this->P_D_A1_YLow))(I_IAperture_In) = " << (*(this->P_D_A1_YLow))(I_IAperture_In) << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): (*(this->P_D_A1_YHigh))(I_IAperture_In) = " << (*(this->P_D_A1_YHigh))(I_IAperture_In) << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): (*(this->P_D_A1_YHigh))(I_IAperture_In) - (*(this->P_D_A1_YLow))(I_IAperture_In) + 1 = " << (*(this->P_D_A1_YHigh))(I_IAperture_In) - (*(this->P_D_A1_YLow))(I_IAperture_In) + 1 << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): D_A3_SFSM.rows() = " << D_A3_SFSM.rows() << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): I_BinHeight = " << I_BinHeight << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): I_NBin = " << I_NBins << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): I_A2_IBinBoundY(*,0) = " << I_A2_IBinBoundY(Range::all(), 0) << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): I_A2_IBinBoundY(*,1) = " << I_A2_IBinBoundY(Range::all(), 1) << endl;
	Array<int, 1> I_A1_IBinBoundYTemp(I_A2_IBinBoundY.rows());
	I_A1_IBinBoundYTemp = I_A2_IBinBoundY(Range::all(),1) - I_A2_IBinBoundY(Range::all(),0);
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): I_A2_IBinBoundY(*,1) - I_A2_IBinBoundY(*,0) = " << I_A1_IBinBoundYTemp << endl;

	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): I_A2_IBinBoundY(I_IBin, *) = " << I_A2_IBinBoundY(I_IBin, Range::all()) << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(I_IBin, 0) + 1 = " << I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(I_IBin, 0) + 1 << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int n = 0; n < I_NR(=" << I_NR << "; n++): ERROR: (0.5 * I_IBin * I_BinHeight(=" << I_BinHeight << ")) + n(=" << n << ") = " << (0.5 * I_IBin * I_BinHeight) + n << " D_A2_CCD_Ap.rows() = " << D_A2_CCD_Ap.rows() << " => Returning FALSE" << endl;
	return false;
      }
      if (D_A1_SSF.size() != D_A2_CCD_Ap.cols()){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_SSF.size() = " << D_A1_SSF.size() << " != D_A2_CCD_Ap.cols() = " << D_A2_CCD_Ap.cols() << " => Returning FALSE" << endl;
	return false;
      }
      D_A2_CCD_Ap(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0, 0) + n, Range::all()) = D_A1_SSF;
//      D_A2_ErrAll((0.5 * I_IBin * I_BinHeight) + n, Range::all()) = (*(const_cast<CFits*>(this)->P_D_A2_ErrArray))(I_A2_IBound(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)));
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": this->P_D_A2_ErrArray(I_A2_IBound(I_IBin,0)(=" << I_A2_IBound(I_IBin,0) << "), *) = " << (*(this->P_D_A2_ErrArray))(I_A2_IBound(I_IBin,0), Range::all()) << endl;
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_ErrAll((0.5 * I_IBin(=" << I_IBin << ") * I_BinHeight(" << I_BinHeight << ")) + n, Range::all()) set to " << D_A2_ErrAll((0.5 * I_IBin * I_BinHeight) + n, Range::all()) << endl;
//      return false;

      if (((I_A2_IBinBoundY(I_IBin, 0) + n) < 0) || ((I_A2_IBinBoundY(I_IBin, 0) + n) >= P_I_A2_MaskArray->rows())){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: ((I_A2_IBound(I_IBin, 0) + n)=" << I_A2_IBinBoundY(I_IBin, 0) + n << " < 0) || ((I_A2_IBound(I_IBin, 0) + n) >= P_I_A2_MaskArray->rows()=" << P_I_A2_MaskArray->rows() << ") => Returning FALSE" << endl;
	return false;
      }
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A2_MinCenMax(Range(I_A2_IBound(I_IBin, 0) + n, I_A2_IBound(I_IBin, 0) + n + 100)) = " << I_A2_MinCenMax(Range(I_A2_IBinBoundY(I_IBin, 0) + n, I_A2_IBinBoundY(I_IBin, 0) + n + 100)) << endl;
      #endif
      if ((I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin, 0) + n, 0) < 0) || (I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin, 0) + n, 0) >= P_I_A2_MaskArray->cols()) || (I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin, 0) + n, 0) >= I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2))){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: (I_A2_MinCenMax(I_A2_IBound(I_IBin=" << I_IBin << ", 0)=" << I_A2_IBinBoundY(I_IBin, 0) << " + n=" << n << " = " << I_A2_IBinBoundY(I_IBin, 0) + n << ", 0) = " << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin, 0) + n, 0) << " < 0) || (I_A2_MinCenMax(I_A2_IBound(I_IBin, 0) + n, 0) >= P_I_A2_MaskArray->cols()=" << P_I_A2_MaskArray->cols() << ") || (I_A2_MinCenMax(I_A2_IBound(I_IBin, 0) + n, 0) >= I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2)=" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << ") => Returning FALSE" << endl;
	return false;
      }
      I_A2_Msk(n, Range::all()) = (*P_I_A2_MaskArray)(I_A2_IBinBoundY(I_IBin,0) + n, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2)));
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        //cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SlitFunc_Im_In(n, Range(" << I_A1_Pix_SF_Beg(n) << ", " << I_A1_Pix_SF_End(n) << ")) set to " << D_A2_SlitFunc_Im_In(n, Range(I_A1_Pix_SF_Beg(n), I_A1_Pix_SF_End(n))) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_XCenters(" << I_A2_IBinBoundY(I_IBin,0) + n << ") = " << D_A1_XCenters(I_A2_IBinBoundY(I_IBin,0) + n) << endl;
	double D_Temp = D_A1_XCenters(I_A2_IBinBoundY(I_IBin,0) + n) + (*(this->P_D_A1_XLow))(I_IAperture_In);
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_XCenters(" << I_A2_IBinBoundY(I_IBin,0)+n << ") + P_D_A1_XLow(" << I_IAperture_In << ") = " << D_Temp << endl;
	D_Temp = D_A1_XCenters(I_A2_IBinBoundY(I_IBin,0) + n) + (*(this->P_D_A1_XHigh))(I_IAperture_In);
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_XCenters(" << I_A2_IBinBoundY(I_IBin,0)+n << ") + P_D_A1_XHigh(" << I_IAperture_In << ") = " << D_Temp << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, *) = " << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, Range::all()) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 0) = " << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 0) << ", I_A2_MinCenMax(I_A2_IBound(I_IBin,0) + n, 2) = " << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + n, 2) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A2_Msk(n, Range::all()) set to " << I_A2_Msk(n, Range::all()) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A2_Msk(n, Range::all()) set to " << I_A2_Msk(n, Range::all()) << endl;
      #endif
//      if (n == 18)
//	return false;
      if (max(I_A2_Msk(n, Range::all())) > 1){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A2_Msk(n=" << n << ", *) = " << I_A2_Msk(n, Range::all()) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: max(I_A2_Msk) > 1" << endl;
        return false;
      }
      if (this->ErrorsRead){
	Array<int, 1> I_A1_NPixX(I_A2_MinCenMax.rows());
	I_A1_NPixX = I_A2_MinCenMax(Range::all(), 2)  - I_A2_MinCenMax(Range::all(), 0) + 1;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A1_NPixX = " << I_A1_NPixX << endl;
        #endif
	if (D_A2_Err.cols() != D_A1_Err.size()){
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_Err.cols(=" << D_A2_Err.cols() << ") != D_A1_Err.size(=" << D_A1_Err.size() << ")" << endl;
	  return false;
	}
        D_A2_Err(n, Range::all()) = D_A1_Err;
	if (D_A2_Err_AllRows.cols() != D_A1_Err.size()){
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_Err_AllRows.cols(=" << D_A2_Err_AllRows.cols() << ") != D_A1_Err.size(=" << D_A1_Err.size() << ")" << endl;
	  return false;
	}
	if ((I_A2_IBinBoundY(I_IBin, 0) + n < 0) || (I_A2_IBinBoundY(I_IBin, 0) + n >= D_A2_Err_AllRows.rows())){
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: (I_A2_IBound(I_IBin=" << I_IBin << ", 0)=" << I_A2_IBinBoundY(I_IBin, 0) << " + n = " << I_A2_IBinBoundY(I_IBin, 0) + n << " < 0) || (I_A2_IBound(I_IBin, 0) + n >= D_A2_Err_AllRows.rows()=" << D_A2_Err_AllRows.rows() << ") => Returning FALSE" << endl;
	  return false;
	}
	D_A2_Err_AllRows(I_A2_IBinBoundY(I_IBin, 0) + n, Range::all()) = D_A1_Err;
      }
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SlitFunc_Im_In(n, 0) set to " << D_A2_SlitFunc_Im_In(n, 0) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SlitFunc_Im_In(n, D_A2_SlitFunc_Im_In.cols()-1) set to " << D_A2_SlitFunc_Im_In(n, D_A2_SlitFunc_Im_In.cols()-1) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBins << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SlitFunc_Im_In(n, *) set to " << D_A2_SlitFunc_Im_In(n, Range::all()) << endl;
      #endif
//      return false;
      ///      sfpnt(j0(j):j1(j)) = ssf
//      if (D_A1_SFPnt.size() <= I_A1_J1(n))
//      {
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ") <= I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ") <= I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << endl;
//        return false;
//      }
//      D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) = D_A1_SSF;
//#ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_SFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_SFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
//#endif

      ///      ysfpnt(j0(j):j1(j)) = irow(k0:k1) - ycen(ib+j)
//      if (D_A1_XSFPnt.size() <= I_A1_J1(n))
//      {
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_XSFPnt.size(=" << D_A1_XSFPnt.size() << ") <= I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_XSFPnt.size(=" << D_A1_XSFPnt.size() << ") <= I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << endl;
//        return false;
//      }
//      if (D_A1_ICol.size() <= I_A2_MinCenMax(I_IB + n, 2))
//      {
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_ICol.size(=" << D_A1_ICol.size() << ") <= I_A2_MinCenMax(I_IB + n, 2)(=" << I_A2_MinCenMax(I_IB + n, 2) << ")" << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A1_ICol.size(=" << D_A1_ICol.size() << ") <= I_A2_MinCenMax(I_IB + n, 2)(=" << I_A2_MinCenMax(I_IB + n, 2) << ")" << endl;
//        return false;
//      }
//      if (I_A2_MinCenMax(I_IB + n, 2) - I_A2_MinCenMax(I_IB + n, 0) != I_A1_J1(n) - I_A1_J0(n))
//      {
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_MinCenMax(I_IB + n, 2) - I_A2_MinCenMax(I_IB + n, 0) (=" << I_A2_MinCenMax(I_IB + n, 2) - I_A2_MinCenMax(I_IB + n, 0) << ") != I_A1_J1(n) - I_A1_J0(n) = " << I_A1_J1(n) - I_A1_J0(n) << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_MinCenMax(I_IB + n, 2) - I_A2_MinCenMax(I_IB + n, 0) (=" << I_A2_MinCenMax(I_IB + n, 2) - I_A2_MinCenMax(I_IB + n, 0) << ") != I_A1_J1(n) - I_A1_J0(n) = " << I_A1_J1(n) - I_A1_J0(n) << endl;
//        return false;
//      }
//      D_A1_XSFPnt(Range(I_A1_J0(n), I_A1_J1(n))) = D_A1_ICol(Range(I_A2_MinCenMax(I_IB + n, 0), I_A2_MinCenMax(I_IB + n, 2))) - (*P_D_A2_XCenters)(I_IAperture_In, I_IB + n);
//#ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_XSFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_XSFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin=" << I_NBin << "; I_IBin++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_XSFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_XSFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
//#endif
      ///      if(imask) then msk(j,*) = mask(ib+j,k0:k1)
//      if (I_IMask)
//      {
//      if (I_A2_Msk.cols() != I_A2_MinCenMax(I_IB + n, 2)-I_A2_MinCenMax(I_IB + n, 0)+1)
//      {
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_Msk.cols(=" << I_A2_Msk.cols() << ") != I_A2_MinCenMax(I_IB + n, 2)-I_A2_MinCenMax(I_IB + n, 0)+1(=" << I_A2_MinCenMax(I_IB + n, 2)-I_A2_MinCenMax(I_IB + n, 0)+1 << ")" << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_Msk.cols(=" << I_A2_Msk.cols() << ") != I_A2_MinCenMax(I_IB + n, 2)-I_A2_MinCenMax(I_IB + n, 0)+1(=" << I_A2_MinCenMax(I_IB + n, 2)-I_A2_MinCenMax(I_IB + n, 0)+1 << ")" << endl;
//        return false;
//      }
      if (n >= I_A2_Msk.rows())
      {
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: n(=" << n << ") >= I_A2_Msk.rows(=" << I_A2_Msk.rows() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: n(=" << n << ") >= I_A2_Msk.rows(=" << I_A2_Msk.rows() << ")" << endl;
        return false;
      }
      //}
      ///    endfor
    } /// for (int n = 0; n < I_NR; n++)
    if (max(I_A2_Msk) > 1){
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": A. I_A2_Msk = " << I_A2_Msk << endl;
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": A. ERROR: max(I_A2_Msk) = " << max(I_A2_Msk) << " > 1" << endl;
      return false;
    }

    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: D_A2_Err = " << D_A2_Err << endl;
    #endif
    D_A2_Err_Temp.resize(D_A2_Err.rows(), D_A2_Err.cols());
    D_A2_Err_Temp = D_A2_Err;
//    return false;



//    Array<double, 2> D_A2_SlitFuncTemp(I_NR, I_NXSF-I_NPixCut_Left-I_NPixCut_Right);
//    D_A2_SlitFuncTemp = D_A2_SlitFunc_Im_In(Range::all(), Range(I_NPixCut_Left, D_A2_SlitFunc_Im_In.cols()-1-I_NPixCut_Right));
//    D_A2_SlitFunc_Im_In.resize(I_NR, I_NXSF-I_NPixCut_Left-I_NPixCut_Right);
//    D_A2_SlitFunc_Im_In = D_A2_SlitFuncTemp;
//    if (this->ErrorsRead){
//      D_A2_SlitFuncTemp = D_A2_Err(Range::all(), Range(I_NPixCut_Left, D_A2_SlitFunc_Im_In.cols()-1-I_NPixCut_Right));
//      D_A2_Err.resize(I_NR, I_NXSF - I_NPixCut_Left - I_NPixCut_Right);
//      D_A2_Err = D_A2_SlitFuncTemp;
//    }
//    D_A2_SlitFuncTemp.resize(1,1);
//    Array<int, 2> I_A2_SlitFuncTemp(I_NR, I_NXSF-I_NPixCut_Left-I_NPixCut_Right);
//    I_A2_SlitFuncTemp = I_A2_Msk(Range::all(), Range(I_NPixCut_Left, D_A2_SlitFunc_Im_In.cols()-1-I_NPixCut_Right));
//    I_A2_Msk.resize(I_NR, I_NXSF - I_NPixCut_Left - I_NPixCut_Right);
//    I_A2_Msk = I_A2_SlitFuncTemp;
//    I_A2_SlitFuncTemp.resize(1,1);








    //    (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 5. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: I_A1_Pix_SF_Beg = " << I_A1_Pix_SF_Beg << endl;
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: I_A1_Pix_SF_End = " << I_A1_Pix_SF_End << endl;
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: I_A1_NPixLeft = " << I_A1_NPixLeft << endl;
//      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: I_A1_NPixRight = " << I_A1_NPixRight << endl;
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: I_A2_MinCenMax = " << I_A2_MinCenMax << endl;
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: D_A2_SlitFunc_Im_In(*,0) set to " << D_A2_SlitFunc_Im_In(Range::all(),0) << endl;
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: D_A2_SlitFunc_Im_In(*,ncols-1=" << D_A2_SlitFunc_Im_In.cols()-1 << ") set to " << D_A2_SlitFunc_Im_In(Range::all(),D_A2_SlitFunc_Im_In.cols()-1) << endl;
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: I_A2_Msk(*,0) set to " << I_A2_Msk(Range::all(), 0) << endl;
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": end for: I_A2_Msk(*,ncols-1=" << I_A2_Msk.cols()-1 << ") set to " << I_A2_Msk(Range::all(), I_A2_Msk.cols()-1) << endl;
      CString CS_TempA(DEBUGDIR);
      CS_TempA.Add(CString("I_A2_Msk.fits"));
      this->WriteFits(&I_A2_Msk, CS_TempA);
      CS_TempA.Set(CString("D_A2_SlitFunc_Im_In.fits"));
      this->WriteFits(&D_A2_SlitFunc_Im_In, CS_TempA);
    #endif
//    return false;

    D_A2_SlitFuncOrig.resize(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
    /// Backup original Slit Function
    D_A2_SlitFuncOrig = D_A2_SlitFunc_Im_In;
    ///      if(keyword_set(telluric)) then begin
    for (int p=0; p<D_A2_SlitFunc_Im_In.rows(); p++)
    {
      /// Set MySF to 0. where < 3.*(-RON)
      D_A2_SlitFunc_Im_In(p, Range::all()) = where(D_A2_SlitFunc_Im_In(p, Range::all()) < (3. * (0.-this->D_ReadOutNoise)), 0., D_A2_SlitFunc_Im_In(p, Range::all()));
    }
    if (I_Telluric == 1)///Piskunov
    {
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC), I_Telluric == 1" << endl;
      #endif
      D_A1_Sky.resize(D_A2_SlitFunc_Im_In.rows());
      D_A1_ErrSky.resize(D_A2_SlitFunc_Im_In.rows());
      ///      tel=total(sf,1)
      D_A1_Tel.resize(D_A2_SlitFunc_Im_In.cols());
      D_A1_Tel = sum(D_A2_SlitFunc_Im_In(j, i), j);
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A2_SlitFunc_Im_In(*,0) = " << D_A2_SlitFunc_Im_In(Range::all(),0) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A1_Tel set to " << D_A1_Tel.size() << ": " << D_A1_Tel << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A1_Tel set to " << D_A1_Tel << endl;
      #endif
      ///      itel=where(tel le (max(tel)-min(tel))/100.+min(tel),ntel)
      I_A1_ITel.resize(D_A1_Tel.size());
      I_A1_ITel = where(D_A1_Tel <= (max(D_A1_Tel) - min(D_A1_Tel))
                        / 100. + min(D_A1_Tel), 1, 0);
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): I_A1_ITel set to " << I_A1_ITel << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): I_A1_ITel set to " << I_A1_ITel << endl;
      #endif
      ///      tel=sf(*,itel)
      D_A2_Tel.resize(D_A2_SlitFunc_Im_In.rows(), sum(I_A1_ITel));
      D_A2_ErrTel.resize(D_A2_SlitFunc_Im_In.rows(), sum(I_A1_ITel));
      pos = 0;
      for (int o = 0; o < I_A1_ITel.size(); o++)
      {
        if (I_A1_ITel(o) == 1)
        {
          D_A2_Tel(Range::all(), pos) = D_A2_SlitFunc_Im_In(Range::all(), o);
          D_A2_ErrTel(Range::all(), pos) = D_A2_Err(Range::all(), o);
          pos++;
        }
      }
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A2_Tel set to " << D_A2_Tel << endl;//.transpose(secondDim, firstDim) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A2_Tel set to " << D_A2_Tel << endl;//.transpose(secondDim, firstDim) << endl;
      #endif
      /// ???????????????????????????????
      /// reform(transpose(array) => array) => row vector   ?????????????????????
      /// ???????????????????????????????

      ///      sc=dblarr(nc)
      D_A1_SC.resize(I_NR);
      D_A1_SC = 0.;

      if (this->ErrorsRead){
        I_A1_ErrInd.resize(D_A2_Tel.cols());
        D_A1_ErrTel.resize(I_NR);
        D_A1_ErrTel = 0.;
      }

      ///      for itel=0,nc-1 do $
      for (int o = 0; o < I_NR; o++)
      {
        ///        sc(itel)=median(reform(tel(itel,*)))
        if (o >= D_A2_Tel.rows())
        {
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: o(=" << o << ") >= D_A2_Tel.rows(=" << D_A2_Tel.rows() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: o(=" << o << ") >= D_A2_Tel.rows(=" << D_A2_Tel.rows() << ")" << endl;
          return false;
        }
        if (this->ErrorsRead){
          D_A1_ErrTelSub.resize(D_A2_ErrTel.cols());
	  D_A1_ErrTelSub = D_A2_ErrTel(o, Range::all());
          PP_Args_Median[1] = &D_A1_ErrTelSub;
        }
        D_A1_SC(o) = Median(D_A2_Tel(o, Range::all()), CS_A1_Args_Median, PP_Args_Median);
        if (this->ErrorsRead){
          D_A1_ErrSky(o) = D_Val_ErrOutMedian;
          D_A2_Err(o, Range::all()) += D_Val_ErrOutMedian;
	  D_A2_ErrTel(o, Range::all()) = D_A1_ErrTelSub;
        }
      }
      D_A1_Sky = D_A1_SC;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A1_SC set to " << D_A1_SC << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A1_SC set to " << D_A1_SC << endl;
      #endif
      //      if (D_A2_SlitFunc_Im_In.cols() == 0)
      //      {
      //        cout << "CFits::MkSlitFunc: D_A2_SlitFunc_Im_In.cols(=" << D_A2_SlitFunc_Im_In << ") == 0!!!" << endl;
      //        (*P_OFS_Log) << "CFits::MkSlitFunc: D_A2_SlitFunc_Im_In.cols(=" << D_A2_SlitFunc_Im_In << ") == 0!!!" << endl;
      //        D_A2_SlitFunc_Im_In.resizeAndPreserve(1, 1);
      //    }
      ///      sf = sf - sc#replicate(1,yslitf1-yslitf0+1)

      Array<double, 1> *p_tempDblVecArr = this->Replicate(1., I_A2_MinCenMax(0, 2) - I_A2_MinCenMax(0, 0) + 1);
      if (D_A2_SlitFunc_Im_In.cols() != p_tempDblVecArr->size()){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_SlitFunc_Im_In.cols()=" << D_A2_SlitFunc_Im_In.cols() << " != p_tempDblVecArr->size()=" <<  p_tempDblVecArr->size() << " => Returning FALSE" << endl;
	return false;
      }
//      D_A2_SlitFunc_Im_In.resizeAndPreserve(I_NR, p_tempDblVecArr->size());
      Array<double, 2> *p_d2mata = VecArrACrossB(D_A1_SC, *p_tempDblVecArr);

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): I_IBin = " << I_IBin << ": I_NR = " << I_NR << ", p_tempDblVecArr->size() = " << p_tempDblVecArr->size() << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): I_NR = " << I_NR << ", p_tempDblVecArr->size() = " << p_tempDblVecArr->size() << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A1_SC = " << D_A1_SC << ", VecArrACrossB(D_A1_SC, *p_tempDblVecArr) = " << *p_d2mata << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A1_SC = " << D_A1_SC << ", VecArrACrossB(D_A1_SC, *p_tempDblVecArr) = " << *p_d2mata << endl;
      #endif
      if (D_A2_SlitFunc_Im_In.rows() != D_A1_SC.size())
      {
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_SlitFunc_Im_In.rows(=" << D_A2_SlitFunc_Im_In.rows() << ") != D_A1_SC.size(=" << D_A1_SC.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_SlitFunc_Im_In.rows(=" << D_A2_SlitFunc_Im_In.rows() << ") != D_A1_SC.size(=" << D_A1_SC.size() << ")" << endl;
        return false;
      }
      if (D_A2_SlitFunc_Im_In.cols() != p_tempDblVecArr->size())
      {
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_SlitFunc_Im_In.cols(=" << D_A2_SlitFunc_Im_In.cols() << ") != p_tempDblVecArr->size(=" << p_tempDblVecArr->size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A2_SlitFunc_Im_In.cols(=" << D_A2_SlitFunc_Im_In.cols() << ") != p_tempDblVecArr->size(=" << p_tempDblVecArr->size() << ")" << endl;
        return false;
      }
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): p_d2mata = " << *p_d2mata << endl;//.transpose(secondDim, firstDim) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): p_d2mata = " << *p_d2mata << endl;//.transpose(secondDim, firstDim) << endl;
      #endif
      D_A2_SlitFunc_Im_In -= (*p_d2mata);
      delete p_tempDblVecArr;
      delete p_d2mata;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A2_SlitFunc_Im_In set to " << D_A2_SlitFunc_Im_In << endl;//.transpose(secondDim, firstDim) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A2_SlitFunc_Im_In set to " << D_A2_SlitFunc_Im_In << endl;//.transpose(secondDim, firstDim) << endl;
        CFits* p_tempfits = new CFits();
	CString CS_TempB(DEBUGDIR);
	CS_TempB.Add(CString("MkSlitFunc_TELLURIC_D_A2_SlitFunc_Im_In.fits"));
        p_tempfits->SetFileName(CS_TempB);
        p_tempfits->SetNRows(D_A2_SlitFunc_Im_In.rows());
        p_tempfits->SetNCols(D_A2_SlitFunc_Im_In.cols());
        p_tempfits->GetPixArray() = D_A2_SlitFunc_Im_In;
        p_tempfits->WriteArray();
        delete(p_tempfits);
      #endif

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_NR(=" << I_NR << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_NR(=" << I_NR << endl;

        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_NR(=" << I_NR << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_NR(=" << I_NR << endl;
      #endif
      /// replicate(1, yslitf1 - yslitf0 + 1) => dblarr(yslitf1 - yslitf0 + 1)
      /// sc#replicate(...) => dblarr(nc, yslitf1 - yslitf0 + 1)
      /// sf - sc#replicate(...) => dblarr(nc, yslitf1 - yslitf0 + 1)

      ///      sfpnt = reform(transpose(sf),n_elements(sfpnt))
      //      D_A1_SFPnt.resize(I_NR * I_A1_Temp.size());
//      if (D_A1_SFPnt.size() != D_A2_SlitFunc_Im_In.size())
//      {
//        cout << "CFits::MkSlitFunc: ERROR: D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ") != D_A2_SlitFunc_Im_In.size(=" << D_A2_SlitFunc_Im_In.size() << ")" << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ") != D_A2_SlitFunc_Im_In.size(=" << D_A2_SlitFunc_Im_In.size() << ")" << endl;
//        return false;
//      }
//      Array<double, 1> *p_D_A1_SFPnt = this->Reform(D_A2_SlitFunc_Im_In);
//      if (p_D_A1_SFPnt->size() != I_NSF)
//      {
//        cout << "CFits::MkSlitFunc: ERROR: p_D_A1_SFPnt->size(=" << p_D_A1_SFPnt->size() << ") != I_NSF(=" << I_NSF << ")" << endl;
//        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: p_D_A1_SFPnt->size(=" << p_D_A1_SFPnt->size() << ") != I_NSF(=" << I_NSF << ")" << endl;
//        return false;
//      }
//      D_A1_SFPnt = (*p_D_A1_SFPnt);
//      delete p_D_A1_SFPnt;

//#ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): MARK: D_A1_SFPnt set to " << D_A1_SFPnt << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): MARK: D_A1_SFPnt set to " << D_A1_SFPnt << endl;
//#endif
//return false;
// #endif


    } /// end if (I_Telluric == 1)
    else if (I_Telluric == 3){

      I_A2_Mask_Tel.resize(I_A2_Msk.rows(), I_A2_Msk.cols());
      I_A2_Mask_Tel = I_A2_Msk;
      if (max(I_A2_Mask_Tel) > 1){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 0. I_A2_Mask_TelTemp = " << I_A2_Mask_TelTemp << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 0. ERROR: max(I_A2_Mask_Tel = " << I_A2_Mask_Tel << ") = " << max(I_A2_Mask_Tel) << " > 1" << endl;
	return false;
      }

      Array<int, 1> *P_I_A1_UseRow_Tel = this->IndGenArr(I_A2_Msk.rows());
      I_A1_UseRow_Tel.resize(I_A2_Msk.rows());
      I_A1_UseRow_Tel = (*P_I_A1_UseRow_Tel);
      delete(P_I_A1_UseRow_Tel);

//      D_A2_ErrIn_Tel.resize(D_A2_Err.rows(), D_A2_Err.cols());
//      D_A2_ErrIn_Tel = D_A2_Err;

      D_A2_TempIm.resize(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());

      Array<int, 1> I_A1_MaxPos(D_A2_SlitFunc_Im_In.rows());
      I_A1_MaxPos = 0;
      Array<int, 1> I_A1_MaxPosCol(D_A2_SlitFunc_Im_In.cols());
      I_A1_MaxPosCol = 0;
      Array<int, 1> *P_I_A1_MaxPosColInd;
      int I_NMax = 0;

      D_A1_SFMax.resize(D_A2_SlitFunc_Im_In.rows());
      for (int p=0; p<D_A2_SlitFunc_Im_In.rows(); p++)
      {
        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: for(p(=" << p << "); p<D_A2_SlitFunc_Im_In.rows()=" << D_A2_SlitFunc_Im_In.rows() << "; p++): D_A2_SlitFunc_Im_In(p,*) = " << D_A2_SlitFunc_Im_In(p,Range::all()) << endl;
        #endif

        /// Set MySF to 0. where < 3.*(-RON)
///////////////////////////////////////////////////////////////////////////////////
//        D_A2_SlitFunc_Im_In(p, Range::all()) = where(D_A2_SlitFunc_Im_In(p, Range::all()) < (3. * (0.-this->D_ReadOutNoise)), 0., D_A2_SlitFunc_Im_In(p, Range::all()));

        /// Normalize rows of D_A2_SlitFunc_Im_In to 1.
        if (sum(D_A2_SlitFunc_Im_In(p, Range::all())) < 0.00000000000000001)
          D_A2_SlitFunc_Im_In(p, Range::all()) = 1.;
        D_A2_SlitFunc_Im_In(p,Range::all()) /= sum(D_A2_SlitFunc_Im_In(p,Range::all()));
        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: for(p(=" << p << ")...): D_A2_SlitFunc_Im_In(p,*) = " << D_A2_SlitFunc_Im_In(p,Range::all()) << endl;
        #endif

        /// Get maximum of D_A2_SlitFunc_Im_In for every row
        D_A1_SFMax(p) = max(D_A2_SlitFunc_Im_In(p,Range::all()));

	/// Find MaxPos
	I_A1_MaxPosCol = where(fabs(D_A2_SlitFunc_Im_In(p,Range::all()) - D_A1_SFMax(p)) < 0.000001,1,0);
	P_I_A1_MaxPosColInd = this->GetIndex(I_A1_MaxPosCol, I_NMax);
	I_A1_MaxPos(p) = (*P_I_A1_MaxPosColInd)(0);

        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: for(p(=" << p << ")...): D_A1_SFMax(p) = " << D_A1_SFMax(p) << endl;
        #endif
      }/// end for (int p=0; p<D_A2_SlitFunc_Im_In.rows(); p++)
      int I_MaxPos = this->Median(I_A1_MaxPos);
      for (int p=0; p<D_A2_SlitFunc_Im_In.rows(); p++){
        D_A1_SFMax(p) = max(D_A2_SlitFunc_Im_In(p,Range(I_MaxPos-1,I_MaxPos+1)));
      }
//    return false;
      #ifdef __DEBUG_FITS_TELLURIC__
        CString *P_CS_MySF = new CString(DEBUGDIR);
        CString *P_CS_MySFTemp;
	P_CS_MySF->Add(CString("MaxOnly_D_A2_SlitFunc_Im_In_Norm_IBin"));
        P_CS_MySFTemp = P_CS_MySF->IToA(I_IBin);
        P_CS_MySF->Add(*P_CS_MySFTemp);
        P_CS_MySF->Add(CString("Tel3.fits"));
        this->WriteFits(&D_A2_SlitFunc_Im_In, *P_CS_MySF);
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: File " << *P_CS_MySF << " written" << endl;
        delete(P_CS_MySF);
//        delete(P_CS_MySFTemp);
      #endif

      /// Median filter D_A1_SFMax
///      P_D_A1_SFMax = this->MedianVec(D_A1_SFMax,5);
///#ifdef __DEBUG_FITS_TELLURIC__
///      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): P_D_A1_SFMax = " << *P_D_A1_SFMax << endl;
///#endif

    /// remove elements with dev > 3. * stddev from D_A1_SFMax
///    dev=sqrt(total(msk*(imm-sp#sf)^2)/total(msk))
///  j=where(abs(imm-sp#sf) gt 3.*dev,nj)
///  if(nj gt 0) then begin
///    msk(j)=0B
/*      D_A2_SlitFunc_Im_In_Max.resize(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
      for (int nn=0; nn < D_A2_SlitFunc_Im_In.cols(); nn++)
      {
        P_D_A1_Col = this->MedianVec(D_A2_SlitFunc_Im_In(Range::all(), nn), 5);
        D_A2_SlitFunc_Im_In_Max(Range::all(), nn) = *P_D_A1_Col;
        delete(P_D_A1_Col);
      }

      /// --- re-normalize D_A2_SlitFunc_Im_In_Max
      for (int nn=0; nn < D_A2_SlitFunc_Im_In.rows(); nn++)
      {
        double sum_sf = sum(D_A2_SlitFunc_Im_In_Max(nn, Range::all()));
        if (sum_sf >= 0.00000000000000001)
          D_A2_SlitFunc_Im_In_Max(nn, Range::all()) /= sum_sf;
      }
      #ifdef __DEBUG_FITS_TELLURIC__
        P_CS_MySF = new CString(DEBUGDIR);
        P_CS_MySF->Add(CString("D_A2_SlitFunc_Im_In_Median"));
//        P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
//        *P_CS_MySF += *P_CS_MySFTemp;
        P_CS_MySF->Add(CString(".fits"));
        this->WriteFits(&D_A2_SlitFunc_Im_In_Max, *P_CS_MySF);
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: File " << *P_CS_MySF << " written" << endl;
        delete(P_CS_MySF);
//        delete(P_CS_MySFTemp);
      #endif
*/








/// /////////////////////////////////////////////////////////////////////////

//      D_A2_SlitFunc_Im_In = D_A2_SlitFunc_Im_In_Max;

/// /////////////////////////////////////////////////////////////////////////

















      /// TODO: ONLY TAKE HIGHEST VALUES, NOT MIDDLE ONES?!? <- Already did median filtering!
      /// --- remove elements from D_A1_SFMax which are outside the median value +/- 2sigma
      //P_I_A1_Ind = new Array<int, 1>(1);
      P_I_A1_Ind_Last = this->IndGenArr(D_A2_SlitFunc_Im_In.rows());
      I_A1_UseRow_Tel_AllRows.resize(D_A2_SlitFunc_Im_In.rows());
      I_A1_UseRow_Tel_AllRows = (*P_I_A1_Ind_Last);
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Telluric == 3: initialized *P_I_A1_Ind_Last = " << *P_I_A1_Ind_Last << endl;
      #endif
///      do{
        D_DevOld = D_DevTemp;
        D_DevTemp = sqrt(sum(pow((D_A1_SFMax) - Median(D_A1_SFMax),2)) / D_A1_SFMax.size());
        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: while: D_DevTemp set to " << D_DevTemp << endl;
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: while: Median(D_A1_SFMax) = " << Median(D_A1_SFMax) << endl;
        #endif
        I_A1_IndA.resize(D_A1_SFMax.size());


        /** ************************************/


	double D_MedianSFMax = Median(D_A1_SFMax);
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: D_A1_SFMax = " << D_A1_SFMax << endl;
	  cout << "CFits::MkSlitFunc: D_MedianSFMax = " << D_MedianSFMax << endl;
        #endif
        I_A1_IndA = where((D_A1_SFMax > D_MedianSFMax) & (D_A1_SFMax < 1.5 * D_MedianSFMax),1,0);
//        I_A1_IndA = where(fabs(D_A1_SFMax - Median(D_A1_SFMax)) < 4. * D_DevTemp,1,0);


        /** ************************************/



//        delete(P_I_A1_Ind);
	P_I_A1_Ind = this->GetIndex(I_A1_IndA, nind_temp);
        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::MkSlitFunc: nind_temp = " << nind_temp << endl;
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: while: I_A1_IndA set to " << I_A1_IndA << endl;
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: while: *P_I_A1_Ind set to " << *P_I_A1_Ind << endl;
        #endif
        Array<double, 2> D_A2_SFMax(2,2);
        this->GetSubArrCopy(D_A2_SlitFunc_Im_In,
                            *P_I_A1_Ind,
			    0,
                            D_A2_SFMax);
	Array<double, 1> *P_D_A1_SFMa;
	for (int i_c=0; i_c<D_A2_SlitFunc_Im_In.cols(); i_c++){
	  P_D_A1_SFMa = this->MedianVec(D_A2_SFMax(Range::all(), i_c),5);
	  D_A2_SFMax(Range::all(), i_c) = (*P_D_A1_SFMa);
	  delete(P_D_A1_SFMa);
	}
	for (int inde=0; inde<P_I_A1_Ind->size(); inde++){
	  D_A2_SlitFunc_Im_In((*P_I_A1_Ind)(inde), Range::all()) = D_A2_SFMax(inde, Range::all());
	}
        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: while: D_A1_SFMax set to " << D_A1_SFMax << endl;
        #endif


//	return false;


	I_A1_UseRow_TelTemp.resize(I_A1_UseRow_Tel.size());
	I_A1_UseRow_TelTemp = I_A1_UseRow_Tel;
	I_A1_UseRow_Tel.resize(P_I_A1_Ind->size());
	I_A2_Mask_TelTemp.resize(I_A2_Mask_Tel.rows(), I_A2_Mask_Tel.cols());
	I_A2_Mask_TelTemp = 0;
//	D_A2_ErrIn_TelTemp.resize(D_A2_ErrIn_Tel.rows(), D_A2_ErrIn_Tel.cols());
//        D_A2_SlitFunc_Im_In_MaxTemp.resize(D_A2_SlitFunc_Im_In_Max.rows(), D_A2_SlitFunc_Im_In_Max.cols());
//        D_A2_SlitFunc_Im_In_MaxTemp = D_A2_SlitFunc_Im_In_Max;
//	I_A2_Mask_TelTemp = I_A2_Mask_Tel;
//	D_A2_ErrIn_TelTemp = D_A2_ErrIn_Tel;
//        D_A2_SlitFunc_Im_In_Max.resize(P_I_A1_Ind->size(), D_A2_SlitFunc_Im_In.cols());
//	I_A2_Mask_Tel.resize(P_I_A1_Ind->size(), D_A2_SlitFunc_Im_In.cols());
//	D_A2_ErrIn_Tel.resize(P_I_A1_Ind->size(), D_A2_SlitFunc_Im_In.cols());
//        D_A1_XCenMXC_TelTemp.resize(D_A1_XCenMXC.size());
//	D_A1_XCenMXC_TelTemp = D_A1_XCenMXC;
//	D_A1_XCenMXC.resize(P_I_A1_Ind->size());
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Telluric == 3: *P_I_A1_Ind_Last = " << *P_I_A1_Ind_Last << endl;
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 1. I_A2_Mask_Tel = " << I_A2_Mask_Tel << endl;
        #endif
        if (max(I_A2_Mask_Tel) > 1){
  	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 1A. I_A2_Mask_TelTemp = " << I_A2_Mask_TelTemp << endl;
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 1A. ERROR: max(I_A2_Mask_Tel = " << I_A2_Mask_Tel << ") = " << max(I_A2_Mask_Tel) << " > 1" << endl;
	  return false;
        }
	for (int nnn=0; nnn<P_I_A1_Ind->size(); nnn++){
//          D_A2_SlitFunc_Im_In_Max(nnn,Range::all()) = D_A2_SlitFunc_Im_In_MaxTemp((*P_I_A1_Ind)(nnn), Range::all());
	  I_A2_Mask_TelTemp((*P_I_A1_Ind)(nnn),Range::all()) = I_A2_Mask_Tel((*P_I_A1_Ind)(nnn), Range::all());
//	  D_A2_ErrIn_Tel(nnn,Range::all()) = D_A2_ErrIn_TelTemp((*P_I_A1_Ind)(nnn), Range::all());
//	  D_A1_XCenMXC(nnn) = D_A1_XCenMXC_TelTemp((*P_I_A1_Ind)(nnn));
	  if ((*P_I_A1_Ind)(nnn) >= I_A1_UseRow_Tel_AllRows.size()){
	    cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: (*P_I_A1_Ind)(nnn=" << nnn << ")=" << (*P_I_A1_Ind)(nnn) << ") = " << (*P_I_A1_Ind)(nnn) << " >= I_A1_UseRow_Tel_AllRows.size()=" << I_A1_UseRow_Tel_AllRows.size() << endl;
	    return false;
	  }
	  I_A1_UseRow_Tel(nnn) = I_A1_UseRow_Tel_AllRows((*P_I_A1_Ind)(nnn));
	}
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          CString CS_TempC("P_I_A1_Ind_1.dat");
	  this->WriteArrayToFile(*P_I_A1_Ind, CS_TempC, CString("ascii"));
        #endif


	Array<double, 1> D_A1_SFMax_SumRows(D_A2_SlitFunc_Im_In.cols());
	Array<double, 2> D_A2_SlitFunc_Im_In_Times_Mask(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
	D_A2_SlitFunc_Im_In_Times_Mask = D_A2_SlitFunc_Im_In * I_A2_Mask_TelTemp;
	D_A1_SFMax_SumRows = sum(D_A2_SlitFunc_Im_In_Times_Mask(j,i),j);
	CString CS_SFMax_SumRows("SFMax_SumRows_");
	if (B_MaximaOnly){
          #ifdef __DEBUG_FITS_SLITFUNC_FILES__
            cout << "CFits::MkSlitFunc: B_MaximaOnly: D_A1_SFMax_SumRows = " << D_A1_SFMax_SumRows << endl;
          #endif
//	  return false;
	  CS_SFMax_SumRows.Add(CString("MaxOnly_"));
	}
	else{
          #ifdef __DEBUG_FITS_SLITFUNC_FILES__
            cout << "CFits::MkSlitFunc: !B_MaximaOnly: D_A1_SFMax_SumRows = " << D_A1_SFMax_SumRows << endl;
          #endif
	}
        #ifdef __DEBUG_FITS_SLITFUNC_FILES__
          CS_SFMax_SumRows.Add(CString("IBin"));
	  CString *P_CS_Tmp = CS_SFMax_SumRows.IToA(I_IBin);
	  CS_SFMax_SumRows.Add(*P_CS_Tmp);
	  delete(P_CS_Tmp);
          CS_SFMax_SumRows.Add(CString("_IRunTel"));
	  P_CS_Tmp = CS_SFMax_SumRows.IToA(I_Run_Tel);
	  CS_SFMax_SumRows.Add(*P_CS_Tmp);
	  delete(P_CS_Tmp);
          CS_SFMax_SumRows.Add(CString(".fits"));
          this->WriteFits(&D_A1_SFMax_SumRows, CS_SFMax_SumRows);
        #endif

//	I_A1_Ind_Temp.resize(P_I_A1_Ind_Last->size());
//	I_A1_Ind_Temp = (*P_I_A1_Ind_Last);
	P_I_A1_Ind_Last->resize(P_I_A1_Ind->size());
//	for (int llll=0; llll < P_I_A1_Ind->size(); llll++){
          (*P_I_A1_Ind_Last) = (*P_I_A1_Ind);
//	}
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 2. I_A2_Mask_TelTemp = " << I_A2_Mask_TelTemp << endl;
        #endif
	I_A2_Mask_Tel = I_A2_Mask_TelTemp;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 3. I_A2_Mask_Tel = " << I_A2_Mask_Tel << endl;
        #endif
        if (max(I_A2_Mask_Tel) > 1){
  	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 3A. I_A2_Mask_TelTemp = " << I_A2_Mask_TelTemp << endl;
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 3A. ERROR: max(I_A2_Mask_Tel = " << I_A2_Mask_Tel << ") = " << max(I_A2_Mask_Tel) << " > 1" << endl;
	  return false;
        }
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          D_A2_TempIm.resize(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SlitFunc_Im_In = " << D_A2_SlitFunc_Im_In << endl;
	  D_A2_TempIm = D_A2_SlitFunc_Im_In * I_A2_Mask_Tel;
	  CS_TempC.Set(DEBUGDIR);
	  CS_TempC.Add(CString("D_A2_SlitFunc_Im_In_Times_Mask_1.fits"));
          this->WriteFits(&D_A2_TempIm, CS_TempC);
	  D_A2_TempIm.resize(1,1);
        #endif
//        GetSubArrCopy(D_A2_SlitFunc_Im_In_MaxTemp, *P_I_A1_Ind, 0, D_A2_SlitFunc_Im_In_Max);
/*        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: while: D_A2_SlitFunc_Im_In_Max set to " << D_A2_SlitFunc_Im_In_Max << endl;
          P_CS_MySF = new CString(DEBUGDIR);
          P_CS_MySF->Add(CString("D_A2_SlitFunc_Im_In_Max"));
          //P_CS_MySFTemp = P_CS_MySF->IToA(I_Iter_Sky_Max);
          //*P_CS_MySF += *P_CS_MySFTemp;
          P_CS_MySF->Add(CString(".fits"));
          this->WriteFits(&D_A2_SlitFunc_Im_In_Max, *P_CS_MySF);
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: File " << *P_CS_MySF << " written" << endl;
          delete(P_CS_MySF);
//          delete(P_CS_MySFTemp);
///          I_Iter_Sky_Max++;
        #endif*/
//      } while (D_DevTemp - D_DevOld > D_DevTemp / 100.);
//return false;
      /// Get maximum of all maxima
//      double D_SFMax = max(D_A1_SFMax);
//      delete(P_D_A1_SFMax);

      /// Get index positions of D_A1_SFMax where D_A1_SFMax > D_SFMax - 2%
//      P_I_A1_SFMaxInd = this->Replicate(1, D_A1_SFMax.size());
//      I_A1_SFMaxInd.resize(D_A1_SFMax.size());
//      I_A1_SFMaxInd = *P_I_A1_SFMaxInd;
//      delete(P_I_A1_SFMaxInd);
//      I_A1_SFMaxInd = where(D_A1_SFMax > D_SFMax - (D_SFMax/20.),1,0);
///      I_A1_SFMaxInd = where(D_A1_SFMax > D_SFMax - ((D_SFMax - min(D_A1_SFMax))/50.),1,0);
//      #ifdef __DEBUG_FITS_TELLURIC__
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 3: D_SFMax = " << D_SFMax << endl;
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): I_A1_SFMaxInd = " << I_A1_SFMaxInd << endl;
//      #endif
//      P_I_A1_SFMaxInd = this->GetIndex(I_A1_SFMaxInd, I_NGood);
//      #ifdef __DEBUG_FITS_TELLURIC__
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): *P_I_A1_SFMaxInd = " << *P_I_A1_SFMaxInd << endl;
//      #endif

      /// Create SF array of the highest Slit Functions
//      D_A2_SlitFunc_Im_In_MaxTemp.resize(D_A2_SlitFunc_Im_In_Max.rows(), D_A2_SlitFunc_Im_In_Max.cols());
//      D_A2_SlitFunc_Im_In_MaxTemp = D_A2_SlitFunc_Im_In_Max;
//      D_A2_SlitFunc_Im_In_Max.resize(P_I_A1_SFMaxInd->size(), D_A2_SlitFunc_Im_In.cols());
//      GetSubArrCopy(D_A2_SlitFunc_Im_In_MaxTemp,
//                    *P_I_A1_SFMaxInd,
//                    0,
//                    D_A2_SlitFunc_Im_In_Max);
//      #ifdef __DEBUG_FITS_TELLURIC__
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): D_A2_SlitFunc_Im_In_Max = " << D_A2_SlitFunc_Im_In_Max << endl;
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): *P_I_A1_Ind = " << *P_I_A1_Ind << endl;
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": KeyWord_Set(TELLURIC): *P_I_A1_SFMaxInd = " << *P_I_A1_SFMaxInd << endl;
//        CString CS_TempD(DEBUGDIR);
//	CS_TempD.Add(CString("P_I_A1_Ind_2.dat"));
//	this->WriteArrayToFile(*P_I_A1_Ind, CS_TempD, CString("ascii"));
//        CS_TempD.Set(DEBUGDIR);
//	CS_TempD.Add(CString("P_I_A1_SFMaxInd.dat"));
//	this->WriteArrayToFile(*P_I_A1_SFMaxInd, CS_TempD, CString("ascii"));
//      #endif
//return false;

//      I_A2_Mask_TelTemp = 0;
//      D_A2_Ind_TempA.resize(P_I_A1_SFMaxInd->size(), 1);
//      #ifdef __DEBUG_FITS_MKSLITFUNC__
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 4. I_A2_Mask_Tel = " << I_A2_Mask_Tel << endl;
//      #endif
//      if (max(I_A2_Mask_Tel) > 1){
//	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 4A. ERROR: max(I_A2_Mask_Tel = " << I_A2_Mask_Tel << ") = " << max(I_A2_Mask_Tel) << " > 1" << endl;
//	return false;
//      }
//      for (int mmm=0; mmm < P_I_A1_SFMaxInd->size(); mmm++){
//	I_A2_Mask_TelTemp((*P_I_A1_Ind_Last)((*P_I_A1_SFMaxInd)(mmm)), Range::all()) = I_A2_Mask_Tel((*P_I_A1_Ind_Last)((*P_I_A1_SFMaxInd)(mmm)), Range::all());
//	D_A2_Ind_TempA(mmm,0) = (*P_I_A1_Ind_Last)((*P_I_A1_SFMaxInd)(mmm));
//      }
//      I_A2_Mask_Tel = I_A2_Mask_TelTemp;
//      if (max(I_A2_Mask_Tel) > 1){
//	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 5. I_A2_Mask_TelTemp = " << I_A2_Mask_TelTemp << endl;
//	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 5. ERROR: max(I_A2_Mask_Tel = " << I_A2_Mask_Tel << ") = " << max(I_A2_Mask_Tel) << " > 1" << endl;
//	return false;
//      }
//      #ifdef __DEBUG_FITS_MKSLITFUNC__
//        D_A2_TempIm.resize(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
//	D_A2_TempIm = D_A2_SlitFunc_Im_In * I_A2_Mask_Tel;
//	CString CS_TempE(DEBUGDIR);
//	CS_TempE.Add(CString("D_A2_SlitFunc_Im_In_Times_Mask_2.fits"));
//	this->WriteFits(&D_A2_TempIm, CS_TempE);
//	D_A2_TempIm.resize(1,1);
//	CS_TempE.Set(DEBUGDIR);
//	CS_TempE.Add(CString("P_I_A1_Ind_P_I_A1_SFMaxInd.fits"));
//        this->WriteArrayToFile(D_A2_Ind_TempA, CS_TempE, CString("ascii"));
//      #endif
//      return false;
//      I_A1_UseRow_TelTemp.resize(I_A1_UseRow_Tel.size());
//      I_A1_UseRow_TelTemp = I_A1_UseRow_Tel;
//      I_A1_UseRow_Tel.resize(P_I_A1_SFMaxInd->size());
//      for (int mmm=0; mmm < P_I_A1_SFMaxInd->size(); mmm++){
//	I_A1_UseRow_Tel(mmm) = I_A1_UseRow_TelTemp((*P_I_A1_SFMaxInd)(mmm));
//      }
//      #ifdef __DEBUG_FITS_TELLURIC__
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 2: P_I_A1_SFMaxInd set to " << *P_I_A1_SFMaxInd << endl;
//        P_CS_MySF = new CString(DEBUGDIR);
//        P_CS_MySF->Add(CString("D_A2_SlitFunc_Im_In_Max_Max"));
        //P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
        //*P_CS_MySF += *P_CS_MySFTemp;
//        P_CS_MySF->Add(CString(".fits"));
//        this->WriteFits(&D_A2_SlitFunc_Im_In_Max, *P_CS_MySF);
//        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": TELLURIC == 2: File " << *P_CS_MySF << " written" << endl;
//        delete(P_CS_MySF);
        //delete(P_CS_MySFTemp);
    //cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A2_SlitFunc_Im_In(I_A1_SFMaxInd = " << *P_I_A1_SFMaxInd << ",*) = " << D_A2_SlitFunc_Im_In_Max << endl;
//      #endif
//      delete(P_I_A1_SFMaxInd);*/
//      #ifdef __DEBUG_FITS_MKSLITFUNC__
//        D_A2_TempIm.resize(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
//	D_A2_TempIm = D_A2_SlitFunc_Im_In * I_A2_Mask_Tel;
//        CString CS_TempF(DEBUGDIR);
//	CS_TempF.Add(CString("D_A2_SlitFunc_Im_In_Times_Mask_Final.fits"));
//	this->WriteFits(&D_A2_TempIm, CS_TempF);
//	D_A2_TempIm.resize(0,0);
//      #endif
      delete(P_I_A1_Ind);
    }/// end else if (Telluric == 3)

//    D_A2_SFOut.resize(this->NRows, this->NCols);
//    D_A2_SFOut = 0.;
    //    CString **pp_cstr = (CString**)malloc(sizeof(CString*) * 8);

    /**
     *  ///if keyword_set(TELLURIC) then cs_a1(0) = CString("TELLURIC")
     *     if (I_XCorProf > 0){
     *      cs_a1(pppos) = CString("XCOR_PROF");
     *      args[pppos] = &I_XCorProf;
     *      cout << "args[pppos=" << pppos << "] set to I_XCorProf = " << *(int*)args[pppos] << endl;
     *      pppos++;
     *    }
     *    cs_a1(pppos) = CString("XCOR_PROF_OUT");
     *    args[pppos] = &D_A1_XCorProf_Out;
     *    pppos++;
     *
     *
     *  cs_a1(pppos) = CString("LAMBDA_SF");
     *  pppos++;
     *
     *  cs_a1(pppos) = CString("LAMBDA_SP");
     *  pppos++;
     *
     *  cs_a1(pppos) = CString("WING_SMOOTH_FACTOR");
     *  pppos++;
     *
     *  cs_a1(pppos) = CString("XLOW");
     *  pppos++;
     *
     *  cs_a1(pppos) = CString("SP_OUT");
     *  pppos++;
     *
     *  cs_a1(pppos) = CString("STOP");
     *  pppos++;
     *
     *  cs_a1(pppos) = CString("MASK");
     *  pppos++;
     *
     *  if (I_Telluric > 1)
     *  {
     *    cs_a1(pppos) = CString("SKY");
     *    pppos++;
     *    cs_a1(pppos) = CString("SP_FIT");
     *    pppos++;
     *     }
     *
     *     if (this->ErrorsRead){
     *       cs_a1(pppos) = CString("ERRORS");
     *       pppos++;
     *       cs_a1(pppos) = CString("ERRORS_OUT");
     *       pppos++;
     *       cs_a1(pppos) = CString("ERRORS_SP_OUT");
     *       pppos++;
     *       if (I_Telluric > 1)
     *       {
     *         cs_a1(pppos) = CString("ERR_SKY");
     *         pppos++;
     *       }
     *     }
     *     cs_a1(pppos) = CString("I_BIN");
     *     pppos++;
     **/

    I_RunMax = 1;
    if (I_Telluric > 2){
      I_RunMax = I_MaxIterSky;
      this->I_MaxIterSig = 0;
      B_MaximaOnly = true;
    }
    I_Run_Tel = 0;
    D_A2_SlitFunc_Im_In_Tel.resize(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
    D_A2_SlitFunc_Im_In_Tel = D_A2_SlitFunc_Im_In;
    D_A1_Sky_Temp.resize(D_A2_SlitFunc_Im_In.rows());
    D_A1_Sky_Temp = 0.;
    if (I_Telluric != 1){
      D_A1_Sky.resize(D_A1_Sky_Temp.size());
      D_A1_Sky = 0.;
    }
    D_A2_SFOld.resize(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
    D_A2_SFOld = 0.;
    D_SFDev = 0.;
    do{
      pppos = 0;
      if (I_Telluric > 0)
        pppos++;
      if (I_XCorProf > 0){
	pppos++;
	pppos++;
      }

//    cout << "CFits::MkSlitFunc: cs_a1(pppos) = " << cs_a1(pppos) << endl;
//    return false;

//      args[pppos] = &D_A2_SFOut;
//      pppos++;

      args[pppos] = &D_LambdaSF;
      pppos++;

      args[pppos] = &I_LambdaSP;
      pppos++;

      args[pppos] = &D_WingSmoothFactor;
      pppos++;


      args[pppos] = &D_XLow;
      pppos++;

      D_A1_SP_Out.resize(D_A2_SlitFunc_Im_In_Tel.rows());
      D_A1_SP_Out = 0.;
      args[pppos] = &D_A1_SP_Out;
      pppos++;

      I_Stop = 0;
//      if (I_IBin == 6)
//      I_Stop = 1;
//    I_Stop = 0;
      args[pppos] = &I_Stop;
      pppos++;

      I_A2_Mask.resize(I_A2_Msk.rows(), I_A2_Msk.cols());
      I_A2_Mask_Temp.resize(I_A2_Msk.rows(), I_A2_Msk.cols());
      if (I_Telluric < 3){
        I_A2_Mask_Temp = I_A2_Msk;
      }
      else{
	I_A2_Mask_Temp.resize(I_A2_Mask_Tel.rows(), I_A2_Mask_Tel.cols());
//        if (I_A2_Mask_Temp.rows() != I_A2_Mask_Tel.rows()){
//	  cout << "CFits::MkSlitFunc: ERROR: I_A2_Mask_Temp.rows() != I_A2_Mask_Tel.rows() => Returning FALSE" << endl;
//        }
//        if (I_A2_Mask_Temp.cols() != I_A2_Mask_Tel.cols()){
//          cout << "CFits::MkSlitFunc: ERROR: I_A2_Mask_Temp.cols() != I_A2_Mask_Tel.cols() => Returning FALSE" << endl;
//        }
        I_A2_Mask_Temp = I_A2_Mask_Tel;
      }
      I_A2_Mask = I_A2_Mask_Temp;
      I_A2_MaskApTemp.resize(I_A2_Mask.rows(), I_A2_Mask.cols());
      I_A2_MaskApTemp = I_A2_Mask_Temp;
      args[pppos] = &I_A2_Mask_Temp;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A2_Mask_Temp = " << I_A2_Mask_Temp << endl;//.transpose(secondDim, firstDim) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": args[" << pppos << "] set to " << *((Array<int, 2>*)(args[pppos])) << endl;
//	if (!B_MaximaOnly)
//          return false;
      #endif
      if (max(I_A2_Mask_Temp) > 1){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: A. max(I_A2_Mask_Temp = " << I_A2_Mask_Temp << ") > 1 => Returning FALSE" << endl;
	return false;
      }
      pppos++;

      if (I_Telluric > 1)
      {
	D_A1_Sky_Temp.resize(D_A2_SlitFunc_Im_In_Tel.rows());
	D_A1_Sky_Temp = 0.;
        args[pppos] = &D_A1_Sky_Temp;
        pppos++;
	D_A1_SPFit.resize(D_A2_SlitFunc_Im_In_Tel.rows());
	D_A1_SPFit = 0.;
        args[pppos] = &D_A1_SPFit;
        pppos++;
      }

      if (this->ErrorsRead){
/// **      if (I_Telluric < 2)
        args[pppos] = &D_A2_Err;
/// **      else
/// **        args[pppos] = &D_A2_ErrIn_Tel;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_Err = " << D_A2_Err << endl;//.transpose(secondDim, firstDim) << endl;
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": args[" << pppos << "] set to " << *((Array<double, 2>*)(args[pppos])) << endl;
//	  return false;
        #endif
        pppos++;

	D_A1_ErrOut.resize(D_A2_SlitFunc_Im_In_Tel.rows());
	D_A1_ErrOut = 0.;
        args[pppos] = &D_A1_ErrOut;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A1_ErrOut = " << D_A1_ErrOut << endl;//.transpose(secondDim, firstDim) << endl;
//          cout << "CFits::MkSlitFunc: args[" << pppos << "] set to " << *((Array<double, 1>*)(args[pppos])) << endl;
        #endif
        pppos++;

	D_A1_Errors_SP_Out.resize(D_A2_SlitFunc_Im_In_Tel.rows());
	D_A1_Errors_SP_Out = 0.;
        args[pppos] = &D_A1_Errors_SP_Out;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A1_Errors_SP_Out = " << D_A1_Errors_SP_Out << endl;//.transpose(secondDim, firstDim) << endl;
//          cout << "CFits::MkSlitFunc: args[" << pppos << "] set to " << *((Array<double, 1>*)(args[pppos])) << endl;
        #endif
        pppos++;

        if (I_Telluric > 1)
        {
	  D_A1_ErrSky.resize(D_A2_SlitFunc_Im_In_Tel.rows());
	  D_A1_ErrSky = 0.;
          args[pppos] = &D_A1_ErrSky;
          pppos++;
        }
      }

      args[pppos] = &I_IBin;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << endl;//.transpose(secondDim, firstDim) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": args[" << pppos << "] set to " << *((int*)(args[pppos])) << endl;
      #endif
      pppos++;

      cs_a1(pppos) = CString("DEBUGFILES_SUFFIX");
      CS_SF_DebugFilesSuffix.Set("_Ap");
      CString *P_CS_Num = CS_SF_DebugFilesSuffix.IToA(I_IAperture_In);
      CS_SF_DebugFilesSuffix.Add(*P_CS_Num);
      delete(P_CS_Num);
      CS_SF_DebugFilesSuffix.Add("_IBin");
      P_CS_Num = CS_SF_DebugFilesSuffix.IToA(I_IBin);
      CS_SF_DebugFilesSuffix.Add(*P_CS_Num);
      CS_SF_DebugFilesSuffix.Add(CString("_IRunTel"));
      delete(P_CS_Num);
      P_CS_Num = CS_SF_DebugFilesSuffix.IToA(I_Run_Tel);
      CS_SF_DebugFilesSuffix.Add(*P_CS_Num);
      CS_SF_DebugFilesSuffix.Add(CString("_Tel"));
      delete(P_CS_Num);
      P_CS_Num = CS_SF_DebugFilesSuffix.IToA(I_Telluric);
      CS_SF_DebugFilesSuffix.Add(*P_CS_Num);
      delete(P_CS_Num);
      if (B_MaximaOnly)
	CS_SF_DebugFilesSuffix.Add(CString("_MaxOnly"));
      args[pppos] = &CS_SF_DebugFilesSuffix;
      pppos++;
    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 6. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    ///slit_func,sf,
    ///          ycen(ib:ie)-yc(ib:ie),
    ///          sp,
    ///          sfsm,
    ///          NOISE=noise,
    ///          OVERSAMPLE=osamp,
    ///          IM_OUT=sfbin,
    ///          LAMBDA_SF=lambda_sf,
    ///          LAMBDA_SP=lambda_sp,
    ///          USE_COL=jgood,
    ///          BAD=jbad,
    ///          MASK=msk
    //    Array<double, 1> D_A1_SF(D_A2_SlitFunc_Im_In.cols());
    //    D_A1_SF = D_A2_SlitFunc_Im_In(0,Range::all());
//return false;

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 6.A this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": " << *P_CS_FileName << ": for (int I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin(=" << I_NBins << "); I_IBin++): I_IAperture_In = " << I_IAperture_In << ": Starting SlitFunc" << endl;//.transpose(secondDim, firstDim) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": " << *P_CS_FileName << ": for (int I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin(=" << I_NBins << "); I_IBin++): I_IAperture_In = " << I_IAperture_In << ": Starting SlitFunc" << endl;//.transpose(secondDim, firstDim) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin(=" << I_NBins << "); I_IBin++): I_IAperture_In = " << I_IAperture_In << ": D_A2_SlitFunc_Im_In_Tel = " << D_A2_SlitFunc_Im_In_Tel << endl;//.transpose(secondDim, firstDim) << endl;
      #endif
//return false;
      cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", I_IBin = " << I_IBin << ": starting SlitFunc" << endl;
      CString *P_CS_Tel;
      CString *P_CS_IRunTel;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        tempppos = 0;
        if (I_IBin < 100)
        {
          CS_TempNum.Set("0");
//      tmpstr[tempppos] = '0';
//      tempppos++;
        }
        if (I_IBin < 10)
        {
          CS_TempNum.Set("00");
//      tmpstr[tempppos] = '0';
//      tempppos++;
        }
        tempm = I_IBin;
        tempmt = I_IBin / 10;
        if (tempmt > 0)
        {
          P_CS_Temp = CS_TempNum.IToA(tempmt);
          CS_TempNum.Add(*P_CS_Temp);
          delete(P_CS_Temp);
          tempm -= 10 * tempmt;
        }
//      cout << "CFits::MkSlitFunc: tempm = " << tempm << endl;
        P_CS_Temp = CS_TempNum.IToA(tempm);
        CS_TempNum.Add(*P_CS_Temp);
        delete(P_CS_Temp);

        CString CS_FName_SF(CString("SlitFunc_SFIn_in_"));
	if (B_MaximaOnly)
	  CS_FName_SF.Add(CString("MaxOnly_"));
        CS_FName_SF.Add(CString("IBin"));
	CS_FName_SF.Add(CS_TempNum);
	P_CS_Tel = CS_FName_SF.IToA(I_Telluric);
	P_CS_IRunTel = CS_FName_SF.IToA(I_Run_Tel);
	CS_FName_SF.Add(CString("_Tel"));
	CS_FName_SF.Add(*P_CS_Tel);
	CS_FName_SF.Add(CString("_IRunTel"));
	CS_FName_SF.Add(*P_CS_IRunTel);
	CS_FName_SF.Add(CString(".fits"));
//        this->WriteFits(&D_A2_SlitFuncOrig,  CS_FName_SF + CString(".fits"));
        this->WriteFits(&D_A2_SlitFunc_Im_In_Tel,  CS_FName_SF);
	delete(P_CS_Tel);
	delete(P_CS_IRunTel);
      #endif

      Array<double, 2> D_A2_SlitFunc_Im_In_SumRows(D_A2_SlitFunc_Im_In.rows(), D_A2_SlitFunc_Im_In.cols());
      D_A2_SlitFunc_Im_In_SumRows = D_A2_SlitFunc_Im_In_Tel * I_A2_Mask_Temp;
      Array<double, 1> D_A1_SlitFunc_Im_In_SumRows(D_A2_SlitFunc_Im_In_SumRows.cols());
      D_A1_SlitFunc_Im_In_SumRows = sum(D_A2_SlitFunc_Im_In_SumRows(j,i),j);
      #ifdef __DEBUG_FITS_MkSLITFUNC_FILES__
        CString CS_Sum("SlitFuncImInTel_SumCols");
        CS_Sum.Add(CS_SF_DebugFilesSuffix);
        CS_Sum.Add(".fits");
        this->WriteFits(&D_A1_SlitFunc_Im_In_SumRows, CS_Sum);
      #endif
      if (!this->SlitFunc(D_A2_SlitFunc_Im_In_Tel,
                          I_IAperture_In,
                          D_A1_XCenMXC,
                          D_A1_SP,
                          D_A2_SFSM,
                          cs_a1,
                          args))
      {
        cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", I_IBin = " << I_IBin << ": ERROR: SlitFunc returned FALSE!" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: SlitFunc returned FALSE!" << endl;
        return false;
      }

//      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", I_IBin = " << I_IBin << ": D_A1_SP = " << D_A1_SP << endl;
        cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", I_IBin = " << I_IBin << ": D_A1_SP_Out = " << D_A1_SP_Out << endl;
        cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", I_IBin = " << I_IBin << ": D_A1_Errors_SP_Out = " << D_A1_Errors_SP_Out << endl;
//      #endif
      Array<double, 1> D_A1_SNR(D_A1_SP.size());
      D_A1_SNR = D_A1_SP / D_A1_SP_Out;
      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", I_IBin = " << I_IBin << ": D_A1_SP / D_A1_SP_Out = " << D_A1_SNR << endl;
      #endif
      D_A1_SNR = D_A1_SP_Out / D_A1_Errors_SP_Out;
      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", I_IBin = " << I_IBin << ": D_A1_SNR = " << D_A1_SNR << endl;
      #endif
//return false;



//      D_A1_SP = D_A1_SP_Out;




      #ifdef __DEBUG_FITS_MKSLITFUNC__
        Array<double, 2> D_A2_MaskTimesSlitFunc(I_A2_Mask_Temp.rows(), I_A2_Mask_Temp.cols());
        D_A2_MaskTimesSlitFunc = D_A2_SlitFunc_Im_In_Tel * I_A2_Mask_Temp;
        CString CS_MaskOut("SlitFuncTimesMask_just_after_SlitFunc");
        CS_MaskOut.Add(CS_SF_DebugFilesSuffix);
        CS_MaskOut.Add(CString(".fits"));
        if (!this->WriteFits(&D_A2_MaskTimesSlitFunc, CS_MaskOut)){
          cout << "CFits::MkSlitFunc: ERROR: WriteFits(I_A2_Mask_Temp, " << CS_MaskOut << ") returned FALSE" << endl;
          return false;
        }
      #endif
      I_A2_Mask = I_A2_Mask_Temp;
      I_A2_Mask_Temp = I_A2_MaskApTemp;
      if (!B_MaximaOnly){
        #ifdef __DEBUG_FITS_SLITFUNC_FILES__
          cout << "CFits::MkSlitFunc: !B_MaximaOnly: After SlitFunc: I_A2_Mask = " << I_A2_Mask <<  endl;
        #endif
//	return false;
      }

      cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", I_IBin = " << I_IBin << ": SlitFunc ready" << endl;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_IBin = " << I_IBin << ": D_A2_SFSM = " << D_A2_SFSM << endl;
        cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_IBin = " << I_IBin << ": After SlitFunc: D_A2_Err = " << D_A2_Err << endl;
      #endif
//      return false;
//      if (I_Telluric == 1)
//        return false;
      if (!B_MaximaOnly){
	if (D_A3_SFSM.cols() != D_A2_SFSM.cols()){
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_A3_SFSM.cols(=" << D_A3_SFSM.cols() << ") != D_A2_SFSM.cols(=" << D_A2_SFSM.cols() << ")" << endl;
	  return false;
	}
//	cout << "I_IBin = " << I_IBin << ": D_A3_SFSM = " << D_A3_SFSM << endl;
//	if (I_IBin == 1)
//          return false;
        if (I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0) - (I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0)) + 1 != D_A2_SFSM.rows()){
	  cout << "CFits::MkSlitFunc: ERROR: I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0) - (I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0)) + 1 (=" << I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0) - (I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0)) + 1 << ") != D_A2_SFSM.rows()=" << D_A2_SFSM.rows() << " => Returning FALSE" << endl;
	  return false;
	}
//	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SFSM = " << D_A2_SFSM << endl;
	D_A3_SFSM(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), Range::all(), I_IBin) = D_A2_SFSM;
//	cout << "CFits::MkSlitFunc: I_A2_IBinBoundY = " << I_A2_IBinBoundY << endl;
//	cout << "CFits::MkSlitFunc: D_A3_SFSM(Range(" << I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0) << ", " << I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0) << "), Range::all(), I_IBin=" << I_IBin << ") = " << D_A3_SFSM(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), Range::all(), I_IBin) << endl;
//	if (I_IBin > 0)
//          cout << "CFits::MkSlitFunc: D_A3_SFSM(Range(" << I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0) << ", " << I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0) << "), Range::all(), " << I_IBin-1 << ") = " << D_A3_SFSM(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), Range::all(), I_IBin-1) << endl;
//	if (I_IBin < I_NBins-1)
//          cout << "CFits::MkSlitFunc: D_A3_SFSM(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), Range::all(), I_IBin+1=" << I_IBin + 1 << ") = " << D_A3_SFSM(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), Range::all(), I_IBin+1) << endl;
//	if (I_IBin == 1)
//	  return false;

	D_A2_SP(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), I_IBin) = D_A1_SP;








	D_A2_Errors_SP_Out(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), I_IBin) = D_A1_Errors_SP_Out;




	//if (!B_MaximaOnly){
  	for (int i_row=0; i_row<I_A2_Mask.rows(); i_row++){
	  if (max(I_A2_Mask(i_row, Range::all())) == 1){
            #ifdef __DEBUG_FITS_MKSLITFUNC__
  	      cout << "CFits::MkSlitFunc: (*(this->P_I_A2_MaskArray))(" << I_A2_IBinBoundY(I_IBin, 0)+i_row << ", Range(" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0)+i_row, 0) << ", " << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin, 0)+i_row, 1) << ")) = " << (*(this->P_I_A2_MaskArray))(I_A2_IBinBoundY(I_IBin, 0)+i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0)+i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin, 0)+i_row, 1))) << endl;
            #endif
  	    for (int i_col=0; i_col<I_A2_Mask.cols(); i_col++){
	      if (I_A2_Mask(i_row, i_col) == 0)
                (*(this->P_I_A2_MaskArray))(I_A2_IBinBoundY(I_IBin, 0)+i_row,  I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0)+i_row, 0) + i_col) = I_A2_Mask(i_row, i_col);
 	    }
            #ifdef __DEBUG_FITS_MKSLITFUNC__
  	      cout << "CFits::MkSlitFunc: (*(this->P_I_A2_MaskArray))(" << I_A2_IBinBoundY(I_IBin, 0)+i_row << ", Range(" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0)+i_row, 0) << ", " << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin, 0)+i_row, 1) << ")) = " << (*(this->P_I_A2_MaskArray))(I_A2_IBinBoundY(I_IBin, 0)+i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0)+i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin, 0)+i_row, 1))) << endl;
            #endif
	  }
	}
//	  return false;

/**        if (I_XCorProf > 0){
	  CString CS_DebugFileName(DEBUGDIR);
	  CS_DebugFileName.Add(CString("D_A1_XCorProf_Out_"));
	  CS_DebugFileName.Add(CS_SF_DebugFilesSuffix);
	  CS_DebugFileName.Add(CString(".fits"));
	  this->WriteArrayToFile(D_A1_XCorProf_Out, CS_DebugFileName, CString("ascii"));
	  int I_NDeg = 5;
	  Array<double, 1> *P_D_A1_PolyCoeffs = new Array<double, 1>(6);
	  Array<CString, 1> CS_A1_Args_PolyFit(1);
	  CS_A1_Args_PolyFit(0) = CString("YFIT");
          void **PP_Args_PolyFit = (void**)malloc(sizeof(void*) * 1);
	  Array<double, 1> D_A1_Fit(D_A1_XCorProf_Out.size());
	  D_A1_Fit = 0.;
	  PP_Args_PolyFit[0] = &D_A1_Fit;
	  Array<double, 1> *P_D_A1_X = this->DIndGenArr(D_A1_XCorProf_Out.size());
	  if (!this->PolyFit(*P_D_A1_X, D_A1_XCorProf_Out, I_NDeg, CS_A1_Args_PolyFit, PP_Args_PolyFit, P_D_A1_PolyCoeffs)){
	    cout << "CFits::MkSlitFunc: ERROR: this->PolyFit(XCorProf) returned FALSE => Returning FALSE" << endl;
	    delete(P_D_A1_PolyCoeffs);
	    return false;
	  }
	  CS_DebugFileName.Set(DEBUGDIR);
	  CS_DebugFileName.Add(CString("D_A1_XCorProf_Fit_"));
	  CS_DebugFileName.Add(CS_SF_DebugFilesSuffix);
	  CS_DebugFileName.Add(CString(".fits"));
	  this->WriteArrayToFile(D_A1_Fit, CS_DebugFileName, CString("ascii"));
	  cout << "CFits::MkSlitFunc: after PolyFit: D_A1_XCorProf_Out = " << D_A1_XCorProf_Out << endl;
	  cout << "CFits::MkSlitFunc: after PolyFit: D_A1_Fit = " << D_A1_Fit << endl;
  	  D_A2_XCorProf(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), I_IBin) = D_A1_Fit;
	  Array<double, 1> D_A1_Diff(D_A1_XCorProf_Out.size());
	  D_A1_Diff = D_A1_XCorProf_Out - D_A1_Fit;
	  CS_DebugFileName.Set(DEBUGDIR);
	  CS_DebugFileName.Add(CString("D_A1_XCorProf_Diff_"));
	  CS_DebugFileName.Add(CS_SF_DebugFilesSuffix);
	  CS_DebugFileName.Add(CString(".fits"));
	  this->WriteArrayToFile(D_A1_Diff, CS_DebugFileName, CString("ascii"));
	  cout << "CFits::MkSlitFunc: after PolyFit: D_A1_Diff = " << D_A1_Diff << endl;
	  cout << "CFits::MkSlitFunc: after PolyFit: max(D_A1_Diff) = " << max(D_A1_Diff) << endl;
	  delete(P_D_A1_PolyCoeffs);
	  free(PP_Args_PolyFit);
	  if (I_Run_XCor == 1)
            return false;
	}**/
	if (I_Telluric == 1){
          D_A2_Sky(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), I_IBin) = D_A1_Sky;
          D_A2_ErrSky(Range(I_A2_IBinBoundY(I_IBin, 0) - I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(0,0)), I_IBin) = D_A1_ErrSky;
	}
      }/// end if (!B_MaximaOnly)
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_IAperture_In = " << I_IAperture_In << ", IBin = " << I_IBin << ": D_A2_SFSM set to " << D_A2_SFSM << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_IAperture_In = " << I_IAperture_In << ", IBin = " << I_IBin << ": D_A1_SP set to " << D_A1_SP << endl;
//        if (I_Telluric < 2)
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_IAperture_In = " << I_IAperture_In << ", IBin = " << I_IBin << ": I_A2_Mask_Temp set to " << I_A2_Mask_Temp << endl;
//        else
//          cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ", IBin = " << I_IBin << ": I_A2_Mask_Tel set to " << I_A2_Mask_Tel << endl;
      #endif
//return false;
///    double D_Mean_SF = mean(D_A2_SFOut);
///    cout << "CFits::MkSlitFunc: D_Mean_SF set to " << D_Mean_SF << endl;
///    double D_Max_SF = max(D_A2_SFOut);
///    cout << "CFits::MkSlitFunc: D_Max_SF set to " << D_Max_SF << endl;
//    if (I_IAperture_In == 2 && I_IBin == 6)
//      return false;

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": SlitFunc ready" << endl;

        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": After SlitFunc: D_A1_SP =  " << D_A1_SP << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": After SlitFunc: D_A1_SP = " << D_A1_SP << endl;

        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": After SlitFunc: D_A2_SFSM =  " << D_A2_SFSM << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": After SlitFunc: D_A2_SFSM = " << D_A2_SFSM << endl;

        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": After SlitFunc: D_A2_SFSM = Im_Out = " << D_A2_SFSM << endl;//.transpose(secondDim, firstDim) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": After SlitFunc: D_A2_SFSM = Im_Out = " << D_A2_SFSM << endl;//.transpose(secondDim, firstDim) << endl;
      #endif

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        CString CS_FNameOut(DEBUGDIR);
	CS_FNameOut.Add(CString("SlitFunc_SFSMOut_out"));
	CS_FNameOut.Add(CS_TempNum);
	CS_FNameOut.Add(CS_SF_DebugFilesSuffix);
	CS_FNameOut.Add(CString(".fits"));
        this->WriteFits(&D_A2_SFSM,  CS_FNameOut);
      #endif
//return false;
    /// Normalize sfpnt for the plot
/*      for (int n = 0; n < I_NR; n++)
      {

      //      (*P_OFS_Log) << "CFits::MkSlitFunc: 8. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

      ///      sfpnt(j0(j):j1(j)) = sfpnt(j0(j):j1(j)) / (sp(j)>1.)
        if (n >= D_A1_SP.size())
        {
          cout << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A1_SP.size(=" << D_A1_SP.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A1_SP.size(=" << D_A1_SP.size() << ")" << endl;
          return false;
        }
        d_tmp = D_A1_SP(n);
        if (d_tmp < 1.)
          d_tmp = 1.;

      ///      sfbin(j,*) = sfbin(j,*) / (sp(j)>1.)
        if (n >= D_A2_SFSM.rows())
        {
          cout << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A2_SFSM.rows(=" << D_A2_SFSM.rows() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A2_SFSM.rows(=" << D_A2_SFSM.rows() << ")" << endl;
          return false;
        }

        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: for (int n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SFSM(n, Range::all()) set to " << D_A2_SFSM(n, Range::all()) << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: for (int n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SFSM(n, Range::all()) set to " << D_A2_SFSM(n, Range::all()) << endl;
        #endif
      ///    endfor
      }/// end for (int n = 0; n < I_NR; n++)**/
//return false;
    ///    blz(ib:ie)=sp
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin(=" << I_NBins << "); I_IBin++): D_A1_SP = " << D_A1_SP << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": for (int I_IBin(=" << I_IBin << ") = 0; I_IBin < I_NBin(=" << I_NBins << "); I_IBin++): D_A1_SP = " << D_A1_SP << endl;
      #endif

      /// Save images to big arrays
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    D_A2_SFOut = where(D_A2_SFOut < 0., 0., D_A2_SFOut);
//    if (sum(I_A2_Msk) == I_A2_Msk.rows() * I_A2_Msk.cols()){
//      cout << "Mask didn't work" << endl;
//      return false;
//    }
//      for (int q=0; q < D_A2_SFOut.rows(); q++)
//        D_A2_SFOut(q, Range::all()) = D_A2_SFOut(q, Range::all()) / sum(D_A2_SFOut(q, Range::all()));

//      #ifdef __DEBUG_SEDM__
//        CString CS_FileName_SF_Out = CString(DEBUGDIR)+CString("SEDM_SF_Out_new.dat");
//        this->WriteArrayToFile(D_A2_SFOut,CS_FileName_SF_Out,CString("ascii"));
//    return false;
//      #endif

      if (I_Telluric == 3){/// Subtract minimum of each row > 0. from Slit Function
        double D_MinSF = 0.;
        for (int q=0; q<D_A2_SFSM.rows(); q++){


	  /// TODO: Only include pixels which are not marked as bad (old strategy with some border pixels equal to zero)
//	  Array<double, 1> D_A1_SF_FindMin(sum(I_A2_Mask_Temp(q, Range::all())));
//	  int I_PosTemp = 0;
//	  for (int w=0; w<I_A2_Mask_Temp.cols(); w++){
//	    if (I_A2_Mask_Temp(q,w) == 1){
//	      D_A1_SF_FindMin(I_PosTemp) = D_A2_SFOut(q,w);
//	      I_PosTemp++;
//	    }
//	  }

	  D_MinSF = min(D_A2_SFSM(q, Range::all()));
//	  D_MinSF = min(D_A1_SF_FindMin);
//	  D_MinSF = min(D_A2_SFOut(q, Range::all()));
//	  if (D_MinSF > 0.){
            D_A2_SFSM(q, Range::all()) = D_A2_SFSM(q, Range::all()) - D_MinSF;
//	    cout << "CFits::MkSlitFunc: D_A2_SFSM(" << q << ", *) set to " << D_A2_SFSM(q, Range::all()) << endl;
//	    for (int w=0; w<I_A2_Mask_Temp.cols(); w++){
//	      if (I_A2_Mask_Temp(q,w) == 0)
//		D_A2_SFOut(q,w) = 0.;
//	    }
//	  }
//	  if (D_MinSF < 0.){
//            D_A2_SFOut(q, Range::all()) = D_A2_SFOut(q, Range::all()) - D_MinSF;
//	    for (int w=0; w<I_A2_Mask_Temp.cols(); w++){
//	      if (I_A2_Mask_Temp(q,w) == 0)
//		D_A2_SFOut(q,w) = 0.;
//	    }
//	  }
	  double D_Sum_D_A2_SFSM = sum(D_A2_SFSM(q,Range::all()));
	  if (abs(D_Sum_D_A2_SFSM) < 0.00000000000000001){
	    cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: D_Sum_D_A2_SFSM == 0 => Returning FALSE" << endl;
	    return false;
	  }
          D_A2_SFSM(q, Range::all()) = D_A2_SFSM(q, Range::all()) / D_Sum_D_A2_SFSM;
          #ifdef __DEBUG_FITS_MKSLITFUNC__
            cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_Sum_D_A2_SFSM = " << D_Sum_D_A2_SFSM << endl;
            cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SFSM(q=" << q << ", *) set to " << D_A2_SFSM(q, Range::all()) << endl;
          #endif
//	    return false;
        }/// end for (int q=0; q<D_A2_SFSM.rows(); q++){
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          CString CS_FName("D_A2_SFOut_Tel3");
	  if (B_MaximaOnly)
	    CS_FName.Add(CString("_MaxOnly"));
	  CS_FName.Add(CString("_IRunTel"));
	  CString *P_CS_FNameT = CS_FName.IToA(I_Run_Tel);
	  CS_FName.Add(*P_CS_FNameT);
	  delete(P_CS_FNameT);
	  CS_FName.Add(CString(".fits"));
          this->WriteFits(&D_A2_SFSM, CS_FName);
        #endif
      }/// end if (I_Telluric == 3)

      this->CastIntArrToDblArr(I_A2_Mask, D_A2_Mask);
      if (fabs(mean(I_A2_Mask) - mean(D_A2_Mask)) > 0.000001){
        cout << "CFits::MkSlitFunc: ERROR: mean(I_A2_Mask)(=" << mean(I_A2_Mask) << ") != mean(D_A2_Mask)(=" << mean(D_A2_Mask) << ")" << endl;
        return false;
      }
      D_SFDev = sqrt(sum(pow2(D_A2_SFSM - D_A2_SFOld) * D_A2_Mask)/sum(D_A2_Mask));
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_Run_Tel = " << I_Run_Tel << ": D_SFDev = " << D_SFDev << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_Run_Tel = " << I_Run_Tel << ": mean(D_A2_SlitFunc_Im_In_Tel) / 1000. = " << mean(D_A2_SlitFunc_Im_In_Tel) / 1000. << endl;
      #endif
      D_A2_SFOld = D_A2_SFSM;

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Before Fit: 1. D_A2_Err = " << D_A2_Err << endl;
      #endif
//      return false;
      if (I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(I_IBin, 0) + 1 != I_A2_Mask.rows()){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin, 1) - I_A2_IBound(I_IBin, 0) + 1(=" << I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(I_IBin, 0) + 1 << ") != I_A2_Mask.rows())(=" << I_A2_Mask.rows() << ")" << endl;
//	cout << "CFits::MkSlitFunc: int(0.5 * I_IBin(=" << I_IBin << ") * I_BinHeight(=" << I_BinHeight << ")) = " << int(0.5 * I_IBin * I_BinHeight) << endl;
//	cout << "CFits::MkSlitFunc: int(0.5 * (I_IBin+1) * I_BinHeight)-1 = " << int(0.5 * (I_IBin+1) * I_BinHeight)-1 << endl;
	return false;
      }
      if (I_A2_Mask_AllRows.cols() != I_A2_Mask.cols()){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_Mask_AllRows.cols(=" << I_A2_Mask_AllRows.cols() << ") != I_A2_Mask.cols(=" << I_A2_Mask.cols() << ")" << endl;
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SFSM.cols() = " << D_A2_SFSM.cols() << endl;
	return false;
      }
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_Run_Tel = " << I_Run_Tel << ": I_IBin = " << I_IBin << ", I_A2_IBound = " << I_A2_IBinBoundY.rows() << " x " << I_A2_IBinBoundY.cols() << ", I_A2_IBound(I_IBin, *) = " << I_A2_IBinBoundY(I_IBin, Range::all()) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_Run_Tel = " << I_Run_Tel << ": I_IBin = " << I_IBin << ", I_A2_Mask_AllRows = " << I_A2_Mask_AllRows.rows() << " x " << I_A2_Mask_AllRows.cols() << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_Run_Tel = " << I_Run_Tel << ": I_IBin = " << I_IBin << ", I_A2_Mask = " << I_A2_Mask.rows() << " x " << I_A2_Mask.cols() << endl;
        cout << "CFits::MkSlitFunc: Before Fit: 2. D_A2_Err = " << D_A2_Err << endl;
      #endif
//      return false;

      if (I_A2_IBinBoundY(I_IBin, 0) < 0){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin=" << I_IBin << ", 0) = " << I_A2_IBinBoundY(I_IBin, 0) << " < 0 => Return false" << endl;
	return false;
      }
      if (I_A2_IBinBoundY(I_IBin, 1) >= I_A2_Mask_AllRows.rows()){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin=" << I_IBin << ", 1) = " << I_A2_IBinBoundY(I_IBin, 1) << " >= I_A2_Mask_AllRows.rows() = " << I_A2_Mask_AllRows.rows() << " => Returning FALSE" << endl;
	return false;
      }
      if (I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(I_IBin, 0) + 1 != I_A2_Mask.rows()){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_IBound(I_IBin=" << I_IBin << ", 1)(=" << I_A2_IBinBoundY(I_IBin, 1) << ") - I_A2_IBound(I_IBin, 0)(=" << I_A2_IBinBoundY(I_IBin, 0) << ") + 1 = " << I_A2_IBinBoundY(I_IBin, 1) - I_A2_IBinBoundY(I_IBin, 0) + 1 << " != I_A2_Mask.rows()=" << I_A2_Mask.rows() << " => Returning FALSE" << endl;
	return false;
      }
      if (I_A2_Mask_AllRows.cols() != I_A2_Mask.cols()){
	cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: I_A2_Mask_AllRows.cols()=" << I_A2_Mask_AllRows.cols() << " != I_A2_Mask.cols()=" << I_A2_Mask.cols() << " => Returning FALSE" << endl;
	return false;
      }
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_A2_Mask = " << I_A2_Mask << endl;
      #endif
      if (!B_MaximaOnly){
        for (int i_row=0; i_row<I_A2_Mask.rows(); i_row++){
          #ifdef __DEBUG_FITS_MKSLITFUNC__
            cout << "CFits::MkSlitFunc: I_A2_Mask_AllRows(" << I_A2_IBinBoundY(I_IBin, 0)+i_row << ", *) = " << I_A2_Mask_AllRows(I_A2_IBinBoundY(I_IBin, 0)+i_row, Range::all()) << endl;
          #endif
	  for (int i_col=0; i_col<I_A2_Mask.cols(); i_col++){
            if (I_A2_Mask(i_row, i_col) == 0)
              I_A2_Mask_AllRows(I_A2_IBinBoundY(I_IBin, 0)+i_row, i_col) = 0;
	  }
          #ifdef __DEBUG_FITS_MKSLITFUNC__
            cout << "CFits::MkSlitFunc: I_A2_Mask_AllRows(" << I_A2_IBinBoundY(I_IBin, 0)+i_row << ", *) = " << I_A2_Mask_AllRows(I_A2_IBinBoundY(I_IBin, 0)+i_row, Range::all()) << endl;
          #endif
        }
//        return false;
      }/// end if (!B_MaximaOnly)
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A2_Mask_AllRows(Range(" << I_A2_IBinBoundY(I_IBin, 0) << ", " << I_A2_IBinBoundY(I_IBin, 1) << "), Range::all()) set to I_A2_Mask = " << I_A2_Mask << endl;
      #endif
//      if (!B_MaximaOnly && I_IBin == 4)
//      return false;

//      cout << "CFits::MkSlitFunc: Before Fit: 3. D_A2_Err = " << D_A2_Err << endl;
//      return false;

      D_A2_Err.resize(D_A2_Err_Temp.rows(), D_A2_Err_Temp.cols());
      D_A2_Err = D_A2_Err_Temp;
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Before Fit: 4. D_A2_Err = " << D_A2_Err << endl;
      #endif
//      return false;
      if ((I_Run_Tel == (I_RunMax-1)) || (D_SFDev < mean(D_A2_SFSM) / 5000000.)){
        #ifdef __DEBUG_FITS_MKSLITFUNC__
  	  if (D_SFDev < mean(D_A2_SlitFunc_Im_In_Tel) / 5000000.){
	    if (B_MaximaOnly)
              cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": B_MaximaOnly==TRUE: D_SFDev = " << D_SFDev << ": mean(D_A2_SFSM) = " << mean(D_A2_SFSM) << endl;
	    else
              cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_SFDev = " << D_SFDev << ": mean(D_A2_SFSM) = " << mean(D_A2_SFSM) << endl;
//	  if (!B_MaximaOnly)
//            return false;
	  }
        #endif
	if (B_MaximaOnly){
  	  B_MaximaOnly = false;
          this->I_MaxIterSig = I_MaxIterSig_Temp;
//	  return false;
          if (I_Telluric == 3){
            I_Run_Tel = -1;
	    D_SFDev = 1.;
            I_A2_Mask_Tel = I_A2_Msk;
	    I_A2_Mask_Temp = I_A2_Msk;
            #ifdef __DEBUG_FITS_MKSLITFUNC__
	      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A2_Mask_Tel set to " << I_A2_Mask_Tel << endl;
            #endif
	    D_A2_SlitFunc_Im_In = D_A2_SlitFuncOrig;
	    D_A2_SlitFunc_Im_In_Tel = D_A2_SlitFuncOrig;
            #ifdef __DEBUG_FITS_MKSLITFUNC__
 	      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SlitFunc_Im_In_Tel set to " << D_A2_SlitFunc_Im_In_Tel << endl;
            #endif
//	    return false;
	    D_A1_Sky = 0.;
            #ifdef __DEBUG_FITS_MKSLITFUNC__
	      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SFSM = " << D_A2_SFSM << endl;
            #endif
//	    return false;
	  }
          else{
            I_Run_Tel = I_RunMax;
	  }
	}
        else{
          I_Run_Tel = I_RunMax;
        }
      }/// end if ((I_Run_Tel == (I_RunMax-1)) || (D_SFDev < mean(D_A2_SFSM) / 5000.))

      if (I_Telluric == 3){
        Array<CString, 1> CS_A1_Args_Fit(4);
        void **PP_Args_Fit;
        PP_Args_Fit = (void**)malloc(sizeof(void*) * 4);
        CS_A1_Args_Fit = CString(" ");

        if (D_A2_SlitFuncOrig.rows() != D_A2_Err.rows()){
          cout << "CFits::MkSlitFunc: ERROR: D_A2_SlitFuncOrig.rows() != D_A2_Err.rows()" << endl;
          return false;
        }
	if (this->ErrorsRead){
          CS_A1_Args_Fit(0) = CString("MEASURE_ERRORS_IN");
          PP_Args_Fit[0] = &D_A2_Err;
          #ifdef __DEBUG_FITS_MKSLITFUNC__
	    cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Just before Fit: D_A2_Err = " << D_A2_Err << endl;
          #endif
//	  return false;
	}

        if (D_A2_SlitFuncOrig.rows() != I_A2_Mask.rows()){
          cout << "CFits::MkSlitFunc: ERROR: D_A2_SlitFuncOrig.rows() != I_A2_Mask.rows()" << endl;
          return false;
        }
        CS_A1_Args_Fit(1) = CString("MASK_INOUT");
//        PP_Args_Fit[1] = &I_A2_Msk;
	/// TODO ????????????????????????????????????????????????
        PP_Args_Fit[1] = &I_A2_Mask;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Just before Fit: I_A2_Mask = " << I_A2_Mask << endl;
        #endif
//        if (!B_MaximaOnly && I_IBin == 4)
//        return false;

        CS_A1_Args_Fit(2) = CString("SIGMA_OUT");
        Array<double, 2> D_A2_Sigma_Fit(D_A2_SFSM.rows(),2);
	D_A2_Sigma_Fit = 0.;
        PP_Args_Fit[2] = &D_A2_Sigma_Fit;

        double D_Reject = 5.;
        CS_A1_Args_Fit(3) = CString("REJECT_IN");
        PP_Args_Fit[3] = &D_Reject;




	/// Use SlitFunc_Im_In for fit, and SlitFunc_im_in_tel for SlitFunc()
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": min(D_A2_SlitFunc_Im_In_Tel) = " << min(D_A2_SlitFunc_Im_In_Tel) << endl;
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Just before Fit: D_A2_SFSM = " << D_A2_SFSM << endl;
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Just before Fit: D_A2_SlitFuncOrig = " << D_A2_SlitFuncOrig << endl;
        #endif
//	if (I_Telluric == 1)
//	  return false;

        if (D_A2_SlitFuncOrig.rows() != D_A2_SFSM.rows()){
          cout << "CFits::MkSlitFunc: ERROR: D_A2_SlitFuncOrig.rows() != D_A2_SFSM.rows()" << endl;
          return false;
        }
        if (!this->LinFitBevington(D_A2_SlitFuncOrig,      ///: in
                                   D_A2_SFSM,             ///: in
                                   D_A1_SPFit,             ///: out
                                   D_A1_Sky_Temp,          ///: in/out
                                   true,                   ///: with sky: in
                                   CS_A1_Args_Fit,         ///: in
                                   PP_Args_Fit)){          ///: in/out
  /// MEASURE_ERRORS_IN = Array<double,2>(D_A2_CCD_In.rows, D_A2_CCD_In.cols) : in
  /// REJECT_IN = double                                                      : in
  /// MASK_INOUT = Array<double,2>(D_A1_CCD_In.rows,D_A1_CCD_In.cols)         : in/out
  /// CHISQ_OUT = Array<double,1>(D_A2_CCD_In.rows)                           : out
  /// Q_OUT = Array<double,1>(D_A2_CCD_In.rows)                               : out
  /// SIGMA_OUT = Array<double,2>(D_A2_CCD_In.rows, 2): [*,0]: sigma_sp, [*,1]: sigma_sky : out
          cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": 1. I_Telluric == 2: ERROR: this->Fit(...) returned FALSE => Returning FALSE" << endl;
	  return false;
        }
        #ifdef __DEBUG_FITS_MKSLITFUNC__
  	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": Just after Fit: D_A2_SFSM = " << D_A2_SFSM << endl;
        #endif
//	if (!B_MaximaOnly)
//	  return false;
        D_A1_Sky_Temp = where(D_A1_Sky_Temp < 0., 0., D_A1_Sky_Temp);
        D_A1_Sky = D_A1_Sky_Temp;

        #ifdef __DEBUG_FITS_MKSLITFUNC__
	  Array<double, 2> D_A2_MaskTimesSFOrig(D_A2_SlitFuncOrig.rows(), D_A2_SlitFuncOrig.cols());
	  D_A2_MaskTimesSFOrig = D_A2_SlitFuncOrig * I_A2_Mask;
  	  CString CS_MaskFitOut("SFOrigTimesMaskAfterFit");
          CS_MaskFitOut.Add(CS_SF_DebugFilesSuffix);
          CS_MaskFitOut.Add(".fits");
          this->WriteFits(&D_A2_MaskTimesSFOrig, CS_MaskFitOut);
        #endif


	///Remove sky from D_A2_SlitFunc_Im_In_Tel???
	double D_ImMin;
	for (int tttt=0; tttt<D_A2_SlitFunc_Im_In_Tel.rows(); tttt++){
	  D_A2_SlitFunc_Im_In_Tel(tttt, Range::all()) = D_A2_SlitFuncOrig(tttt, Range::all()) - D_A1_Sky(tttt);
	  for (int uuuu=0; uuuu<D_A2_SlitFunc_Im_In_Tel.cols(); uuuu++){
	    if (I_A2_Mask_Temp(tttt, uuuu) == 0)
	      D_A2_SlitFunc_Im_In_Tel(tttt, uuuu) = 0.;
	  }
          for (int uuuu=0; uuuu<D_A2_SlitFunc_Im_In_Tel.cols(); uuuu++){
            if (I_A2_Mask_Temp(tttt, uuuu) == 0)
	      D_A2_SlitFunc_Im_In_Tel(tttt, uuuu) = 0.;
	  }
	  D_ImMin = min(D_A2_SlitFunc_Im_In_Tel(tttt, Range::all()));
	  if (D_ImMin < 0. - (3. * this->D_ReadOutNoise)){
	    D_ImMin = D_ImMin + (3. * this->D_ReadOutNoise);
            #ifdef __DEBUG_FITS_MKSLITFUNC__
              cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": tttt=" << tttt << ": D_ImMin = " << D_ImMin << endl;
              cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": tttt=" << tttt << ": D_A2_SlitFunc_Im_In_Tel(tttt,*) = " << D_A2_SlitFunc_Im_In_Tel(tttt, Range::all()) << endl;
              cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": tttt=" << tttt << ": D_A1_Sky(tttt) = " << D_A1_Sky(tttt) << endl;
            #endif
	    D_A2_SlitFunc_Im_In_Tel(tttt, Range::all()) -= D_ImMin;
            #ifdef __DEBUG_FITS_MKSLITFUNC__
              cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": tttt=" << tttt << ": D_A2_SlitFunc_Im_In_Tel(tttt,*) set to " << D_A2_SlitFunc_Im_In_Tel(tttt, Range::all()) << endl;
            #endif
	    D_A1_Sky(tttt) += D_ImMin;
            #ifdef __DEBUG_FITS_MKSLITFUNC__
              cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": tttt=" << tttt << ": D_A1_Sky(tttt) set to " << D_A1_Sky(tttt) << endl;
            #endif
	      //	    return false;
	  }
	}


	#ifdef __DEBUG_FITS_MKSLITFUNC__
	  cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_Run_Tel = " << I_Run_Tel << ": after sky subtraction: min(D_A2_SlitFunc_Im_In_Tel) = " << min(D_A2_SlitFunc_Im_In_Tel) << endl;
        #endif

        #ifdef __DEBUG_FITS_MKSLITFUNC__
          CString CS_SPFit(DEBUGDIR);
	  CS_SPFit.Add(CString("D_A1_SPFit_"));
	  if (B_MaximaOnly)
	    CS_SPFit.Add(CString("MaxOnly_"));
	  CString* P_CS_Int = CS_SPFit.IToA(I_Run_Tel);
	  CS_SPFit.Add(*P_CS_Int);
	  CS_SPFit.Add(CString(".dat"));
	  this->WriteArrayToFile(D_A1_SPFit, CS_SPFit, CString("ascii"));
	  CString CS_SkyFit(DEBUGDIR);
	  CS_SkyFit.Add(CString("D_A1_SkyFit_"));
	  if (B_MaximaOnly)
	    CS_SkyFit.Add(CString("MaxOnly_"));
	  CS_SkyFit.Add(*P_CS_Int);
	  CS_SkyFit.Add(CString(".dat"));
	  this->WriteArrayToFile(D_A1_Sky, CS_SkyFit, CString("ascii"));
	  delete(P_CS_Int);
  	  CString CS_SlitFunc_Im_In_Tel(DEBUGDIR);
	  CS_SlitFunc_Im_In_Tel.Add(CString("D_A2_SlitFunc_Im_In_Tel_skySubtracted"));
          if (B_MaximaOnly)
            CS_SlitFunc_Im_In_Tel.Add(CString("_MaxOnly"));
          CString* P_CS_IntT = CS_SlitFunc_Im_In_Tel.IToA(I_Run_Tel);
	  CS_SlitFunc_Im_In_Tel.Add(*P_CS_IntT);
	  delete(P_CS_IntT);
	  CS_SlitFunc_Im_In_Tel.Add(CString(".fits"));
	  this->WriteFits(&D_A2_SlitFunc_Im_In_Tel, CS_SlitFunc_Im_In_Tel);
        #endif

	D_A1_ErrSky.resize(D_A1_SPFit.size());
        D_A1_ErrSky(Range::all()) = D_A2_Sigma_Fit(Range::all(),1);
//	if (I_A2_IBound(I_IBin, 1) - I_A2_IBound(0,0) - (I_A2_IBound(I_IBin, 0) - I_A2_IBound(0,0)) + 1 != D_A1_ErrOut.size()){
//	  cout << "CFits::MkSlitFunc: ERROR: Size is wrong" << endl;
//	  return false;
//	}
//	D_A2_ErrSky(Range(I_A2_IBound(I_IBin, 0) - I_A2_IBound(0,0), I_A2_IBound(I_IBin, 1) - I_A2_IBound(0,0)), I_IBin) = D_A1_ErrSky;

        D_A1_ErrOut.resize(D_A1_SPFit.size());
        D_A1_ErrOut(Range::all()) = D_A2_Sigma_Fit(Range::all(),0);
//	D_A2_ErrOut(Range(I_A2_IBound(I_IBin, 0) - I_A2_IBound(0,0), I_A2_IBound(I_IBin, 1) - I_A2_IBound(0,0)), I_IBin) = D_A1_ErrOut;
	D_A1_Sky_Temp = 0.;
	free(PP_Args_Fit);
      }/// end if (I_Telluric == 3)
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_Run_Tel = " << I_Run_Tel << endl;
      #endif
//      if (I_Run_Tel == 1 && !B_MaximaOnly)
//	return false;
      I_Run_Tel++;
///      if ((I_Run_Tel == (I_RunMax)) || (D_SFDev < mean(D_A2_SlitFunc_Im_In_Tel) / 5000.)){
///	if (B_MaximaOnly){
///  	  B_MaximaOnly = false;
///          if (I_Telluric > 1){
///            I_Run_Tel = 0;
///	    D_SFDev = 1.;
///            I_A2_Mask_Tel = I_A2_Msk;
///	    cout << "CFits::MkSlitFunc: I_A2_Mask_Tel set to " << I_A2_Mask_Tel << endl;
///	    D_A2_SFOld = D_A2_SFOut;
///	    D_A2_SlitFunc_Im_In = D_A2_SlitFuncOrig;
///	    D_A2_SlitFunc_Im_In_Tel = D_A2_SlitFuncOrig;
///	    cout << "CFits::MkSlitFunc: D_A2_SlitFunc_Im_In_Tel set to " << D_A2_SlitFunc_Im_In_Tel << endl;
/// //	    return false;
///	    D_A1_Sky = 0.;
///	  }
///          else{
///            I_Run_Tel = I_RunMax;
///	  }
///	}
///        else{
///          I_Run_Tel = I_RunMax;
///        }
///      }
    } while (I_Run_Tel < I_RunMax);

//    return false;













    for (int q=0; q < D_A1_SP.size(); q++){

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": D_A2_SFSM(q=" << q << ", Range::all()) = " << D_A2_SFSM(q, Range::all()) << ": P_D_A2_ProfArray(I_A2_IBound(I_IBin,0)+q=" << I_A2_IBinBoundY(I_IBin,0)+q << ", Range(" << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + q, 0) << ", " << I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + q, 2) << ")) set to " << (*P_D_A2_ProfArray)(I_A2_IBinBoundY(I_IBin,0) + q, Range(I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + q, 0), I_A2_MinCenMax(I_A2_IBinBoundY(I_IBin,0) + q, 2))) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": I_A2_Msk(q=" << q << ", Range::all()) = " << I_A2_Msk(q,Range::all()) << endl;
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": max(I_A2_Msk(q=" << q << ", Range::all())) = " << max(I_A2_Msk(q,Range::all())) << endl;
      #endif
      if (max(I_A2_Msk(q, Range::all())) > 1){
        cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: max(I_A2_Msk(q=" << q << ", Range::all())) > 1" << endl;
        return false;
      }
    }/// end for (int q=0; q < D_A1_SP.size(); q++)
    if (max(I_A2_Msk > 1)){
      cout << "CFits::MkSlitFunc: I_IBin = " << I_IBin << ": ERROR: max(I_A2_Msk=" << I_A2_Msk << ") > 1" << endl;
      return false;
    }
    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 11. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;
  } /// end for (int I_IBin = 0; I_IBin < I_NBin; I_IBin++) /// Loop thru sf regions






























  D_A1_Sky.resize(I_A2_IBinBoundY(I_NBins-1,1) - I_A2_IBinBoundY(0,0) + 1);
  D_A1_ErrSky.resize(I_A2_IBinBoundY(I_NBins-1,1) - I_A2_IBinBoundY(0,0) + 1);
  D_A1_SP.resize(I_A2_IBinBoundY(I_NBins-1,1) - I_A2_IBinBoundY(0,0) + 1);








  D_A1_Errors_SP_Out.resize(I_A2_IBinBoundY(I_NBins-1,1) - I_A2_IBinBoundY(0,0) + 1);







//  if (I_XCorProf > 0)
//    D_A1_XCorProf_Out.resize(I_A2_IBinBoundY(I_NBins-1,1) - I_A2_IBinBoundY(0,0) + 1);
  D_A2_SF.resize(I_A2_IBinBoundY(I_NBins-1,1) - I_A2_IBinBoundY(0,0) + 1, max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1);
  if (D_A1_SP.size() != D_A2_SP.rows()){
    cout << "CFits::MkSlitFunc: ERROR: D_A1_SP.size(=" << D_A1_SP.size() << ") != D_A2_SP.rows(= " << D_A2_SP.rows() << ")" << endl;
    return false;
  }
  if (D_A2_SF.rows() != D_A3_SFSM.rows()){
    cout << "CFits::MkSlitFunc: ERROR: D_A2_SF.rows(=" << D_A2_SF.rows() << ") != D_A3_SFSM.rows(= " << D_A3_SFSM.rows() << ")" << endl;
    return false;
  }
  if (D_A2_SF.cols() != D_A3_SFSM.cols()){
    cout << "CFits::MkSlitFunc: ERROR: D_A2_SF.cols(=" << D_A2_SF.cols() << ") != D_A3_SFSM.cols(= " << D_A3_SFSM.cols() << ")" << endl;
    return false;
  }
  if (I_NBins == 1){
    D_A1_SP = D_A2_SP(Range::all(), 0);
//    if (I_XCorProf > 0)
//      D_A1_XCorProf_Out = D_A2_XCorProf(Range::all(), 0);

    if (I_Telluric == 1){
      D_A1_Sky = D_A2_Sky(Range::all(), 0);
      D_A1_ErrSky = D_A2_ErrSky(Range::all(), 0);
    }

    D_A2_SF = D_A3_SFSM(Range::all(), Range::all(), 0);
  }
  else{
    int I_Bin = 0;
    double D_Weight_Bin0 = 0.;
    double D_Weight_Bin1 = 0.;
    int I_Row_Rel=0;
    double D_RowSum;
    for (int i_row = 0; i_row < D_A3_SFSM.rows(); i_row++){
      for (int i_ibin=0; i_ibin<I_NBins; i_ibin++){
	D_RowSum = sum(D_A3_SFSM(i_row, Range::all(), i_ibin));
	if (D_RowSum > 0.){
          D_A3_SFSM(i_row, Range::all(), i_ibin) = D_A3_SFSM(i_row, Range::all(), i_ibin) / D_RowSum;
          #ifdef __DEBUG_FITS_MKSLITFUNC__
            cout << "D_A3_SFSM(" << i_row << ", *, " << i_ibin << ") = " << D_A3_SFSM(i_row, Range::all(), i_ibin) << endl;
            cout << "i_row = " << i_row << ": i_ibin = " << i_ibin << ": D_RowSum = " << D_RowSum << endl;
          #endif
	}
      }
      if ((I_Bin == 0) && (i_row < I_BinHeight/2)){
	D_A1_SP(i_row) = D_A2_SP(i_row, 0);
//        if (I_XCorProf > 0)
//          D_A1_XCorProf_Out(i_row) = D_A2_XCorProf(i_row, 0);

	D_A2_SF(i_row, Range::all()) = D_A3_SFSM(i_row, Range::all(), 0);
	if (I_Telluric == 1){
	  D_A1_Sky(i_row) = D_A2_Sky(i_row, 0);
	  D_A1_ErrSky(i_row) = D_A2_ErrSky(i_row, 0);
	}







	if (ErrorsRead){
	  D_A1_Errors_SP_Out(i_row) = D_A2_Errors_SP_Out(i_row, 0);
	}








      }
      else if ((I_Bin == I_NBins-1)){// && (i_row > (I_A2_IBound(I_Bin-1, 1) - (I_A2_IBound(0,1) / 2.)))){
	D_A1_SP(i_row) = D_A2_SP(i_row, I_Bin);
	D_A2_SF(i_row, Range::all()) = D_A3_SFSM(i_row, Range::all(), I_Bin);
//        if (I_XCorProf > 0)
//          D_A1_XCorProf_Out(i_row) = D_A2_XCorProf(i_row, I_Bin);
	if (I_Telluric == 1){
	  D_A1_Sky(i_row) = D_A2_Sky(i_row, I_Bin);
	  D_A1_ErrSky(i_row) = D_A2_ErrSky(i_row, I_Bin);
	}







	if (ErrorsRead){
	  D_A1_Errors_SP_Out(i_row) = D_A2_Errors_SP_Out(i_row, I_Bin);
	}









      }
      else{
//	if (I_Bin == 0)
//          I_Row_Rel = 0;//i_row - int((double(I_Bin) + 0.5) * I_BinHeight);
//        I_Row_Rel = i_row - int((double(I_Bin) + 0.5) * I_BinHeight);
//        D_Weight_Bin1 = 2. * I_Row_Rel * I_BinHeight;
        D_Weight_Bin1 = 2. * double(I_Row_Rel) / double(I_BinHeight);
        D_Weight_Bin0 = 1. - D_Weight_Bin1;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": I_NBin = " << I_NBins << endl;
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": I_Bin = " << I_Bin << endl;
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": I_Row_Rel = " << I_Row_Rel << endl;
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": D_Weight_Bin0 = " << D_Weight_Bin0 << endl;
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": D_Weight_Bin1 = " << D_Weight_Bin1 << endl;
        #endif
	if (i_row >= D_A2_SP.rows()){
	  cout << "CFits::MkSlitFunc: ERROR: i_row = " << i_row << " >= D_A2_SP.rows() = " << D_A2_SP.rows() << " => Returning FALSE" << endl;
	  return false;
	}
	if (I_Bin + 1 >= D_A2_SP.cols()){
	  cout << "CFits::MkSlitFunc: ERROR: I_Bin + 1 = " << I_Bin + 1 << " >= D_A2_SP.cols() = " << D_A2_SP.cols() << " => Returning FALSE" << endl;
	  return false;
	}

        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": I_Bin = " << I_Bin << ": D_A2_SP(i_row, I_Bin) = " << D_A2_SP(i_row, I_Bin) << ", D_A2_SP(i_row, I_Bin + 1) = " << D_A2_SP(i_row, I_Bin + 1) << endl;
        #endif
        D_A1_SP(i_row) = (D_A2_SP(i_row, I_Bin) * D_Weight_Bin0) + (D_A2_SP(i_row, I_Bin + 1) * D_Weight_Bin1);
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": I_Bin = " << I_Bin << ": D_A1_SP(" << i_row << ") set to " << D_A1_SP(i_row) << endl;
        #endif







	if (ErrorsRead){
	  D_A1_Errors_SP_Out(i_row) = (D_A2_Errors_SP_Out(i_row, I_Bin) * D_Weight_Bin0) + (D_A2_Errors_SP_Out(i_row, I_Bin + 1) * D_Weight_Bin1);
	}











//        if (I_XCorProf > 0)
//          D_A1_XCorProf_Out(i_row) = (D_A2_XCorProf(i_row, I_Bin) * D_Weight_Bin0) + (D_A2_XCorProf(i_row, I_Bin + 1) * D_Weight_Bin1);


        #ifdef __DEBUG_FITS_MKSLITFUNC__
	  cout << "CFits::MkSlitFunc: D_A3_SFSM(i_row, *, I_Bin) = " << D_A3_SFSM(i_row, Range::all(), I_Bin) << ", D_A3_SFSM(i_row, *, I_Bin+1) = " << D_A3_SFSM(i_row, Range::all(), I_Bin+1) << endl;
        #endif
	D_A2_SF(i_row, Range::all()) = (D_A3_SFSM(i_row, Range::all(), I_Bin) * D_Weight_Bin0) + (D_A3_SFSM(i_row, Range::all(), I_Bin+1) * D_Weight_Bin1);
	D_A2_SF(i_row, Range::all()) = D_A2_SF(i_row, Range::all()) / sum(D_A2_SF(i_row, Range::all()));
        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": I_Bin = " << I_Bin << ": D_A2_SF(" << i_row << ", *) set to " << D_A2_SF(i_row, Range::all()) << endl;
        #endif

	if (I_Telluric == 1){
	  if (i_row >= D_A1_Sky.rows()){
	    cout << "CFits::MkSlitFunc: ERROR: i_row >= D_A1_Sky.rows()=" << D_A1_Sky.rows() << " => Returning FALSE" << endl;
	    return false;
	  }
	  D_A1_Sky(i_row) = (D_A2_Sky(i_row, I_Bin) * D_Weight_Bin0) + (D_A2_Sky(i_row, I_Bin + 1) * D_Weight_Bin1);
	  D_A1_ErrSky(i_row) = (D_A2_ErrSky(i_row, I_Bin) * D_Weight_Bin0) + (D_A2_ErrSky(i_row, I_Bin + 1) * D_Weight_Bin1);
          cout << "CFits::MkSlitFunc: i_row = " << i_row << ": I_Bin = " << I_Bin << ": D_A1_Sky(" << i_row << ") set to " << D_A1_Sky(i_row) << endl;
	}

	I_Row_Rel++;

//	if (i_row > I_BinHeight / 2)
//	  return false;
      }
//      if ((i_row - I_BinHeight + 1) > ((I_Bin+0.5)*I_BinHeight)){

      if (I_Row_Rel == (I_BinHeight/2)){
	I_Bin++;
	I_Row_Rel = 0;
        #ifdef __DEBUG_FITS_MKSLITFUNC__
  	  cout << "CFits::MkSlitFunc: i_row = " << i_row << ": I_Bin set to " << I_Bin << endl;
        #endif
      }
    }/// end for (int i_row = 0; i_row < D_A3_SFSM.rows(); i_row++){
  }/// end if (I_NBin != 1){
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A2_SF set to " << D_A2_SF << endl;
  #endif
//  if (I_XCorProf > 0){
//    B_Run_XCor = true;
//    I_Run_XCor++;
//    I_XCorProf = 0;
//  }
//  else{
//    B_Run_XCor = false;
//  }
//}while (B_Run_XCor);
//  return false;

//  if (I_Telluric == 1)
//    return false;

  D_A1_SPFit.resize(D_A1_SP.size());
  if ((*(this->P_D_A1_YHigh))(I_IAperture_In) - (*(this->P_D_A1_YLow))(I_IAperture_In) + 1 != D_A1_SP.size()){
    cout << "CFits::MkSlitFunc: ERROR: D_A1_SP.size(=" << D_A1_SP.size() << ") is wrong" << endl;
    return false;
  }



  Array<CString, 1> CS_A1_Args_Fit(3);
  void **PP_Args_Fit;
  PP_Args_Fit = (void**)malloc(sizeof(void*) * 3);
  CS_A1_Args_Fit = CString(" ");

  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A2_Err = " << D_A2_Err << endl;
  #endif

  Array<double, 2> D_A2_ErrAp(I_A2_IBinBoundY(I_NBins-1, 1) - I_A2_IBinBoundY(0,0) + 1, D_A2_Err_AllRows.cols());
  D_A2_ErrAp = 0.;
  if (this->ErrorsRead){
    CS_A1_Args_Fit(0) = CString("MEASURE_ERRORS_IN");
    D_A2_ErrAp = D_A2_Err_AllRows(Range(I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_NBins-1, 1)), Range::all());
    PP_Args_Fit[0] = &D_A2_ErrAp;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: D_A2_ErrAp = " << D_A2_ErrAp << endl;
    #endif
  }

  CS_A1_Args_Fit(1) = CString("MASK_INOUT");
  Array<int, 2> I_A2_MaskAp(I_A2_IBinBoundY(I_NBins-1, 1) - I_A2_IBinBoundY(0,0) + 1, I_A2_Mask_AllRows.cols());
  I_A2_MaskAp = I_A2_Mask_AllRows(Range(I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_NBins-1, 1)), Range::all());
  PP_Args_Fit[1] = &I_A2_MaskAp;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "I_A2_MaskAp = " << I_A2_MaskAp << endl;
  #endif
        //return false;

  CS_A1_Args_Fit(2) = CString("SIGMA_OUT");
  Array<double, 2> D_A2_Sigma_Fit(D_A2_SF.rows(),2);
  PP_Args_Fit[2] = &D_A2_Sigma_Fit;




  Array<double, 1> D_A1_SkyFit(D_A1_SPFit.size());
  D_A1_SkyFit = 0.;
  bool B_WithSky = false;
  if (I_Telluric > 0){
    D_A1_SkyFit = 1.;
    B_WithSky = true;
  }
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: Before Fit: D_A2_CCD_Ap = " << D_A2_CCD_Ap << endl;
  #endif
  #ifdef __DEBUG_FITS_MkSLITFUNC_FILES__
    CString CS_FileName_CCD_Ap(CString("CCD_Ap"));
    CString *P_CS_TempIToA = CS_FileName_CCD_Ap.IToA(I_IAperture_In);
    CS_FileName_CCD_Ap.Add(*P_CS_TempIToA);
    delete(P_CS_TempIToA);
    CS_FileName_CCD_Ap.Add(CString("_Tel"));
    P_CS_TempIToA = CS_FileName_CCD_Ap.IToA(I_Telluric);
    CS_FileName_CCD_Ap.Add(*P_CS_TempIToA);
    delete(P_CS_TempIToA);
    CS_FileName_CCD_Ap.Add(CString(".fits"));
    if (!this->WriteFits(&D_A2_CCD_Ap,CS_FileName_CCD_Ap)){
      cout << "CFits::MkSlitFunc: WriteFits(D_A2_CCD_Ap," << CS_FileName_CCD_Ap << ") returned FALSE!" << endl;
      return false;
    }
  #endif
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: Before Fit: D_A2_SF = " << D_A2_SF << endl;
  #endif
//  if (!this->Fit(D_A2_CCD_Ap,      ///: in
  if (!this->LinFitBevington(D_A2_CCD_Ap,      ///: in
                             D_A2_SF,             ///: in
                             D_A1_SPFit,             ///: out
                             D_A1_SkyFit,          ///: in/out
                             B_WithSky,                   ///: with sky: in
                             CS_A1_Args_Fit,         ///: in
                             PP_Args_Fit)){          ///: in/out
  /// MEASURE_ERRORS_IN = Array<double,2>(D_A2_CCD_In.rows, D_A2_CCD_In.cols) : in
  /// REJECT_IN = double                                                      : in
  /// MASK_INOUT = Array<double,2>(D_A1_CCD_In.rows,D_A1_CCD_In.cols)         : in/out
  /// CHISQ_OUT = Array<double,1>(D_A2_CCD_In.rows)                           : out
  /// Q_OUT = Array<double,1>(D_A2_CCD_In.rows)                               : out
  /// SIGMA_OUT = Array<double,2>(D_A2_CCD_In.rows, 2): [*,0]: sigma_sp, [*,1]: sigma_sky : out
    cout << "CFits::MkSlitFunc: 2. ERROR: this->Fit(...) returned FALSE => Returning FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_MkSLITFUNC_FILES__
    CString CS_MaskFinalOut("Mask_Final");
    CS_MaskFinalOut.Add(CS_SF_DebugFilesSuffix);
    CS_MaskFinalOut.Add(".fits");
    this->WriteFits(&I_A2_MaskAp, CS_MaskFinalOut);

    CS_MaskFinalOut.Set("D_A2_CCD_Ap");
    CS_MaskFinalOut.Add(CS_SF_DebugFilesSuffix);
    CS_MaskFinalOut.Add(".fits");
    this->WriteFits(&D_A2_CCD_Ap, CS_MaskFinalOut);

    cout << "Just after Fit: D_A1_SPFit = " << D_A1_SPFit << endl;
    cout << "Just after Fit: D_A1_SkyFit = " << D_A1_SkyFit << endl;
    cout << "Just after Fit: D_A2_SF = " << D_A2_SF << endl;
  #endif
//  if (I_Telluric == 1)
//    return false;

  if (I_A2_IBinBoundY(I_NBins-1, 1) - I_A2_IBinBoundY(0,0) + 1 != D_A1_SPFit.size()){
    cout << "CFits::MkSlitFunc: ERROR: I_A2_IBound(I_NBin-1, 1)(=" << I_A2_IBinBoundY(I_NBins-1, 1) << ") - I_A2_IBound(0,0)(=" << I_A2_IBinBoundY(0,0) << ") + 1 != D_A1_SPFit.size()(=" << D_A1_SPFit.size() << ")" << endl;
    return false;
  }
  (*(this->P_D_A2_SP_Fit))(I_IAperture_In, Range(I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_NBins-1, 1))) = D_A1_SPFit;

  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: (*P_D_A1_BLZ)(Range((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In), (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In))) = " << (*P_D_A1_BLZ)(Range((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In), (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In))) << endl;
  #endif
  (*P_D_A1_BLZ)(Range((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In), (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In))) = D_A1_SP;
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: (*P_D_A1_BLZ)(Range((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In), (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In))) set to " << (*P_D_A1_BLZ)(Range((*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YLow))(I_IAperture_In), (*(this->P_D_A1_YCenter))(I_IAperture_In) + (*(this->P_D_A1_YHigh))(I_IAperture_In))) << endl;
  #endif


//  if (I_Telluric == 1){
//    cout << "CFits::MkSlitFunc: D_A1_Sky = " << D_A1_Sky << endl;
//    return false;
//  }


//  cout << "CFits::MkSlitFunc: (*(this->P_I_A2_MaskArray))(Range(I_A2_IBinBoundY(0,0), I_A2_IBinBoundY(I_NBins-1,1)), I_A2_MinCenMax(I_A2_IBinBoundY(0,0)+i_row, 0) + i_col)
    /// TODO TODO TODO: Check pixel positions
  for (int i_row=0; i_row < D_A1_SPFit.size(); i_row++){
      ///(I_A2_IBound(0,0) + n, Range(I_A2_MinCenMax(I_A2_IBound(0,0) + n, 0), I_A2_MinCenMax(I_A2_IBound(0,0) + n, 2)))
      ///D_A2_SlitFunc_Im_In(n, Range(I_A1_Pix_SF_Beg(n), I_A1_Pix_SF_End(n))) = D_A1_SSF;

    for (int i_col=0; i_col<I_A2_Mask_AllRows.cols(); i_col++){
      if (I_A2_Mask_AllRows(i_row, i_col) == 0)
        (*(this->P_I_A2_MaskArray))(I_A2_IBinBoundY(0,0)+i_row, I_A2_MinCenMax(I_A2_IBinBoundY(0,0)+i_row, 0) + i_col) = 0;
    }

    (*(this->P_D_A2_ProfArray))(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) = D_A2_SF(i_row, Range::all());

    (*(this->P_D_A2_RecArray))(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) = D_A2_SF(i_row, Range::all()) * D_A1_SP(i_row);

    (*this->P_D_A2_RecFitArray)(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) = D_A2_SF(i_row, Range::all()) * D_A1_SPFit(i_row);
///      (*this->P_D_A2_RecArray)(I_A2_IBound(0,0) + q, Range(I_A2_MinCenMax(I_A2_IBound(0,0) + q, 0), I_A2_MinCenMax(I_A2_IBound(0,0) + q, 2))) = D_A2_SF(q, Range::all()) * D_A1_SP(q);
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: D_A2_SF(q=" << i_row << ", Range::all()) = " << D_A2_SF(i_row, Range::all()) << ", D_A1_SPFit(q) = " << D_A1_SPFit(i_row) << ": P_D_A2_RecFitArray(I_A2_IBound(0,0)+q=" << I_A2_IBinBoundY(0,0)+i_row << ", Range(" << I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0) << ", " << I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2) << ")) set to " << (*P_D_A2_RecFitArray)(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) << endl;
    #endif

//    (*this->P_D_A2_RecFitArray)(I_A2_IBound(0,0) + q, Range(I_A2_MinCenMax(I_A2_IBound(0,0) + q, 0), I_A2_MinCenMax(I_A2_IBound(0,0) + q, 2))) = D_A2_SF(q, Range::all()) * D_A1_SPFit(q);
//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: D_A2_SF(q=" << q << ", Range::all()) = " << D_A2_SF(q, Range::all()) << ", D_A1_SP(q) = " << D_A1_SP(q) << ": P_D_A2_RecFitArray(I_A2_IBound(0,0)+q=" << I_A2_IBound(0,0)+q << ", Range(" << I_A2_MinCenMax(I_A2_IBound(0,0) + q, 0) << ", " << I_A2_MinCenMax(I_A2_IBound(0,0) + q, 2) << ")) set to " << (*P_D_A2_RecFitArray)(I_A2_IBound(0,0) + q, Range(I_A2_MinCenMax(I_A2_IBound(0,0) + q, 0), I_A2_MinCenMax(I_A2_IBound(0,0) + q, 2))) << endl;
//    #endif

//    (*this->P_D_A2_ProfArray)(I_A2_IBinBoundY(0,0) + q, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + q, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + q, 2))) = D_A2_SF(q, Range::all());
    ///TODO!!! see below
    if (I_Telluric > 0){
      (*(this->P_D_A2_SkyFit))(I_IAperture_In, I_A2_IBinBoundY(0,0) + i_row) = D_A1_SkyFit(i_row);
      (*(this->P_D_A2_RecSkyFitArray))(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) = D_A1_SkyFit(i_row);
      if (I_Telluric > 1){
        (*this->P_D_A2_Sky)(I_IAperture_In, I_A2_IBinBoundY(0,0) + i_row) = D_A1_SkyFit(i_row);
        (*this->P_D_A2_RecSkyArray)(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) = D_A1_SkyFit(i_row);
      }
      else{
        (*(this->P_D_A2_Sky))(I_IAperture_In, I_A2_IBinBoundY(0,0) + i_row) = D_A1_Sky(i_row);
        (*(this->P_D_A2_RecSkyArray))(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) = D_A1_Sky(i_row);
      }
    }
    if (this->ErrorsRead)
    {
//      (*this->P_D_A2_ErrArray)(I_A2_IBound(0,0) + q, Range(I_A2_MinCenMax(I_A2_IBound(0,0) + q, 0), I_A2_MinCenMax(I_A2_IBound(0,0) + q, 2))) = D_A2_Err(q, Range::all());

      /// Mark bad pixels with large errors in this->P_D_A2_ErrArray
      (*(this->P_D_A2_ErrArray))(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) = where(I_A2_Mask_AllRows(i_row, Range::all()) < 1, 10000., (*(this->P_D_A2_ErrArray))(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))));

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: (*this->P_D_A2_ErrArray)(I_A2_IBound(0,0) + q=" << I_A2_IBinBoundY(0,0) + i_row << ", Range(I_A2_MinCenMax(I_A2_IBound(0,0) + q, 0)=" << I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0) << ", I_A2_MinCenMax(I_A2_IBound(0,0) + q, 2)=" << I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2) << ")) set to " << (*this->P_D_A2_ErrArray)(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) << endl;
      #endif

      (*(this->P_D_A2_Errors_EcFit))(I_IAperture_In, I_A2_IBinBoundY(0,0) + i_row) = D_A2_Sigma_Fit(i_row,0);

      if (I_Telluric > 0){
        (*(this->P_D_A2_SkyFitError))(I_IAperture_In, I_A2_IBinBoundY(0,0) + i_row) = D_A2_Sigma_Fit(i_row,1);
	if (I_Telluric > 1){
          (*(this->P_D_A2_SkyError))(I_IAperture_In, I_A2_IBinBoundY(0,0) + i_row) = D_A2_Sigma_Fit(i_row,1);
          (*this->P_D_A2_ErrArray)(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) += D_A2_Sigma_Fit(i_row, 1);
	}
        else{
          (*(this->P_D_A2_SkyError))(I_IAperture_In, I_A2_IBinBoundY(0,0) + i_row) = D_A1_ErrSky(i_row);
          (*this->P_D_A2_ErrArray)(I_A2_IBinBoundY(0,0) + i_row, Range(I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 0), I_A2_MinCenMax(I_A2_IBinBoundY(0,0) + i_row, 2))) += D_A1_ErrSky(i_row);
	}

//	#ifdef __DEBUG_FITS_MKSLITFUNC__
//          cout << "CFits::MkSlitFunc: (*this->P_D_A2_Errors_Ec)(I_IAperture_In=" << I_IAperture_In << ", I_A2_IBound(0,0) + q=" << I_A2_IBinBoundY(0,0) + i_row << ", q=" << i_row << ") set to " << (*(this->P_D_A2_Errors_Ec))(I_IAperture_In, I_A2_IBinBoundY(0,0) + i_row) << endl;
//        #endif
      }// end if (I_Telluric > 0)
    }// end if (this->ErrorsRead)
  }// end for (int i_row=0; i_row < D_A1_SPFit.size(); i_row++){


  if (ErrorsRead){
/**  Array<CString, 1> CS_A1_Args_ExtractErrors(1);
  CS_A1_Args_ExtractErrors(0).Set(CString("APERTURES"));
  void **PP_Args_ExtractErrors;
  Array<int, 1> I_A1_Apertures(1);
  I_A1_Apertures(0) = I_IAperture_In;
  PP_Args_ExtractErrors = (void**)malloc(sizeof(void*) * 1);
  PP_Args_ExtractErrors[0] = &I_A1_Apertures;
  this->ProfileCalculated = true;
  if (!this->ExtractErrors(CS_A1_Args_ExtractErrors, PP_Args_ExtractErrors)){
    cout << "CFits::MkSlitFunc: ERROR: this->ExtractErrors returned FALSE" << endl;
    return false;
  }
  cout << "CFits::MkSlitFunc: ERROR: this->ExtractErrors returned TRUE" << endl;
  (*(this->P_D_A2_Errors_Ec))(I_IAperture_In, Range::all()) = this->GetLastExtracted()(I_IAperture_In, Range::all());
**/







    (*(this->P_D_A2_Errors_Ec))(I_IAperture_In, Range::all()) = D_A1_Errors_SP_Out;
  }






  Array<double, 1> *P_D_A1_BLZSmooth;
  if (this->KeyWord_Set(CS_A1_Args_In, CString("FLAT")) >= 0)
  {
    P_D_A1_BLZSmooth = this->MedianVec(*P_D_A1_BLZ, I_LambdaSP);
  }
  else
  {
    P_D_A1_BLZSmooth = new Array<double, 1>(1);
    (*P_D_A1_BLZSmooth) = 0.;
  }
  double fac = 1.;// / sum(D_A1_SF);

//  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("FLAT"))) >= 0)
//  {
//    if (P_D_A1_BLZSmooth->size() < irow + 1)
//    {
//      cout << "CFits::MkSlitFunc: BLZ set: ERROR: P_D_A1_BLZSmooth->size(=" << P_D_A1_BLZSmooth->size() << ") < irow(=" << irow << ") + 1 => Returning" << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ set: ERROR: P_D_A1_BLZSmooth->size(=" << P_D_A1_BLZSmooth->size() << ") < irow(=" << irow << ") + 1 => Returning" << endl;
//      return false;
//    }
//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: BLZ set: P_D_A1_BLZSmooth(irow=" << irow << ") = " << (*P_D_A1_BLZSmooth)(irow) << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ set: P_D_A1_BLZSmooth(irow=" << irow << ") = " << (*P_D_A1_BLZSmooth)(irow) << endl;
//    #endif

//    fac *= (*P_D_A1_BLZSmooth)(irow);

//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: BLZ set: fac set to *= (*P_D_A1_BLZSmooth)(irow)(=" << (*P_D_A1_BLZSmooth)(irow) << ") = " << fac << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ set: fac set to 1 / sum = " << fac << endl;
//    #endif

//  }/// end if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("FLAT"))) >= 0)



  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("FLAT"))) >= 0)
  {
    (*this->P_D_A2_Blaze)(I_IAperture_In, Range::all()) = (*P_D_A1_BLZSmooth)(Range::all());
  }
  else
  {
    (*this->P_D_A2_Blaze)(I_IAperture_In, Range::all()) = (*P_D_A1_BLZ)(Range::all());
  }
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: P_D_A2_Blaze(I_IAperture_In=" << I_IAperture_In << ", *) set to " << (*(this->P_D_A2_Blaze))(I_IAperture_In, Range::all()) << endl;

    CString CS_D_A2_SlitFTemp("");
    CString *P_CS_NumTemp = new CString("");

    CS_D_A2_SlitFTemp.Set(DEBUGDIR);
    delete(P_CS_NumTemp);
    P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
    CS_D_A2_SlitFTemp.Add(CString("D_A1_SPFit_Tel"));
    CS_D_A2_SlitFTemp.Add(*P_CS_NumTemp);
    CS_D_A2_SlitFTemp.Add(CString(".dat"));
    delete(P_CS_NumTemp);
    this->WriteArrayToFile(D_A1_SPFit, CS_D_A2_SlitFTemp, CString("ascii"));
    cout << "CFits::MkSlitFunc: " << CS_D_A2_SlitFTemp << " written" << endl;

    cout << "CFits::MkSlitFunc: (*this->P_D_A1_YCenter)(I_IAperture_In=" << I_IAperture_In << ")(=" << (*this->P_D_A1_YCenter)(I_IAperture_In) << ")+(*this->P_D_A1_YHigh)(I_IAperture_In)(=" << (*this->P_D_A1_YHigh)(I_IAperture_In) << ") = " << (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In) << endl;
    cout << "CFits::MkSlitFunc: D_A2_SF.rows = I_A2_IBound(I_NBin(=" << I_NBins << ")-1,1)(=" << I_A2_IBinBoundY(I_NBins-1,1) << ") - I_A2_IBound(0,0)(=" << I_A2_IBinBoundY(0,0) << ") + 1    = " << I_A2_IBinBoundY(I_NBins-1,1) - I_A2_IBinBoundY(0,0) + 1 << endl;
    cout << "CFits::MkSlitFunc: D_A2_SF.cols = max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1 = " << max(I_A2_MinCenMax(Range::all(), 2) - I_A2_MinCenMax(Range::all(), 0))+1 << endl;
  #endif

  int I_Row = 0;
  for (int irow = (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YLow)(I_IAperture_In); irow < (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In); irow++)
  {
    #ifdef __DEBUG_FITS__
      CS_D_A2_SlitFTemp.Set(CString("D_A2_Im_Tel"));
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp.Add(*P_CS_NumTemp);
      CS_D_A2_SlitFTemp.Add(CString("_irow"));
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp.Add(*P_CS_NumTemp);
      CS_D_A2_SlitFTemp.Add(CString(".dat"));
      delete(P_CS_NumTemp);
      Array<double, 1> D_A1_SlitFunc(I_A2_MinCenMax(irow, 2) - I_A2_MinCenMax(irow, 0) + 1);
      D_A1_SlitFunc = (*(this->P_D_A2_PixArray))(irow, Range(I_A2_MinCenMax(irow, 0), I_A2_MinCenMax(irow, 2)));
      this->WriteArrayToFile(D_A1_SlitFunc, CS_D_A2_SlitFTemp, CString("ascii"));
      cout << "CFits::MkSlitFunc: " << CS_D_A2_SlitFTemp << " written" << endl;

      CString CS_D_A1_SF(CString("D_A1_Prof_Tel"));
      CString *P_CS_NumA = CS_D_A1_SF.IToA(I_Telluric);
      CS_D_A1_SF.Add(*P_CS_NumA);
      CS_D_A1_SF.Add(CString("_irow"));
      delete(P_CS_NumA);
      P_CS_NumA = CS_D_A1_SF.IToA(irow);
      CS_D_A1_SF.Add(*P_CS_NumA);
      CS_D_A1_SF.Add(CString(".dat"));
      if (I_Row >= D_A2_SF.rows()){
	cout << "CFits::MkSlitFunc: ERROR: I_Row = " << I_Row << " >= D_A2_SF.rows() = " << D_A2_SF.rows() << " => Returning FALSE" << endl;
	return false;
      }
      this->WriteArrayToFile(D_A2_SF(I_Row, Range::all()), CS_D_A1_SF, CString("ascii"));
      delete(P_CS_NumA);
      cout << "CFits::MkSlitFunc: " << CS_D_A1_SF << " written" << endl;

      CS_D_A1_SF.Set(CString("D_A1_Im_Tel"));
      P_CS_NumA = CS_D_A1_SF.IToA(I_Telluric);
      CS_D_A1_SF.Add(*P_CS_NumA);
      CS_D_A1_SF.Add(CString("_irow"));
      delete(P_CS_NumA);
      P_CS_NumA = CS_D_A1_SF.IToA(irow);
      CS_D_A1_SF.Add(*P_CS_NumA);
      CS_D_A1_SF.Add(CString(".dat"));
      this->WriteArrayToFile((*(const_cast<CFits*>(this)->P_D_A2_PixArray))(irow, Range(I_A2_MinCenMax(irow, 0), I_A2_MinCenMax(irow, 2))), CS_D_A1_SF, CString("ascii"));
      delete(P_CS_NumA);
      cout << "CFits::MkSlitFunc: " << CS_D_A1_SF << " written" << endl;

      CS_D_A1_SF.Set(CString("D_A1_Sky_Tel"));
      P_CS_NumA = CS_D_A1_SF.IToA(I_Telluric);
      CS_D_A1_SF.Add(*P_CS_NumA);
      CS_D_A1_SF.Add(CString("_irow"));
      delete(P_CS_NumA);
      P_CS_NumA = CS_D_A1_SF.IToA(irow);
      CS_D_A1_SF.Add(*P_CS_NumA);
      CS_D_A1_SF.Add(CString(".dat"));
      Array<double, 1> D_A1_SkyRow(1);
      if (I_Row >= D_A1_SkyFit.rows()){
	cout << "CFits::MkSlitFunc: ERROR: I_Row = " << I_Row << " >= D_A1_SkyFit.rows() = " << D_A1_SkyFit.rows() << " => Returning FALSE" << endl;
	return false;
      }
      D_A1_SkyRow = D_A1_SkyFit(I_Row);
      this->WriteArrayToFile(D_A1_SkyRow, CS_D_A1_SF, CString("ascii"));
      cout << "CFits::MkSlitFunc: " << CS_D_A1_SF << " written" << endl;
      delete(P_CS_NumA);
      I_Row++;
    #endif
  }// end for (int irow = (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YLow)(I_IAperture_In); irow <= (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In); irow++)




/**





















  //  (*P_OFS_Log) << "CFits::MkSlitFunc: 12. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

  //  for (int I_IBin = 0; I_IBin < I_NBin; I_IBin++)
  //  {
  //    for (int n = 0; n < )
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XHigh = " << *P_D_A1_XHigh << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_BinCen = " << D_A1_BinCen << endl;
  #endif

  ///Trim end pixels of slitf, since they are sometimes bad.
  ///  ysfmin = min(yslitf, max=ysfmax)                  ;range of yslitf
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A1_XSlitF = to " << D_A1_XSlitF << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XSlitF = to " << D_A1_XSlitF << endl;
  #endif
  D_XSFMin = min(D_A1_XSlitF);
  D_XSFMax = max(D_A1_XSlitF);

  #ifdef __DEBUG_FITS_MKSLITFUNC__
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_XSFMin set to " << D_XSFMin << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_XSFMax set to " << D_XSFMax << endl;
  #endif
  ///  nysf = n_elements(yslitf)                          ;number of subpixels
  I_NXSF = D_A1_XSlitF.size();

  ///  dysf = (ysfmax - ysfmin) / (nysf - 1)             ;subpixel size
  D_DXSF = (D_XSFMax - D_XSFMin) / (I_NXSF - 1);
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_DXSF set to " << D_DXSF << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_DXSF set to " << D_DXSF << endl;
  #endif
  ///  ntrim = ceil(1.0 / dysf)                          ;subpixels to trim
  I_NTrim = (int)this->Ceil(1.0 / D_DXSF);
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: I_NTrim set to " << I_NTrim << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: I_NTrim set to " << I_NTrim << endl;
  #endif
  ///  yslitf = yslitf(ntrim:nysf-ntrim-1)               ;trim subpixel indexes
  D_A1_XSlitFTemp.resize(I_NXSF - 2 * I_NTrim);
  D_A1_XSlitFTemp = D_A1_XSlitF(Range(I_NTrim, I_NXSF - I_NTrim - 1));
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A1_XSlitFTemp set to " << D_A1_XSlitFTemp << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XSlitFTemp set to " << D_A1_XSlitFTemp << endl;
  #endif
//  return false;
  ///  slitf = slitf(ntrim:nysf-ntrim-1,*)               ;trim slit functions
  D_A2_SlitFTemp.resize(I_NXSF - 2 * I_NTrim + 1, D_A2_SlitF.cols());
  D_A2_SlitFTemp = D_A2_SlitF(Range(I_NTrim, I_NXSF - I_NTrim - 1), Range::all());
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_A2_SlitFTemp set to " << D_A2_SlitFTemp << endl;
    cout << "CFits::MkSlitFunc: D_A1_XSlitFTemp = " << D_A1_XSlitFTemp << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A2_SlitFTemp set to " << D_A2_SlitFTemp << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XSlitFTemp = " << D_A1_XSlitFTemp << endl;
  #endif

  ///  ysfmin = min(yslitf, max=ysfmax)                  ;range of yslitf
  D_XSFMin = min(D_A1_XSlitFTemp);
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_XSFMin set to " << D_XSFMin << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_XSFMin set to " << D_XSFMin << endl;
  #endif
  D_XSFMax = max(D_A1_XSlitFTemp);
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: D_XSFMax set to " << D_XSFMax << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_XSFMax set to " << D_XSFMax << endl;
  #endif
  ///  nysf = n_elements(yslitf)                         ;number of subpixels
  I_NXSF = D_A1_XSlitFTemp.size();
  #ifdef __DEBUG_FITS_MKSLITFUNC__
    cout << "CFits::MkSlitFunc: I_NXSF set to " << I_NXSF << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: I_NXSF set to " << I_NXSF << endl;
  #endif
  ///Use slit function and fit to order to normalize flat.
  ///    if(cole0 gt 0) then begin                         ;skip the beginning of the order
  ///      for icol=0,cole0-1 do begin                     ;loop thru image columns
  ///        if(onum eq ofirst) then y0 = 0 $              ;starting row to change
  ///        else                    y0 = ((yprev(icol)+1)>0)<(nrow-1)
  ///        if(onum eq nord) then   y1 = nrow-1 $         ;ending row to change
  ///        else                    y1 = ((yc(icol) + y_upper_lim)<(nrow-1))>0
  ///        im(icol,y0:y1) = 1.0
  ///      endfor
  ///    endif

  ///    for icol=cole0,cole1 do begin                     ;loop thru image columns


  /// NOTE: SOMETHING SEEMS TO GO WRONG HERE!!! if I_NBins == 1 this SHOULD NOT change the SlitFunction as derived before in MkSlitFunc (D_A2_SFSM)
  for (irow = (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YLow)(I_IAperture_In); irow <= (*this->P_D_A1_YCenter)(I_IAperture_In)+(*this->P_D_A1_YHigh)(I_IAperture_In); irow++)
  {
      CS_D_A2_SlitFTemp.Set(DEBUGDIR);
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("D_A2_SlitFuncOrig_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      Array<double, 1> D_A1_SlitFunc(I_A2_MinCenMax(irow, 2) - I_A2_MinCenMax(irow, 0) + 1);
      D_A1_SlitFunc = (*(this->P_D_A2_PixArray))(irow, Range(I_A2_MinCenMax(irow, 0), I_A2_MinCenMax(irow, 2)));
      this->WriteArrayToFile(D_A1_SlitFunc, CS_D_A2_SlitFTemp, CString("ascii"));

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 13. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    /// exwd = 0.5 if not set by KeyWord
    ///      if(exwd(0,onum-1) gt 1.5) then begin            ;starting row to change
    ///        y0 = yc(icol) - exwd(0,onum-1)                ;exwd is in pixels
    ///      endif else begin                                ;or a fraction
    ///        y0 = yc(icol) - round(y_lower_lim*exwd(0,onum-1))
    ///      endelse
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_XCenters(irow) = " << D_A1_XCenters(irow) << ", 0. - (*this->P_D_A1_XLow)(I_IAperture_In) = " << 0. - (*this->P_D_A1_XLow)(I_IAperture_In) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_XCenters(irow) = " << D_A1_XCenters(irow) << ", 0. - (*this->P_D_A1_XLow)(I_IAperture_In) = " << 0. - (*this->P_D_A1_XLow)(I_IAperture_In) << endl;
    #endif
//    I_X0 = I_A2_MinCenMax(irow, 0);///(int)((*P_D_A2_XCenters)(I_IAperture_In, irow))


    /// TODO TODO TODO Check I_X0 and I_X1
///    I_X0 = this->Fix(D_A1_XCenters(irow))
///           - this->Round(0. - (*this->P_D_A1_XLow)(I_IAperture_In));
    //I_X0 = (int)(D_A1_XCenters(irow) + (*this->P_D_A1_XLow)(I_IAperture_In));

//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X0 set to "<< I_X0 << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X0 set to "<< I_X0 << endl;
//    #endif
    ///      if(exwd(1,onum-1) gt 1.5) then begin            ;ending row to change
    ///        y1 = yc(icol) + exwd(1,onum-1)               ;exwd is in pixels
    ///      endif else begin                                ;or a fraction
    ///        y1 = yc(icol) + round(y_lower_lim*exwd(1,onum-1))
    ///      endelse
    ///I_X1 = I_A2_MinCenMax(irow, 2);///(int)((*P_D_A2_XCenters)(I_IAperture_In, irow)) +
//    I_X1 = this->Fix(D_A1_XCenters(irow)) + this->Round((*this->P_D_A1_XHigh)(I_IAperture_In));// * 0.5);
//    I_X1 = (int)(D_A1_XCenters(irow) + (*this->P_D_A1_XHigh)(I_IAperture_In));// * 0.5);

//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X1 set to "<< I_X1 << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X1 set to "<< I_X1 << endl;
//    #endif


//    if (I_X0 >= 0 && I_X0 < this->NCols && I_X1 >= 0 && I_X1 < this->NCols)
    if (I_A2_MinCenMax(irow, 0) >= 0 && I_A2_MinCenMax(irow, 0) < this->NCols && I_A2_MinCenMax(irow, 2) >= 0 && I_A2_MinCenMax(irow, 2) < this->NCols)
    {
      ///      iy = y0 + indgen(y1 - y0 + 1)                   ;list of rows to change
      I_A1_IX.resize(I_A2_MinCenMax(irow, 2) - I_A2_MinCenMax(irow, 0) + 1);
      I_A1_IX = i + I_A2_MinCenMax(irow, 0);

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_A1_IX set to " << I_A1_IX << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_A1_IX set to " << I_A1_IX << endl;
      #endif

      ///      yint = (iy - ycen(icol) - ysfmin) / dysf        ;interpolation grid
      D_A1_XInt.resize(I_A1_IX.size());
      D_A1_XInt = (I_A1_IX - D_A1_XCenters(irow) - D_XSFMin) / D_DXSF;

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_XInt set to (I_A1_IX(=" << I_A1_IX << ") - D_A1_XCenters(irow)(=" << D_A1_XCenters(irow) << ") - D_XSFMin(=" <<  - D_XSFMin << ")) / D_DXSF(=" << D_DXSF << ") = " << D_A1_XInt << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_XInt set to " << D_A1_XInt << endl;
      #endif

      ///Linearly interpolate slit functions onto desired rows in current column.
      ///      isort = sort(abs(binc - icol))                  ;sort by distance
      D_A1_TempArr.resize(D_A1_BinCen.size());
      D_A1_TempArr = abs(D_A1_BinCen - irow);
      Array<int, 1> *p_I_A1_ISort = this->SortIndices(D_A1_TempArr);
      //      cout << "CFits::MkSlitFunc: p_I_A1_ISort set to " << *p_I_A1_ISort << endl;
      I_A1_ISort.resize(p_I_A1_ISort->size());//.resize(D_A1_BinCen.size());
      I_A1_ISort = (*p_I_A1_ISort);
      delete p_I_A1_ISort;

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_A1_ISort set to " << I_A1_ISort << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_A1_ISort set to " << I_A1_ISort << endl;
      #endif

      ///        ic0 = isort(0)                                ;index of closest bin
      I_IR0 = I_A1_ISort(0);
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_IR0 set to " << I_IR0 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_IR0 set to " << I_IR0 << endl;
      #endif
      ///      if(n_elements(isort) le 1) then begin           ;For short partial orders
      if (I_A1_ISort.size() <= 1)
      {
        ///        ic1=isort
        I_IR1 = I_A1_ISort(0);
      }/// end if (I_A1_ISort.size() <= 1)
      ///      endif else begin
      else
      {
        ///        ic1 = isort(1)                                ;index of next closest bin
        I_IR1 = I_A1_ISort(1);

        ///        bc0 = binc(ic0)                               ;closest bin center
        //        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_BinCen = " << D_A1_BinCen << ", D_A1_IR0 = " << D_A1_IR0 << endl;
        //        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_BinCen = " << D_A1_BinCen << ", D_A1_IR0 = " << D_A1_IR0 << endl;
        D_BR0 = D_A1_BinCen(I_IR0);

        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_BR0 set to " << D_BR0 << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_BR0 set to " << D_BR0 << endl;
        #endif

        ///        bc1 = binc(ic1)                               ;next closest center
        D_BR1 = D_A1_BinCen(I_IR1);

        #ifdef __DEBUG_FITS_MKSLITFUNC__
          cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_BR1 set to " << D_BR1 << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_BR1 set to " << D_BR1 << endl;
        #endif

        ///      endelse
      }/// end else if (I_A1_ISort.size() > 1)
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_IR1 set to " << I_IR1 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_IR1 set to " << I_IR1 << endl;
      #endif

      ///      sf0 = interpolate(slitf(*,ic0), yint)           ;interpolate onto rows
      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): SF0: D_A1_XInt = " << D_A1_XInt << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): SF0: D_A1_XInt = " << D_A1_XInt << endl;
      #endif

      D_A1_TempArrA.resize(D_A2_SlitFTemp.rows());
      D_A1_TempArrA = D_A2_SlitFTemp(Range::all(), I_IR0);

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_TempArrA = " << D_A1_TempArrA << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_TempArrA = " << D_A1_TempArrA << endl;
      #endif

      CString CS_D_A2_SlitFTemp(DEBUGDIR);
      CString *P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("D_A1_TempArrA_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      this->WriteArrayToFile(D_A1_TempArrA, CS_D_A2_SlitFTemp, CString("ascii"));
      CS_D_A2_SlitFTemp.Set(DEBUGDIR);
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("D_A1_XInt_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      this->WriteArrayToFile(D_A1_XInt, CS_D_A2_SlitFTemp, CString("ascii"));
      CS_D_A2_SlitFTemp.Set(DEBUGDIR);
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("D_A1_XInt_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      this->WriteArrayToFile(D_A1_XInt, CS_D_A2_SlitFTemp, CString("ascii"));

      ///       D_A1_XInt = (I_A1_IX - D_A1_XCenters(irow) - D_XSFMin) / D_DXSF;
      Array<double, 1> *p_D_A1_SF0 = this->InterPolate(D_A1_TempArrA, D_A1_XInt);

      D_A1_TempArrA.resize(0);
      CS_D_A2_SlitFTemp.Set(DEBUGDIR);
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("p_D_A1_SF0_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      this->WriteArrayToFile(*p_D_A1_SF0, CS_D_A2_SlitFTemp, CString("ascii"));

      CS_D_A2_SlitFTemp.Set(DEBUGDIR);
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("D_A2_SlitFuncOrig_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      Array<double, 1> D_A1_SlitFunc(I_A2_MinCenMax(irow, 2) - I_A2_MinCenMax(irow, 0) + 1);
      D_A1_SlitFunc = (*(this->P_D_A2_PixArray))(irow, Range(I_A2_MinCenMax(irow, 0), I_A2_MinCenMax(irow, 2)));
      this->WriteArrayToFile(D_A1_SlitFunc, CS_D_A2_SlitFTemp, CString("ascii"));

      CS_D_A2_SlitFTemp.Set(DEBUGDIR);
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("D_A2_SlitFuncOrig_x_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      Array<double, 1> D_A1_XX(I_A2_MinCenMax(irow, 2) - I_A2_MinCenMax(irow, 0) + 1);
      cout << "D_A1_XCenMXC = " << D_A1_XCenMXC << endl;
      for (int iiii=0; iiii<D_A1_XX.size(); iiii++)
        D_A1_XX(iiii) = (double(iiii)+D_A1_XCenMXC(irow)-1.)*double(this->I_OverSample);
      cout << "D_A1_XX = " << D_A1_XX << endl;
//      return false;
      this->WriteArrayToFile(D_A1_XX, CS_D_A2_SlitFTemp, CString("ascii"));

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): p_D_A1_SF0 set to " << *p_D_A1_SF0 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): p_D_A1_SF0 set to " << *p_D_A1_SF0 << endl;
      #endif
      ///      sf1 = interpolate(slitf(*,ic1), yint)           ;interpolate onto rows

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): SF1: D_A1_XInt = " << D_A1_XInt << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): SF1: D_A1_XInt = " << D_A1_XInt << endl;
      #endif

      D_A1_TempArrB.resize(D_A2_SlitFTemp.rows());
      D_A1_TempArrB = D_A2_SlitFTemp(Range::all(), I_IR1);

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_TempArrB = " << D_A1_TempArrB << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_TempArrB = " << D_A1_TempArrB << endl;
      #endif

      Array<double, 1> *p_D_A1_SF1 = this->InterPolate(D_A1_TempArrB, D_A1_XInt);
      D_A1_TempArrB.resize(0);
      CS_D_A2_SlitFTemp.Set(DEBUGDIR);
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("p_D_A1_SF1_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      this->WriteArrayToFile(*p_D_A1_SF1, CS_D_A2_SlitFTemp, CString("ascii"));

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_SF1 set to " << *p_D_A1_SF1 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_SF1 set to " << *p_D_A1_SF1 << endl;
      #endif

      ///      sf = sf0 + (sf1-sf0)/(bc1-bc0) * (icol-bc0)     ;extra/interpolate icol
      D_A1_SF.resize(p_D_A1_SF0->size());

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        D_A1_TempArrC.resize(p_D_A1_SF0->size());
        D_A1_TempArrC = (*p_D_A1_SF1) - (*p_D_A1_SF0);
        cout << "CFits::MkSlitFunc: Calculating D_A1_SF to D_A1_SF0(=" << *p_D_A1_SF0 << ") + (D_A1_SF1(=" << *p_D_A1_SF1 << ") - D_A1_SF0(=" << *p_D_A1_SF0 << ") = " << D_A1_TempArrC << ") /" << endl;
        cout << "CFits::MkSlitFunc:              (D_BR1(=" << D_BR1 << ") - D_BR0(=" << D_BR0 << ") = " << D_BR1 - D_BR0 << ") * (irow(=" << irow << ") - D_BR0(=" << D_BR0 << ") = " << irow - D_BR0 << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: Calculating D_A1_SF to D_A1_SF0(=" << *p_D_A1_SF0 << ") + (D_A1_SF1(=" << *p_D_A1_SF1 << ") - D_A1_SF0(=" << *p_D_A1_SF0 << ") = " << D_A1_TempArrC << ") /" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc:              (D_BR1(=" << D_BR1 << ") - D_BR0(=" << D_BR0 << ") = " << D_BR1 - D_BR0 << ") * (irow(=" << irow << ") - D_BR0(=" << D_BR0 << ") = " << irow - D_BR0 << ")" << endl;
        D_A1_TempArrC.resize(1);
      #endif


      D_A1_SF = (*p_D_A1_SF0) + ((*p_D_A1_SF1) - (*p_D_A1_SF0)) / (D_BR1 - D_BR0) * ((double)irow - D_BR0);
      delete p_D_A1_SF0;
      delete p_D_A1_SF1;
      CS_D_A2_SlitFTemp.Set(DEBUGDIR);
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(I_Telluric);
      CS_D_A2_SlitFTemp += CString("D_A1_SFlt0_Tel") + (*P_CS_NumTemp) + CString("_irow");
      delete(P_CS_NumTemp);
      P_CS_NumTemp = CS_D_A2_SlitFTemp.IToA(irow);
      CS_D_A2_SlitFTemp += (*P_CS_NumTemp) + CString(".dat");
      this->WriteArrayToFile(D_A1_SF, CS_D_A2_SlitFTemp, CString("ascii"));

      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_SF set to " << D_A1_SF << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_SF set to " << D_A1_SF << endl;
      #endif
      if (abs(sum(D_A1_SF)) < 0.000000001)
      {
        cout << "CFits::MkSlitFunc: ERROR: sum(D_A1_SF) == 0" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: sum(D_A1_SF) == 0" << endl;
        return false;
      }












      D_A1_SF = where(D_A1_SF < 0., 0., D_A1_SF);









      D_A1_SF = D_A1_SF / sum(D_A1_SF);
      CString CS_D_A1_SF(DEBUGDIR);
      CString *P_CS_NumA = CS_D_A1_SF.IToA(I_Telluric);
      CS_D_A1_SF += CString("D_A1_SF_end_Tel") + (*P_CS_NumA) + CString("_irow");
      delete(P_CS_NumA);
      P_CS_NumA = CS_D_A1_SF.IToA(irow);
      CS_D_A1_SF += (*P_CS_NumA) + CString(".dat");
      this->WriteArrayToFile(D_A1_SF, CS_D_A1_SF, CString("ascii"));
      delete(P_CS_NumA);


























      (*P_D_A2_ProfArray)(irow, Range(I_A2_MinCenMax(irow, 0), I_A2_MinCenMax(irow, 2))) = D_A1_SF * fac;
      CS_D_A1_SF.Set(DEBUGDIR);
      P_CS_NumA = CS_D_A1_SF.IToA(I_Telluric);
      CS_D_A1_SF += CString("D_A1_Prof_Tel") + (*P_CS_NumA) + CString("_irow");
      delete(P_CS_NumA);
      P_CS_NumA = CS_D_A1_SF.IToA(irow);
      CS_D_A1_SF += (*P_CS_NumA) + CString(".dat");
      this->WriteArrayToFile(D_A1_SF, CS_D_A1_SF, CString("ascii"));
      delete(P_CS_NumA);

      CS_D_A1_SF.Set(DEBUGDIR);
      P_CS_NumA = CS_D_A1_SF.IToA(I_Telluric);
      CS_D_A1_SF += CString("D_A1_Im_Tel") + (*P_CS_NumA) + CString("_irow");
      delete(P_CS_NumA);
      P_CS_NumA = CS_D_A1_SF.IToA(irow);
      CS_D_A1_SF += (*P_CS_NumA) + CString(".dat");
      this->WriteArrayToFile((*(const_cast<CFits*>(this)->P_D_A2_PixArray))(irow, Range(I_A2_MinCenMax(irow, 0), I_A2_MinCenMax(irow, 2))), CS_D_A1_SF, CString("ascii"));
      delete(P_CS_NumA);

      CS_D_A1_SF.Set(DEBUGDIR);
      P_CS_NumA = CS_D_A1_SF.IToA(I_Telluric);
      CS_D_A1_SF += CString("D_A1_Sky_Tel") + (*P_CS_NumA) + CString("_irow");
      delete(P_CS_NumA);
      P_CS_NumA = CS_D_A1_SF.IToA(irow);
      CS_D_A1_SF += (*P_CS_NumA) + CString(".dat");
      Array<double, 1> D_A1_SkyRow(I_A2_MinCenMax(irow, 2) - I_A2_MinCenMax(irow, 0) + 1);
      D_A1_SkyRow = D_A1_SkyFit(irow);
      this->WriteArrayToFile(D_A1_SkyRow, CS_D_A1_SF, CString("ascii"));
      delete(P_CS_NumA);
      /// TODO!!!! see above


















      #ifdef __DEBUG_FITS_MKSLITFUNC__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): P_D_A2_ProfArray(irow(=" << irow << "), Range(I_A2_MinCenMax(irow, 0)(=" << I_A2_MinCenMax(irow, 0) << "), I_A2_MinCenMax(irow, 2)(=" << I_A2_MinCenMax(irow, 2) << ")) set to " << (*P_D_A2_ProfArray)(irow, Range(I_A2_MinCenMax(irow, 0), I_A2_MinCenMax(irow, 2))) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): P_D_A2_ProfArray(irow(=" << irow << "), Range(I_A2_MinCenMax(irow, 0)(=" << I_A2_MinCenMax(irow, 0) << "), I_A2_MinCenMax(irow, 2)(=" << I_A2_MinCenMax(irow, 2) << ")) set to " << (*P_D_A2_ProfArray)(irow, Range(I_A2_MinCenMax(irow, 0), I_A2_MinCenMax(irow, 2))) << endl;
      #endif
    }/// end if (I_X0 != I_X1)


    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: end for (irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++)" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: end for (irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++)" << endl;
    #endif

  }/// end for (irow = 0; irow < this->NRows; irow++)
  //return false;


  //  /// Vector containing the interpolated column
  //  Array<double, 1> D_A1_InterPol(I_NXSF);
  /*  /// Fill Profile Array
    /// Loop through Bins
    for (int m = -1; m < I_NBin; m++)
    {
      /// First Bin
      if (m == -1)
      {
        /// Set first rows to first slit function
        I_StartInd = I_A1_IBeg(0);
        I_EndInd = (int)D_A1_BinCen(0);
        D_A1_SlitPixA = 2. * D_A2_SlitFTemp(Range::all(), 0) - D_A2_SlitFTemp(Range::all(), 1);
        D_A1_SlitPixB = D_A2_SlitFTemp(Range::all(), 0);

  //      i_nrows = (int)(D_A1_BinCen(1)) - (int)(D_A1_BinCen(0));
  /*      /// Loop through rows of Profile Array from beginning to BinCenter
            for (int n = I_A1_IBeg(0); n <= D_A1_BinCen(0); n++)
        {
          (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = I_A1_IBeg(0)=" << I_A1_IBeg(0) << "; n <= D_A1_BinCen(0)=" << D_A1_BinCen(0) << "): Setting PixArray(m, Range(XCenters(I_IAperture_In=" << I_IAperture_In << " + Low(I_IAperture_In)=" << (*P_D_A1_XLow)(I_IAperture_In) << "))=" << Range((int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)), (int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)) + I_NSlitF - 1) << " to D_A2_SlitFTemp(Range::all(), 0) = " << D_A2_SlitFTemp(Range::all(), m) << endl;


          D_A2_Profile(n,Range::all())
              = D_A2_SlitFTemp(Range::all(), m);
      }*/
  /*    }
      else if (m == I_NBin - 1)
      {
        /// Set last rows to last slit function
        I_StartInd = (int)D_A1_BinCen(m);
        I_EndInd = I_A1_IEnd(m);
        D_A1_SlitPixA = D_A2_SlitFTemp(Range::all(), m);
        D_A1_SlitPixB = 2 * D_A1_SlitPixA - D_A2_SlitFTemp(Range::all(), m-1);

  /*      for (int n = (int)(D_A1_BinCen(m)); n <= I_A1_IEnd(m); n++)
        {
          (*P_OFS_Log) << "CFits::MkSlitFunc: Setting D_A2_Profile(n=" << n << ", Range((int)((*P_D_A2_XCenters)(I_IAperture_In, n)(=" << (*P_D_A2_XCenters)(I_IAperture_In, n) << ") + (*P_D_A1_XLow)(I_IAperture_In)(=" << (*P_D_A1_XLow)(I_IAperture_In) << ")), (int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In) = " << (*P_D_A1_XLow)(I_IAperture_In) << ") + I_NSlitF(=" << I_NSlitF << ") - 1) = " << Range((int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)), (int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)) + I_NSlitF - 1) << ") to D_A2_SlitFTemp(Range::all(), m=" << m << ") = " << D_A2_SlitFTemp(Range::all(), m) << endl;

          D_A2_Profile(n, Range((int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)), (int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)) + I_NSlitF - 1)) = D_A2_SlitFTemp(Range::all(), m);
      }*/
  /*    }
      else
      {
        /// Set last rows to last slit function
        I_StartInd = (int)D_A1_BinCen(m);
        I_EndInd = (int)D_A1_BinCen(m+1);
        D_A1_SlitPixA = D_A2_SlitFTemp(Range::all(), m);
        D_A1_SlitPixB = D_A2_SlitFTemp(Range::all(), m+1);

        /// Interpolate profile rows from bins
        /// Loop through columns of Slit Function
        /// NOTE: Columns of Slit Function belong to (Rows of PixArray + Offset)
      //if (m < I_NBin)
     // {
      }

      /// Sum SubPixels to real Pixels of Profile Array
      D_A1_SlitPixBinA.resize(I_NXSF);
      D_A1_SlitPixBinA = 0.;
      D_A1_SlitPixBinB.resize(I_NXSF);
      D_A1_SlitPixBinB = 0.;

  /*    WeightFirst = (*this->P_D_A2_XCenters)(I_IAperture_In, 0) +
          (double)((*this->P_D_A1_XLow)(I_IAperture_In));
      XFirst = (int)WeightFirst;
      WeightFirst -= (double)XFirst;
      WeightFirst = 1. - WeightFirst;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XFirst set to " << XFirst << ", WeightFirst set to " << WeightFirst << endl;

      WeightLast = (*this->P_D_A2_XCenters)(I_IAperture_In, 0) +
          (*this->P_D_A1_XHigh)(I_IAperture_In);
      XLast = (int)WeightLast;
      WeightLast -= (double)XLast;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XLast set to " << XLast << ", WeightLast set to " << WeightLast << endl;

      npix = XLast - XFirst + 1;
      if (npix != I_NXSF)
      {
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): ERROR: npix(=" << npix << ") != I_NXSF(=" << I_NXSF << ") => Returning FALSE!";
        return false;
      }
      for (int p = 0; p < I_NXSF; p++)
      {
        temp_ind_arr = where((*P_D_A1_XLow)(I_IAperture_In) + (*P_D_A2_XCenters)(I_IAperture_In, I_StartInd) >= p && D_A1_XSlitFTemp - (*P_D_A1_XLow)(I_IAperture_In) < p+1, 1, 0);
        ind_arr.resize(sum(temp_ind_arr));
        int temppos = 0;
        for (int o = 0; o < D_A1_XSlitFTemp.size(); o++)
        {
          if (temp_ind_arr(o) == 1)
          {
            ind_arr(temppos) = o;
            temppos++;
          }
        }
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): ind_arr set to " << ind_arr << endl;

        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): this->GetSubArr(D_A2_Profile(m, Range::all()), ind_arr) = " << this->GetSubArr(D_A2_SlitFTemp(m, Range::all()), ind_arr) << endl;

        D_A2_Profile(p, I_StartInd) = sum(this->GetSubArr(D_A1_SlitPixA, ind_arr));
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): D_A2_Profile(p, I_StartInd=" << I_StartInd << ") set to " << D_A2_Profile(p,I_StartInd) << endl;

        D_A2_Profile(p, I_EndInd) = sum(this->GetSubArr(D_A1_SlitPixA, ind_arr));
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): D_A2_Profile(p, I_EndInd=" << I_EndInd << ") set to " << D_A2_Profile(p,I_EndInd) << endl;
      }
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): D_A2_Profile(Range::all(), I_StartInd=" << I_StartInd << ") set to " << D_A2_Profile(Range::all(),I_StartInd) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): D_A2_Profile(Range::all(), I_EndInd=" << I_EndInd << ") set to " << D_A2_Profile(Range::all(),I_EndInd) << endl;



      i_nrows = I_EndInd - I_StartInd + 1;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin=" << I_NBin << "; m++): i_nrows set to " << i_nrows << "; I_NXSF = " << I_NXSF << endl;

      D_A1_Ind.resize(i_nrows);
      D_A1_Ind = i / i_nrows;

      /// Vector of y_start(==0) and y_end(==1)
      D_A1_YBin(0) = 0.;
      D_A1_YBin(1) = 1.;

      /// Loop through Rows of Profile Array
      for (int n = 0; n < i_nrows; n++)
      {
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin=" << I_NBin << "; m++): for (int n = 0; n < i_nrows(=" << i_nrows << "); n++): Starting Interpolation" << endl;

  //      /// Pixels to interpolate between
  //      D_A1_Bins(0) = D_A1_SlitPixA(n);
  //      D_A1_Bins(1) = D_A1_SlitPixB(n);
  //      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (int n = 0; n < i_nrows(=" << i_nrows << "); n++): D_A1_Bins set to " << D_A1_Bins << endl;

  //      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (int n = 0; n < i_nrows(=" << i_nrows << "); n++): Starting InterPol: D_A1_YBin = " << D_A1_YBin << ", D_A1_Bins = " << D_A1_Bins << ", D_A1_Ind = " << D_A1_Ind << endl;

        WeightFirst = (*this->P_D_A2_XCenters)(I_IAperture_In, m) +
                      (double)((*this->P_D_A1_XLow)(I_IAperture_In));
        XFirst = (int)WeightFirst;
        WeightFirst -= (double)XFirst;
        WeightFirst = 1. - WeightFirst;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XFirst set to " << XFirst << endl;

        WeightLast = (*this->P_D_A2_XCenters)(I_IAperture_In, m) +
                     (*this->P_D_A1_XHigh)(I_IAperture_In);
        XLast = (int)WeightLast;
        WeightLast -= (double)XLast;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XLast set to " << XLast << endl;

        npix = XLast - XFirst + 1;
        for (int n = 0; n < npix; n++)
        {

          (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): for (int n(=" << n << ") = 0; n < npix(=" << npix << "); n++): PixArray(m=" << m << ", (XFirst + n)=" << XFirst + n << ") set to " << (*P_D_A2_PixArray)(m, XFirst + n) << endl;
        }
        D_A2_Profile(n, Range(I_StartInd, I_EndInd))
            = D_A1_SlitPixA + ((n / I_NXSF) * (D_A1_SlitPixB - D_A1_SlitPixA));

        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin=" << I_NBin << "; m++): for (int n = 0; n < I_NXSF(=" << I_NXSF << "); n++): D_A1_Bins = " << D_A1_Bins << endl;
      }
    }
    this->WriteArrayToFile(D_A2_Profile, *(new CString("/home/azuri/entwicklung/c/fitsutil/cfits/test/Profile_out.dat")));
    /// Fill PixArray with Profile
    (*this->P_D_A2_PixArray) = 0.;
    /// Loop through rows
    for (int m = (*this->P_D_A1_XMin)(I_IAperture_In); m <= (*this->P_D_A1_XMax)(I_IAperture_In); m++)
    {

      /// Loop through columns
    }*

  /// FILENAME
  CS_Temp.Set("FILENAME");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    CString CS_TempFileName(*(CString*)ArgV_In[I_Pos]);
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkSlitFunc: KeyWord_Set(FILENAME): CS_TempFileName set to " << CS_TempFileName << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(FILENAME): CS_TempFileName set to " << CS_TempFileName << endl;
    #endif
    this->WriteArrayToFile(D_A2_SlitF, CS_TempFileName, CString("ascii"));
  }

  /*  cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->rows() = " << P_D_A2_Blaze->rows() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->cols() = " << P_D_A2_Blaze->cols() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->size() = " << P_D_A2_Blaze->size() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_BLZ(" << I_IAperture_In << ", *) = " << (*P_D_A2_Blaze)(I_IAperture_In, Range::all()) << endl;
  */
  //delete[] tmpstr;

  *this->P_D_A2_RecArray = where((*this->P_D_A2_RecArray) < 0., 0., (*this->P_D_A2_RecArray));
  *this->P_D_A2_RecFitArray = where((*this->P_D_A2_RecFitArray) < 0., 0., (*this->P_D_A2_RecFitArray));
//  *this->P_D_A2_RecSkyArray = where((*this->P_D_A2_RecSkyArray) < 0., 0., (*this->P_D_A2_RecSkyArray));

  D_A1_DXScatter.resize(0);
  I_A2_IBinBoundY.resize(0);
  D_A1_ICol.resize(0);
  I_A2_Msk.resize(0, 0);
  D_A1_SC.resize(0);
  D_A1_Scatter.resize(0);
  D_A2_SFSM.resize(0, 0);
  D_A1_SF.resize(0);
  D_A2_SlitFunc_Im_In.resize(0,0);
  D_A2_SlitFTemp.resize(0,0);
  D_A1_SP.resize(0);
  D_A1_SSF.resize(0);
  D_A1_Tel.resize(0);
  D_A2_Tel.resize(0,0);
  D_A1_Temp.resize(0);
  D_A1_TempArr.resize(0);
  D_A1_TempArrA.resize(0);
  D_A1_TempArrB.resize(0);
  D_A1_TempArrC.resize(0);
  D_A1_TempArrD.resize(0);
  D_A1_XCenMXC.resize(0);
  D_A1_XCentersE.resize(0);
  D_A1_XInt.resize(0);
  D_A1_XSlitFTemp.resize(0);
  I_A1_I.resize(0);
  I_A1_ISort.resize(0);
  I_A1_ITel.resize(0);
  I_A1_IX.resize(0);
  delete P_D_A1_BLZSmooth;

  free(PP_Args_Fit);
  free(PP_Args_Median);
  free(args);

  /*  for (int ipos = 0; ipos < pppos; ipos++)
    {
      delete pp_cstr[ipos];
  //    delete args[ipos];
  }*/
  //    delete pp_cstr;
  //    delete(args);

//  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("BLZ"));
//  if (I_Pos < 0)/// KeyWord not set
//  {
    // #ifdef __DEBUG_FITS_MKSLITFUNC__
    //    cout << "CFits::MkSlitFunc: BLZ not set: writing P_D_A1_BLZ to file" << endl;
    //    (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ not set: writing P_D_A1_BLZ to file" << endl;
    // #endif
    //    ofstream *P_OFS_BLZ = new ofstream("blz_out.text");
    //    for (int iblz=0; iblz < P_D_A1_BLZ->size(); iblz++)
    //      (*P_OFS_BLZ) << (*P_D_A1_BLZ)(iblz) << endl;
    //    delete P_OFS_BLZ;
//    #ifdef __DEBUG_FITS_MKSLITFUNC__
//      cout << "CFits::MkSlitFunc: BLZ not set: deleting P_D_A1_BLZ" << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ not set: deleting P_D_A1_BLZ" << endl;
//      cout << "CFits::MkSlitFunc: BLZ not set: P_D_A1_BLZ deleted" << endl;
//      (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ not set: P_D_A1_BLZ deleted" << endl;
//    #endif
//  }

  //  CS_A1_Args_In.resize(0);
  cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ": D_A2_SF = " << D_A2_SF << endl;
  cout << "CFits::MkSlitFunc: I_IAperture_In = " << I_IAperture_In << ": D_A1_SP = " << D_A1_SP << endl;
  return true;
}

/**
  MkProfIm
  Make Profile Image
 **/
bool CFits::MkProfIm()
{
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args = CString(" ");
  void **PP_Args;
  PP_Args = (void**)malloc(sizeof(void*) * 1);

  int I_temp = 0;
  PP_Args[0] = &I_temp;

  if (!this->MkProfIm(CS_A1_Args, PP_Args))
  {
    cout << "CFits::MkProfIm(): ERROR: MkProfIm(CS_A1_Args=" << CS_A1_Args << ") returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::MkProfIm(): ERROR: MkProfIm(CS_A1_Args=" << CS_A1_Args << ") returned FALSE => Returning FALSE" << endl;
    return false;
  }
  return true;
}

/**
  MkProfIm
  Make Profile Image
 **/
bool CFits::MkProfIm(const Array<CString, 1> &CS_A1_Args_In,       ///: in
                     void *ArgV_In[])                                  ///: in
/** KeyWords and Values:   SWATH_WIDTH:              int: in
                           LAMBDA_SF  :              int: in (Smoothing across dispersion)
                           LAMBDA_SP  :              int: in (Smoothing along dispersion)
                           FLAT       :             bool: in
                           TELLURIC   :             int(0-none, 1-Piskunov, 2-mine, 3-mine with sky continuum): in (subtract sky lines)
                           OLD: none (use old version of SlitFunc)
                           AREA        = Array<int, 1>(4): [xmin, xmax, ymin, ymax]: in
                           WING_SMOOTH_FACTOR = double  : in
                           XCOR_PROF  : int: in
                           APERTURES  : Array<int, 1>: in (Apertures to extract)
                           **/
{
  #ifdef __DEBUG_FITS_MKPROFIM__
    (*P_OFS_Log) << "CFits::MkProfIm: started: this = " << *this << endl;

    (*P_OFS_Log) << "CFits::MkProfIm: P_D_A1_XHigh = " << (*this->P_D_A1_XHigh) << endl;

    (*P_OFS_Log) << "CFits::MkProfIm: P_D_A1_XLow = " << (*this->P_D_A1_XLow) << endl;
  #endif

  Array<double, 1> D_A1_ScatterBelow(this->NRows);
  D_A1_ScatterBelow = 0.;

  Array<double, 1> D_A1_XScatterBelow(this->NRows);
  D_A1_XScatterBelow = 0.;

  Array<double, 1> D_A1_ScatterAbove(this->NRows);
  D_A1_ScatterAbove = 0.;

  Array<double, 1> D_A1_XScatterAbove(this->NRows);
  D_A1_XScatterAbove = 0.;

  //  double D_XLeftLim;
  //  double D_XRightLim;
  //  double D_LambdaSF = 40.;
  //  double D_LambdaSP = 20.;

  //  int I_YLowerLim;
  //  int I_YUpperLim;

  //  int I_NArgs = 0;
  int I_Pos = 0;
  int I_NArgs = 0;
  int I_XMin = 0;
  int I_XMax = this->NCols-1;
  int I_YMin = 0;
  int I_YMax = this->NRows-1;

  Array<double, 1> D_A1_XSlitF(1);
  Array<double, 2> D_A2_SlitF(1,1);
  Array<double, 1> D_A1_BinCen(1);
  D_A1_BinCen = 0.;
  Array<double, 1> D_A1_BLZ(this->NRows);
  D_A1_BLZ = 0.;


  Array<CString, 1> CS_A1_Args_MkSlitF(14);
  CS_A1_Args_MkSlitF = CString(" ");

  void **PP_Args;
  PP_Args = (void**)malloc(sizeof(void*) * 14);

  //  CS_A1_Args_MkSlitF(0) = CString("Y_LOWER_LIM");
  //  PP_Args[0] = &I_YLowerLim;
  //  I_NArgs++;

  //  CS_A1_Args_MkSlitF(1) = CString("Y_UPPER_LIM");
  //  PP_Args[1] = &I_YUpperLim;
  //  I_NArgs++;

  //  CS_A1_Args_MkSlitF(0) = CString("OVERSAMPLE");
  //  PP_Args[0] = &I_OverSample;
  //  I_NArgs++;

  CS_A1_Args_MkSlitF(I_NArgs) = CString("CCD_GAIN");
  PP_Args[I_NArgs] = &this->D_Gain;
  I_NArgs++;

  CS_A1_Args_MkSlitF(I_NArgs) = CString("CCD_READN");
  PP_Args[I_NArgs] = &this->D_ReadOutNoise;
  I_NArgs++;

  CS_A1_Args_MkSlitF(I_NArgs) = CString("NO_SCATTER");
  int noscat = 1;
  PP_Args[I_NArgs] = &noscat;
  I_NArgs++;

  int I_XCorProf = 0;
  CString CS_Temp(" ");
  CS_Temp.Set("XCOR_PROF");
//  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_Temp)) >= 0)
  {
    I_XCorProf = *(int*)(ArgV_In[I_Pos]);
    cout << "CFits::MkProfIm: KeyWord_Set(XCOR_PROF): I_XCorProf set to " << I_XCorProf << endl;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      (*P_OFS_Log) << "CFits::MkProfIm: KeyWord_Set(XCOR_PROF): I_XCorProf set to " << I_XCorProf << endl;
    #endif
    if (I_XCorProf > 0){
      CS_A1_Args_MkSlitF(I_NArgs) = CString("XCOR_PROF");
      PP_Args[I_NArgs] = &I_XCorProf;
      cout << "PP_Args[I_NArgs=" << I_NArgs << "] set to I_XCorProf = " << *(int*)PP_Args[I_NArgs] << endl;
      I_NArgs++;
    }
//    return false;
  }

  Array<int, 1> *P_I_A1_AperturesToExtract = this->IndGenArr(this->I_NApertures);
  CS_Temp.Set("APERTURES");
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_Temp)) >= 0)
  {
    delete(P_I_A1_AperturesToExtract);
    P_I_A1_AperturesToExtract = (Array<int, 1>*)(ArgV_In[I_Pos]);
    cout << "CFits::MkProfIm: KeyWord_Set(APERTURES): P_I_A1_AperturesToExtract set to " << *P_I_A1_AperturesToExtract << endl;
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      (*P_OFS_Log) << "CFits::MkProfIm: KeyWord_Set(APERTURES): P_I_A1_AperturesToExtract set to " << *P_I_A1_AperturesToExtract << endl;
    #endif
//    if (I_XCorProf > 0){
//      CS_A1_Args_MkSlitF(I_NArgs) = CString("XCOR_PROF");
//      PP_Args[I_NArgs] = &I_XCorProf;
//      cout << "PP_Args[I_NArgs=" << I_NArgs << "] set to I_XCorProf = " << *(int*)PP_Args[I_NArgs] << endl;
//      I_NArgs++;
//    }
//    return false;
  }

  int I_SwathWidth = 300;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("SWATH_WIDTH"))) >= 0)
  {
    CS_A1_Args_MkSlitF(I_NArgs) = CString("SWATH_WIDTH");
    I_SwathWidth = *(int*)ArgV_In[I_Pos];
    PP_Args[I_NArgs] = &I_SwathWidth;
    I_NArgs++;
    cout << "CFits::MkProfIm: KeyWord_Set(SWATH_WIDTH): I_Pos = " << I_Pos << ": I_SwathWidth set to " << I_SwathWidth << endl;
  }

  ///Area to extract
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("AREA"))) >= 0)
  {
    Array<int, 1> I_A1_Area(4);
    I_A1_Area = *(Array<int, 1>*)ArgV_In[I_Pos];
    //#ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkProfIm: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
      //(*P_OFS_Log) << "CFits::MkProfIm: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
    //#endif
    I_XMin = I_A1_Area(0);
    I_XMax = I_A1_Area(1);
    I_YMin = I_A1_Area(2);
    I_YMax = I_A1_Area(3);
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MkProfIm: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
      //(*P_OFS_Log) << "CFits::MkProfIm: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
    #endif
//      return false;
  }

  int I_Telluric = 0;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("TELLURIC"))) >= 0)
  {
    I_Telluric = *(int*)ArgV_In[I_Pos];
    if (I_Telluric > 0){
      CS_A1_Args_MkSlitF(I_NArgs) = CString("TELLURIC");
      PP_Args[I_NArgs] = &I_Telluric;
      I_NArgs++;
      cout << "CFits::MkProfIm: I_Telluric set to " << I_Telluric << endl;
    }
  }

  double D_SF_Smooth = 1. / double(this->I_OverSample);
  cout << "CFits::MkProfIm: CS_A1_Args_In = " << CS_A1_Args_In << endl;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("LAMBDA_SF"))) >= 0)
  {
    cout << "CFits::MkProfIm: I_Pos = " << I_Pos << ", I_NArgs = " << I_NArgs << endl;
    D_SF_Smooth = *(double*)(ArgV_In[I_Pos]);
    cout << "CFits::MkProfIm: D_SF_Smooth set to " << D_SF_Smooth << endl;
    CS_A1_Args_MkSlitF(I_NArgs) = CString("LAMBDA_SF");
    PP_Args[I_NArgs] = &D_SF_Smooth;
    cout << "CFits::MkProfIm: PP_Args[" << I_NArgs << "] set to " << *(double*)PP_Args[I_NArgs] << endl;
    I_NArgs++;
    cout << "CFits::MkProfIm: I_NArgs = " << I_NArgs << endl;
//    return false;
  }

  double D_WingSmoothFactor = 0.;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("WING_SMOOTH_FACTOR"))) >= 0)
  {
    cout << "CFits::MkProfIm: I_Pos = " << I_Pos << ", I_NArgs = " << I_NArgs << endl;
    D_WingSmoothFactor = *(double*)(ArgV_In[I_Pos]);
    cout << "CFits::MkProfIm: D_WingSmoothFactor set to " << D_WingSmoothFactor << endl;
    CS_A1_Args_MkSlitF(I_NArgs) = CString("WING_SMOOTH_FACTOR");
    PP_Args[I_NArgs] = &D_WingSmoothFactor;
    cout << "CFits::MkProfIm: PP_Args[" << I_NArgs << "] set to " << *(double*)PP_Args[I_NArgs] << endl;
    I_NArgs++;
    cout << "CFits::MkProfIm: I_NArgs = " << I_NArgs << endl;
//    return false;
  }

  CS_A1_Args_MkSlitF(I_NArgs) = CString("BLZ");
  PP_Args[I_NArgs] = &D_A1_BLZ;
  I_NArgs++;

  int I_SP_Smooth = 1;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("LAMBDA_SP"))) >= 0)
  {
    I_SP_Smooth = *(int*)ArgV_In[I_Pos];
    CS_A1_Args_MkSlitF(I_NArgs) = CString("LAMBDA_SP");
    PP_Args[I_NArgs] = &I_SP_Smooth;
    I_NArgs++;
    cout << "CFits::MkProfIm: I_SP_Smooth set to " << I_SP_Smooth << endl;
  }
  if (this->KeyWord_Set(CS_A1_Args_In, CString("FLAT")) >= 0)
  {
    CS_A1_Args_MkSlitF(I_NArgs) = CString("FLAT");
    PP_Args[I_NArgs] = &D_A1_BLZ;
    I_NArgs++;
  }

  if (this->KeyWord_Set(CS_A1_Args_In, CString("OLD")) >= 0)
    CS_A1_Args_MkSlitF(I_NArgs) = CString("OLD");
  //  else
//  {
//    while (I_NArgs < 10)
//    {
//      CS_A1_Args_MkSlitF(I_NArgs) = CString(" ");
//      PP_Args[I_NArgs] = &noscat;
//      I_NArgs++;
//    }
//  }

  #ifdef __DEBUG_FITS_MKPROFIM__
    cout << "CFits::MkProfIm: CS_A1_Args_MkSlitF set to " << CS_A1_Args_MkSlitF << endl;
    (*P_OFS_Log) << "CFits::MkProfIm: CS_A1_Args_MkSlitF set to " << CS_A1_Args_MkSlitF << endl;
  #endif
  //  cout << "CFits::MkProfIm: I_NArgs set to " << I_NArgs << endl;
  //  CS_A1_Args.resizeAndPreserve(I_NArgs);

  *this->P_D_A2_RecArray = 0.;//*this->P_D_A2_PixArray;
  *this->P_D_A2_RecFitArray = 0.;//*this->P_D_A2_PixArray;
  *this->P_D_A2_RecSkyArray = 0.;//*this->P_D_A2_PixArray;

  int i_ord;
  for (int i_ap = 0; i_ap < P_I_A1_AperturesToExtract->size(); i_ap++)//1; i_ord++)//
  {
    i_ord = (*P_I_A1_AperturesToExtract)(i_ap);
    if (((*(this->P_D_A1_XCenter))(i_ord) >= I_XMin)
        && ((*(this->P_D_A1_XCenter))(i_ord) <= I_XMax)
        && ((((*(this->P_D_A1_YCenter))(i_ord)+(*(this->P_D_A1_YLow))(i_ord) >= I_YMin)
            && ((*(this->P_D_A1_YCenter))(i_ord)+(*(this->P_D_A1_YLow))(i_ord) <= I_YMax))
           || (((*(this->P_D_A1_YCenter))(i_ord)+(*(this->P_D_A1_YHigh))(i_ord) >= I_YMin)
            && ((*(this->P_D_A1_YCenter))(i_ord)+(*(this->P_D_A1_YHigh))(i_ord) <= I_YMax)))){
      #ifdef __DEBUG_FITS_MKPROFIM__
        cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): this->P_CS_FileName = " << *this->P_CS_FileName << endl;
        (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): this->P_CS_FileName = " << *this->P_CS_FileName << endl;
      #endif
      //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): this->P_D_A2_XCenters = " << *this->P_D_A2_XCenters << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): this->P_D_A2_XCenters = " << *this->P_D_A2_XCenters << endl;
      // #endif
      //    Array<double, 1> D_A1_XCenters((*this->P_D_A2_XCenters)(i_ord, Range::all()));

      // #ifdef __DEBUG_FITS_MKPROFIM__
      //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_A1_XCenters set to " << D_A1_XCenters << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_A1_XCenters set to " << D_A1_XCenters << endl;

      //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XHigh = " << (*this->P_D_A1_XHigh) << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XHigh = " << (*this->P_D_A1_XHigh) << endl;

      //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XLow = " << (*this->P_D_A1_XLow) << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XLow = " << (*this->P_D_A1_XLow) << endl;
      // #endif
      //    D_XLeftLim = 0. - (*this->P_D_A1_XLow)(i_ord);

      // #ifdef __DEBUG_FITS_MKPROFIM__
      //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_XLeftLim set to " << D_XLeftLim << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_XLeftLim set to " << D_XLeftLim << endl;
      // #endif
      //    D_XRightLim = (*this->P_D_A1_XHigh)(i_ord);

      // #ifdef __DEBUG_FITS_MKPROFIM__
      //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_XRightLim set to " << D_XRightLim << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_XRightLim set to " << D_XRightLim << endl;
      // #endif
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_YCenter(i_ord) = " << (*P_D_A1_YCenter)(i_ord) << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XMin(i_ord) = " << (*P_D_A1_XMin)(i_ord) << endl;
      //    I_YLowerLim = (int)((*this->P_D_A1_XMin)(i_ord));

      // #ifdef __DEBUG_FITS_MKPROFIM__
      //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): I_YLowerLim set to " << I_YLowerLim << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): I_YLowerLim set to " << I_YLowerLim << endl;
      // #endif
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XMax(i_ord) = " << (*P_D_A1_XMax)(i_ord) << endl;
      //    I_YUpperLim = (int)((*this->P_D_A1_XMax)(i_ord));
      // #ifdef __DEBUG_FITS_MKPROFIM__
      //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): I_YUpperLim set to " << I_YUpperLim << endl;
      //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): I_YUpperLim set to " << I_YUpperLim << endl;
      // #endif
      time_t seconds;
      seconds = time(NULL);
      cout << "CFits::MkProfIm: Starting MkSlitFunc(): time = " << seconds << endl;
      timeval tim;
      gettimeofday(&tim, NULL);
      double t1=tim.tv_sec+(tim.tv_usec/1000000.0);
      cout << "CFits::MkProfIm: Starting MkSlitFunc(): time = " << t1 << endl;
      if (!MkSlitFunc(D_A1_ScatterBelow,  //: in
                      D_A1_XScatterBelow, //: in
                      D_A1_ScatterAbove,  //: in
                      D_A1_XScatterAbove, //: in
                      //                    D_A1_XCenters,      //: in
                      //                    D_XLeftLim,         //: in
                      //                    D_XRightLim,        //: in
                      D_A1_XSlitF,        //: out
                      D_A2_SlitF,         //: out
                      D_A1_BinCen,        //: out
                      i_ord,     //: in
                      //I_NArgs,            //: in
                      CS_A1_Args_MkSlitF,  //: in
                      PP_Args))
      {
        //      delete PP_CString;
        //      delete PP_Args;
        cout << "CFits::MkProfIm: ERROR: MkSlitFunc returned FALSE => returning FALSE" << endl;
        (*P_OFS_Log) << "CFits::MkProfIm: ERROR: MkSlitFunc returned FALSE => returning FALSE" << endl;
        return false;
      }
      cout << "Fits::MkProfIm: MkSlitFunc finished" << endl;
      gettimeofday(&tim, NULL);
      double t2=tim.tv_sec+(tim.tv_usec/1000000.0);
      cout << "CFits::MkProfIm: MkSlitFunc finished after " << t2-t1 << endl;
      seconds = time(NULL);
      cout << "CFits::MkProfIm: MkSlitFunc returned TRUE at " << seconds << endl;
      #ifdef __DEBUG_FITS_MKPROFIM__
        (*P_OFS_Log) << "CFits::MkProfIm: MkSlitFunc returned TRUE" << endl;
      #endif
      //    cout << "CFits::MkProfIm: D_A1_BLZ = " << D_A1_BLZ;
      //    (*this->P_D_A2_Blaze)(i_ord, Range::all()) = D_A1_BLZ;

      /*                     //PLOT        =
      Y_LOWER_LIM = int             : in
      Y_UPPER_LIM = int             : in
      LAMBDA_SF   = double          : in
      LAMBDA_SP   = int             : in
      SWATH_WIDTH = int             : in
      BLZ         = Array<double, 1>: out
      OVERSAMPLE  = int             : in
      MASK        = Array<double, 2>: in
      CCD_GAIN    = double          : in
      CCD_READN   = double          : in
      NO_SCATTER  = void
      TELLURIC    = void
      FILENAME    = CString         : in
      */


      //    if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("BLZ"))) >= 0)
      //    {
      // #ifdef __DEBUG_FITS_MKPROFIM__
//    cout << "CFits::MkProfIm: reinitializing D_A1_BLZ " << endl;
//    (*P_OFS_Log) << "CFits::MkProfIm: reinitializing D_A1_BLZ " << endl;
// #endif
//    D_A1_BLZ = 0.;
    //      if (this->P_D_A2_Blaze->cols() != D_A1_BLZ.size())
    //      {
    //        cout << "CFits::MkProfIm: ERROR: BLZ set: this->P_D_A2_Blaze->cols(=" << P_D_A2_Blaze->cols() << ") != D_A1_BLZ.size(=" << D_A1_BLZ.size() << ") => Returning FALSE" << endl;
    //        (*P_OFS_Log) << "CFits::MkProfIm: ERROR: BLZ set: this->P_D_A2_Blaze->cols(=" << P_D_A2_Blaze->cols() << ") != D_A1_BLZ.size(=" << D_A1_BLZ.size() << ") => Returning FALSE" << endl;
    //        return false;
    //      }
    //      (*this->P_D_A2_Blaze)(i_ord, Range::all()) = D_A1_BLZ;
    // #ifdef __DEBUG_FITS_MKPROFIM__
    //      cout << "CFits::MkProfIm: this->P_D_A2_Blaze(i_ord(=" << i_ord << "), Range::all()) set to " << (*this->P_D_A2_Blaze)(i_ord, Range::all()) << endl;
    //      (*P_OFS_Log) << "CFits::MkProfIm: this->P_D_A2_Blaze(i_ord(=" << i_ord << "), Range::all()) set to " << (*this->P_D_A2_Blaze)(i_ord, Range::all()) << endl;
    // #endif
    //    }
    }
  }/// end for (i_ord = 0; i_ord < this->I_NApertures; i_ord++)
  //  this->WriteArrayToFile((*P_D_A2_ProfArray), CString("/home/azuri/entwicklung/c/fitsutil/cfits/test/Profile_out.dat"));
  // #ifdef __DEBUG_FITS_MKPROFIM__
  //  cout << "CFits::MkProfIm: P_D_A2_ProfArray written to Profile_out.dat" << endl;
  //  (*P_OFS_Log) << "CFits::MkProfIm: P_D_A2_ProfArray written to Profile_out.dat" << endl;
  // #endif
  // #ifdef __DEBUG_FITS_MKPROFIM__
  //  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("BLZ"))) >= 0)
  //    this->WriteArrayToFile((*P_D_A2_Blaze), CString("/home/azuri/entwicklung/c/fitsutil/cfits/test/Blaze_out.dat"));
  // #endif
  /*  for (int ippos = 0; ippos < I_NArgs; ippos++)
    {
      delete PP_CString[ippos];
  }*/
  //  delete PP_CString;
  free(PP_Args);
  D_A1_ScatterBelow.resize(0);
  D_A1_XScatterBelow.resize(0);
  D_A1_ScatterAbove.resize(0);
  CS_A1_Args_MkSlitF.resize(0);
  D_A1_XScatterAbove.resize(0);
  D_A1_XSlitF.resize(0);
  D_A2_SlitF.resize(0,0);
  D_A1_BinCen.resize(0);
  D_A1_BLZ.resize(0);

  this->ProfileCalculated = true;
  cout << "CFits::MkProfIm: ready" << endl;
  return true;
}

/**
  MkNormFlatProf
  Make Normalized Flat Profile
 **/
bool CFits::MkNormFlatProf(int I_LambdaSP_In,
                           Array<CString, 1> CS_A1_Args_In,
                           void *Args_In[])
/**
 * Keywords and Values: SWATH_WIDTH:                 int: in
 *                      AREA:        Array<double, 1>(4): in
 *                      LAMBDA_SF:                double: in
 * **/
{
  int I_NArgs = 0;
  Array<CString, 1> CS_A1_Args_MkProfIm(5);
  CS_A1_Args_MkProfIm = CString(" ");
  void **PP_Args;
  PP_Args = (void**)malloc(sizeof(void*) * 5);

  if (!this->ClassInvariant())
  {
    cout << "CFits::MkNormFlatProf: ERROR: this->ClassInvariant() returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::MkNormFlatProf: ERROR: this->ClassInvariant() returned FALSE => Returning FALSE" << endl;
    return false;
  }
  /// Trace Functions
  if (!this->TraceFunctionsCalculated)
  {
    if (!this->CalcTraceFunctions())
    {
      cout << "CFits::MkNormFlatProf: ERROR: this->CalcTraceFunctions() returned FALSE" << endl;
      (*P_OFS_Log) << "CFits::MkNormFlatProf: ERROR: this->CalcTraceFunctions() returned FALSE" << endl;
      return false;
    }
  }

  /// Profile
  CS_A1_Args_MkProfIm(I_NArgs) = CString("FLAT");
  PP_Args[I_NArgs] = &I_LambdaSP_In;
  I_NArgs++;

  CS_A1_Args_MkProfIm(I_NArgs) = CString("LAMBDA_SP");
  PP_Args[I_NArgs] = &I_LambdaSP_In;
  I_NArgs++;

  int I_Pos;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("SWATH_WIDTH"))) >= 0)
  {
    CS_A1_Args_MkProfIm(I_NArgs) = CString("SWATH_WIDTH");
    int I_SwathWidth = *(int*)Args_In[I_Pos];
    PP_Args[I_NArgs] = &I_SwathWidth;
    I_NArgs++;
  }

  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("LAMBDA_SF"))) >= 0)
  {
    CS_A1_Args_MkProfIm(I_NArgs) = CString("LAMBDA_SF");
    double D_LambdaSF = *(double*)Args_In[I_Pos];
    cout << "CFits::MkNormFlatProf: D_LambdaSF set to " << D_LambdaSF << endl;
    PP_Args[I_NArgs] = &D_LambdaSF;
    cout << "CFits::MkNormFlatProf: PP_Args[" << I_NArgs << "] set to " << *(double*)PP_Args[I_NArgs] << endl;
    I_NArgs++;
  }

  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("AREA"))) >= 0)
  {
    CS_A1_Args_MkProfIm(I_NArgs) = CString("AREA");
    Array<int, 1> I_A1_Area = *(Array<int, 1>*)Args_In[I_Pos];
    PP_Args[I_NArgs] = &I_A1_Area;
    I_NArgs++;
  }

  if (!this->MkProfIm(CS_A1_Args_MkProfIm, PP_Args))
  {
    cout << "CFits::MkNormFlatProf: ERROR: this->MkProfIm() returned FALSE" << endl;
    (*P_OFS_Log) << "CFits::MkNormFlatProf: ERROR: this->MkProfIm() returned FALSE" << endl;
    return false;
  }
  /*  for (int i=0; i < this->NRows; i++)
    {
      for (int j=0; j < this->NCols; j++)
      {
        if ((*P_D_A2_ProfArray)(i,j) < 10000.)
        {
          (*P_D_A2_ProfArray)(i,j) = 1.;
          cout << "CFits::MkNormFlatProf: pixel (" << i << ", " << j << ") set to 1." << endl;
        }
      }
  }*/

  //TODO: set normalized Flat to 1 where SNR < 100

  return true;
}






/**
bool CFits::MkScatter(const Array<CString, 1> &CS_A1_Args_In,           //: in
                      void *ArgV_In[]){                  //: in{
  /**
  orders...dblarr(order+1,nord)   -> P_D_A2_Coeffs(I_NApertures, 3)
  sz = size(im)...intarr
  ncol...int                      -> this->NRows
  nrow...int                      -> this->NCols
  nord...int                      -> this->I_NApertures
  CCD_gain...double               -> this->D_Gain
  CCD_rdnoise...double            -> this->D_ReadOutNoise
  osamp...int                     -> this->I_OverSample
  lambda_sf...double              -> d_lambda_sf
  xcol...dblarr(ncol)             -> D_A1_XRow(this->NRows)
  back...fltarr(ncol,nord+1)      -> D_A2_Back(this->NRows, this->I_NApertures+1)  ;fitted scattered light model
  back_data...fltarr(ncol,nord+1) -> D_A2_BackData(this->NRows, this->I_NApertures+1)  ;scattered light data
  yback...intarr(ncol,nord+1)     -> I_A2_YBack(this->NRows, this->I_NApertures+1) ;scattered light coordinates
  ycen0...dblarr(ncol)            -> D_A1_YCenA ;the shape of the starting order
  ycen1...dblarr(ncol)            -> D_A1_YCenB ;the shape of the starting order
  ycen...dblarr(ncol)             -> D_A1_YCen  ;central line of the troff
  ymin...dblarr(ncol)             -> P_I_A1_YMin    ;bottom boundary of the region of interest
  ymax...dblarr(ncol)             -> P_I_A1_YMax    ;top boundary of the region of interest
  nc...int                        -> I_NC       ;dimensions of the region of interest
  nr...int                        -> I_NR
  width...double, int             -> D_Width / I_Width
  ibeg...int                      -> I_Beg    ;left boundary to consider (lower)
  iend...int                      -> I_End    ;right boundary to consider (upper)
  icen...int                      -> I_Y_Center   ;central column of area of interest(->row)
  height...double, int            -> D_Height / I_Height
  x_left_lim...int                -> I_Y_Lower_Limit
  x_right_lim...int               -> I_Y_Upper_Limit
  sf...fltarr(nc,nr)              -> P_D_A2_SF
  sp...vector                     -> D_A1_SP
  sfsm...vector                   -> D_A1_SFSM
  sfbin...dblarr(nc,nr)           -> D_A2_SFOut
  imask...int                     -> i_mask
  nslitf...int                    -> I_NSlitF
  yslitf...vector(double)         -> D_A1_YSlitF
  dev...double                    -> D_Dev
  var...double                    -> D_Var
  k...intarr                      -> I_A1_Index_k
  iback...intarr                  -> P_I_A1_IBackInd
  scatter...
//    if(imask) then msk = bytarr(nc,nr)
  **

/**  ;Get image size.
  sz = size(im)                 ;variable info
  ncol = sz(1)                  ;number of columns
  nrow = sz(2)                  ;number of rows
  nord = n_elements(orders(0,*));number of orders

  msk = 0
  imask = 0

  if(not keyword_set(gain))    then CCD_gain = 1. $       ; CCD gain
                               else CCD_gain = gain
  if(not keyword_set(rdnoise)) then CCD_rdnoise = 0. $    ; CCD rdnoise
                               else CCD_rdnoise = rdnoise
  if(keyword_set(order_extra_width)) then begin
    if(order_width gt 0. and order_width lt 2.) then $
      extra_offset=order_width
  endif else extra_offset=1.

**

  cout << "CFits::MkScatter: im(0,0) = (" << P_D_A2_PixArray->rows() << ", " << P_D_A2_PixArray->cols() << "): " << (*P_D_A2_PixArray)(0,0) << endl;
  cout << "CFits::MkScatter: im(5,10) = (" << P_D_A2_PixArray->rows() << ", " << P_D_A2_PixArray->cols() << "): " << (*P_D_A2_PixArray)(5,10) << endl;
  cout << "CFits::MkScatter: im(10,10) = (" << P_D_A2_PixArray->rows() << ", " << P_D_A2_PixArray->cols() << "): " << (*P_D_A2_PixArray)(10,10) << endl;
  cout << "CFits::MkScatter: im(0:3,*) = (" << P_D_A2_PixArray->rows() << ", " << P_D_A2_PixArray->cols() << "): " << (*P_D_A2_PixArray)(Range(0,3),Range::all()) << endl;
  cout << "CFits::MkScatter: P_D_A2_Coeffs = (" << P_D_A2_Coeffs->size() << "): " << (*P_D_A2_Coeffs) << endl;

  int i, j;

///  nloop = 10                    ;smoothing loop for scattered light
//  int i_nloop = 10;

  double D_Lambda_SF = 1.;
  double D_Lambda_SP = 1.;
  double D_Width, D_Height;
  double D_Dev, D_Var;
  int I_Width, I_Height;
  int I_Beg, I_End;
  int i_ord = 1;
  int I_Pos = 0;
  int I_Y_Lower_Limit;
  int I_Y_Upper_Limit;
  int I_Y_Center;
  int I_NC, I_NR;
  int i_mask;

///  ;Initialize arrays.
///  xcol = dindgen(ncol)                          ;indices of all columns
  Array<double,1> D_A1_XRow(this->NRows);
  for (i=0; i < this->NRows; i++){
    D_A1_XRow(i) = double(i);
  }
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: D_A1_XRow.rows() = " << D_A1_XRow.rows() << endl;
#endif
///  back = fltarr(ncol,nord+1)                    ;fitted scattered light model
  Array<double, 2> D_A2_Back(this->NRows, this->I_NApertures+1);
  D_A2_Back = 0.;
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: D_A2_Back.rows() = " << D_A2_Back.rows() << ", D_A2_Back.cols() = " << D_A2_Back.cols() << endl;
#endif
///  back_data = back                              ;scattered light data
  Array<double, 2> D_A2_BackData(this->NRows, this->I_NApertures+1);
  D_A2_BackData = 0.;
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: D_A2_BackData.rows() = " << D_A2_BackData.rows() << ", D_A2_BackData.cols() = " << D_A2_BackData.cols() << endl;
#endif

///  yback = intarr(ncol,nord+1)                   ;scattered light coordinates
  Array<int, 2> I_A2_YBack(this->NRows, this->I_NApertures+1);
  I_A2_YBack = 0;
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: I_A2_YBack.rows() = " << I_A2_YBack.rows() << ", I_A2_YBack.cols() = " << I_A2_YBack.cols() << endl;
#endif

  Array<double, 2>* P_D_A2_SF;// = new Array<int, 2>(2,2);
  Array<double, 1> D_A1_SP(this->NRows);// = new Array<int, 2>(2,2);
  Array<double, 1> D_A1_SFSM(this->NRows);// = new Array<int, 2>(2,2);
//  cout << "CFits::MkScatter: P_I_A2_SF->rows() = " << P_I_A2_SF->rows() << ", P_I_A2_SF->cols() = " << P_I_A2_SF->cols() << endl;

  Array<double, 1> D_A1_YCen(this->NRows);
  Array<double, 1> D_A1_YCenA(this->NRows);
  Array<double, 1> D_A1_YCenB(this->NRows);
  Array<int,1>* P_I_A1_YMin;///(this->NRows)
  Array<int,1>* P_I_A1_YMax;///(this->NRows)
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: D_A1_YCenA.rows() = " << D_A1_YCenA.rows() << endl;
#endif

///  ycen1 = poly(xcol, orders(*,0))               ;the shape of the starting order
  if (!this->TraceFunctionsCalculated){
    if (!CalcTraceFunctions()){
      cout << "CFits::MkScatter: ERROR: CalcTraceFunctions() returned FALSE!!! -> returning\n";
      return false;
    }
  }
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: CalcTraceFunctions() returned TRUE\n";
#endif

  if (this->KeyWord_Set(CS_A1_Args_In, CString("POLYTRACE")) >= 0){
    D_A1_YCenB = *(this->Poly(D_A1_XRow, (*this->P_D_A2_Coeffs)(0,Range(0,(*this->P_I_A1_NCoeffs)(0)-1))));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_YCenB = " << D_A1_YCenB << endl;
#endif
  }
  else{
    D_A1_YCenB = (*this->P_D_A2_XCenters)(0,Range::all());///Poly(D_A1_XRow, this->P_D_A2_Coeffs(0,Range(0,this->P_I_A1_NCoeffs(0)));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_YCenB = " << D_A1_YCenB << endl;
#endif
  }

  /**
;Loop through orders

  **

  CString CS_Temp("OSample");
///  if(keyword_set(osample)) then osamp=osample $ ;slitf pixels / real pixel
///  else                          osamp = 10
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    if (!this->Set_OverSample(*(double*)ArgV_In[I_Pos])){
      cout << "CFits::MkScatter: KeyWord_Set(" << CS_Temp << "): this.Set_OverSample(" << *(double*)ArgV_In[I_Pos] << ") returned FALSE!!! => Returning" << endl;
      return false;
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: KeyWord_Set(" << CS_Temp << "): this.Set_OverSample(" << *(double*)ArgV_In[I_Pos] << ") returned TRUE" << endl;
#endif
  }

///  if(not keyword_set(lam_sf)) then lambda_sf=1.
  CS_Temp.Set("LAMBDA_SF");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_Lambda_SF = *(double*)ArgV_In[I_Pos];
    cout << "CFits::MkScatter: KeyWord_Set(" << CS_Temp << "): D_Lambda_SF set to " << D_Lambda_SF << endl;
  }

///  if(not keyword_set(lam_sf)) then lambda_sf=1.
  CS_Temp.Set("LAMBDA_SP");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_Lambda_SP = *(double*)ArgV_In[I_Pos];
    cout << "CFits::MkScatter: KeyWord_Set(" << CS_Temp << "): D_Lambda_SP set to " << D_Lambda_SP << endl;
  }
//  return false;

  Array<int, 2> I_A2_Mask(this->NRows, this->NCols);
  Array<int, 2> I_A2_Msk(this->NRows, this->NCols);
  CS_Temp.Set("MASK");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_A2_Mask = *(Array<int, 2>*)ArgV_In[I_Pos];
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: KeyWord_Set(MASK): I_A2_Mask set to " << I_A2_Mask << endl;
#endif
//    (*P_OFS_Log) << "CFits::MkScatter: KeyWord_Set(MASK): I_A2_Mask set to " << I_A2_Mask << endl;
    if (I_A2_Mask.rows() == this->NRows && I_A2_Mask.cols() == this->NCols){
      i_mask = 1;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: KeyWord_Set(MASK): i_mask set to " << i_mask << endl;
#endif
    }
    else{
      cout << "CFits::MkScatter: KeyWord_Set(MASK): ERROR: size of I_A2_Mask doesn't match image size => returning" << endl;
      (*P_OFS_Log) << "CFits::MkScatter: KeyWord_Set(MASK): ERROR: size of I_A2_Mask doesn't match image size => returning" << endl;
      return false;
    }
  }
  else{
    i_mask = 0;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: not(KeyWord_Set(MASK)): i_mask set to " << i_mask << endl;
#endif
  }

  Array<CString, 1> CS_A1_Args_SlitFunc(10);
  CS_A1_Args_SlitFunc = CString(" ");
  void **PP_Args_SlitFunc = (void**)malloc(sizeof(void*) * 10);

  Array<CString, 1> CS_A1_Args_Bottom(10);
  CS_A1_Args_Bottom = CString(" ");
  void **PP_Args_Bottom = (void**)malloc(sizeof(void*) * 10);

  Array<CString, 1> CS_A1_Args_Middle(10);
  CS_A1_Args_Middle = CString(" ");
  void **PP_Args_Middle = (void**)malloc(sizeof(void*) * 10);

  Array<double, 2> D_A2_Im_Out(1,1);
  Array<int,1> *P_I_A1_YCenFix = new Array<int,1>(1);
  Array<double,1> D_A1_YCen_minus_YCenFix(1);
  int I_NSlitF = 0;
  Array<double, 1> D_A1_YSlitF(1);
  Array<double,1> D_A1_SFSM_Temp(1);
  Array<double,1> D_A1_YSlitF_k(1);
  double D_SFSM_Median = 0;
  Array<double,1> *P_D_A1_JBack = new Array<double,1>(1);
  int I_Temp;
  Array<int,1> I_A1_Ind_k(1);
  double D_Median_SFSM;// = this->Median(D_A1_SFSM)+0.5*D_Var;
  Array<int,1> I_A1_Index_k(1);
  int I_NBack = 0;
  int I_N1=0;
  int I_N2=0;
  Array<double,1> *P_D_A1_Middle_SFSM = new Array<double,1>(1);

  int I_Ind_Min1 = 0;
  int I_Ind_Min2 = 0;
  Array<double,1> D_A1_TempInd(1);
  Array<int, 1> I_A1_JBack(1);
  Array<double,1> D_A1_YSlitF_k_jback(I_N1);

  Array<int,1> *P_I_A1_IMax1;
  TinyVector<int,1> I_TV_IMax1;
  double D_IMax1 = 0.;
  int I_IMax1 = 0;
  double D_M1 = 0.;
  Array<int,1> I_A1_JBack1(1);
  int I_IMax2 = 0;
  double D_M2 = 0.;
  Array<int,1> I_A1_IBack_Where(1);
  Array<int,1> *P_I_A1_IBackInd = new Array<int,1>(1);
  Array<double,1> D_A1_SF1(1);
  double D_Step = 0.;
  double d_temp = 0.;
  Array<int,1>* P_I_A1_H = new Array<int,1>(1);
  int I_NH = 0;

  Array<int,1> *P_I_A1_IHMax;
  int I_IHMax = 0;
  double D_HMax = 0.;
  Array<int,1> I_A1_TempH(1);
  Array<int,1> I_A1_I0_Where(1);
  int I_I0 = 0;
  int I_I1 = 0;
  Array<int,1> I_A1_II_Where(1);
  int I_NII1;
  Array<int,1> *P_I_A1_II = new Array<int,1>(1);
  Array<double,1> D_A1_YSlitF_II(1);
  long L_Y1 = 0;
  long L_Y2 = 0;
  int I_YY1;
  int I_YY2;
  Array<double,1> D_A1_Scatter(1);
  double D_YY;
  TinyVector<int,1> I_TV_IMax2;
  Array<double,1> D_A1_YBack_k(1);
  Array<double,1> D_A1_Temp_A(1);

///  for ord=1,nord-1 do begin
  for (i_ord = 1; i_ord < this->I_NApertures; i_ord++){

    cout << "CFits::MkScatter: I_NApertures = " << I_NApertures << endl;
    cout << "CFits::MkScatter: P_D_A2_Coeffs(i_ord,Range::all()) = " << (*P_D_A2_Coeffs)(i_ord,Range::all()) << endl;

///    if(not keyword_set(swath_width)) then width = 400 $    ; CCD rdnoise
///    else width = swath_width
    CS_Temp.Set("SWATH_WIDTH");
    if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
    {
      D_Width = *(double*)ArgV_In[I_Pos];
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: KeyWord_Set(SWATH_WIDTH): D_Width set to " << D_Width << endl;
//      (*P_OFS_Log) << "CFits::MkScatter: KeyWord_Set(SWATH_WIDTH):  set to " << D_Width << endl;
#endif
    }
    else{
      D_Width = 400.;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: not(KeyWord_Set(SWATH_WIDTH)): D_Width set to " << D_Width << endl;
#endif
    }
///    ycen0 = ycen1
    D_A1_YCenA = D_A1_YCenB;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_YCenA set to " << D_A1_YCenA << endl;
    cout << "CFits::MkScatter: D_A1_YCenA(2045) set to " << D_A1_YCenA(2045) << endl;
#endif
///    ycen1 = poly(xcol, orders(*,ord))           ;the shape of the next order
    if (this->KeyWord_Set(CS_A1_Args_In, CString("POLYTRACE")) >= 0){
      D_A1_YCenB = *(this->Poly(D_A1_XRow, (*this->P_D_A2_Coeffs)(i_ord,Range(0,(*this->P_I_A1_NCoeffs)(i_ord)-1))));
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: POLYTRACE: D_A1_YCenB set to " << D_A1_YCenB << endl;
#endif
    }
    else{
      D_A1_YCenB = (*this->P_D_A2_XCenters)(i_ord,Range::all());///Poly(D_A1_XRow, this->P_D_A2_Coeffs(i_ord,*));
      cout << "CFits::MkScatter: !POLYTRACE: D_A1_YCenB set to " << D_A1_YCenB << endl;
    }
    cout << "CFits::MkScatter: D_A1_YCenB(2045) set to " << D_A1_YCenB(2045) << endl;

///    ibeg = colrange(0,ord-1)>colrange(0,ord)    ;left boundary to consider
    if ((*this->P_D_A1_YCenter)(i_ord-1)+(*this->P_D_A1_YLow)(i_ord-1) > (*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_YLow)(i_ord)){
      I_Beg = int((*this->P_D_A1_YCenter)(i_ord-1)+(*this->P_D_A1_YLow)(i_ord-1));
    }
    else{
      I_Beg = int((*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_XMin)(i_ord));
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_Beg set to " << I_Beg << endl;
#endif

///    iend = colrange(1,ord-1)<colrange(1,ord)    ;right boundary to consider
    if ((*this->P_D_A1_YCenter)(i_ord+1)+(*this->P_D_A1_YHigh)(i_ord-1) < (*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_YHigh)(i_ord)){
      I_End = int((*this->P_D_A1_YCenter)(i_ord-1)+(*this->P_D_A1_YHigh)(i_ord-1));
      if (I_End < (*this->P_D_A1_YCenter)(i_ord-1)+(*this->P_D_A1_YHigh)(i_ord-1))
        I_End++;
    }
    else{
      I_End = int((*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_YHigh)(i_ord));
      if (I_End < (*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_YHigh)(i_ord))
        I_End++;
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_End set to " << I_End << endl;
#endif

///    width = ((iend-ibeg+1)*0.1)>width           ;width to consider (swath < width < iend-ibeg+1)
    if (double(I_End - I_Beg + 1) * 0.1 > D_Width){
      D_Width = double(I_End - I_Beg + 1) * 0.1;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: D_Width set to " << D_Width << endl;
#endif
    }

///    width = round((width<(iend-ibeg))*0.5)      ;half-width to avoid rounding errors
    if (D_Width < (I_End - I_Beg))
      I_Width = Round(D_Width * 0.5);
    else
      I_Width = Round((I_End - I_Beg) * 0.5);
    cout << "CFits::MkScatter: I_Width set to " << I_Width << endl;

///    height = mean(ycen1(ibeg:iend)-ycen0(ibeg:iend)) ;mean height
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_YCenB(Range(I_Beg=" << I_Beg << ", I_End=" << I_End << ")) = " << D_A1_YCenB(Range(I_Beg, I_End)) << endl;
    cout << "CFits::MkScatter: mean(D_A1_YCenB(Range(I_Beg, I_End))) = " << mean(D_A1_YCenB(Range(I_Beg, I_End))) << endl;
    cout << "CFits::MkScatter: D_A1_YCenA(Range(I_Beg=" << I_Beg << ", I_End=" << I_End << ")) = " << D_A1_YCenA(Range(I_Beg, I_End)) << endl;
    cout << "CFits::MkScatter: mean(D_A1_YCenA(Range(I_Beg, I_End)) = " << mean(D_A1_YCenA(Range(I_Beg, I_End))) << endl;
#endif

    D_Height = mean(D_A1_YCenB(Range(I_Beg, I_End)) - D_A1_YCenA(Range(I_Beg, I_End)));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_Height set to " << D_Height << endl;
#endif

///    height = round(height*0.5*extra_offset)>3 ;half-height to avoid rounding errors
    if (Round(D_Height * 0.5) > 3)
      I_Height = Round(D_Height * 0.5);
    else
      I_Height = 3;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_Height set to " << I_Height << endl;
#endif

///    x_left_lim  = ibeg                          ;store for future use
    I_Y_Lower_Limit = I_Beg;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_Y_Lower_Limit set to " << I_Y_Lower_Limit << endl;
#endif

///    x_right_lim = iend
    I_Y_Upper_Limit = I_End;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_Y_Upper_Limit set to " << I_Y_Upper_Limit << endl;
#endif

///    icen = round(0.5*(ibeg+iend))               ;central column
    I_Y_Center = Round(0.5 * (I_Beg + I_End));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_Y_Center set to " << I_Y_Center << endl;
#endif

///    ibeg = icen-width                           ;starting column of the region of interest
    I_Beg = I_Y_Center - I_Width;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_Beg set to " << I_Beg << endl;
#endif

///    iend = icen+width                           ;ending column of the region of interest
    I_End = I_Y_Center + I_Width;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_End set to " << I_End << endl;
#endif

///    ycen = 0.5*(ycen1+ycen0)                    ;central line of the troff
    D_A1_YCen = 0.5 * (D_A1_YCenB + D_A1_YCenA);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_YCen set to " << D_A1_YCen << endl;
#endif

///    ymin = fix(ycen)-height                     ;bottom boundary of the region of interest
    P_I_A1_YMin = Fix(D_A1_YCen);
    *P_I_A1_YMin = *P_I_A1_YMin - I_Height;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: *P_I_A1_YMin set to " << *P_I_A1_YMin << endl;
#endif

///    ymax = fix(ycen)+height                     ;top boundary of the region of interest
    P_I_A1_YMax = Fix(D_A1_YCen);
    *P_I_A1_YMax = *P_I_A1_YMax + I_Height;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: *P_I_A1_YMax set to " << *P_I_A1_YMax << endl;
#endif

///    nc = 2*width+1                              ;dimensions of the region of interest
    I_NC = 2 * I_Width + 1;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_NC set to " << I_NC << endl;
#endif

///    nr = 2*height+1
    I_NR = 2 * I_Height + 1;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_NR set to " << I_NR << endl;
#endif

///Copy the region of interest to sf
///sf = fltarr(nc,nr)
//    delete(P_I_A2_SF);
    P_D_A2_SF = new Array<double, 2>(I_NC, I_NR);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: P_D_A2_SF->rows() = " << P_D_A2_SF->rows() << ", P_D_A2_SF->cols() = " << P_D_A2_SF->cols() << endl;
#endif

///    for j=0,nc-1 do begin
    for (j=0; j < I_NC; j++){
///      sf(j,*) = im(ibeg+j,ymin(j+ibeg):ymax(j+ibeg))
#ifdef __DEBUG_FITS_MKSCATTER_A__
      cout << "CFits::MkScatter: (*P_I_A1_YMin)(j+I_Beg = " << j+I_Beg << ") = " << (*P_I_A1_YMin)(j+I_Beg) << endl;
      cout << "CFits::MkScatter: (*P_I_A1_YMax)(j+I_Beg = " << j+I_Beg << ") = " << (*P_I_A1_YMax)(j+I_Beg) << endl;
      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(I_Beg+j,Range((*P_I_A1_YMin)(j+I_Beg),(*P_I_A1_YMax)(j+I_Beg))) = " << (*this->P_D_A2_PixArray)(I_Beg+j,Range((*P_I_A1_YMin)(j+I_Beg),(*P_I_A1_YMax)(j+I_Beg))) << endl;
      cout << "CFits::MkScatter: P_D_A2_SF->rows() = " << P_D_A2_SF->rows() << ", P_D_A2_SF->cols() = " << P_D_A2_SF->cols() << endl;
      cout << "CFits::MkScatter: this->P_D_A2_PixArray->rows() = " << this->P_D_A2_PixArray->rows() << ", this->P_D_A2_PixArray->cols() = " << this->P_D_A2_PixArray->cols() << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(0,0) = " << (*this->P_D_A2_PixArray)(0,0) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(9,0) = " << (*this->P_D_A2_PixArray)(9,0) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(0,9) = " << (*this->P_D_A2_PixArray)(0,9) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(4089,300) = " << (*this->P_D_A2_PixArray)(4089,300) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(4079,300) = " << (*this->P_D_A2_PixArray)(4079,300) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(4089,290) = " << (*this->P_D_A2_PixArray)(4089,290) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(0,300) = " << (*this->P_D_A2_PixArray)(0,300) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(9,300) = " << (*this->P_D_A2_PixArray)(9,300) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(0,290) = " << (*this->P_D_A2_PixArray)(0,290) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(4089,0) = " << (*this->P_D_A2_PixArray)(4089,0) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(4079,0) = " << (*this->P_D_A2_PixArray)(4079,0) << endl;
//      cout << "CFits::MkScatter: (*this->P_D_A2_PixArray)(4089,9) = " << (*this->P_D_A2_PixArray)(4089,9) << endl;
#endif
      (*P_D_A2_SF)(j,Range::all()) = (*this->P_D_A2_PixArray)(I_Beg+j,Range((*P_I_A1_YMin)(j+I_Beg),(*P_I_A1_YMax)(j+I_Beg)));
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: (*P_D_A2_SF)(j=" << j << ",Range::all()) set to " << (*P_D_A2_SF)(j,Range::all()) << endl;
#endif
///      if(imask) then msk(j,*) = mask(ibeg+j,ymin(j+ibeg):ymax(j+ibeg))
      if (i_mask >= 1)
      {
        I_A2_Msk(j,Range::all()) = I_A2_Mask(I_Beg + j, Range((*P_I_A1_YMin)(j+I_Beg),(*P_I_A1_YMax)(j+I_Beg)));
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: I_A2_Msk(j=" << j << ", Range::all()) set to " << I_A2_Msk(j,Range::all()) << endl;
#endif
      }
///    endfor

    }
//  }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for (j=0; j < I_NC; j++) finished " << endl;
#endif

///    if(imask) then msk = bytarr(nc,nr)
    if (i_mask >= 1){
      I_A2_Msk = 0;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_A2_Msk set to 0" << endl;
#endif
    }
///    slit_func,sf,$
///              ycen(ibeg:iend)-fix(ycen(ibeg:iend)),$
///              sp,$
///              sfsm,$
///              NOISE=noise,$
///              OVERSAMPLE=osamp,$
///              LAMBDA_SF=lam_sf,$
///              LAMBDA_SP=lam_sp,$
///              MASK=msk,$
///              IM_OUT=sfbin,$
///              LOGFILE=loglun

    CS_A1_Args_SlitFunc(0).Set("LAMBDA_SF");
    PP_Args_SlitFunc[0] = &D_Lambda_SF;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: CS_A1_Args_SlitFunc(0) set to LAMBDA_SF = " << D_Lambda_SF << endl;
#endif

    CS_A1_Args_SlitFunc(1).Set("LAMBDA_SP");
    PP_Args_SlitFunc[1] = &D_Lambda_SP;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: CS_A1_Args_SlitFunc(1) set to LAMBDA_SP = " << D_Lambda_SP << endl;
#endif

    CS_A1_Args_SlitFunc(2).Set("PROF_OUT");
    D_A2_Im_Out.resize(P_D_A2_SF->rows(), P_D_A2_SF->cols());
    PP_Args_SlitFunc[2] = &D_A2_Im_Out;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: CS_A1_Args_SlitFunc(2) set to PROF_OUT = " << endl;
#endif

///  CS_A1_Args_SlitFunc(3).Set("MASK");
///  PP_Args_SlitFunc[3] = &I_A2_Msk;

    delete(P_I_A1_YCenFix);
    P_I_A1_YCenFix = Fix(D_A1_YCen(Range(I_Beg,I_End)));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: P_I_A1_YCenFix set to " << *P_I_A1_YCenFix << endl;
#endif

    D_A1_YCen_minus_YCenFix.resize(P_I_A1_YCenFix->size());
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_YCen_minus_YCenFix.size() = " << D_A1_YCen_minus_YCenFix.size() << endl;
#endif

    D_A1_YCen_minus_YCenFix = D_A1_YCen(Range(I_Beg,I_End)) - (*P_I_A1_YCenFix);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_YCen_minus_YCenFix set to " << D_A1_YCen_minus_YCenFix << endl;

    cout << "CFits::MkScatter: Starting SlitFunc" << endl;
#endif
    if (!this->SlitFunc(*P_D_A2_SF,
                        i_ord,
                        D_A1_YCen_minus_YCenFix,
                        D_A1_SP,
                        D_A2_SFSM,
                        CS_A1_Args_SlitFunc,
                        PP_Args_SlitFunc)){
      cout << "CFits::MkScatter: ERROR: SlitFunc returned FALSE => Returning FALSE!!!" << endl;
      return false;
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: SlitFunc returned TRUE" << endl;
    cout << "CFits::MkScatter: D_Lambda_SF = " << D_Lambda_SF << endl;
    cout << "CFits::MkScatter: D_Lambda_SP = " << D_Lambda_SP << endl;
    cout << "CFits::MkScatter: D_A1_SP = " << D_A1_SP << endl;
    cout << "CFits::MkScatter: D_A1_SFSM = " << D_A1_SFSM << endl;
#endif

    CString CS_FileName_ImOut(DEBUGDIR);
    CS_FileName_ImOut += CString("cfits_im_out.fits");
//  ofstream *P_OFS_ImOut = new ofstream(CS_FileName_ImOut.Get());
//  (*P_OFS_ImOut) << D_A2_Im_Out << endl;
//  delete(P_OFS_ImOut);
    if (!this->WriteFits(&D_A2_Im_Out,CS_FileName_ImOut)){
      cout << "CFits::MkScatter: WriteFits(D_A2_Im_Out," << CS_FileName_ImOut << ") returned FALSE!" << endl;
      return false;
    }

//
//  cout << "CFits::MkScatter: D_A1_SP = " << D_A1_SP.size() << ": " << endl;
//  int uu;
//  for (uu=0; uu<D_A1_SP.size(); uu++){
//    cout << D_A1_SP(uu) << endl;
//  }
//  cout << "CFits::MkScatter: D_A1_SFSM = " << D_A1_SFSM.size() << ": " << endl;
//  for (uu=0; uu<D_A1_SFSM.size(); uu++){
//    cout << D_A1_SFSM(uu) << endl;
//  }
//  cout << "CFits::MkScatter: D_A2_Im_Out.rows() = " << D_A2_Im_Out.rows() << ",  D_A2_Im_Out.cols() = " << D_A2_Im_Out.cols() << endl;
//  cout << "CFits::MkScatter: D_A2_Im_Out = " << D_A2_Im_Out << endl;
///    nslitf = n_elements(sfsm)
    I_NSlitF = D_A1_SFSM.size();
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_NSlitF set to " << I_NSlitF << endl;
#endif

///    yslitf = (findgen(nslitf)-0.5)/osamp-1.5-height            ;final subpixel scale
    D_A1_YSlitF.resize(I_NSlitF);
    for (i=0; i < I_NSlitF; i++){
      D_A1_YSlitF(i) = double(i) - 0.5;
    }

//  cout << "CFits::MkScatter: D_A1_YSlitF set to " << D_A1_YSlitF << endl;
    D_A1_YSlitF /= this->I_OverSample;
//  cout << "CFits::MkScatter: D_A1_YSlitF set to " << D_A1_YSlitF << endl;
    D_A1_YSlitF -= 1.5 + double(I_Height);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_YSlitF set to " << D_A1_YSlitF << endl;
#endif

///    dev = CCD_rdnoise/CCD_gain/sqrt(total(sp)/(iend - ibeg + 1.)) ;Typical pixel scatter normalized to counts

#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_ReadOutNoise = " << D_ReadOutNoise << endl;
    cout << "CFits::MkScatter: D_Gain = " << D_Gain << endl;
    cout << "CFits::MkScatter: sum(D_A1_SP) = " << sum(D_A1_SP) << endl;
    cout << "CFits::MkScatter: (I_End - I_Beg + 1.) = " << (I_End - I_Beg + 1.) << endl;
    cout << "CFits::MkScatter: sqrt(sum(D_A1_SP) / (I_End - I_Beg + 1.)) = " << sqrt(sum(D_A1_SP) / (I_End - I_Beg + 1.)) << endl;
#endif
    D_Dev = this->D_ReadOutNoise / this->D_Gain / sqrt(sum(D_A1_SP) / (double(I_End - I_Beg) + 1.));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_Dev set to " << D_Dev << endl;
#endif

///    var = stddev(sfsm)
    D_Var = this->StdDev(D_A1_SFSM);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_Var set to " << D_Var << endl;
#endif

///;
///; This is an improved version which is near the final form
///;
///    jback = bottom(sfsm<median(sfsm), 1, eps=dev, /POLY)       ;Fit the bottom with a smooth curve
    D_A1_SFSM_Temp.resize(D_A1_SFSM.size());
    D_A1_SFSM_Temp = D_A1_SFSM;
    D_SFSM_Median = this->Median(D_A1_SFSM);
    D_A1_SFSM_Temp = where(D_A1_SFSM_Temp > D_SFSM_Median, D_SFSM_Median, D_A1_SFSM);

    CS_A1_Args_Bottom(0).Set("EPS");
    PP_Args_Bottom[0] = &D_Dev;

    CS_A1_Args_Bottom(1).Set("POLY");
    I_Temp = 1;
    PP_Args_Bottom[1] = &I_Temp;

    CS_A1_Args_Bottom(2).Set(" ");

//    delete(P_D_A1_JBack);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: Starting 1. Bottom(D_A1_SFSM_Temp,1,(*const_cast<const Array<CString, 1>*>(&CS_A1_Args_Bottom)),PP_Args_Bottom, P_D_A1_JBack)" << endl;
#endif
    if (!this->Bottom(D_A1_SFSM_Temp,1,(*const_cast<const Array<CString, 1>*>(&CS_A1_Args_Bottom)),PP_Args_Bottom, P_D_A1_JBack)){
      cout << "CFits::MkScatter: ERROR: 1. Bottom(D_A1_SFSM_Temp,1,(*const_cast<const Array<CString, 1>*>(&CS_A1_Args_Bottom)),PP_Args_Bottom, P_D_A1_JBack) returned FALSE" << endl;
      P_D_A1_JBack->resize(D_A1_SFSM_Temp.size());
      (*P_D_A1_JBack) = -100000;
      return false;
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 1. *P_D_A1_JBack set to " << *P_D_A1_JBack << endl;
#endif
///    jback = (sfsm - jback) > 0.                                ;Find all positive spikes
    D_A1_SFSM_Temp = D_A1_SFSM - (*P_D_A1_JBack);
    (*P_D_A1_JBack) = where(D_A1_SFSM_Temp < 0., 0., D_A1_SFSM_Temp);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 2. *P_D_A1_JBack set to " << *P_D_A1_JBack << endl;
#endif

///    k = where(jback(1:nslitf-2) gt jback(0:nslitf-3) and $     ;above the middle
///              jback(1:nslitf-2) gt jback(2:nslitf-1) and $
///              sfsm(1:nslitf-2) gt median(sfsm)+0.5*var, nback) + 1
    I_A1_Ind_k.resize(I_NSlitF-2);
    I_A1_Ind_k = 0;
    D_Median_SFSM = this->Median(D_A1_SFSM)+0.5*D_Var;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_Median_SFSM set to " << D_Median_SFSM << endl;
#endif

    for (i=0;i<I_NSlitF-2;i++){
      if ((*P_D_A1_JBack)(i+1) > (*P_D_A1_JBack)(i) &&
          (*P_D_A1_JBack)(i+1) > (*P_D_A1_JBack)(i+2) &&
          D_A1_SFSM(i+1) > D_Median_SFSM){
        I_A1_Ind_k(i+1) = 1;
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: 1. (*P_D_A1_JBack)(i+0=" << i << ") = " << (*P_D_A1_JBack)(i) << " < " << endl;
        cout << "CFits::MkScatter: 1. (*P_D_A1_JBack)(i+1=" << i+1 << ") = " << (*P_D_A1_JBack)(i+1) << " > " << endl;
        cout << "CFits::MkScatter: 1. (*P_D_A1_JBack)(i+2=" << i+2 << ") = " << (*P_D_A1_JBack)(i+2) << endl;
        cout << "CFits::MkScatter: 1. I_A1_Ind_k(i+1=" << i+1 << ") set to " << I_A1_Ind_k(i+1) << endl;
        cout << "CFits::MkScatter: 1. D_A1_SFSM(i+1=" << i+1 << ") = " << D_A1_SFSM(i+1) << " > D_Median_SFSM = " << D_Median_SFSM << endl;
#endif
      }
    }
    I_A1_Index_k.resize(sum(I_A1_Ind_k));
    D_A1_YSlitF_k.resize(sum(I_A1_Ind_k));
    j = 0;
    for (i=0;i<I_A1_Ind_k.size();i++){
      if (I_A1_Ind_k(i) == 1){
        I_A1_Index_k(j) = i;
        D_A1_YSlitF_k(j) = D_A1_YSlitF(i);
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: I_A1_Index_k(j=" << j << ") set to " << I_A1_Index_k(j) << endl;
        cout << "CFits::MkScatter: D_A1_YSlitF_k(j=" << j << ") set to " << D_A1_YSlitF_k(j) << endl;
#endif
        j++;
      }
    }
    I_NBack = sum(I_A1_Ind_k);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_NBack set to " << I_NBack << endl;
#endif
    I_N1=0;
    I_N2=0;

///    m1=where(yslitf(k) lt 0, n1) ;Part of the gap which is below the central line
///    m2=where(yslitf(k) gt 0, n2) ;Part of the gap which is above the central line
//  Array<int,1> I_A1_M1(I_A1_Index_k.size());
    for (i=0;i<I_A1_Index_k.size();i++){
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: D_A1_YSlitF(I_A1_Index_k(i)=" << I_A1_Index_k(i) << ") = " << D_A1_YSlitF(I_A1_Index_k(i)) << endl;
#endif
      if (D_A1_YSlitF(I_A1_Index_k(i)) < 0.)
        I_N1++;
      if (D_A1_YSlitF(I_A1_Index_k(i)) > 0.)
        I_N2++;
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_N1 set to " << I_N1 << endl;
    cout << "CFits::MkScatter: I_N2 set to " << I_N2 << endl;
#endif
///    if(n1 eq 0 or n2 eq 0) then begin ;This happens e.g. if the two adjacent
///                                      ;orders have dramatically different level
///                                      ;of signal

    CS_A1_Args_Middle(0).Set("EPS");
    PP_Args_Middle[0] = &D_Dev;

    CS_A1_Args_Middle(1).Set("POLY");
    I_Temp = 1;
    PP_Args_Middle[1] = &I_Temp;

    if (I_N1 == 0 || I_N2 ==0){
///      k = where(jback(1:nslitf-2) gt jback(0:nslitf-3) and $     ;above the middle
///                jback(1:nslitf-2) gt jback(2:nslitf-1) and $
///                sfsm(1:nslitf-2) gt middle(sfsm, 1, eps=dev, /POLY), nback) + 1
      I_A1_Ind_k = 0;

//      delete(P_D_A1_Middle_SFSM);
      if (!this->Middle(D_A1_SFSM, 1, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Middle_SFSM)){
        cout << "CFits::MkScatter: ERROR: 1. Middle(D_A1_SFSM, 1, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Middle_SFSM) returned FALSE" << endl;
        P_D_A1_Middle_SFSM->resize(D_A1_SFSM.size());
        (*P_D_A1_Middle_SFSM) = -100000;
        return false;
      }
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: *P_D_A1_Middle_SFSM set to " << *P_D_A1_Middle_SFSM << endl;
#endif
      for (i=0;i<I_NSlitF-2;i++){
        if ((*P_D_A1_JBack)(i+1) > (*P_D_A1_JBack)(i) &&
            (*P_D_A1_JBack)(i+1) > (*P_D_A1_JBack)(i+2) &&
              D_A1_SFSM(i+1) > (*P_D_A1_Middle_SFSM)(i)){
          I_A1_Ind_k(i+1) = 1;
        }
      }
      I_NBack = sum(I_A1_Ind_k);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_NBack set to " << I_NBack << endl;
#endif
      I_A1_Index_k.resize(I_NBack);
      D_A1_YSlitF_k.resize(I_NBack);
      I_A1_Index_k = 0;
      j = 0;
      for (i=0;i<I_A1_Ind_k.size();i++){
        if (I_A1_Ind_k(i) == 1){
          I_A1_Index_k(j) = i;
          D_A1_YSlitF_k(j) = D_A1_YSlitF(i);
          j++;
        }
      }
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_A1_Index_k to " << I_A1_Index_k << endl;
#endif
///      m1=where(yslitf(k) lt 0, n1)
///      m2=where(yslitf(k) gt 0, n2)
      I_N1 = 0;
      I_N2 = 0;
//  Array<int,1> I_A1_M1(I_A1_Index_k.size());
      for (i=0;i<I_A1_Index_k.size();i++){
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: 2. D_A1_YSlitF(I_A1_Index_k(i)=" << I_A1_Index_k(i) << ") = " << D_A1_YSlitF(I_A1_Index_k(i)) << endl;
#endif
        if (D_A1_YSlitF(I_A1_Index_k(i)) < 0.)
          I_N1++;
        if (D_A1_YSlitF(I_A1_Index_k(i)) > 0.)
          I_N2++;
      }
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: 2. I_N1 set to " << I_N1 << endl;
      cout << "CFits::MkScatter: 2. I_N2 set to " << I_N2 << endl;
#endif
      delete(P_D_A1_Middle_SFSM);
      #ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: P_D_A1_Middle_SFSM deleted" << endl;
      #endif
      ///    endif
    }

///    if(n1 eq 0 or n2 eq 0) then begin ;This can still happen of the overall
///                                      ;signal level is way too low
    #ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_N1 = " << I_N1 << ", I_N2 = " << I_N2 << endl;
    #endif
    if (I_N1 == 0 || I_N2 ==0){
///      k = where(jback(1:nslitf-2) gt jback(0:nslitf-3) and $     ;above the middle
///                jback(1:nslitf-2) gt jback(2:nslitf-1) and $
///                sfsm(1:nslitf-2) gt middle(sfsm, 1, eps=dev, /POLY), nback) + 1
      I_A1_Ind_k = 0;

//      delete(P_D_A1_Middle_SFSM);
      #ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: Starting 2. Middle(D_A1_SFSM, 1, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Middle_SFSM)" << endl;
      #endif
      P_D_A1_Middle_SFSM = new Array<double, 1>(1);
      if (!this->Middle(D_A1_SFSM, 1, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Middle_SFSM)){
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: ERROR: 2. Middle(D_A1_SFSM, 1, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Middle_SFSM) returned FALSE" << endl;
#endif
        P_D_A1_Middle_SFSM->resize(D_A1_SFSM.size());
        (*P_D_A1_Middle_SFSM) = -100000;
        return false;
      }
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: *P_D_A1_Middle_SFSM set to " << *P_D_A1_Middle_SFSM << endl;
#endif
      for (i=0;i<I_NSlitF-2;i++){
        if ((*P_D_A1_JBack)(i+1) > (*P_D_A1_JBack)(i) &&
            (*P_D_A1_JBack)(i+1) > (*P_D_A1_JBack)(i+2) &&
            D_A1_SFSM(i+1) > (*P_D_A1_Middle_SFSM)(i)){
          I_A1_Ind_k(i+1) = 1;
        }
      }
      I_NBack = sum(I_A1_Ind_k);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_NBack set to " << I_NBack << endl;
#endif
      I_A1_Index_k.resize(I_NBack);
      D_A1_YSlitF_k.resize(I_NBack);
      I_A1_Index_k = 0;
      j = 0;
      for (i=0;i<I_A1_Ind_k.size();i++){
        if (I_A1_Ind_k(i) == 1){
          I_A1_Index_k(j) = i;
          D_A1_YSlitF_k(j) = D_A1_YSlitF(i);
          j++;
        }
      }
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_A1_Index_k to " << I_A1_Index_k << endl;
#endif
///      m1=where(yslitf(k) lt 0, n1)
///      m2=where(yslitf(k) gt 0, n2)
      I_N1 = 0;
      I_N2 = 0;
//  Array<int,1> I_A1_M1(I_A1_Index_k.size());
      for (i=0;i<I_A1_Index_k.size();i++){
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: 2a. D_A1_YSlitF(I_A1_Index_k(i)=" << I_A1_Index_k(i) << ") = " << D_A1_YSlitF(I_A1_Index_k(i)) << endl;
#endif
        if (D_A1_YSlitF(I_A1_Index_k(i)) < 0.)
          I_N1++;
        if (D_A1_YSlitF(I_A1_Index_k(i)) > 0.)
          I_N2++;
      }
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: 3. I_N1 set to " << I_N1 << endl;
      cout << "CFits::MkScatter: 3. I_N2 set to " << I_N2 << endl;
#endif
      delete(P_D_A1_Middle_SFSM);
///    endif
    }
    if (I_N1 == 0 || I_N2 ==0){
///    if(n1 eq 0 or n2 eq 0) then begin ;Ultimate method
      cout << "CFits::MkScatter: Failed finding interorder boundaries. Using 5 pixels around central line." << endl;
///      k=(sort(abs(yslitf)))(0:4)
///    endif
//      return false;
    Array<double,1> D_A1_Abs(D_A1_YSlitF.size());
    D_A1_Abs = abs(D_A1_YSlitF);
    Array<double,1> *P_D_A1_Sort = this->BubbleSort(D_A1_Abs);
    I_A1_Index_k.resize(5);
    D_A1_YSlitF_k.resize(5);
    for (i=0; i<5; i++){
      I_A1_Index_k = (*P_D_A1_Sort)(i); /// intarr = dblarr???
      D_A1_YSlitF_k(i) = D_A1_YSlitF(I_A1_Index_k(i));
    }
    cout << "CFits::MkScatter: I_A1_Ind_k set to " << I_A1_Ind_k << endl;
    delete(P_D_A1_Sort);
    }
///    if(nback lt 2 or (nback ge 2 and $           ; Check if we have only noise
///      (min(yslitf(k)) gt  height*0.5 or $
///       max(yslitf(k)) lt -height*0.5))) then begin
    I_Ind_Min1 = 0;
    I_Ind_Min2 = 0;
    if (I_NBack < 2 || (I_NBack >= 2 && (min(D_A1_YSlitF_k) > D_Height*0.5 || max(D_A1_YSlitF_k) < 0.-D_Height*0.5))){
///      nback=2
      I_NBack = 2;
///      n1=min(abs(yslitf+height*0.5),k1)          ; In this case just select
      D_A1_TempInd.resize(D_A1_YSlitF.size());

      D_A1_TempInd = abs(D_A1_YSlitF+D_Height*0.5);
      I_Ind_Min1 = minIndex(D_A1_TempInd)(0);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_Ind_Min1 set to " << I_Ind_Min1 << endl;
#endif
      I_N1 = D_A1_TempInd(I_Ind_Min1);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_N1 set to " << I_N1 << endl;
#endif
///      n2=min(abs(yslitf-height*0.5),k2)          ; the central half
      D_A1_TempInd = abs(D_A1_YSlitF-D_Height*0.5);
      I_Ind_Min2 = minIndex(D_A1_TempInd)(0);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_Ind_Min2 set to " << I_Ind_Min2 << endl;
#endif
      I_N2 = D_A1_TempInd(I_Ind_Min2);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_N2 set to " << I_N2 << endl;
#endif
      I_A1_Index_k.resize(2);
///      k=[k1,k2]
      I_A1_Index_k(0) = I_Ind_Min1;
      I_A1_Index_k(1) = I_Ind_Min2;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_A1_Index_k set to " << I_A1_Index_k << endl;
#endif

///    endif
    }
    ///
///    if(jback(0) ge jback(1)) then begin
    if ((*P_D_A1_JBack)(0) >= (*P_D_A1_JBack)(1)){
///      k = [0,k]
      I_A1_Ind_k.resize(I_A1_Index_k.size());
      I_A1_Ind_k = I_A1_Index_k;
      if (!this->InsertAt(&I_A1_Index_k,0,0)){
        cout << "CFits::MkScatter: ERROR: InsertAt(&I_A1_Index_k,0,0) returned FALSE!" << endl;
        return false;
      }
      if (I_A1_Index_k(0) == 0){
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: InsertAt(&I_A1_Index_k,0,0) returned TRUE" << endl;
#endif
      }
      else{
        cout << "CFits::MkScatter: InsertAt(&I_A1_Index_k,0,0) returned TRUE, I_A1_Index_k(0) == 0 returned FALSE" << endl;
        return false;
      }
      if (sum(where(I_A1_Index_k(Range(1,I_A1_Index_k.size()-1)) == I_A1_Ind_k,0,1)) == 0){
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: InsertAt(&I_A1_Index_k,0,0) returned TRUE" << endl;
#endif
      }
      else {
        cout << "CFits::MkScatter: InsertAt(&I_A1_Index_k,0,0) returned TRUE, sum(where(I_A1_Index_k(Range(1,I_A1_Index_k.size()-1))(=" << I_A1_Index_k(Range(1,I_A1_Index_k.size()-1)) << ") == I_A1_Ind_k(=" << I_A1_Ind_k << "))) = " << sum(where(I_A1_Index_k(Range(1,I_A1_Index_k.size()-1)) == I_A1_Ind_k,0,1)) << ") returned FALSE" << endl;
        return false;
      }
      I_NBack++;
///      nback = nback + 1
///    endif
    }
///    if(jback(nslitf-1) ge jback(nslitf-2)) then begin
    if ((*P_D_A1_JBack)(I_NSlitF - 1) >= (*P_D_A1_JBack)(I_NSlitF-2)){
///      k = [k,nslitf-1]
///      nback = nback + 1
      I_A1_Ind_k.resize(I_A1_Index_k.size());
      I_A1_Ind_k = I_A1_Index_k;
      if (!this->InsertAt(&I_A1_Index_k,I_NSlitF-1,I_A1_Index_k.size())){
        cout << "CFits::MkScatter: ERROR: InsertAt(&I_A1_Index_k,I_NSlitF-1,I_A1_Index_k.size()) returned FALSE!" << endl;
        return false;
      }
      if (I_A1_Index_k(I_A1_Index_k.size()-1) == I_NSlitF-1 && sum(where(I_A1_Index_k(Range(0,I_A1_Index_k.size()-2)) == I_A1_Ind_k,0,1)) == 0){
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: InsertAt(&I_A1_Index_k,I_NSlitF-1,I_A1_Index_k.size()) returned TRUE" << endl;
#endif
      }
      else{
        cout << "CFits::MkScatter: InsertAt(&I_A1_Index_k,0,0) returned TRUE, I_A1_Index_k(size-1) == 0 returned FALSE" << endl;
        return false;
      }
      I_NBack++;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_NBack set to " << I_NBack << endl;
#endif
///    endif
    }

///    jback = where(yslitf(k) lt 0, n1)
    D_A1_YSlitF_k.resize(I_A1_Index_k.size());
    for (i=0;i<I_A1_Index_k.size();i++){
      D_A1_YSlitF_k(i) = D_A1_YSlitF(I_A1_Index_k(i));
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 1. D_A1_YSlitF_k set to " << D_A1_YSlitF_k << endl;
#endif
    I_A1_JBack.resize(D_A1_YSlitF_k.size());

    I_A1_JBack = where(D_A1_YSlitF_k < 0.,1,0);
    I_N1 = sum(I_A1_JBack);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_N1 set to " << I_N1 << endl;
#endif

///    m1 = max(yslitf(k(jback)), imax1)
    D_A1_YSlitF_k_jback.resize(I_N1);

    I_A1_Ind_k.resize(I_N1);
    j=0;
    for (i=0; i<D_A1_YSlitF_k.size();i++){
      if (I_A1_JBack(i) == 1){
        D_A1_YSlitF_k_jback(j) = D_A1_YSlitF_k(i);
        I_A1_Ind_k(j) = I_A1_Index_k(i);
        j++;
      }
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 1. D_A1_YSlitF_k_jback = " << D_A1_YSlitF_k_jback << endl;
#endif
    I_TV_IMax1 = maxIndex(D_A1_YSlitF_k_jback);
    P_I_A1_IMax1 = this->MaxIndex(I_TV_IMax1);
//    I_TV_IMax1 = maxIndex(D_A1_YSlitF_k_jback);
    D_IMax1 = max(D_A1_YSlitF_k_jback);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 1. P_I_A1_IMax1 set to " << *P_I_A1_IMax1 << endl;
    cout << "CFits::MkScatter: 1. D_IMax1 set to " << D_IMax1 << endl;
#endif
    I_IMax1 = (*P_I_A1_IMax1)(0);
    delete(P_I_A1_IMax1);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 1. I_IMax1 set to " << I_IMax1 << endl;
#endif
//  Array<double,1> D_A1_M1(I_A1_IMax1.size());
//  for (i=0;i<I_A1_IMax1.size()-1;i++){
//    D_A1_M1(i) = D_A1_YSlitF_k_jback(I_A1_IMax1(i));
///    imax1 = k(jback(imax1))
    I_IMax1 = I_A1_Ind_k(I_IMax1);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_IMax1 set to " << I_IMax1 << endl;
#endif
//  }
    D_M1 = D_A1_YSlitF(I_IMax1);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_M1 set to " << D_M1 << endl;
#endif
//  cout << "CFits::MkScatter: I_IMax1 set to " << I_IMax1 << endl;

///    jback = where(yslitf(k) gt 0, n2)
    I_A1_JBack1.resize(D_A1_YSlitF_k.size());
    D_A1_YSlitF_k.resize(I_A1_Index_k.size());
    for (i=0;i<I_A1_Index_k.size();i++){
      D_A1_YSlitF_k(i) = D_A1_YSlitF(I_A1_Index_k(i));
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 2. D_A1_YSlitF_k set to " << D_A1_YSlitF_k << endl;
#endif
    I_A1_JBack1 = where(D_A1_YSlitF_k > 0.,1,0);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_A1_JBack1 set to " << I_A1_JBack1 << endl;
#endif
    I_N2 = sum(I_A1_JBack1);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_N2 set to " << I_N2 << endl;
#endif
///    m2 = min(yslitf(k(jback)), imax2)
    D_A1_YSlitF_k_jback.resize(I_N2);
    I_A1_Ind_k.resize(I_N2);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_A1_Index_k set to " << I_A1_Index_k << endl;
#endif
    j=0;
    for (i=0; i<D_A1_YSlitF_k.size() ;i++){
      if (I_A1_JBack1(i) == 1){
        D_A1_YSlitF_k_jback(j) = D_A1_YSlitF_k(i);
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: i=" << i << ": D_A1_YSlitF_k_jback(j=" << j << ") set to " << D_A1_YSlitF_k_jback(j) << endl;
#endif
        I_A1_Ind_k(j) = I_A1_Index_k(i);
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: i=" << i << ": I_A1_Ind_k(j=" << j << ") set to " << I_A1_Ind_k(j) << endl;
#endif
        j++;
      }
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 2. D_A1_YSlitF_k_jback set to " << D_A1_YSlitF_k_jback << endl;
    cout << "CFits::MkScatter: 2. I_A1_Ind_k set to " << I_A1_Ind_k << endl;
#endif
    I_TV_IMax2 = minIndex(D_A1_YSlitF_k_jback);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 2. I_TV_IMax2 set to " << I_TV_IMax2 << endl;
#endif

    I_IMax2 = I_TV_IMax2(0);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 2. I_IMax2 set to " << I_IMax2 << endl;
#endif
//  Array<double,1> D_A1_M2(I_A1_IMax2.size());
//  for (i=0;i<I_A1_IMax2.size()-1;i++){
//    D_A1_M2(i) = D_A1_YSlitF_k_jback(I_A1_IMax2(i));
///    imax2 = k(jback(imax2))
    I_IMax2 = I_A1_Ind_k(I_IMax2);
//  }
    D_M2 = D_A1_YSlitF(I_IMax2);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 3. I_IMax2 set to " << I_IMax2 << endl;
    cout << "CFits::MkScatter: 3. D_M2 set to " << D_M2 << endl;
#endif
//  cout << "CFits::MkScatter: I_A1_IMax2 set to " << I_A1_IMax2 << endl;

///    k=[imax1,imax2]
    I_A1_Index_k.resize(2);
    I_A1_Index_k(0) = I_IMax1;
    I_A1_Index_k(1) = I_IMax2;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 4. I_A1_Index_k set to " << I_A1_Index_k << endl;
#endif

///    if(nback eq 0) then begin
    if (I_NBack == 0){
///      print,'MKSCATTER: Failed to find the boundaries of the inter-order troff'
///      print,'           Using default'
///      print,'Order: '+strtrim(ord,2)+'  X-range: ('+strtrim(ibeg,2)+','+strtrim(iend,2)+')'
///      k = [0, n_elements(nslitf-1)]/// ?????????????????????????
      I_A1_Index_k.resize(2);
      I_A1_Index_k(0) = 0;
      I_A1_Index_k(1) = I_NSlitF-1;/// ?????????????????????????
///    endif
    }
///    jback = bottom(sfsm(k(0):k(1)), 1, eps=dev, /poly)         ;Fit bottom with a straight line
//    delete(P_D_A1_JBack);

    CS_A1_Args_Bottom(0).Set("EPS");
    PP_Args_Bottom[0] = &D_Dev;

    CS_A1_Args_Bottom(1).Set("POLY");
    I_Temp = 1;
    PP_Args_Bottom[1] = &I_Temp;

    CS_A1_Args_Bottom(2).Set(" ");

    if (!this->Bottom(D_A1_SFSM(Range(I_A1_Index_k(0),I_A1_Index_k(1))),1,CS_A1_Args_Bottom,PP_Args_Bottom, P_D_A1_JBack)){
      cout << "CFits::MkScatter: ERROR: 2. Bottom(D_A1_SFSM(Range(I_A1_Index_k(0),I_A1_Index_k(1))),1,CS_A1_Args_Bottom,PP_Args_Bottom, P_D_A1_JBack) returned FALSE" << endl;
      P_D_A1_JBack->resize(I_A1_Index_k(1) - I_A1_Index_k(0) + 1);
      (*P_D_A1_JBack) = -100000;
      return false;
    }

#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 3. *P_D_A1_JBack set to " << *P_D_A1_JBack << endl;
#endif

///    iback = where(sfsm(k(0):k(1)) le jback, nback)             ;Find all the points below
//  Array<double,1> D_A1_TempSFSM(I_A1_Index_k(1) - I_A1_Index_k(0) + 1);
//  D_A1_TempSFSM = D_A1_SFSM(Range(I_A1_Index_k(0),I_A1_Index_k(1)));

    I_A1_IBack_Where.resize(P_D_A1_JBack->size());
    #ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_A1_IBack_Where set to " << I_A1_IBack_Where << endl;
    #endif
    I_A1_IBack_Where = where(D_A1_SFSM(Range(I_A1_Index_k(0),I_A1_Index_k(1))) <= (*P_D_A1_JBack), 1, 0);
    #ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: P_D_A1_JBack = " << *P_D_A1_JBack << endl;
      cout << "CFits::MkScatter: P_I_A1_IBackInd = " << *P_I_A1_IBackInd << endl;
      cout << "CFits::MkScatter: I_A1_IBack_Where set to " << I_A1_IBack_Where << endl;
    #endif
    delete(P_I_A1_IBackInd);
    #ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: P_I_A1_IBackInd deleted " << endl;
    #endif
    P_I_A1_IBackInd = this->GetIndex(I_A1_IBack_Where, I_NBack);
    #ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: P_I_A1_IBackInd set to " << *P_I_A1_IBackInd << endl;
      cout << "CFits::MkScatter: I_NBack set to " << I_NBack << endl;
    #endif
///    if(nback le 5) then begin
    if (I_NBack <= 5){
///      print,'MKSCATTER: Major error in the order format: could not detect inter-order troff'
      cout << "CFits::MKSCATTER: i_ord = " << i_ord << ": Major error in the order format: could not detect inter-order troff" << endl;
///      stop
      return false;
///    endif
    }
///    iback = iback + k(0)
    (*P_I_A1_IBackInd) += double(I_A1_Index_k(0));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: 2. P_I_A1_IBackInd set to " << *P_I_A1_IBackInd << endl;
#endif
///    imax1 = min(iback)
    I_IMax1 = min(*P_I_A1_IBackInd);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_IMax1 set to " << I_IMax1 << endl;
#endif

///    imax2 = max(iback)
    I_IMax2 = max(*P_I_A1_IBackInd);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_IMax2 set to " << I_IMax2 << endl;
#endif

///    sf1 = sfsm(iback)
    D_A1_SF1.resize(I_NBack);
    for (i=0; i<I_NBack; i++){
      D_A1_SF1(i) = D_A1_SFSM((*P_I_A1_IBackInd)(i));
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_A1_SF1 set to " << D_A1_SF1 << endl;
#endif

///    iback = 0
///    jback = 0

///    step = (max(sf1)-min(sf1))/(((n_elements(sf1)/10)<200)>10)
    D_Step = (max(D_A1_SF1) - min(D_A1_SF1));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_Step set to " << D_Step << endl;
#endif
    d_temp = double(D_A1_SF1.size()/10);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: d_temp set to " << d_temp << endl;
#endif
    if (d_temp > 200.){
      d_temp = 200.;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: d_temp set to " << d_temp << endl;
#endif
    }
    if (d_temp < 10.){
      d_temp = 10.;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: d_temp set to " << d_temp << endl;
#endif
    }
    D_Step /= d_temp;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: min(D_A1_SF1) = " << min(D_A1_SF1) << endl;
    cout << "CFits::MkScatter: max(D_A1_SF1) = " << max(D_A1_SF1) << endl;
    cout << "CFits::MkScatter: D_Step set to " << D_Step << endl;
#endif

///    h = histogram(sf1,bin=step)
    delete(P_I_A1_H);
    P_I_A1_H = this->Histogram(D_A1_SF1, D_Step);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: *P_I_A1_H set to " << *P_I_A1_H << endl;
#endif

///    nh = n_elements(h)
    I_NH = P_I_A1_H->size();
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_NH set to " << I_NH << endl;
#endif

///    hmax = max(h,ihmax)

    I_TV_IMax1 = maxIndex(*P_I_A1_H);
    P_I_A1_IHMax = this->MaxIndex(I_TV_IMax1);
//    I_TV_IHMax = maxIndex((*P_I_A1_H));
    I_IHMax = (*P_I_A1_IHMax)(0);
    delete(P_I_A1_IHMax);
    D_HMax = (*P_I_A1_H)(I_IHMax);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: D_HMax set to " << D_HMax << endl;
#endif

///    i0 = where(h(0:ihmax) lt 0.1*hmax, n1)
///    if(n1 gt 0) then i0 = max(i0) else i0=0
    I_A1_TempH.resize(I_IHMax+1);
    I_A1_TempH = (*P_I_A1_H)(Range(0,I_IHMax));
    I_A1_I0_Where.resize(I_A1_TempH.size());
    I_A1_I0_Where = where(I_A1_TempH < 0.1*D_HMax,1,0);
    I_N1 = sum(I_A1_I0_Where);
    I_I0 = 0;
    for (i=0; i<I_A1_I0_Where.size(); i++){
      if (I_A1_I0_Where(i) == 1)
        I_I0 = i;
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_I0 set to " << I_I0 << endl;
#endif

///    i1 = where(h(ihmax:nh-1) lt 0.1*hmax, n2)
///    if(n2 gt 0) then i1 = min(i1)+ihmax else i1=nh-1
    I_A1_TempH.resize(I_NH-I_IHMax);
    I_A1_TempH = (*P_I_A1_H)(Range(I_IHMax,I_NH-1));
    I_A1_I0_Where.resize(I_A1_TempH.size());
    I_A1_I0_Where = where(I_A1_TempH < 0.1*D_HMax,1,0);
    I_N2 = sum(I_A1_I0_Where);
    I_I1 = 0;
    if (I_N2 > 0){
      i=0;
      while (I_I1 == 0){
        if (I_A1_I0_Where(i) == 1){
          I_I1 = i;
          break;
        }
        i++;
      }
      I_I1 += I_IHMax;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_N2(=" << I_N2 << ") > 0: I_I1 set to " << I_I1 << endl;
#endif
    }
    else{
      I_I1 = I_NH-1;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: I_N2(=" << I_N2 << ") == 0: I_I1 set to " << I_I1 << endl;
#endif
    }
///    ii = where(sf1-min(sf1) ge step*i0 and sf1-min(sf1) lt step*i1, nii1)
///         +imax1
    I_A1_II_Where.resize(D_A1_SF1.size());
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: where(D_A1_SF1(=" << D_A1_SF1 << ")" << endl;
    cout << "- min(D_A1_SF1)(=" << min(D_A1_SF1) << ")" << endl;
    D_A1_Temp_A.resize(D_A1_SF1.size());
    D_A1_Temp_A = D_A1_SF1-min(D_A1_SF1);
    cout << "= " << D_A1_Temp_A << endl;
    cout << ">= D_Step(=" << D_Step << ") * I_I0(=" << I_I0 << ")" << endl;
    cout << "= " << D_Step*I_I0 << endl;
    cout << " && D_A1_SF1-min(D_A1_SF1) < D_Step * I_I1(=" << I_I1 << ")" << endl;
    cout << "= " << D_Step * I_I1 << endl;
#endif
    I_A1_II_Where = where(D_A1_SF1-min(D_A1_SF1) >= D_Step*I_I0 && D_A1_SF1-min(D_A1_SF1) < D_Step * I_I1,1,0);
    delete(P_I_A1_II);
    P_I_A1_II = this->GetIndex(I_A1_II_Where,I_NII1);
    (*P_I_A1_II) += I_IMax1;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: P_I_A1_II set to " << *P_I_A1_II << endl;
    cout << "CFits::MkScatter: I_NII1 set to " << I_NII1 << endl;
#endif

    D_A1_YSlitF_II.resize(P_I_A1_II->size());
    L_Y1 = 0;
    L_Y2 = 0;
///    if(nii1 le 0) then begin
    if (I_NII1 <= 0){
/// #ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MKSCATTER: Could not detect background points between orders " << endl;// I_Order_In-1 << " and " << ord
/// #endif
    }
    else{
///      y1 =  ceil(min(yslitf(ii)))                        ;bottom boundary of the troff
///      y2 = floor(max(yslitf(ii)))                        ;top boundary of the troff
      this->GetSubArrCopy(D_A1_YSlitF,
                          *P_I_A1_II,
                          D_A1_YSlitF_II);
      L_Y1 = Ceil(min(D_A1_YSlitF_II));
      L_Y2 = Floor(max(D_A1_YSlitF_II));
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: min(D_A1_YSlitF_II) = " << min(D_A1_YSlitF_II) << endl;
      cout << "CFits::MkScatter: L_Y1 set to " << L_Y1 << endl;
      cout << "CFits::MkScatter: max(D_A1_YSlitF_II) = " << max(D_A1_YSlitF_II) << endl;
      cout << "CFits::MkScatter: L_Y2 set to " << L_Y2 << endl;
#endif
///    endelse
    }

///    if(nii1 le 0) then begin
///      print,'MKSCATTER: Could not detect any background points'
///      stop
///    endif
    if (I_NII1 <= 0){
      cout << "CFits::MKSCATTER: Could not detect any background points" << endl;
      return false;
    }

///    yback(*,ord) = ycen                                  ;scattered light coordinates
    for (i=0;i<D_A1_YCen.size();i++)
      I_A2_YBack(i,i_ord) = int(D_A1_YCen(i));
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: I_A2_YBack(Range::all(),i_ord=" << i_ord << ") set to " << I_A2_YBack(Range::all(),i_ord) << endl;
#endif

///    for j=0,ncol-1 do begin                              ;scattered light in col j
    for (j = 0; j < this->NRows; j++){
///      yy1 = round(ycen(j)+y1)>0                          ;first row
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for(j=" << j << ",...): D_A1_YCen(j)(=" << D_A1_YCen(j) << ") + L_Y1(=" << L_Y1 << ") = " << D_A1_YCen(j) + L_Y1 << endl;
#endif
      I_YY1 = this->Round(D_A1_YCen(j) + L_Y1);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for(j=" << j << ",...): I_YY1 set to " << I_YY1 << endl;
#endif
      if (I_YY1 < 0)
        I_YY1 = 0;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for(j=" << j << ",...): I_YY1 set to " << I_YY1 << endl;
#endif
///      yy2 = round(ycen(j)+y2)<(nrow-1)                   ;last row
      I_YY2 = this->Round(D_A1_YCen(j) + L_Y2);
      if (I_YY2 > this->NCols-1)
        I_YY2 = this->NCols-1;
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for(j=" << j << ",...): I_YY2 set to " << I_YY2 << endl;
#endif


///      if(yy2-yy1 gt (0.3*(y2-y1)+1)) then begin          ;check if inside the frame
      if (I_YY2 - I_YY1 > (0.3*double(L_Y2-L_Y1) + 1.)){
///        scatter = reform(im(j,yy1:yy2))                  ;scattered light profile
        D_A1_Scatter.resize(I_YY2-I_YY1+1);
        D_A1_Scatter = (*this->P_D_A2_PixArray)(j,Range(I_YY1,I_YY2));
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): (I_YY2 - I_YY1 > (0.3*double(L_Y2-L_Y1) + 1.)): D_A1_Scatter set to " << D_A1_Scatter << endl;
#endif

///        if(imask) then begin
        if (i_mask){
///          k = where(mask(j,yy1:yy2) eq 1B, nk)           ;check for bad pixels
///          if(nk lt (yy2-yy1+1) and nk ge 2) then begin   ;if found, interpolate
///            scatter = interpol(scatter(k), k, findgen(yy2-yy1+1))
///          endif
///        endif
          cout << "Implement this!!!" << endl;
          return false;
        }
///        back_data(j,ord) = median(scatter)               ;take median
        D_A2_BackData(j,i_ord) = this->Median(D_A1_Scatter);
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): (I_YY2 - I_YY1 > (0.3*double(L_Y2-L_Y1) + 1.)): D_A2_BackData(j,i_ord) set to " << D_A2_BackData(j,i_ord) << endl;
#endif
///      endif else begin
      }
      else{
///        back_data(j,ord) = -10000                        ;bad point
        D_A2_BackData(j,i_ord) = -10000.;
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): else(not((I_YY2 - I_YY1 > (0.3*double(L_Y2-L_Y1) + 1.)))): D_A2_BackData(j,i_ord=" << i_ord << ") set to " << D_A2_BackData(j,i_ord) << endl;
#endif
///      endelse
      }
///      if(ord eq 1) then begin                            ;for the first order try
      if (i_ord == 1){
///        yy = ycen0(j) - (ycen(j) - ycen0(j))             ;to find background below
        D_YY = D_A1_YCenA(j) - (D_A1_YCen(j) - D_A1_YCenA(j));
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): if(i_ord == 1): D_YY set to " << D_YY << endl;
#endif

///        yy1 = round(yy+y1)>0                             ;first row
        I_YY1 = Round(D_YY + double(L_Y1));
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: I_YY1 set to " << I_YY1 << endl;
#endif
        if (I_YY1 < 0.){
          I_YY1 = 0.;
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: if(I_YY1 < 0.): I_YY1 set to " << I_YY1 << endl;
#endif
        }
///        yy2 = round(yy+y2)<(nrow-1)                      ;last row
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: D_YY + L_Y2 = " << D_YY + L_Y2 << endl;
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: D_YY + double(L_Y2) = " << D_YY + double(L_Y2) << endl;
#endif
//        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: Round(D_YY + L_Y2) = " << Round(D_YY + L_Y2) << endl;
        I_YY2 = Round(D_YY + double(L_Y2));
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: I_YY2 set to " << I_YY2 << endl;
#endif
        if (I_YY2 > this->NCols - 1){
          I_YY2 = this->NCols - 1;
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: if (I_YY2 > this->NCols-1): I_YY2 set to " << I_YY2 << endl;
#endif
        }
///        yback(j,ord-1) = yy                              ;scattered light coordinates
        I_A2_YBack(j,i_ord-1) = int(D_YY);
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: I_A2_YBack(j=" << j << ",i_ord(=" << i_ord << ")-1) set to " << I_A2_YBack(j,i_ord-1) << endl;
#endif

///        if(yy2-yy1 gt (0.3*(y2-y1)+1)) then begin        ;check if inside the frame
        if (double(I_YY2 - I_YY1) > (0.3*double(L_Y2 - L_Y1)+1.)){
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: if (double(I_YY2(= " << I_YY2 << ") - I_YY1(=" << I_YY1 << ")) = " << double(I_YY2-I_YY1) << " > (0.3*double(L_Y2(=" << L_Y2 << ") - L_Y1(=" << L_Y1 << "))+1.) = " << (0.3*double(L_Y2 - L_Y1)+1.) << ")" << endl;
#endif
///          scatter = reform(im(j,yy1:yy2))                ;scattered light profile
          D_A1_Scatter.resize(I_YY2-I_YY1+1);
          D_A1_Scatter = (*this->P_D_A2_PixArray)(j,Range(I_YY1,I_YY2));
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: if (I_YY2 - I_YY1 > (0.3*double(L_Y2 - L_Y1)+1.)): D_A1_Scatter set to " << D_A1_Scatter << endl;///          if(imask) then begin
#endif
          if (i_mask){
            cout << "CFits::MkScatter: IMPLEMENT THIS!!!" << endl;
            return false;
///            k = where(mask(j,yy1:yy2) eq 1B, nk)         ;check for bad pixels
///            if(nk lt (yy2-yy1+1) and nk ge 2) then begin ;if found, interpolate
///              scatter = interpol(scatter(k), k, findgen(yy2-yy1+1))
///            endif
///          endif
          }
///          back_data(j,ord-1) = median(scatter)           ;take median
          D_A2_BackData(j,i_ord-1) = this->Median(D_A1_Scatter);
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: if (I_YY2 - I_YY1 > (0.3*double(L_Y2 - L_Y1)+1.)): D_A2_BackData(j,i_ord-1) set to " << D_A2_BackData(j,i_ord-1) << endl;
#endif
///        endif else begin
        }
        else{
///          back_data(j,ord-1) = -10000
          D_A2_BackData(j,i_ord-1) = -10000.;
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: else(not( if (I_YY2 - I_YY1 > (0.3*double(L_Y2 - L_Y1)+1.)))): D_A2_BackData(j,i_ord-1) set to " << D_A2_BackData(j,i_ord-1) << endl;
#endif
///        endelse
        }
///      endif else if(ord eq nord-1) then begin            ;for the last order try
//        return false;
      }
      else if (i_ord == I_NApertures-1){

///        yy = ycen1(j) + (ycen1(j) - ycen(j))             ;to find background above
        D_YY = D_A1_YCenB(j) + (D_A1_YCenB(j) - D_A1_YCen(j));
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): D_A1_YCenB(j)(=" << D_A1_YCenB(j) << ") - D_A1_YCen(j)(=" << D_A1_YCen(j) << ") = " << (D_A1_YCenB(j) - D_A1_YCen(j)) << endl;
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): D_YY set to " << D_YY << endl;
#endif

///        yback(j,ord+1) = yy                              ;scattered light coordinates
        I_A2_YBack(j,i_ord+1) = int(D_YY);
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): I_A2_YBack(j,i_ord+1) set to " << I_A2_YBack(j,i_ord+1) << endl;
#endif

///        yy1 = round(yy+y1)>0                             ;first row
        I_YY1 = Round(D_YY + double(L_Y1));
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): D_YY + L_Y1(=" << L_Y1 << "): I_YY1 set to " << I_YY1 << endl;
#endif
        if (I_YY1 < 0.){
          I_YY1 = 0.;
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): if (I_YY1 < 0.): I_YY1 set to " << I_YY1 << endl;
#endif
        }
///        yy2 = round(yy+y2)<(nrow-1)                      ;last row
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): D_YY + L_Y2(=" << L_Y2 << ") = " << D_YY + L_Y2 << endl;
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): D_YY + double(L_Y2) = " << D_YY + double(L_Y2) << endl;
#endif
//        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == 1: Round(D_YY + L_Y2) = " << Round(D_YY + L_Y2) << endl;
        I_YY2 = Round(D_YY + double(L_Y2));
#ifdef __DEBUG_FITS_MKSCATTER__
        cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): I_YY2 set to " << I_YY2 << endl;
#endif
        if (I_YY2 > this->NCols - 1){
          I_YY2 = this->NCols - 1;
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): if(I_YY2 > this->NCols - 1): I_YY2 set to " << I_YY2 << endl;
#endif
        }


///        if(yy2-yy1 gt (0.3*(y2-y1)+1)) then begin        ;check if inside the frame
        if (double(I_YY2 - I_YY1) > 0.3*double(L_Y2-L_Y1)+1.){
///          scatter = reform(im(j,yy1:yy2))                ;scattered light profile
          D_A1_Scatter.resize(I_YY2-I_YY1+1);
          D_A1_Scatter = (*P_D_A2_PixArray)(j,Range(I_YY1,I_YY2));
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): if (I_YY2 - I_YY1 > (0.3*(L_Y2-L_Y1)+1)): D_A1_Scatter set to " << D_A1_Scatter << endl;
#endif
///          if(imask) then begin
          if (i_mask){
            cout << "IMPLEMENT THIS!!!" << endl;
            return false;
///            k = where(mask(j,yy1:yy2) eq 1B, nk)         ;check for bad pixels
///            if(nk lt (yy2-yy1+1) and nk ge 2) then begin ;if found, interpolate
///              scatter = interpol(scatter(k), k, findgen(yy2-yy1+1))
///            endif
///          endif
          }
///          back_data(j,ord+1) = median(scatter)           ;take median
          D_A2_BackData(j,i_ord+1) = this->Median(D_A1_Scatter);
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): if (I_YY2 - I_YY1 > (0.3*(L_Y2-L_Y1)+1)): D_A2_BackData(j,i_ord+1) set to " << D_A2_BackData(j,i_ord+1) << endl;
#endif
///        endif else begin
        }
        else{
///          back_data(j,ord+1) = -10000
          D_A2_BackData(j,i_ord+1) = -10000.;
#ifdef __DEBUG_FITS_MKSCATTER__
          cout << "CFits::MkScatter: for(j=" << j << ",...): i_ord == I_NApertures-1(=" << I_NApertures-1 << "): else(not(if (I_YY2 - I_YY1 > (0.3*(L_Y2-L_Y1)+1)))): D_A2_BackData(j,i_ord+1) set to " << D_A2_BackData(j,i_ord+1) << endl;
#endif
///        endelse
        }
///      endif
      }
///    endfor
//      return false;
    }
  }

///  print,'MKSCATTER: Order '+strtrim(nord,2)+' was processed'
  cout << "CFits::MkScatter: Order " << I_NApertures << " was processed" << endl;

///;Interpolate missing data from the adjacent troffs
///  for i=0,ncol-1 do begin
  Array<double,1> D_A1_Y(I_A2_YBack.cols());
  Array<int,1> I_A1_Index_k_Where(D_A2_BackData.rows());
  Array<int,1> *P_I_A1_Index_k;
  Array<double,1> *P_D_A1_InterPol = new Array<double,1>(1);
  Array<double,1> D_A1_BackData_k(1);
//  Array<int,1> I_A1_YBack_k(1);
  Array<double,1> D_A1_YBack(1);
  int i_nind;
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: I_A2_YBack.rows() = " << I_A2_YBack.rows() << ", I_A2_YBack.cols() = " << I_A2_YBack.cols() << endl;
#endif
  for (i=0;i<this->NRows;i++){
///    y=yback(i,*)
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for(i=" << i << "; this->Nrows(=" << this->NRows << ")-1; i++) started" << endl;
    cout << "CFits::MkScatter: for(i=" << i << "; this->Nrows(=" << this->NRows << ")-1; i++): I_A2_YBack(i,*) = " << I_A2_YBack(i,Range::all()) << endl;
#endif
    for (j=0; j < D_A1_Y.size(); j++){
//        cout << "CFits::MkScatter: for(i=" << i << "; this->Nrows(=" << this->NRows << ")-1; i++): for (jj=" << jj << "; jj < D_A1_Y.size(=" << D_A1_Y.size() << "); jj++) started";
        D_A1_Y(j) = double(I_A2_YBack(i,j));
//        cout << "CFits::MkScatter: for(i=" << i << "; this->Nrows(=" << this->NRows << ")-1; i++): for (jj=" << jj << "; jj < D_A1_Y.size(=" << D_A1_Y.size() << "); jj++): D_A1_Y(jj) set to " << D_A1_Y(jj) << endl;
    }
///    k=where(back_data(i,*) gt -1000)
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for(i(=" << i << ")...): D_A1_Y set to " << D_A1_Y << endl;
#endif
    I_A1_Index_k_Where.resize(D_A2_BackData.cols());
    cout << "CFits::MkScatter: for(i(=" << i << ")...):   D_A2_BackData(i,Range::all()) = " << D_A2_BackData(i,Range::all()) << endl;
    cout << "CFits::MkScatter: for(i(=" << i << ")...): I_A1_Index_k_Where set to " << I_A1_Index_k_Where << endl;

    I_A1_Index_k_Where = where(D_A2_BackData(i,Range::all()) > -1000.,1,0);
    cout << "CFits::MkScatter: for(i(=" << i << ")...): I_A1_Index_k_Where set to " << I_A1_Index_k_Where << endl;

    P_I_A1_Index_k = this->GetIndex(I_A1_Index_k_Where,i_nind);
    cout << "CFits::MkScatter: for(i(=" << i << ")...): *P_I_A1_Index_k set to " << *P_I_A1_Index_k << endl;

    if (i_nind == 0)
      return false;
    I_A1_Index_k.resize(P_I_A1_Index_k->size());
    I_A1_Index_k = (*P_I_A1_Index_k);
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for(i(=" << i << ")...): I_A1_Index_k set to " << I_A1_Index_k << endl;
#endif
    delete(P_I_A1_Index_k);

///    back_data(i,*) = interpol(back_data(i,k), yback(i,k), yback(i,*))
    D_A1_BackData_k.resize(I_A1_Index_k.size());
    D_A1_YBack_k.resize(I_A1_Index_k.size());
    for (j = 0; j < I_A1_Index_k.size(); j++){
      D_A1_BackData_k(j) = D_A2_BackData(i,I_A1_Index_k(j));
      D_A1_YBack_k(j) = double(I_A2_YBack(i,I_A1_Index_k(j)));
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for(i(=" << i << ")...): D_A1_YBack_k = " << D_A1_YBack_k << endl;
    cout << "CFits::MkScatter: for(i(=" << i << ")...): I_A2_YBack(i,*) = " << I_A2_YBack(i,Range::all()) << endl;
#endif
//    D_A2_BackData.resizeAndPreserve(D_A2_BackData.rows(), I_A1_Index_k.size());
//    D_A2_BackData(i,Range::all()) = D_A1_BackData_k;
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for(i(=" << i << ")...): D_A1_BackData_k set to " << D_A1_BackData_k << endl;
    cout << "CFits::MkScatter: for(i(=" << i << ")...): D_A2_BackData(i,*) set to " << D_A2_BackData(i,Range::all()) << endl;
#endif
    D_A1_YBack.resize(I_A2_YBack.cols());
    for (j=0; j < D_A1_YBack.size(); j++){
      D_A1_YBack(j) = double(I_A2_YBack(i,j));
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for(i(=" << i << ")...): D_A1_YBack set to " << D_A1_YBack << endl;
#endif
    if (!this->InterPol(D_A1_BackData_k, D_A1_YBack_k, D_A1_YBack, P_D_A1_InterPol)){
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: ERROR: InterPol returned FALSE" << endl;
#endif
      delete(P_D_A1_InterPol);
      P_D_A1_InterPol = new Array<double,1>(D_A1_YBack.size());
      (*P_D_A1_InterPol) = -100000.;
//      return false;
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for(i(=" << i << ")...): *P_D_A1_InterPol set to " << *P_D_A1_InterPol << endl;
#endif
    D_A2_BackData(i,Range::all()) = (*P_D_A1_InterPol);









#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for(i(=" << i << ")...): D_A2_BackData(i,*) set to " << D_A2_BackData(i,Range::all()) << endl;
#endif
///  endfor
  }

  cout << "CFits::MkScatter: D_A2_BackData(*,I_NApertures-1) set to " << D_A2_BackData(Range::all(),I_NApertures-1) << endl;

//  return false;

///;Filter out noise: 0th background troff
///  range = [colrange(0,0),colrange(1,0)]
  Array<int,1> I_A1_Range(2);
  I_A1_Range(0) = (*this->P_D_A1_YCenter)(0)+(*this->P_D_A1_YLow)(0);
  I_A1_Range(1) = (*this->P_D_A1_YCenter)(0)+(*this->P_D_A1_YHigh)(0);
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: I_A1_Range set to " << I_A1_Range << endl;
#endif

///  x = indgen(range(1) - range(0) + 1) + range(0)
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: I_A1_Range(0) = " << I_A1_Range(0) << endl;
  cout << "CFits::MkScatter: I_A1_Range(1) = " << I_A1_Range(1) << endl;
  cout << "CFits::MkScatter: I_A1_Range(1) - I_A1_Range(0) = " << I_A1_Range(1) - I_A1_Range(0) << endl;
#endif
  Vector<int> *P_I_VecArr_X = IndGen(I_A1_Range(1) - I_A1_Range(0) + 1);
  (*P_I_VecArr_X) += I_A1_Range(0);
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: 1. *P_I_VecArr_X set to " << P_I_VecArr_X->length() << ": " << *P_I_VecArr_X << endl;
#endif
///  b = middle(back_data(x,0),10.,eps=dev)
  Array<double,1> D_A1_BackData_x(P_I_VecArr_X->length());
  Array<int,1> I_A1_X(P_I_VecArr_X->length());
  for (i=0; i<I_A1_X.size(); i++)
    I_A1_X(i) = (*P_I_VecArr_X)(i);
// #ifdef __DEBUG_FITS_MKSCATTER__
//  cout << "CFits::MkScatter: *P_I_VecArr_X = " << *P_I_VecArr_X << endl;
// #endif
  delete(P_I_VecArr_X);
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: I_A1_X set to " << I_A1_X << endl;
#endif
  this->GetSubArrCopy(D_A2_BackData(Range::all(),0),
                      I_A1_X,
                      D_A1_BackData_x);
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: D_A2_BackData(*,0) = " << D_A2_BackData(Range::all(),0) << endl;
  cout << "CFits::MkScatter: D_A2_BackData(1839,0) = " << D_A2_BackData(1839,0) << endl;
  cout << "CFits::MkScatter: D_A1_BackData_x = " << D_A1_BackData_x << endl;
  cout << "CFits::MkScatter: D_A1_BackData_x(0) = " << D_A1_BackData_x(0) << endl;
#endif
  (CS_A1_Args_Middle(1)).Set(" ");///POLY
  (CS_A1_Args_Middle(2)).Set(" ");///MIN
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: CS_A1_Args_Middle set to " << CS_A1_Args_Middle << endl;
#endif

  Array<double, 1> *P_D_A1_B = new Array<double,1>(1);
  if (!this->Middle(D_A1_BackData_x, 10, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_B)){
    cout << "CFits::MkScatter: ERROR: 3. Middle(D_A1_BackData_x, 10, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_B) returned FALSE" << endl;
    P_D_A1_B->resize(D_A1_BackData_x.size());
    (*P_D_A1_B) = -100000;
  }
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: *P_D_A1_B set to " << *P_D_A1_B << endl;
#endif

///  if(keyword_set(pol)) then $
  Array<double,1> *P_D_A1_Back = new Array<double,1>(1);
  double D_Min = 0.;
  CS_A1_Args_Middle(2).Set("MIN");
  PP_Args_Middle[2] = &D_Min;
  if (this->KeyWord_Set(CS_A1_Args_In, CString("POLY")) >= 0){
///    back(x,0) = middle(b,11,/poly,eps=dev,min=0) $
    CS_A1_Args_Middle(1).Set("POLY");
    if (!this->Middle(*P_D_A1_B, 11, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Back)){
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: ERROR: 4. Middle(*P_D_A1_B, 11, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Back) returned FALSE" << endl;
#endif
      P_D_A1_Back->resize(P_D_A1_B->size());
      (*P_D_A1_Back) = -100000;
      return false;
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: Middle(*P_D_A1_B=" << *P_D_A1_B << ", 11, CS_A1_Args_Middle=" << CS_A1_Args_Middle << ", PP_Args_Middle, P_D_A1_Back=" << *P_D_A1_Back << ") returned TRUE" << endl;
#endif

///  else $
  }
  else{
///    back(x,0) = middle(b,1.d1,eps=dev,min=0)
    CS_A1_Args_Middle(1).Set(" ");
    if (!this->Middle(*P_D_A1_B, 10, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Back)){
      cout << "CFits::MkScatter: ERROR: 5. Middle(*P_D_A1_B, 10, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Back) returned FALSE" << endl;
      P_D_A1_Back->resize(P_D_A1_B->size());
      (*P_D_A1_Back) = -100000;
      return false;
    }
    #ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: Middle(*P_D_A1_B=" << *P_D_A1_B << ", 10, CS_A1_Args_Middle=" << CS_A1_Args_Middle << ", PP_Args_Middle, P_D_A1_Back=" << *P_D_A1_Back << ") returned TRUE" << endl;
    #endif

  }
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: I_A1_X = " << I_A1_X << endl;
#endif
  for (i=0; i < I_A1_X.size(); i++)
    D_A2_Back(I_A1_X(i),0) = (*P_D_A1_Back)(i);
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: *P_D_A1_Back set to " << *P_D_A1_Back << endl;
  cout << "CFits::MkScatter: D_A2_Back(I_A1_X,0) set to " << GetSubArr(D_A2_Back(Range::all(),0),I_A1_X) << endl;
#endif

///;All intermediate background troffs
///  if(nord gt 1) then begin
  if (I_NApertures > 1){
///    for ord=1,nord-1 do begin
    for (i_ord=1; i_ord < I_NApertures; i_ord++){
///      range = [colrange(0,ord-1)<colrange(0,ord), $
///               colrange(1,ord-1)>colrange(1,ord)]
      I_A1_Range(0) = (*this->P_D_A1_YCenter)(i_ord-1)+(*this->P_D_A1_YLow)(i_ord-1);
      if (I_A1_Range(0) > (*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_YLow)(i_ord))
        I_A1_Range(0) = (*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_YLow)(i_ord);
      I_A1_Range(1) = (*this->P_D_A1_YCenter)(i_ord-1)+(*this->P_D_A1_YHigh)(i_ord-1);
      if (I_A1_Range(1) < (*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_YHigh)(i_ord))
        I_A1_Range(1) = (*this->P_D_A1_YCenter)(i_ord)+(*this->P_D_A1_YHigh)(i_ord);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for (i_ord=" << i_ord << ", < I_NApertures=" << I_NApertures << ", i_ord++): I_A1_Range set to " << I_A1_Range << endl;
#endif
///      x = indgen(range(1) - range(0) + 1) + range(0)
///      I_VecArr_X.resize(I_A1_Range(1) - I_A1_Range(0) + 1);

      P_I_VecArr_X = IndGen(I_A1_Range(1) - I_A1_Range(0) + 1);
      (*P_I_VecArr_X) += I_A1_Range(0);
      I_A1_X.resize(P_I_VecArr_X->length());
      for (j=0; j < I_A1_X.size(); j++)
        I_A1_X(j) = (*P_I_VecArr_X)(j);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for (i_ord=" << i_ord << ", < I_NApertures=" << I_NApertures << ", i_ord++): *P_I_VecArr_X set to " << P_I_VecArr_X->length() << ": " << *P_I_VecArr_X << endl;
      cout << "CFits::MkScatter: for (i_ord=" << i_ord << ", < I_NApertures=" << I_NApertures << ", i_ord++): I_A1_X set to " << I_A1_X.size() << ": " << I_A1_X << endl;
#endif
      delete(P_I_VecArr_X);

///      b = middle(back_data(x,ord),10.,eps=dev)
      D_A1_BackData_x.resize(I_A1_X.size());
      this->GetSubArrCopy(D_A2_BackData(Range::all(),i_ord),
                          I_A1_X,
                          D_A1_BackData_x);
      CS_A1_Args_Middle(1).Set(" ");///POLY
      CS_A1_Args_Middle(2).Set(" ");///MIN
//      delete(P_D_A1_B);
      if (!this->Middle(D_A1_BackData_x, 10, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_B)){
        cout << "CFits::MkScatter: ERROR: 5. Middle(D_A1_BackData_x, 10, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_B) returned FALSE" << endl;
        P_D_A1_B->resize(D_A1_BackData_k.size());
        (*P_D_A1_B) = -100000;
        return false;
      }

#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for (i_ord=" << i_ord << ", < I_NApertures=" << I_NApertures << ", i_ord++): *P_D_A1_B set to " << *P_D_A1_B << endl;
#endif
///      if(keyword_set(pol)) then $
//      delete(P_D_A1_Back);
      if (this->KeyWord_Set(CS_A1_Args_In, CString("POLY")) >= 0){
///        back(x,ord) = middle(b,11,/poly,eps=dev,min=0,/DOUBLE) $
        CS_A1_Args_Middle(1).Set("POLY");
        CS_A1_Args_Middle(2).Set("MIN");
        if (!this->Middle(*P_D_A1_B,11,CS_A1_Args_Middle,PP_Args_Middle, P_D_A1_Back)){
          cout << "CFits::MkScatter: ERROR: 6. Middle(*P_D_A1_B, 11, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Back) returned FALSE" << endl;
          P_D_A1_Back->resize(P_D_A1_B->size());
          (*P_D_A1_Back) = -100000;
          return false;
        }

///      else $
      }
      else{
///        back(x,ord) = middle(b,1.d1,eps=dev,min=0)
        CS_A1_Args_Middle(2).Set("MIN");
        if (!this->Middle(*P_D_A1_B,10,CS_A1_Args_Middle,PP_Args_Middle, P_D_A1_Back)){
          cout << "CFits::MkScatter: ERROR: 6. Middle(*P_D_A1_B, 10, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_Back) returned FALSE" << endl;
          P_D_A1_Back->resize(P_D_A1_B->size());
          (*P_D_A1_Back) = -100000;
          return false;
        }

      }
      for (j=0; j < I_A1_X.size(); j++)
        D_A2_Back(I_A1_X(j),i_ord) = (*P_D_A1_Back)(j);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for (i_ord=" << i_ord << ", < I_NApertures=" << I_NApertures << ", i_ord++): *P_D_A1_Back set to " << (*P_D_A1_Back) << endl;
      cout << "CFits::MkScatter: for (i_ord=" << i_ord << ", < I_NApertures=" << I_NApertures << ", i_ord++): D_A2_Back(I_A1_X,i_ord) set to " << GetSubArr(D_A2_Back(Range::all(),i_ord),I_A1_X) << endl;
#endif
///    endfor
    }
///  endif
  }

///;The last background troff
///  range = [colrange(0,nord-1),colrange(1,nord-1)]
I_A1_Range(0) = (*this->P_D_A1_YCenter)(I_NApertures-1)+(*this->P_D_A1_YLow)(I_NApertures-1);
I_A1_Range(1) = (*this->P_D_A1_YCenter)(I_NApertures-1)+(*this->P_D_A1_YHigh)(I_NApertures-1);
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: I_A1_Range set to " << I_A1_Range << endl;
#endif
///  x = indgen(range(1) - range(0) + 1) + range(0)
  P_I_VecArr_X = IndGen(I_A1_Range(1) - I_A1_Range(0) + 1);
  (*P_I_VecArr_X) += I_A1_Range(0);
  I_A1_X.resize(P_I_VecArr_X->length());
  for (i=0; i<I_A1_X.size(); i++)
    I_A1_X(i) = (*P_I_VecArr_X)(i);
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: 2. *P_I_VecArr_X set to " << P_I_VecArr_X->length() << ": " << *P_I_VecArr_X << endl;
  cout << "CFits::MkScatter: 2. I_A1_X set to " << I_A1_X.size() << ": " << I_A1_X << endl;
#endif
  delete(P_I_VecArr_X);
///  b = middle(back_data(x,nord),10.,eps=dev)
  D_A1_BackData_x.resize(I_A1_X.size());
  this->GetSubArrCopy(D_A2_BackData(Range::all(),I_NApertures),
                      I_A1_X,
                      D_A1_BackData_x);
//  delete(P_D_A1_B);
  CS_A1_Args_Middle(1).Set(" ");///POLY
  CS_A1_Args_Middle(2).Set(" ");///MIN
  if (!this->Middle(D_A1_BackData_x,10,CS_A1_Args_Middle,PP_Args_Middle, P_D_A1_B)){
    cout << "CFits::MkScatter: ERROR: 7. Middle(*P_D_A1_B, 10, CS_A1_Args_Middle, PP_Args_Middle, P_D_A1_B) returned FALSE" << endl;
    P_D_A1_B->resize(D_A1_BackData_x.size());
    (*P_D_A1_B) = -100000;
    return false;
  }
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: After Middle: P_D_A1_B set to " << P_D_A1_B->length() << ": " << *P_D_A1_B << endl;
#endif

///  if(keyword_set(pol)) then $
//  delete(P_D_A1_Back);
  if (this->KeyWord_Set(CS_A1_Args_In, CString("POLY")) >= 0){
///    back(x,nord) = bottom(b,11,/poly,eps=dev,min=0,/DOUBLE) $
    D_A1_BackData_x.resize(I_A1_X.size());
    this->GetSubArrCopy(D_A2_BackData(Range::all(),i_ord),
                        I_A1_X,
                        D_A1_BackData_x);

    CS_A1_Args_Bottom(0).Set("EPS");
    PP_Args_Bottom[0] = &D_Dev;

    CS_A1_Args_Bottom(1).Set("POLY");
    I_Temp = 1;
    PP_Args_Bottom[1] = &I_Temp;

    CS_A1_Args_Bottom(2).Set("MIN");
    D_Min = 0.;
    PP_Args_Bottom[2] = &D_Min;

    if (!this->Bottom(*P_D_A1_B,11,CS_A1_Args_Bottom, PP_Args_Bottom, P_D_A1_Back)){
      cout << "CFits::MkScatter: ERROR: 3. Bottom(*P_D_A1_B,11,CS_A1_Args_Bottom, PP_Args_Bottom, P_D_A1_Back) returned FALSE" << endl;
      P_D_A1_Back->resize(P_D_A1_B->size());
      (*P_D_A1_Back) = -100000;
      return false;
    }
    cout << "CFits::MkScatter: ERROR: 3. Bottom(*P_D_A1_B,11,CS_A1_Args_Bottom, PP_Args_Bottom, P_D_A1_Back) returned TRUE" << endl;

///  else $
  }
  else{

    CS_A1_Args_Bottom(0).Set("EPS");
    PP_Args_Bottom[0] = &D_Dev;

    CS_A1_Args_Bottom(1).Set(" ");
    I_Temp = 1;
    PP_Args_Bottom[1] = &I_Temp;

    CS_A1_Args_Bottom(2).Set("MIN");
    D_Min = 0.;
    PP_Args_Bottom[2] = &D_Min;

///    back(x,nord) = bottom(b,1.d1,eps=dev,min=0)
    if (!this->Bottom(*P_D_A1_B,10,CS_A1_Args_Bottom, PP_Args_Bottom, P_D_A1_Back)){
      cout << "CFits::MkScatter: ERROR: 4. Bottom(*P_D_A1_B,10,CS_A1_Args_Bottom, PP_Args_Bottom, P_D_A1_Back) returned FALSE" << endl;
      P_D_A1_Back->resize(P_D_A1_B->size());
      (*P_D_A1_Back) = -100000;
      return false;
    }
    cout << "CFits::MkScatter: 4. Bottom(*P_D_A1_B,10,CS_A1_Args_Bottom, PP_Args_Bottom, P_D_A1_Back) returned TRUE" << endl;

  }
  for (i=0; i < I_A1_X.size(); i++)
    D_A2_Back(I_A1_X(i),this->I_NApertures) = (*P_D_A1_Back)(i);
  cout << "CFits::MkScatter: D_A2_Back(I_A1_X=" << I_A1_X << ",I_NApertures=" << I_NApertures << ") set to " << GetSubArr(D_A2_Back(Range::all(),I_NApertures),I_A1_X) << endl;

///  ycen = findgen(nrow)
  D_A1_YCen.resize(this->NCols);
  Vector<double> *P_D_A1_YCen = DIndGen(this->NCols);
  for (i=0; i<this->NCols; i++)
    D_A1_YCen(i) = (*P_D_A1_YCen)(i);
#ifdef __DEBUG_FITS_MKSCATTER__
  cout << "CFits::MkScatter: D_A1_YCen set to " << D_A1_YCen << endl;
#endif
  delete(P_D_A1_YCen);
///  for j = 0,ncol-1 do begin
  Array<double,1> D_A1_B(1);
  for (j=0; j < this->NRows; j++){
///    b = reform(back(j,*))
    D_A1_B.resize(D_A2_Back.cols());
    D_A1_B = D_A2_Back(j,Range::all());
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): D_A1_B set to " << D_A1_B << endl;
    cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): I_A2_YBack.cols() = " << I_A2_YBack.cols() << endl;
#endif
///    y = reform(yback(j,*))
    D_A1_Y.resize(I_A2_YBack.cols());
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): D_A1_Y.size() = " << D_A1_Y.size() << endl;
#endif
    for (i=0; i<D_A1_Y.size(); i++){
      D_A1_Y(i) = double(I_A2_YBack(j,i));
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): for (i=" << i << "; D_A1_Y.size(); i++) D_A1_Y(i) set to " << D_A1_Y(i) << endl;
#endif
    }
#ifdef __DEBUG_FITS_MKSCATTER__
    cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): D_A1_Y set to " << D_A1_Y << endl;
#endif
///    if(keyword_set(subtract)) then im(j,*) = im(j,*) -  interpol(b, y, ycen)
    if (this->KeyWord_Set(CS_A1_Args_In, CString("SUBTRACT")) >= 0){
//      delete(P_D_A1_InterPol);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): KeyWord_Set(SUBTRACT): D_A1_B = " << D_A1_B << endl;
      cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): KeyWord_Set(SUBTRACT): D_A1_Y = " << D_A1_Y << endl;
      cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): KeyWord_Set(SUBTRACT): D_A1_YCen = " << D_A1_YCen << endl;
#endif
      if (!this->InterPol(D_A1_B, D_A1_Y, D_A1_YCen, P_D_A1_InterPol)){
        cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): ERROR: InterPol(D_A1_B, D_A1_Y, D_A1_YCen, P_D_A1_InterPol) returned FALSE" << endl;
        P_D_A1_InterPol->resize(D_A1_YCen.size());
        (*P_D_A1_InterPol) = 0.;
//        return false;
      }
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): KeyWord_Set(SUBTRACT): *P_D_A1_InterPol set to " << (*P_D_A1_InterPol) << endl;
#endif
      (*P_D_A2_PixArray)(j,Range::all()) -= (*P_D_A1_InterPol);
#ifdef __DEBUG_FITS_MKSCATTER__
      cout << "CFits::MkScatter: for (j=" << j << "; j < this->NRows=" << this->NRows << "; j++): KeyWord_Set(SUBTRACT): (*P_D_A2_PixArray)(j=" << j << ",Range::all()) set to " << (*P_D_A2_PixArray)(j,Range::all()) << endl;
#endif
    }
//    if (j == 1000)
//      return false;
///  endfor
  }

///  return**
  delete(P_I_A1_YCenFix);
  return true;
}**/

/**
  BandSol() const
 **/
int CFits::BandSol(int Argc, void *Argv[]) const
{
  double *a, *r;
  double aa;
  int n, nd, o, p, q;

  /* Double arrays are passed by reference. */
  a = (double*)Argv[0];
  r = (double*)Argv[1];
  /* The size of the system and the number of diagonals are passed by value */
  n = *(int *)Argv[2];
  nd = *(int *)Argv[3];
#ifdef __DEBUG_FITS_BANDSOL__
  cout << "CFits::BandSol: *a = " << *a << endl;
  cout << "CFits::BandSol: *r = " << *r << endl;
  cout << "CFits::BandSol: n = " << n << endl;
  cout << "CFits::BandSol: nd = " << nd << endl;
  (*P_OFS_Log) << "CFits::BandSol: *a = " << *a << endl;
  (*P_OFS_Log) << "CFits::BandSol: *r = " << *r << endl;
  (*P_OFS_Log) << "CFits::BandSol: n = " << n << endl;
  (*P_OFS_Log) << "CFits::BandSol: nd = " << nd << endl;
#endif

  /*
  bandsol solve a sparse system of linear equations with band-diagonal matrix.
     Band is assumed to be symmetrix relative to the main diaginal. Usage:
  CALL_EXTERNAL('bandsol.so', 'bandsol', a, r, n, nd)
  where a is 2D array [n,m] where n - is the number of equations and nd
  is the width of the band (3 for tri-diagonal system),
  nd is always an odd number. The main diagonal should be in a(*,nd/2)
  The first lower subdiagonal should be in a(1:n-1,nd-2-1), the first
             upper subdiagonal is in a(0:n-2,nd/2+1) etc. For example:
                    / 0 0 X X X \
  | 0 X X X X |
  | X X X X X |
  | X X X X X |
  A = | X X X X X |
  | X X X X X |
  | X X X X X |
  | X X X X 0 |
  \ X X X 0 0 /
  r is the array of RHS of size n.
  */

  /* Forward sweep */
  for(o = 0; o < n - 1; o++)
  {
    aa=a[o + n * (nd / 2)];
#ifdef __DEBUG_FITS_BANDSOL__
    (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=0; o<n(=" << n << "); o++): o+n*(nd/2) = " << o+n*(nd/2) << endl;
    (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=0; o<n(=" << n << "); o++): aa set to " << aa << endl;
#endif
    r[o] /= aa;
#ifdef __DEBUG_FITS_BANDSOL__
    (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=0; o<n(=" << n << "); o++): r[o] set to " << r[o] << endl;
#endif
    for(p = 0; p < nd; p++){
      a[o + p * n] /= aa;
#ifdef __DEBUG_FITS_BANDSOL__
      (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=0; o<n(=" << n << "); o++): for(p(=" << p << ")=0; p<nd(=" << nd << "); p++): a[o+p*n=" << o+p*n << "] set to " << a[o+p*n] << endl;
#endif
    }
    for(p = 1; p < MIN(nd / 2 + 1, n - o); p++)
    {
      aa=a[o + p + n * (nd / 2 - p)];
#ifdef __DEBUG_FITS_BANDSOL__
      (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=0; o<n(=" << n << "); o++): for(p(=" << p << ")=0; p<nd(=" << nd << "); p++): aa set to " << aa << endl;
#endif
      r[o + p] -= r[o] * aa;
#ifdef __DEBUG_FITS_BANDSOL__
      (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=0; o<n(=" << n << "); o++): for(p(=" << p << ")=0; p<nd(=" << nd << "); p++): r[o+p=" << o+p << "] set to " << r[o+p] << endl;
#endif
      for(q = 0; q < n * (nd - p); q += n){
        a[o + p + q] -= a[o + q + n * p] * aa;
#ifdef __DEBUG_FITS_BANDSOL__
        (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=0; o<n(=" << n << "); o++): for(p(=" << p << ")=0; p<nd(=" << nd << "); p++): for(q(=" << q << ")=0; q<n*(nd-p)(=" << n*(nd-p) << "); q++): a[o+p+q=" << o+p+q << "] set to " << a[o+p+q] << endl;
#endif
      }
    }
  }

  /* Backward sweep */
  r[n-1] /= a[n - 1 + n * (nd / 2)];
#ifdef __DEBUG_FITS_BANDSOL__
  (*P_OFS_Log) << "bandsol: r[n-1=" << n-1 << "] set to " << r[n-1] << endl;
#endif
  for(o=n-1; o>0; o--)
  {
    for(p=1; p <= MIN(nd/2,o); p++){
      r[o-p] -= r[o] *
                a[o - p + n * (nd / 2 + p)];
#ifdef __DEBUG_FITS_BANDSOL__
      (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=n-1=" << n-1 << "; o>0; o--): for(p(=" << p << ")=1; p<=Min(nd/2=" << nd/2 << ",o=" << o << "); p++): r[o-p=" << o-p << "] set to " << r[o-p] << endl;
#endif
    }
    r[o-1] /= a[o-1+n*(nd/2)];
#ifdef __DEBUG_FITS_BANDSOL__
    (*P_OFS_Log) << "bandsol: for(o(=" << o << ")=n-1=" << n-1 << "; o>0; o--): r[o-1=" << o-1 << "] set to " << r[o-1] << endl;
#endif
  }
  r[0] /= a[n*(nd/2)];
#ifdef __DEBUG_FITS_BANDSOL__
  (*P_OFS_Log) << "bandsol: r[0] set to " << r[0] << endl;
#endif

  return 0;
}

/**
 SlitFunc
 SlitFunc
 **/
  bool CFits::SlitFunc(const Array<double, 2> &D_A2_ImM,
		       int I_IAperture_In,
		       const Array<double, 1> &D_A1_XCenters_In, //: in
		       Array<double, 1> &SPVecArr,   //: out
		       Array<double, 2> &D_A2_SF,   //: out
		       const Array<CString, 1> &CS_A1_Args_In,   //: in
		       void *ArgV_In[])     //: in
/**
 *              TELLURIC   = int [0-none,1-Piskunov,2-mine]     : in
 *              IM_OUT     = Array<double, 2>: out
 *              PROF_OUT   = Array<double, 2>: out
 *              LAMBDA_SF  = double          : in
 *              LAMBDA_SP  = int             : in
 *              WING_SMOOTH_FACTOR = double  : in
 *              USE_ROW    = int             : in
 *              BAD        = Array<int, 1>   : out
 *              MASK       = Array<double, 2>: in/out
 *              STOP       = int [0,1]                          : in
 *              SKY        = Array<double, 1>(D_A2_ImM.rows())  : out
 *              ERRORS     = Array<double, 2>(D_A2_ImM.rows(), D_A2_ImM.cols()): in/out
 *              ERRORS_OUT = Array<double, 1>(D_A2_ImM.rows())  : out
 *              ERR_SKY    = Array<double, 1>(D_A2_ImM.rows())  : out
 *              SP_FIT     = Array<double, 1>(D_A2_ImM.rows())  : out
 *              I_BIN      = int                                : in
 *              DEBUGFILES_SUFFIX = CString: in
 *              ERRORS_SP_OUT = Array<double, 1>(D_A2_ImM.rows()) : out
 *              SP_OUT     = Array<double, 1>(D_A2_ImM.rows()) : out
 *              XLOW       = double                            : in
 *              SFO_OUT    = Array<double, 1>(D_A2_ImM.cols()*I_OverSample)
 **/
{
  /**
  USAGE: SlitFunc(XCenters, SP, SF, NArgs, (*(new CString("Mask")), *(new CString(JBadVecArr)), ...), (<CFits*>P_Mask, <long>JBadVecArr, ...)
  **/

  /**
  Array Akl                      -> Array<double, 2> AKLArr
  Array bkl (size=[N,2*OverSample+1])-> Array<double, 2> BKLArr
  Vector bklind (size=osample+1) -> Array<int, 1> BKLIndVecArr
  Vector Bl                      -> Array<double, 1> BLVecArr
  double dev                     -> double Dev
  int    i                       -> int m
  int/Vector i1                  -> int IFirst/Array<double, 1> IFirstVecArr
  int/Vector i2                  -> int ILast/Array<double, 1> ILastVecArr
  Array  im                      -> Array<double, 2> D_A2_ImM
  Vector(use_col set)/Array imm  -> Array<double, 2> D_A2_ImM->(UseRowVecArr)
  Array  im_out                  -> Array<double, 2> *P_D_A2_Prof_Out
  Vector ind                     -> Array<double, 1> IndVecArr
  int    iter                    -> int  I_Iter_SF
  Vector/long   jbad             -> Array<int, 1> *P_I_A1_JBadVecArr / (*P_I_A1_JBadVecArr)(0)
  int    l                       -> int I_NPixSlitF
  double lamb_sf                 -> double Lamb_SF [: in]
  double lamb_sp                 -> double Lamb_SP [: in]
  double lambda                  -> double Lambda
  Array  mask, mmsk              -> Array<long, 2> P_Mask->PixArray: in
  Vector(use_col set)/Array msk  -> Array<double, 2> Mask(UseRowVecArr)
  int    n                       -> int I_NPixSlitF
  int    ncol                    -> ImM->cols, NColsOut -> OutArr->NCols
  int    nind                    -> int  NInd
  int    nrow                    -> ImM->rows
  Array/Vector  o                -> Array<double, 2> OArr
  Vector oo                      -> Array<double, 1> OOVecArr
  Vector oind                    -> Array<int, 1> OIndVecArr
  Vector olind  (size=osample+1) -> Array<int, 1> OLIndVecArr
  Vector omega                   -> Array<double, 1> OmegaVecArr
  long   osample                 -> int  OverSample [: in]
  int    oversample              -> int  OverSample [: in]
  Vector r                       -> Array<double, 1> RVecArr
  Vector sf                      -> Array<double, 2> D_A2_SF out
  Vector sp                      -> Array<double, 1> SPVecArr: out
  Vector sp_old                  -> Array<double, 1> SPOldVecArr
  Array  ssf                     -> Array<double, 2> SSFArr
  int    use_col                 -> Array<long, 1> UseRowVecArr: in
  double weight                  -> double Weight
  Vector y (size=n)              -> Array<double, 1> XVecArr
  Vector ycen                    -> Array<double, 1> XCenVecArr: in
  Vector yy (size=n)             -> Array<double, 1> XXVecArr
  int(use_col set)/Vector yycen  -> Array<double, 1> XCenVecArr(0) <- XCenter: in
  double yyy                     -> double XXX
  IDL:     array(Column, Row)
  BLITZ++: array(Row, Column) !!!!!!!!!!!!!!!!!!!
  reform(Array, NCols, NRows)  -> Array<double, 2>& Reform(Array<double, 1>, NRows, NCols) <NOTE: Dim1 <=> Dim2>
  replicate(Value, Dim)      -> Replicate(Value, Dim)
  Matrix#Matrix              -> MatrixBTimesA()
  Vector#Vector              -> VecArrACrossB()
  Matrix#Vector              -> VecArrTimesMatrix() <Result: rows == 1>
  Matrix##Matrix             -> MatrixATimesB()
  Vector##Vector             -> VecArrACrossB()
  Matrix##Vector             -> MatrixTimesVecArr() <Result: cols == 1>
  **/
  
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: D_A2_ImM = " << D_A2_ImM << endl;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << endl;
    cout << "CFits::SlitFunc: overSample_In = " << I_OverSample << endl;
    cout << "CFits::SlitFunc: readOutNoise_In = " << D_ReadOutNoise << endl;
    cout << "CFits::SlitFunc: maxIterSig_In = " << I_MaxIterSig << endl;
    cout << "CFits::SlitFunc: maxIterSF_In = " << I_MaxIterSF << endl;
    cout << "CFits::SlitFunc: I_MaxIterSky = " << I_MaxIterSky << endl;
    cout << "CFits::SlitFunc: D_A1_XCenters_In = " << D_A1_XCenters_In << endl;
  #endif

  CString CS_FileName_ImIn = CString(" ");

  Array<double, 1> *P_D_A1_SPErrOut = new Array<double, 1>(D_A2_ImM.rows());
  Array<double, 1> *P_D_A1_SPOut = new Array<double, 1>(D_A2_ImM.rows());
  CString CS_SP("SPVecArr1Final");

  D_A2_SF.resize(D_A2_ImM.rows(), D_A2_ImM.cols());
  D_A2_SF = 0.;
  int I_Bin = 0;
  #ifdef __DEBUG_FITS_SLITFUNC__
    CFits *p_testfitsP = new CFits();
    CS_FileName_ImIn.Set(DEBUGDIR);
    CS_FileName_ImIn.Add(CString("SlitFunc_In.fits"));
    p_testfitsP->SetFileName(CS_FileName_ImIn);
    p_testfitsP->SetNRows(D_A2_ImM.rows());
    p_testfitsP->SetNCols(D_A2_ImM.cols());
    p_testfitsP->GetPixArray() = D_A2_ImM;
    p_testfitsP->WriteArray();
    delete(p_testfitsP);
  #endif

  Array<double,2> D_A2_Im(D_A2_ImM.rows(), D_A2_ImM.cols());
  D_A2_Im = D_A2_ImM;

  //  (*P_OFS_Log) << "CFits::SlitFunc: 0. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

//  int NArgs = CS_A1_Args_In.size();

  CString *P_Delimiter = new CString("/");
  CString *P_Prefix = P_CS_FileName->SubString(0, P_CS_FileName->LastStrPos(*P_Delimiter));
  CString *P_TempString = new CString();
  //  int OverSample = 1;
  int I_NPixSlitF, TempInt, TempIntA, Pos;
//  int TempIntB;
  int IFirst, ILast, I_Iter_SF, NInd;
  int I_Iter_Sky = 0;
  int tempcol;// = OLIndVecArr(n) / OArr.rows();
  int temprow;// = OLIndVecArr(n) - tempcol * OArr.rows();
  int tempint = 0;
  int i_tmp_sum;
  long TempLong;
  int I_NRows_Im = D_A2_Im.rows();
  int I_NCols_Im = D_A2_Im.cols();
  double d_sump;

  Array<double, 1> D_A1_Range(2);
  Array<int, 1> *P_I_A1_JBadVecArr = new Array<int, 1>(1);
  (*P_I_A1_JBadVecArr) = 0;

  Array<double, 1> a(1);
  a = 0.;

  Array<double, 2> AKLArr(1,1);
  AKLArr = 0.;

  Array<double, 1> b(1);
  b = 0.;

  Array<double, 2> BKLArr(1,1);
  BKLArr = 0.;

  Array<int, 1> BKLIndVecArr(1);
  BKLIndVecArr = 0;

  Array<double, 1> BLVecArr(1);
  BLVecArr = 0.;

  Array<double, 1> c(1);
  c = 0.;

  Array<double, 1> D_A1_Ind(1);
  D_A1_Ind = 0.;

  Array<double, 2> D_A2_AKLT(1,1);
  D_A2_AKLT = 0.;

//  Array<double, 1> D_A1_AKL_Data(10);
//  D_A1_AKL_Data = 0.;
//  double *D_A1_AKL_Data;

  Array<int, 2> I_A2_Indarr_AKL;

  Array<double, 2> D_A2_OT(1,1);
  D_A2_OT = 0.;

  Array<double, 2> D_A2_SPVecTimesBKLArr(1, 1);
  D_A2_SPVecTimesBKLArr = 0.;

  Array<int, 1> IFirstVecArr(1);
  IFirstVecArr = 0;

  Array<int, 1> ILastVecArr(1);
  ILastVecArr = 0;

  //  (*P_OFS_Log) << "CFits::SlitFunc: 0A. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  Array<double, 2> *P_D_A2_Prof_Out = new Array<double, 2> (I_NRows_Im, I_NCols_Im);
  (*P_D_A2_Prof_Out) = 0.;

  Array<double, 2> *P_D_A2_Im_Out = new Array<double, 2> (I_NRows_Im, I_NCols_Im);
  (*P_D_A2_Im_Out) = 0.;

  Array<int, 1> IndVecArr(1);
  IndVecArr = 0;

//  Array<double, 2> Mask(1,1);
//  Mask = 0.;

  Array<double, 2> OArr(1,1);
  OArr = 0.;

  Array<int, 1> OIndVecArr(1);
  OIndVecArr = 0;

  Array<int, 1> OLIndVecArr(1);
  OLIndVecArr = 0;

  Array<double, 1> OOVecArr(1);
  OOVecArr = 0.;

  Array<double, 1> OmegaVecArr(1);
  OmegaVecArr = 0.;

  Array<double, 2> OmegaArr(1,1);
  OmegaArr = 0.;

  Array<double, 2> D_A2_TempAA(1, 1);
  D_A2_TempAA = 0.;

  Array<double, 1> D_A1_TempDVecArr(1);
  D_A1_TempDVecArr = 0.;

  Array<double, 1> D_A1_TempDVecArr_Err(1);
  D_A1_TempDVecArr_Err = 0.;

  Array<double, 1> D_A1_TempDVecArrAA(1);
  D_A1_TempDVecArrAA = 0.;

//  Array<double, 2> ProductArr(1,1);
//  ProductArr = 0.;

  Array<double, 1> RVecArr(1);
  RVecArr = 0.;

  Array<double, 1> RVecArr_Err(1);
  RVecArr_Err = 0.;

  Array<double, 1> SFVecArr(I_NCols_Im);
  Array<double, 1> SPOldVecArr(1);
  SPOldVecArr = 0.;
  //  Array<double, 1> SPVecArr(SP.copy());

//  Array<double, 2> D_A2_SFO(1,1);
  Array<double, 2> SSFArr(1,1);
  SSFArr = 0.;

  Array<double, 2> TempArray(1,1);
  TempArray = 0.;

  Array<double, 1> TempDVecArr(1);
  TempDVecArr = 0.;

//  Array<double, 1> TempDVecArrA(1);
//  TempDVecArrA = 0.;

  Array<double, 1> TempDVecArrB(1);
  TempDVecArrB = 0.;

  Array<double, 1> TempDVecArrC(1);
  TempDVecArrC = 0.;

  Array<double, 1> TempDVecArrD(1);
  TempDVecArrD = 0.;

  Array<double, 2> TempDArr(1,1);
  TempDArr = 0.;

  Array<int, 1> TempIVecArr(1);
  TempIVecArr = 0;

  Array<int, 2> *P_I_A2_Mask = new Array<int, 2>(1,1);
  Array<int, 2> *P_I_A2_MaskIn;// = new Array<double, 2>(1,1);
//  (*P_TempMask) = 0.;

  Array<int, 1> UseRowVecArr(1);
  UseRowVecArr = 0;

  Array<int, 1> IVecArr(1);
  IVecArr = 0;

  Array<double, 1> XVecArr(1);
  XVecArr = 0.;

  Array<double, 1> XCenVecArr(1);
  XCenVecArr = 0.;

  Array<double, 2> D_A2_XX(1,1);
  D_A2_XX = 0.;

  Array<double, 2> D_A2_Sky(this->NRows, this->NCols);
  D_A2_Sky = 0.;

  Array<double, 1> D_A1_MySF(1);
  Array<double, 1> D_A1_MySP(1);
  Array<double, 1> *P_D_A1_MySky = new Array<double,1>(1);
  Array<double, 2> D_A2_MySF(1,1);
  Array<double, 2> D_A2_MySP(1,1);
  Array<double, 2> D_A2_MySky(1,1);
  Array<double, 2> D_A2_ImTimesMask(I_NRows_Im,I_NCols_Im);
  Array<double, 2> D_A2_SFTimesMask(I_NRows_Im,I_NCols_Im);
  Array<double, 1> D_A1_OldSky(I_NRows_Im);
  Array<double, 2> *P_D_A2_Errors;
  Array<double, 1> *P_D_A1_ErrOut;
  Array<double, 1> *P_D_A1_ErrSky = new Array<double, 1>(1);
  Array<double, 1> *P_D_A1_SFO_Out = new Array<double, 1>(1);
  Array<double, 1> D_A1_ChiSquare_LinFit(1);
  Array<double, 1> D_A1_Probability_LinFit(1);
  Array<double, 2> D_A2_Sigma_LinFit(1,1);
  Array<double, 3> D_A3_CoVar_LinFit(1,1,1);

  Array<CString, 1> CS_A1_Args_LinFit(10);
  CS_A1_Args_LinFit = CString(" ");
  void **PP_Args_LinFit = (void**)malloc(sizeof(void*) * 10);

  Array<CString, 1> CS_A1_Args_Fit(10);
  CS_A1_Args_Fit = CString(" ");
  void **PP_Args_Fit = (void**)malloc(sizeof(void*) * 10);

  double Weight, Norm, Dev, tmpdbl, Lambda, XXX;
  double Lamb_SF = 1. / this->I_OverSample;
  double D_WingSmoothFactor = 0.;
  double Lamb_SP = 0.;
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "SlitFunc: Lamb_SF = " << Lamb_SF << endl;
    cout << "SlitFunc: Lamb_SP = " << Lamb_SP << endl;
    cout << "SlitFunc: D_WingSmoothFactor = " << D_WingSmoothFactor << endl;
//    return false;
  #endif    
  double D_SPVecPow = 0.;
  double D_XLow = D_A2_Im.rows() / 2.;

  CString CS_TempFileName(" ");

  ofstream *P_SF_Log;
  ofstream *P_SP_Log;

  int isp, isf, I_NInd;

  CString CS_DebugFilesSuffix("");
  Pos = this->KeyWord_Set(CS_A1_Args_In,CString("DEBUGFILES_SUFFIX"));
  if (Pos >= 0)
  {
    CS_DebugFilesSuffix = *(CString*)ArgV_In[Pos];
  }
  #ifdef __DEBUG_FITS_SLITFUNC_FILES__
    CS_FileName_ImIn.Set(CString("SlitFunc_ImIn"));
    CS_FileName_ImIn.Add(CS_DebugFilesSuffix);
    CS_FileName_ImIn.Add(CString(".fits"));
    this->WriteFits(&D_A2_Im, CS_FileName_ImIn);//, CString("ascii"));
  #endif
  #ifdef __DEBUG_SEDM__
    CString CS_FileName_XCentersIn = CString(DEBUGDIR);
    CS_FileName_XCentersIn.Add(CString("SlitFunc_XCentersIn.dat"));
    this->WriteArrayToFile(D_A1_XCenters_In, CS_FileName_XCentersIn, CString("ascii"));
  #endif

  Pos = this->KeyWord_Set(CS_A1_Args_In,CString("I_BIN"));
  if (Pos >= 0)
  {
    I_Bin = *(int*)ArgV_In[Pos];
    cout << "CFits::SlitFunc: I_Bin set to " << I_Bin << endl;
  }
//  cout << "CFits::SlitFunc: CS_A1_Args_In = " << CS_A1_Args_In << endl;

  Pos = this->KeyWord_Set(CS_A1_Args_In,CString("XLOW"));
  if (Pos >= 0)
  {
    D_XLow = *(double*)ArgV_In[Pos];
    cout << "CFits::SlitFunc: D_XLow set to " << D_XLow << endl;
  }
//  cout << "CFits::SlitFunc: CS_A1_Args_In = " << CS_A1_Args_In << endl;
//  return false;

  if (this->ErrorsRead)
  {
    Pos = this->KeyWord_Set(CS_A1_Args_In,CString("ERRORS"));
    if (Pos >= 0)
    {
      P_D_A2_Errors = (Array<double, 2>*)ArgV_In[Pos];
      #ifdef __DEBUG_SLITFUNC__
        cout << "CFits::SlitFunc: KeyWord_Set(ERRORS): *P_D_A2_Errors set to " << *P_D_A2_Errors << endl;
      #endif
    }
    Pos = this->KeyWord_Set(CS_A1_Args_In,CString("ERRORS_OUT"));
    if (Pos >= 0)
    {
      P_D_A1_ErrOut = (Array<double, 1>*)ArgV_In[Pos];
      P_D_A1_ErrOut->resize(D_A2_Im.rows());
      (*P_D_A1_ErrOut) = 0.;
    }
    Pos = this->KeyWord_Set(CS_A1_Args_In,CString("ERRORS_SP_OUT"));
    if (Pos >= 0)
    {
      delete(P_D_A1_SPErrOut);
      P_D_A1_SPErrOut = (Array<double, 1>*)ArgV_In[Pos];
      P_D_A1_SPErrOut->resize(D_A2_Im.rows());
      (*P_D_A1_SPErrOut) = 0.;
    }
  }/// end if (this->ErrorsRead)

  Pos = this->KeyWord_Set(CS_A1_Args_In,CString("SP_OUT"));
  if (Pos >= 0)
  {
    delete(P_D_A1_SPOut);
    P_D_A1_SPOut = (Array<double, 1>*)ArgV_In[Pos];
    P_D_A1_SPOut->resize(D_A2_Im.rows());
    (*P_D_A1_SPOut) = 0.;
  }

  Pos = this->KeyWord_Set(CS_A1_Args_In,CString("SFO_OUT"));
  if (Pos >= 0)
  {
    delete(P_D_A1_SFO_Out);
    P_D_A1_SFO_Out = (Array<double, 1>*)ArgV_In[Pos];
    P_D_A1_SFO_Out->resize(D_A2_Im.cols() * this->I_OverSample);
    (*P_D_A1_SFO_Out) = 0.;
  }

  Array<double, 1> SFVecArrTemp(1);
  SFVecArrTemp = 1.;
  Array<double, 1> *P_D_A1_XCorProfOut;
  int I_XCorProf = 0;
  int I_Pos = 0;
  CString CS_Temp;
  CS_Temp.Set("XCOR_PROF");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_XCorProf = *(int*)ArgV_In[I_Pos];
    P_D_A1_XCorProfOut = (Array<double, 1>*)ArgV_In[I_Pos+1];
    P_D_A1_XCorProfOut->resize(I_NRows_Im);
    (*P_D_A1_XCorProfOut) = 0.;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(XCOR_PROF): I_XCorProf set to " << I_XCorProf << endl;
    #ifdef __DEBUG_FITS_SLITFUNC__
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(XCOR_PROF): I_XCorProf set to " << I_XCorProf << endl;
    #endif
//    return false;
  }
  else{
    P_D_A1_XCorProfOut = new Array<double, 1>(I_NRows_Im);
  }

//  #ifdef __DEBUG_FITS_SLITFUNC__
  //  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_Im = " << D_A2_Im << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: D_A2_Im = " << D_A2_Im << endl;//.transpose(secondDim, firstDim) << endl;
  //  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A1_XCenters_In = " << D_A1_XCenters_In << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: D_A1_XCenters_In = " << D_A1_XCenters_In << endl;
//  #endif
  firstIndex i;
  secondIndex j;

  //  (*P_OFS_Log) << "CFits::SlitFunc: 1. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  XCenVecArr.resize(D_A1_XCenters_In.size());
  XCenVecArr = D_A1_XCenters_In;
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": XCenVecArr = " << XCenVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: XCenVecArr = " << XCenVecArr << endl;
  #endif
  if (this->I_OverSample < 1)
    this->I_OverSample = 1;
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": this->I_OverSample = " << this->I_OverSample << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: this->I_OverSample = " << this->I_OverSample << endl;
  #endif


  P_TempString->Set("MASK");
  if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)
  {
//    if (P_TempMask != NULL)
//      delete P_TempMask;
    P_I_A2_MaskIn = (Array<int, 2>*)ArgV_In[Pos];
    P_I_A2_Mask->resize(P_I_A2_MaskIn->rows(), P_I_A2_MaskIn->cols());
    (*P_I_A2_Mask) = (*P_I_A2_MaskIn);
    #ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(MASK): P_I_A2_Mask read = " << *P_I_A2_Mask << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(MASK): P_I_A2_Mask read = " << *P_I_A2_Mask << endl;
    #endif
    if (max(*P_I_A2_Mask) > 1){
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: max(Mask) > 1" << endl;
      return false;
    }
//    *P_I_A2_Mask = 1;
//#ifdef __DEBUG_FITS_SLITFUNC__
//    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(MASK): P_I_A2_Mask read = " << *P_I_A2_Mask << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(MASK): P_I_A2_Mask read = " << *P_I_A2_Mask << endl;
//#endif
//return false;
    if (P_I_A2_Mask->size() != 1)
    {
      if (P_I_A2_Mask->rows() != I_NRows_Im ||
          P_I_A2_Mask->cols() != I_NCols_Im)
      {
        cout << "SLIT_FUNC: Mask must have the same size as the image" << endl;
      //  (*P_OFS_Log) << "SLIT_FUNC: Mask must have the same size as the image" << endl;
        return false;
      }
//      Mask.resize(P_TempMask->rows(), P_TempMask->cols());
//      Mask = P_TempMask->copy();
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(MASK): (*P_I_A2_Mask) set to " << (*P_I_A2_Mask) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(MASK): (*P_I_A2_Mask) set to " << (*P_I_A2_Mask) << endl;
      #endif

    }/// end if (P_TempMask->size() != 1)
  }/// end if ((Pos = this->KeyWord_Set(CS_A1_Args_In, "MASK")) >= 0)
  ///else
  if (Pos < 0 || (Pos >= 0 && P_I_A2_Mask->size() == 1))
  {
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(MASK): D_A2_Im.rows = " << I_NRows_Im << ", D_A2_Im.cols = " << I_NCols_Im << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(MASK): D_A2_Im.rows = " << I_NRows_Im << ", D_A2_Im.rows = " << I_NCols_Im << endl;
    #endif
    if (I_NCols_Im < 0)
    {
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(MASK): D_A2_Im = " << D_A2_Im << endl;
//      #ifdef __DEBUG_FITS_SLITFUNC_N__
    //  (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(MASK): D_A2_Im = " << D_A2_Im << endl;
//      #endif
    }
    P_I_A2_MaskIn = new Array<int, 2>(I_NRows_Im, I_NCols_Im);
    (*P_I_A2_MaskIn) = 1;
    P_I_A2_Mask->resize(I_NRows_Im, I_NCols_Im);
    (*P_I_A2_Mask) = 1;
//    Mask.resize(I_NRows_Im, I_NCols_Im);
//    Mask = 1.;
    #ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(MASK): (*P_I_A2_Mask) set to " << (*P_I_A2_Mask) << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(MASK): (*P_I_A2_Mask) set to " << (*P_I_A2_Mask) << endl;
    #endif

  }/// end if (Pos < 0 || (Pos >= 0 && P_I_A2_Mask->size() == 1))
//  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": *P_I_A2_Mask = " << *P_I_A2_Mask << endl;

  P_TempString->Set("PROF_OUT");
  if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)
  {
    if (P_D_A2_Prof_Out != NULL)
      delete P_D_A2_Prof_Out;
    P_D_A2_Prof_Out = (Array<double, 2>*)ArgV_In[Pos];
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out read " << endl;// to " << *P_D_A2_Prof_Out << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out->size() = " << P_D_A2_Prof_Out->size() << endl;// to " << *P_D_A2_Prof_Out << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out->rows() = " << P_D_A2_Prof_Out->rows() << endl;// to " << *P_D_A2_Prof_Out << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out->cols() = " << P_D_A2_Prof_Out->cols() << endl;// to " << *P_D_A2_Prof_Out << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out read" << endl;// to " << *P_D_A2_Prof_Out << endl;
    #endif
//    P_D_A2_Prof_Out->resize(I_NRows_Im, I_NCols_Im);
//    (*P_D_A2_Prof_Out) = 0.;
//#ifdef __DEBUG_FITS_SLITFUNC__
//    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out initialized to size " << P_D_A2_Prof_Out->rows() << "x" << P_D_A2_Prof_Out->cols() << endl;// to " << *P_D_A2_Prof_Out << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out initialized to size " << P_D_A2_Prof_Out->rows() << "x" << P_D_A2_Prof_Out->cols() << endl;// to " << *P_D_A2_Prof_Out << endl;
//#endif
  }

  ///      im_out=fltarr(ncol,nrow)
  P_D_A2_Prof_Out->resize(I_NRows_Im, I_NCols_Im);
  (*P_D_A2_Prof_Out) = 0.;
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out resized to (" << I_NRows_Im << ", " << I_NCols_Im << ")" << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): P_D_A2_Prof_Out resized to (" << I_NRows_Im << ", " << I_NCols_Im << ")" << endl;
  #endif
//return false;
  double D_SFMax = 0.;
  Array<double,1> D_A1_SFMax(I_NRows_Im);
  Array<double,1> D_A1_Sky(I_NRows_Im);
  D_A1_Sky = 0.;
  int I_NGoodSF = 0;
  Array<double,2> D_A2_MySFBest(1,1);
  Array<double,1> *P_D_A1_SFMax;
  Array<int,1> I_A1_SFMaxInd(1);
  int I_NGood;
  Array<int,1> *P_I_A1_SFMaxInd;
  Array<double,2> D_A2_MySF_Max(1);
  Array<double,1> *P_D_A1_IndGen = this->Replicate(1., I_NRows_Im);
  Array<double,2> *P_D_A2_MySF;
  Array<double,1> D_A1_STDDEV(1);
  Array<double,1> D_A1_Covariance(1);
  Array<double, 2> D_A2_ImBak(D_A2_Im.rows(), D_A2_Im.cols());
  Array<double, 2> D_A2_ImBak_minus_Im(D_A2_Im.rows(), D_A2_Im.cols());
  int argpos=0;
  Array<double, 1> D_A1_Dev(D_A2_Im.cols());
  D_A1_Dev = 0.;
  double D_Dev = 0.;
  double D_Dev_New = 0.;
  Array<double, 2> D_A2_Mask(2,2);

  Array<int, 1> I_A1_Mask(1);
  I_A1_Mask = 0.;

  Array<double, 1> D_A1_Mask(1);
  D_A1_Mask = 0.;

  CString *P_CS_MySF;
  CString *P_CS_MySFTemp;

  int I_Iter_Sky_Max=5;

  int I_Telluric = 0;
  Pos = this->KeyWord_Set(CS_A1_Args_In,CString("TELLURIC"));
  if (Pos >= 0)
  {
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(TELLURIC): Pos = " << Pos << endl;
    #endif
    I_Telluric = *(int*)(ArgV_In[Pos]);
  }
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Telluric set to " << I_Telluric << endl;
  if (I_Telluric == 2)
  {
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "__TELLURIC_MINE__ set" << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: CS_A1_Args_In = " << CS_A1_Args_In << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: CS_A1_Args_In(0) = " << CS_A1_Args_In(0) << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: CS_A1_Args_In(1) = " << CS_A1_Args_In(1) << endl;
    #endif

    /// take pointer to sky from argument for calculations
    Pos = this->KeyWord_Set(CS_A1_Args_In,CString("SKY"));
    if (Pos >= 0)
    {
      delete(P_D_A1_MySky);
      P_D_A1_MySky = (Array<double,1>*)(ArgV_In[Pos]);
    }
    P_D_A1_MySky->resize(D_A2_Im.rows());
    (*P_D_A1_MySky) = 0.;

    if (this->ErrorsRead)
    {
      Pos = this->KeyWord_Set(CS_A1_Args_In,CString("ERR_SKY"));
      if (Pos >= 0)
      {
        delete(P_D_A1_ErrSky);
        P_D_A1_ErrSky = (Array<double,1>*)(ArgV_In[Pos]);
      }
      P_D_A1_ErrSky->resize(D_A2_Im.rows());
      (*P_D_A1_ErrSky) = 0.;
    }

    D_A2_MySF.resize(I_NRows_Im, I_NCols_Im);
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC = 2: D_A2_MySF.size() = " << D_A2_MySF << endl;
    #endif
    D_A2_MySF = D_A2_Im;
    #ifdef __DEBUG_FITS_TELLURIC__
      P_CS_MySF = new CString(DEBUGDIR);
      P_CS_MySF->Add(CString("D_A2_Im"));
      P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
      P_CS_MySF->Add(*P_CS_MySFTemp);
      P_CS_MySF->Add(CString(".fits"));
      this->WriteFits(&D_A2_Im, *P_CS_MySF);
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: File " << *P_CS_MySF << " written" << endl;
      delete(P_CS_MySF);
      delete(P_CS_MySFTemp);
    #endif
    for (int p=0; p<I_NRows_Im; p++)
    {
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: for(p(=" << p << "); p<D_A2_MySF.rows()=" << D_A2_MySF.rows() << "; p++): D_A2_Im(p,*) = " << D_A2_Im(p,Range::all()) << endl;
      #endif

      /// Set MySF to 0. where < 3.*(-RON)
///////////////////////////////////////////////////////////////////////////////////
      D_A2_MySF(p, Range::all()) = where(D_A2_MySF(p, Range::all()) < (3. * (0.-this->D_ReadOutNoise)), 0., D_A2_MySF(p, Range::all()));

      /// Normalize rows of D_A2_MySF to 1.
      if (sum(D_A2_MySF(p, Range::all())) < 0.00000000000000001)
        D_A2_MySF(p, Range::all()) = 1.;
      D_A2_MySF(p,Range::all()) /= sum(D_A2_MySF(p,Range::all()));
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: for(p(=" << p << ")...): D_A2_MySF(p,*) = " << D_A2_MySF(p,Range::all()) << endl;
      #endif

      /// Get maximum of D_A2_MySF for every row
      D_A1_SFMax(p) = max(D_A2_MySF(p,Range::all()));

      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: for(p(=" << p << ")...): D_A1_SFMax(p) = " << D_A1_SFMax(p) << endl;
      #endif
    }/// end for (int p=0; p<D_A2_MySF.rows(); p++)
//    return false;
    #ifdef __DEBUG_FITS_TELLURIC__
      P_CS_MySF = new CString(DEBUGDIR);
      P_CS_MySF->Add(CString("D_A2_MySF"));
      P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
      P_CS_MySF->Add(*P_CS_MySFTemp);
      P_CS_MySF->Add(CS_DebugFilesSuffix);
      P_CS_MySF->Add(CString(".fits"));
      this->WriteFits(&D_A2_MySF, *P_CS_MySF);
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: File " << *P_CS_MySF << " written" << endl;
      delete(P_CS_MySF);
      delete(P_CS_MySFTemp);
    #endif

    /// Median filter D_A1_SFMax
///      P_D_A1_SFMax = this->MedianVec(D_A1_SFMax,5);
///#ifdef __DEBUG_FITS_TELLURIC__
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(TELLURIC): P_D_A1_SFMax = " << *P_D_A1_SFMax << endl;
///#endif

    /// remove elements with dev > 3. * stddev from D_A1_SFMax
///    dev=sqrt(total(msk*(imm-sp#sf)^2)/total(msk))
///  j=where(abs(imm-sp#sf) gt 3.*dev,nj)
///  if(nj gt 0) then begin
///    msk(j)=0B
    double D_DevOld = 0.;
    double D_DevTemp = 0.;
    int nind_temp;
    Array<int,1> I_A1_IndA(1);
    Array<int,1> *P_I_A1_Ind;
    Array<double,2> D_A2_MySF_Max(I_NRows_Im, I_NCols_Im);
    Array<double,2> D_A2_MySF_MaxTemp(1, 1);
///      D_A1_SFMax.resize(P_D_A1_SFMax->size());
///      D_A1_SFMax = (*P_D_A1_SFMax);
    Array<double, 1> *P_D_A1_Col;
    for (int nn=0; nn < I_NCols_Im; nn++)
    {
      P_D_A1_Col = this->MedianVec(D_A2_MySF(Range::all(), nn), 5);
      D_A2_MySF_Max(Range::all(), nn) = *P_D_A1_Col;
      delete(P_D_A1_Col);
    }

    /// --- re-normalize D_A2_MySF_Max
    for (int nn=0; nn < I_NRows_Im; nn++)
    {
      double sum_sf = sum(D_A2_MySF_Max(nn, Range::all()));
      if (sum_sf >= 0.00000000000000001)
        D_A2_MySF_Max(nn, Range::all()) /= sum_sf;
    }
    #ifdef __DEBUG_FITS_TELLURIC__
      P_CS_MySF = new CString(DEBUGDIR);
      P_CS_MySF->Add(CString("D_A2_MySF_Median"));
      P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
      P_CS_MySF->Add(*P_CS_MySFTemp);
      P_CS_MySF->Add(CS_DebugFilesSuffix);
      P_CS_MySF->Add(CString(".fits"));
      this->WriteFits(&D_A2_MySF_Max, *P_CS_MySF);
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: File " << *P_CS_MySF << " written" << endl;
      delete(P_CS_MySF);
      delete(P_CS_MySFTemp);
    #endif


















    /// TODO: ONLY TAKE HIGHEST VALUES, NOT MIDDLE ONES?!? <- Already did median filtering!
    /// --- remove elements from D_A1_SFMax which are outside the median value +/- 2sigma
    do
    {
      D_DevOld = D_DevTemp;
      D_DevTemp = sqrt(sum(pow((D_A1_SFMax) - Median(D_A1_SFMax),2)) / D_A1_SFMax.size());
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: while: D_DevTemp set to " << D_DevTemp << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: while: Median(D_A1_SFMax) = " << Median(D_A1_SFMax) << endl;
      #endif
      I_A1_IndA.resize(D_A1_SFMax.size());


      /** ************************************/


      I_A1_IndA = where(abs(D_A1_SFMax - Median(D_A1_SFMax)) < 2. * D_DevTemp,1,0);


      /** ************************************/



      Array<int,1> *P_I_A1_Ind = this->GetIndex(I_A1_IndA, nind_temp);
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: while: I_A1_IndA set to " << I_A1_IndA << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: while: *P_I_A1_Ind set to " << *P_I_A1_Ind << endl;
      #endif
      P_D_A1_SFMax = new Array<double, 1>(D_A1_SFMax.size());
      *P_D_A1_SFMax = D_A1_SFMax;
      if (!this->GetSubArrCopy(*P_D_A1_SFMax, *P_I_A1_Ind, D_A1_SFMax)){
	cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: GetSubArrCopy(P_D_A1_SFMax, P_I_A1_Ind, D_A1_SFMax) returned FALSE" << endl;
        return false;
      }
      delete(P_D_A1_SFMax);
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: while: D_A1_SFMax set to " << D_A1_SFMax << endl;
      #endif
      D_A2_MySF_MaxTemp.resize(D_A2_MySF_Max.rows(), D_A2_MySF_Max.cols());
      D_A2_MySF_MaxTemp = D_A2_MySF_Max;
      D_A2_MySF_Max.resize(P_I_A1_Ind->size(), I_NCols_Im);
      for (int nnn=0; nnn<P_I_A1_Ind->size(); nnn++){
	if (((*P_I_A1_Ind)(nnn) < 0) || ((*P_I_A1_Ind)(nnn) >= D_A2_MySF_MaxTemp.rows())){
	  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: ((*P_I_A1_Ind)(nnn=" << nnn << ")(=" << (*P_I_A1_Ind)(nnn) << ") < 0) || ((*P_I_A1_Ind)(nnn) >= D_A2_MySF_MaxTemp.rows(=" << D_A2_MySF_MaxTemp.rows() << "))" << endl;
	  return false;
	}
        D_A2_MySF_Max(nnn,Range::all()) = D_A2_MySF_MaxTemp((*P_I_A1_Ind)(nnn), Range::all());
//        GetSubArrCopy(D_A2_MySF_MaxTemp, *P_I_A1_Ind, 0, D_A2_MySF_Max);
      }
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: while: D_A2_MySF_Max set to " << D_A2_MySF_Max << endl;
      #endif
      #ifdef __DEBUG_FITS_TELLURIC__
        P_CS_MySF = new CString(DEBUGDIR);
        P_CS_MySF->Add(CString("D_A2_MySF_Max"));
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Iter_Sky_Max);
        P_CS_MySF->Add(*P_CS_MySFTemp);
        P_CS_MySF->Add(CS_DebugFilesSuffix);
        P_CS_MySF->Add(CString(".fits"));
        this->WriteFits(&D_A2_MySF_Max, *P_CS_MySF);
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: File " << *P_CS_MySF << " written" << endl;
        delete(P_CS_MySF);
        delete(P_CS_MySFTemp);
        I_Iter_Sky_Max++;
      #endif
    } while (D_DevTemp - D_DevOld > D_DevTemp / 100.);

    /// Get maximum of all maxima
    D_SFMax = max(D_A1_SFMax);
//      delete(P_D_A1_SFMax);

    /// Get index positions of D_A1_SFMax where D_A1_SFMax > D_SFMax - 10%
    I_A1_SFMaxInd.resize(D_A1_SFMax.size());
    I_A1_SFMaxInd = where(D_A1_SFMax > D_SFMax - (D_SFMax/50.),1,0);
///      I_A1_SFMaxInd = where(D_A1_SFMax > D_SFMax - ((D_SFMax - min(D_A1_SFMax))/50.),1,0);
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_SFMax = " << D_SFMax << endl;
//      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(TELLURIC): I_A1_SFMaxInd = " << I_A1_SFMaxInd << endl;
    #endif
    P_I_A1_SFMaxInd = this->GetIndex(I_A1_SFMaxInd, I_NGood);

    /// Create SF array of the highest Slit Functions
    D_A2_MySF_MaxTemp.resize(D_A2_MySF_Max.rows(), I_NCols_Im);
    D_A2_MySF_MaxTemp = D_A2_MySF_Max;
    D_A2_MySF_Max.resize(P_I_A1_SFMaxInd->size(), I_NCols_Im);
    GetSubArrCopy(D_A2_MySF_MaxTemp,
                  *P_I_A1_SFMaxInd,
                  0,
                  D_A2_MySF_Max);
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: P_I_A1_SFMaxInd set to " << *P_I_A1_SFMaxInd << endl;
      P_CS_MySF = new CString(DEBUGDIR);
      P_CS_MySF->Add(CString("D_A2_MySF_Max_Max"));
      P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
      P_CS_MySF->Add(*P_CS_MySFTemp);
      P_CS_MySF->Add(CS_DebugFilesSuffix);
      P_CS_MySF->Add(CString(".fits"));
      this->WriteFits(&D_A2_MySF_Max, *P_CS_MySF);
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: File " << *P_CS_MySF << " written" << endl;
      delete(P_CS_MySF);
      delete(P_CS_MySFTemp);
    //cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(TELLURIC): D_A2_MySF(I_A1_SFMaxInd = " << *P_I_A1_SFMaxInd << ",*) = " << D_A2_MySF_Max << endl;
    #endif
    delete(P_I_A1_SFMaxInd);

    /// Take median        or sum???           of all rows of D_A2_MySF_Max to define initial SlitFunction
    /// TODO: Switch D_A1_MySF to D_A2_MySF consistently
    D_A1_MySF.resize(I_NCols_Im);
    for (int p=0; p < I_NCols_Im; p++)
    {














///      D_A1_MySF(p) = sum(D_A2_MySF_Max(Range::all(),p));
      D_A1_MySF(p) = this->Median(D_A2_MySF_Max(Range::all(),p));
























    }
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_A1_MySF set to " << D_A1_MySF << endl;
    #endif
    if (sum(D_A1_MySF) < 0.00000000000000001)
      D_A1_MySF = 1.;
    D_A1_MySF /= sum(D_A1_MySF);
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_A1_MySF set to " << D_A1_MySF << endl;
    #endif









///return false;
    P_D_A1_MySky->resize(I_NRows_Im);
    /// Get initial values for Spectrum and Sky
    P_D_A2_MySF = this->VecArrACrossB(*P_D_A1_IndGen,D_A1_MySF);
    D_A2_MySF.resize(P_D_A2_MySF->rows(), P_D_A2_MySF->cols());
    D_A2_MySF = *P_D_A2_MySF;
    delete(P_D_A2_MySF);
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_A2_MySF set to " << D_A2_MySF << endl;
      P_CS_MySF = new CString(DEBUGDIR);
      P_CS_MySF->Add(CString("D_A2_MySF_New"));
      P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
      P_CS_MySF->Add(*P_CS_MySFTemp);
      P_CS_MySF->Add(CS_DebugFilesSuffix);
      P_CS_MySF->Add(CString(".fits"));
      this->WriteFits(&D_A2_MySF, *P_CS_MySF);
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: File " << *P_CS_MySF << " written" << endl;
      delete(P_CS_MySF);
      delete(P_CS_MySFTemp);
    #endif






/// TODO: CHECK: are all D_A1_MySF.size() the same during one execution?
    SFVecArr.resize(D_A1_MySF.size());
    SFVecArr = D_A1_MySF;









      /**       bool LinFit(const Array<double, 2> &D_A2_CCD_In,
                          const Array<double, 2> &D_A2_SF_In,
                          Array<double,1> &D_A1_SPFit,
                          Array<double,1> &D_A1_Sky_Out,
                          const Array<CString, 1> &CS_A1_Args_In,   //: in
                          void *ArgV_In[]) const;    //: in/out
    ///            SDEV_IN = Array<double,2>(D_A2_CCD_In.rows, D_A2_CCD_In.cols)        : in
    ///            MEASURE_ERRORS = Array<double,2>(D_A2_CCD_In.rows, D_A2_CCD_In.cols) : in
    ///            CHISQ = Array<double,1>(D_A2_CCD_In.rows)                            : out
    ///            PROB = Array<double,1>(D_A2_CCD_In.rows)                             : out
    ///            SIGMA = Array<double,2>(D_A2_CCD_In.rows, 2)                         : out
    ///            COVAR = Array<double,3>(D_A2_CCD_In.rows, 2, 2)                      : out
    ///            YFIT = Array<double,2>(D_A2_CCD_In.rows, D_A2_CCD_In.cols)           : out
    **/
    argpos = 0;
    if (this->ErrorsRead)
    {
//          CS_A1_Args_LinFit(argpos) = CString("MEASURE_ERRORS");
//          PP_Args_LinFit[argpos] = P_D_A2_Errors;
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": MEASURE_ERRORS_IN set to " << *P_D_A2_Errors << endl;
      #endif
      CS_A1_Args_Fit(argpos) = CString("MEASURE_ERRORS_IN");
      PP_Args_Fit[argpos] = P_D_A2_Errors;
      argpos++;
    }

//        CS_A1_Args_LinFit(argpos) = CString("CHISQ");
//        PP_Args_LinFit[argpos] = &D_A1_ChiSquare_LinFit;
    CS_A1_Args_Fit(argpos) = CString("CHISQ_OUT");
    PP_Args_Fit[argpos] = &D_A1_ChiSquare_LinFit;
    argpos++;

//        CS_A1_Args_LinFit(argpos) = CString("SIGMA");
//        PP_Args_LinFit[argpos] = &D_A2_Sigma_LinFit;
    CS_A1_Args_Fit(argpos) = CString("SIGMA_OUT");
    PP_Args_Fit[argpos] = &D_A2_Sigma_LinFit;
    argpos++;

//        CS_A1_Args_LinFit(argpos) = CString("COVAR");
//        PP_Args_LinFit[argpos] = &D_A3_CoVar_LinFit;
    CS_A1_Args_Fit(argpos) = CString("Q_OUT");
    PP_Args_Fit[argpos] = &D_A1_Probability_LinFit;
    argpos++;

//        CS_A1_Args_LinFit(argpos) = CString("PROB");
//        PP_Args_LinFit[argpos] = &D_A1_Probability_LinFit;
//        argpos++;










///      if (!this->LinearRegression(D_A2_Im, D_A2_MySF, D_A1_MySP, D_A1_Sky, D_A1_STDDEV, D_A1_Covariance)){
///      if (!this->LinFit(D_A2_Im, D_A2_MySF, D_A1_MySP, D_A1_Sky, CS_A1_Args_LinFit, PP_Args_LinFit))
///      {
///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: LinFit returned FALSE!" << endl;
///        return false;
///      }
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": LinFit returned TRUE" << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A1_MySP = " << D_A1_MySP << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A1_Sky = " << D_A1_Sky << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A1_ChiSquare_LinFit = " << D_A1_ChiSquare_LinFit << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A1_Probability_LinFit = " << D_A1_Probability_LinFit << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A2_Sigma_LinFit = " << D_A2_Sigma_LinFit << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A3_CoVar_LinFit = " << D_A3_CoVar_LinFit << endl;

    D_A2_ImBak = D_A2_Im;
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_A2_Im = " << D_A2_Im << endl;
    #endif

    D_A1_Sky = 1.;
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_A2_Im = " << D_A2_Im << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: (*P_I_A2_Mask) = " << (*P_I_A2_Mask) << endl;
    #endif
    D_A2_ImTimesMask = D_A2_Im * (*P_I_A2_Mask);
    D_A2_SFTimesMask = D_A2_MySF * (*P_I_A2_Mask);
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_A2_ImTimesMask = " << D_A2_ImTimesMask << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_A2_SFTimesMask = " << D_A2_SFTimesMask << endl;
    #endif
//      return false;
    if (!this->LinFitBevington(D_A2_ImTimesMask,
                               D_A2_SFTimesMask,
                               D_A1_MySP,
                               D_A1_Sky,
                               CS_A1_Args_Fit,
                               PP_Args_Fit))
    {
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: ERROR: Fit returned FALSE!" << endl;
      return false;
    }
    D_A1_OldSky = D_A1_Sky;
//      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Fit returned TRUE" << endl;
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: after Fit: D_A1_MySP = " << D_A1_MySP << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: after Fit: D_A1_Sky = " << D_A1_Sky << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: after Fit: D_A1_ChiSquare_LinFit = " << D_A1_ChiSquare_LinFit << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: after Fit: D_A1_Probability_LinFit = " << D_A1_Probability_LinFit << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: after Fit: D_A2_Sigma_LinFit = " << D_A2_Sigma_LinFit << endl;
    #endif

//      return false;

///      this->LinearRegression(D_A2_Im, D_A2_MySF, D_A1_MySP, D_A1_Sky, D_A1_STDDEV, D_A1_Covariance);
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinearRegression: D_A1_MySP = " << D_A1_MySP << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinearRegression: D_A1_Sky = " << D_A1_Sky << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinearRegression: D_A1_STDDEV = " << D_A1_STDDEV << endl;
///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinearRegression: D_A1_Covariance = " << D_A1_Covariance << endl;
///      return false;



    SPVecArr.resize(D_A1_MySP.size());
    SPVecArr = D_A1_MySP;


//        D_A1_Sky = where(D_A1_Sky < 0., 0., D_A1_Sky);
//        D_A1_MySP = where(D_A1_MySP < 0., 0., D_A1_MySP);

    /// Save initial sky to P_D_A1_MySky
    (*P_D_A1_MySky) = D_A1_Sky;
    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: D_A1_MySP set to " << D_A1_MySP << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: *P_D_A1_MySky set to " << *P_D_A1_MySky << endl;
      CString CS_TempA(DEBUGDIR);
      CS_TempA.Add(CString("D_A2_Im"));
      CS_TempA.Add(CS_DebugFilesSuffix);
      CS_TempA.Add(CString(".fits"));
      this->WriteFits(&D_A2_Im, CS_TempA);
    #endif
    for (int p=0; p < P_D_A1_MySky->size(); p++)
    {
      /// subtract sky from D_A2_Im
      D_A2_Im(p,Range::all()) -= D_A1_Sky(p);
      D_A2_Im(p,Range::all()) = where(D_A2_Im(p,Range::all()) < 0. - (3. * D_ReadOutNoise), 0., D_A2_Im(p,Range::all()));

      /// Add sky errors to error image
      (*P_D_A2_Errors)(p, Range::all()) += D_A2_Sigma_LinFit(p,1);
    }
    #ifdef __DEBUG_FITS_TELLURIC__
      P_CS_MySF = new CString("D_A2_Im_Minus_Sky_Bin");
      P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
      P_CS_MySF->Add(*P_CS_MySFTemp);
      P_CS_MySF->Add(CS_DebugFilesSuffix);
      P_CS_MySF->Add(CString(".fits"));
      this->WriteFits(&D_A2_Im, *P_CS_MySF);
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TELLURIC == 2: File " << *P_CS_MySF << " written" << endl;
      delete(P_CS_MySF);
      delete(P_CS_MySFTemp);
  //      this->WriteFits(&D_A2_Im, CString(DEBUGDIR)+CString("D_A2_Im-sky.fits"));
    #endif

  //  D_A1_MySF.resize(SFVecArr.size());
  //  D_A1_MySF = SFVecArr;
  }///end if (I_Telluric == 2)

  int Pos_Stop = this->KeyWord_Set(CS_A1_Args_In,CString("STOP"));
  int I_Stop = 0;
  if (Pos_Stop >= 0)
  {
    I_Stop = *(int*)(ArgV_In[Pos_Stop]);
  }


//  if (I_IAperture_In == 1 && I_Stop > 0)
//    return false;


  for (int p=0; p < D_A2_Im.rows(); p++)
  {
    D_A2_Im(p,Range::all()) = where(D_A2_Im(p,Range::all()) < (0.-(3.*this->D_ReadOutNoise)), 0., D_A2_Im(p,Range::all()));
  }






///  if(not keyword_set(mask)) then begin
///    mmsk=byte(im*0)+1B
///  endif else begin
///    if((size(mask))(0) ne (size(im))(0) or $
///       (size(mask))(1) ne (size(im))(1) or $
///       (size(mask))(2) ne (size(im))(2)) then begin
///      print,'SLIT_FUNC: Mask must have the same size as the image'
///      stop
///    endif
///    mmsk=mask
///  endelse
  //  (*P_OFS_Log) << "CFits::SlitFunc: 1.A this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;
///  weight=1./float(osample)
  Weight = 1. / (double)this->I_OverSample;

  /// Set OIndVecArr to Array<int,1>(I_OverSample + 1) with values = index * (I_OverSample + 2)
///  oind=lindgen(osample+1L)*(osample+2L)
  UseRowVecArr = i;//Range(0, I_NCols_Im-1);
  OIndVecArr.resize(this->I_OverSample + 1);
  OIndVecArr = i;//this->LIndGen(this->I_OverSample + 1);
  OIndVecArr *= (this->I_OverSample + 2);
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Weight = " << Weight << endl;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": UseRowVecArr = " << UseRowVecArr << endl;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": OIndVecArr = " << OIndVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: Weight = " << Weight << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: UseRowVecArr = " << UseRowVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: OIndVecArr = " << OIndVecArr << endl;
  #endif

///  if(not keyword_set(lamb_sf)) then lamb_sf=0.1
  P_TempString->Set("LAMBDA_SF");
  Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString);
  if (Pos >= 0)
  {
    Lamb_SF = *(double*)ArgV_In[Pos];
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(LAMBDA_SF): Lamb_SF set to " << Lamb_SF << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SF): Lamb_SF set to " << Lamb_SF << endl;
    #endif
  }
  if ((Pos < 0) || ((Pos >= 0) && (Lamb_SF < 0.01)))
  {
    Lamb_SF = 0.1;
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(LAMBDA_SF): Lamb_SF = " << Lamb_SF << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(LAMBDA_SF): Lamb_SF = " << Lamb_SF << endl;
    #endif
  }

  /// Set N to (number of columns in Im_In * Oversample) + OverSample + 1 (number of sub columns)
  I_NPixSlitF = ((I_NCols_Im + 1) * this->I_OverSample) + 1;
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_NPixSlitF set to " << I_NPixSlitF << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: N set to " << N << endl;
  #endif

  /// Get Bad-pixel mask
  P_TempString->Set("BAD");
  if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)
  {
    if (P_I_A1_JBadVecArr != NULL)
      delete P_I_A1_JBadVecArr;
    P_I_A1_JBadVecArr = (Array<int, 1>*)ArgV_In[Pos];
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(BAD): P_I_A1_JBadVecArr set to " << *P_I_A1_JBadVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(BAD): P_I_A1_JBadVecArr set to " << *P_I_A1_JBadVecArr << endl;
    #endif
  }/// end if ((Pos = this->KeyWord_Set(CS_A1_Args_In, "BAD")) >= 0)
  //  (*P_OFS_Log) << "CFits::SlitFunc: 1.B this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  /**
  for reject=1,1 do begin
    if(keyword_set(use_col)) then begin
      imm=im(use_col,*)
      yycen=ycen(use_col)
      msk=mmsk(use_col,*)
  */
  //  while(true)
  //  {
  P_TempString->Set("USE_ROWS");
  if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)
  {
    Array<int, 1> *P_I_A1_UseRows = (Array<int, 1>*)ArgV_In[Pos];
    UseRowVecArr.resize(P_I_A1_UseRows->size());
    UseRowVecArr = *P_I_A1_UseRows;
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(USE_ROW): ArgV_In[Pos=" << Pos << "]=" << *(int*)(ArgV_In[Pos]) << " => UseRowVecArr set to " << UseRowVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(USE_ROW): ArgV_In[Pos=" << Pos << "]=" << *(int*)(ArgV_In[Pos]) << " => UseRowVecArr set to " << UseRowVecArr << endl;
    #endif
    Array<double, 2> D_A2_ImUseRows(UseRowVecArr.size(), D_A2_Im.cols());
    if (!this->GetSubArrCopy(D_A2_Im, UseRowVecArr, 0, D_A2_ImUseRows)){
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": this->GetSubArrCopy(D_A2_Im, UseRowVecArr) returned FALSE" << endl;
      return false;
    }
    D_A2_Im.resize(D_A2_ImUseRows.rows(), D_A2_ImUseRows.cols());
    D_A2_Im = D_A2_ImUseRows;
    I_NRows_Im = D_A2_Im.rows();
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_Im = " << D_A2_Im << endl;//.transpose(secondDim, firstDim) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: D_A2_Im = " << D_A2_Im << endl;//.transpose(secondDim, firstDim) << endl;
    #endif

    Array<double, 1> D_A1_XCentersUseRow(UseRowVecArr.size());
    if (!this->GetSubArrCopy(XCenVecArr, UseRowVecArr, D_A1_XCentersUseRow)){
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": this->GetSubArrCopy(XCenVecArr, UseRowVecArr) returned FALSE" << endl;
      return false;
    }
    XCenVecArr.resize(UseRowVecArr.size());
    XCenVecArr = D_A1_XCentersUseRow;
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": XCenVecArr = " << XCenVecArr << endl;
    #endif

    Array<int, 2> I_A2_MaskUseRow(UseRowVecArr.size(), P_I_A2_Mask->cols());
    if (!this->GetSubArrCopy(*P_I_A2_Mask, UseRowVecArr, 0, I_A2_MaskUseRow)){
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": this->GetSubArrCopy(*P_I_A2_Mask, UseRowVecArr) returned FALSE" << endl;
      return false;
    }
    P_I_A2_Mask->resize(UseRowVecArr.size(), P_I_A2_Mask->cols());
    (*P_I_A2_Mask) = I_A2_MaskUseRow;
    #ifdef __DEBUG_FITS_SLITFUNC_A__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": (*P_I_A2_Mask) = " << (*P_I_A2_Mask) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: (*P_I_A2_Mask) = " << (*P_I_A2_Mask) << endl;
    #endif
  }/// end if ((Pos = this->KeyWord_Set(CS_A1_Args_In, "USE_ROW")) >= 0)
  /**
      endif else begin
        use_col=indgen(n_elements(im(*,0)))
        imm=im
        yycen=ycen
        msk=mmsk
      endelse
  */
  if (Pos < 0)// || (Pos >= 0 && TempIntB == 0))
  {
    UseRowVecArr.resize(I_NRows_Im);
    UseRowVecArr = i;
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(USE_ROW): UseRowVecArr set to " << UseRowVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(USE_ROW): UseRowVecArr set to " << UseRowVecArr << endl;
    #endif
  }

  //    (*P_OFS_Log) << "CFits::SlitFunc: 2. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;
  /**
      sz=size(imm)
      ncol=sz(1)
      nrow=sz(2)
      n=(nrow+1L)*osample+1L
  */
  if (sum((*P_I_A2_Mask)) < 1)
  {
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: sum((*P_I_A2_Mask)=" << (*P_I_A2_Mask) << ") == 0" << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: ERROR: sum((*P_I_A2_Mask)=" << (*P_I_A2_Mask) << ") == 0" << endl;
    return false;
  }

  /** Set Norm to number of pixels in Im_In devided by sum((*P_I_A2_Mask)) **/
  /// norm=n_elements(msk)/total(long(msk))
  Norm = (I_NRows_Im * I_NCols_Im) / sum((*P_I_A2_Mask));
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Norm set to " << Norm << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: Norm set to " << Norm << endl;
  #endif

  Array<double, 2> D_A2_SPTemp(SPVecArr.size(), 1);

  Array<double, 2> D_A2_ImMedian(D_A2_Im.rows(), D_A2_Im.cols());
  D_A2_ImMedian = D_A2_Im;
  
  blitz::Array<double, 1> D_A1_XProf(1);
  blitz::Array<double, 1> D_A1_YProf(1);

  if (I_Telluric != 2)
  {
    #ifdef __PISKUNOV_ORIG__
/**      sf=total(imm*msk,1)
      if(osample gt 2 and n_elements(sf) gt 5) then sf=median(sf,5)              ; the spectrum
      if(mean(total(imm,2)) lt 1.d3) then $              ; robust guess for sf
        sf=exp(-((dindgen(nrow)-nrow/2.)/(nrow/4.))^2)   ; in case of low S/N
      sf=sf/total(sf)                                    ; slit function
      sp=total((imm*msk)*(replicate(1.,ncol)#sf),2)*norm ; Initial guess for
      if(osample gt 2) then sp=median(sp,5)              ; the spectrum
      sp=sp/total(sp)*total(imm*msk)
**/
      SFVecArr.resize(D_A2_Im.cols());
      SPVecArr.resize(D_A2_Im.rows());
      Array<double, 2> D_A2_ImTimesMask_Guess(D_A2_Im.rows(), D_A2_Im.cols());
      D_A2_ImTimesMask_Guess = (D_A2_Im * (*P_I_A2_Mask));
      SFVecArr = sum(D_A2_ImTimesMask_Guess(j,i),j);
      #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
        cout << "CFits::SlitFunc: PiskunovOrig: 1. SFVecArr set to " << SFVecArr << endl;
      #endif
      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        CString CS_SFOut("PiskunovOrig_SFVecArr1");
        CS_SFOut.Add(CS_DebugFilesSuffix);
        CS_SFOut.Add(".fits");
        this->WriteFits(&SFVecArr, CS_SFOut);
      #endif
      Array<double, 1> *P_D_A1_SF;
      if ((I_OverSample > 2) && (SFVecArr.size() > 5)){
//	Array<int, 1> I_A1_GoodRows(D_A2_Im.rows());
//	I_A1_GoodRows = 1;
//	for (int i_row=0; i_row<D_A2_Im.rows(); i_row++){
//	  if (sum((*P_I_A2_Mask)(i_row, Range::all())) < 1)
//	    I_A1_GoodRows(i_row) = 0;
//	}
//	Array<double, 2> D_A2_SFTempMedian(sum(I_A1_GoodRows, D_A2_Im.cols()));
//	int I_Row = 0;
//	for (int i_row = 0; i_row < D_A2_Im.rows(); i_row++){
//	  if (I_A1_GoodRows(i_row) > 0){
//	    D_A2_SFTempMedian(I_Row, Range::all()) = D_A2_
//	  }
//	}
	P_D_A1_SF = this->MedianVec(SFVecArr, 5);
	SFVecArr = *P_D_A1_SF;
	delete(P_D_A1_SF);
      }
      if (mean(sum(D_A2_Im(i,j),j)) < 1000.){
	Array<double, 1> *P_D_A1_IndGenCols = this->DIndGenArr(D_A2_Im.cols());
	SFVecArr = exp(0. - pow2(((*P_D_A1_IndGenCols) + D_XLow) / (D_A2_Im.cols() / 4.)));
	delete(P_D_A1_IndGenCols);
      }
      SFVecArr = SFVecArr / sum(SFVecArr);
      #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
        CS_SFOut.Set("PiskunovOrig_SFVecArr_DivBySum");
        CS_SFOut.Add(CS_DebugFilesSuffix);
        CS_SFOut.Add(".fits");
        this->WriteFits(&SFVecArr, CS_SFOut);
        cout << "CFits::SlitFunc: PiskunovOrig: D_XLow = " << D_XLow << endl;
        cout << "CFits::SlitFunc: PiskunovOrig: 2. SFVecArr set to " << SFVecArr << endl;
        return false;
      #endif
      Array<double, 1> *P_D_A1_Rep = this->Replicate(1., D_A2_Im.rows());
      Array<double, 2> *P_D_A2_Mat = this->VecArrACrossB((*P_D_A1_Rep), SFVecArr);
      D_A2_ImTimesMask_Guess = D_A2_ImTimesMask_Guess * (*P_D_A2_Mat);
      SPVecArr = sum(D_A2_ImTimesMask_Guess(i,j),j) * P_I_A2_Mask->rows() * P_I_A2_Mask->cols() / sum(*P_I_A2_Mask);
      delete(P_D_A1_Rep);
      delete(P_D_A2_Mat);
      if (I_OverSample > 2){
	P_D_A1_SF = this->MedianVec(SPVecArr, 5);
        SPVecArr = *P_D_A1_SF;
	delete(P_D_A1_SF);
      }
      #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
        cout << "CFits::SlitFunc: PiskunovOrig: 1. SPVecArr set to " << SPVecArr << endl;
      #endif
      SPVecArr = (SPVecArr / sum(SPVecArr)) * sum(D_A2_Im * (*P_I_A2_Mask));
      #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
        cout << "CFits::SlitFunc: PiskunovOrig: 2. SPVecArr set to " << SPVecArr << endl;
      #endif
/**
    dev=sqrt(total(msk*(imm-sp#sf)^2)/total(msk))
    j=where(abs(imm-sp#sf) gt 3.*dev,nj)
    if(nj gt 0) then begin
      msk(j)=0B
    endif
**/
      P_D_A2_Mat = this->VecArrACrossB(SPVecArr, SFVecArr);
      #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
        cout << "CFits::SlitFunc: PiskunovOrig: (*P_D_A2_Mat) set to " << *P_D_A2_Mat << endl;
      #endif
      D_Dev = sqrt(sum((*P_I_A2_Mask) * pow2(D_A2_Im - (*P_D_A2_Mat))) / double(sum(*P_I_A2_Mask)));
      #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
        cout << "CFits::SlitFunc: PiskunovOrig: D_Dev set to " << D_Dev << endl;
      #endif
      int I_NBad = 0;
      Array<int, 1> I_A1_WhereDev(D_A2_Im.cols());
      Array<double, 1> D_A1_WhereDev(D_A2_Im.cols());
      Array<int, 1> *P_I_A1_WhereDev;
      I_A1_WhereDev = 0;
      for (int i_row = 0; i_row < D_A2_Im.rows(); i_row++){
	D_A1_WhereDev = fabs(D_A2_Im(i_row, Range::all()) - (*P_D_A2_Mat)(i_row, Range::all()));
        #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
          cout << "CFits::SlitFunc: PiskunovOrig: i_row = " << i_row << ": D_A1_WhereDev = " << D_A1_WhereDev  << endl;
        #endif
        I_A1_WhereDev = where(D_A1_WhereDev > 3. * D_Dev, 1, 0);
        P_I_A1_WhereDev = this->GetIndex(I_A1_WhereDev, I_NBad);
	if (I_NBad > 0){
  	  for (int i_ind = 0; i_ind < I_NBad; i_ind++){
            #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
	      cout << "CFits::SlitFunc: PiskunovOrig: i_row = " << i_row << ": i_ind = " << i_ind << ": (*P_I_A1_WhereDev)(i_ind) = " << (*P_I_A1_WhereDev)(i_ind)  << endl;
            #endif
	    (*P_I_A2_Mask)(i_row, (*P_I_A1_WhereDev)(i_ind)) = 0;
	  }
	}
	delete(P_I_A1_WhereDev);
      }
      #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
        cout << "CFits::SlitFunc: PiskunovOrig: (*P_I_A2_Mask) set to " << *P_I_A2_Mask << endl;
      #endif
      D_A2_ImTimesMask_Guess = D_A2_Im * (*P_I_A2_Mask);
      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        CString CS_ImTimesMask("PiskunovOrig_ImMTimesMask");
        CS_ImTimesMask.Add(CS_DebugFilesSuffix);
        CS_ImTimesMask.Add(".fits");
        this->WriteFits(&D_A2_ImTimesMask_Guess, CS_ImTimesMask);
      #endif
//      return false;

      #ifdef __DEBUG_FITS_SLITFUNC_PISKUNOV__
        CS_SP.Set(CString("SPVecArr1"));
        CS_SP.Add(CS_DebugFilesSuffix);
        CS_SP.Add(CString(".fits"));
        D_A2_SPTemp.resize(SPVecArr.size(), 1);
        D_A2_SPTemp(Range::all(), 0) = SPVecArr;
        this->WriteFits(&D_A2_SPTemp, CS_SP);
      #endif
    #else
      ///      sf=total(imm*msk,1)
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_Im = " << D_A2_Im << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": *P_I_A2_Mask = " << *P_I_A2_Mask << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: Norm set to " << Norm << endl;
      #endif
      if (this->I_MaxIterSig > 0){
        for (int p = 0; p < I_NCols_Im; p++)
        {
          Array<double, 1> *p_d1temp = MedianVec(D_A2_Im(Range::all(),p), 5, CString("NORMAL"));
          D_A2_ImMedian(Range::all(), p) = (*p_d1temp);             /// Spectrum
          delete p_d1temp;
        }
      }
      D_A2_ImTimesMask = D_A2_ImMedian * (*P_I_A2_Mask);
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_ImTimesMask = " << D_A2_ImTimesMask << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: D_A2_ImTimesMask = " << D_A2_ImTimesMask << endl;
      #endif



      /// MINE:
      for (int p = 0; p < I_NRows_Im; p++)
      {
        d_sump = sum(D_A2_ImTimesMask(p, Range::all()));
        if (d_sump > 0.)
          D_A2_ImTimesMask(p, Range::all()) /= d_sump;
        else
          D_A2_ImTimesMask(p, Range::all()) = 0.;
      }








      SFVecArr.resize(I_NCols_Im);
//    for (int ss=0; ss < D_A2_ImTimesMask.cols(); ss++){
//      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_ImTimesMask(*, ss=" << ss << ") = " << D_A2_ImTimesMask(Range::all(), ss) << endl;
//      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_ImTimesMask(*, ss=" << ss << ") = " << D_A2_ImTimesMask(Range::all(), ss) << endl;
//    }
      SFVecArr = sum(D_A2_ImTimesMask(j, i), j); /** Initial guess for the **/
//    #ifdef __DEBUG_FITS_SLITFUNC_N__
  //  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 1.   SFVecArr.resize(D_A2_ImTimesMask.cols() = D_A2_Im * (*P_I_A2_Mask));" << endl;
  //  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ":      SFVecArr = sum(D_A2_ImTimesMask(j, i), j); /** Initial guess for the Spectrum **/" << endl;
//    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ":      SFVecArr = " << SFVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: 1.   SFVecArr.resize(D_A2_ImTimesMask.cols() = D_A2_Im * (*P_I_A2_Mask));" << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc:      SFVecArr = sum(D_A2_ImTimesMask(j, i), j); /** Initial guess for the Spectrum **/" << endl;
//        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ":      SFVecArr = " << SFVecArr << endl;
//      return false;
  //  (*P_OFS_Log) << "CFits::SlitFunc:      SFVecArr = " << SFVecArr << endl;
//    #endif

/// --- instead of Piskunov:
    ///      sf=median(sf,5)                                    ; the spectrum
///    Array<double, 1> *p_d1temp = MedianVec(SFVecArr, 5, CString("NORMAL"));
///    SFVecArr = (*p_d1temp);             /** Spectrum **/
///    delete p_d1temp;
//    #ifdef __DEBUG_FITS_SLITFUNC_N__
//      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 2.    MedianVec(SFVecArr) = " << SFVecArr << endl;
    ///  (*P_OFS_Log) << "CFits::SlitFunc: 2.     MedianVec(SFVecArr) = " << SFVecArr << endl;
    ///  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(SFVecArr) = " << sum(SFVecArr) << endl;
    ///  (*P_OFS_Log) << "CFits::SlitFunc: sum(SFVecArr) = " << sum(SFVecArr) << endl;
//    #endif
      if (abs(sum(SFVecArr)) < 0.000000001)
      {
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": WARNING: sum(SFVecArr) == 0 => Setting to 1." << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: WARNING: sum(SFVecArr) == 0 => Setting to 1." << endl;
        #endif
        SFVecArr = 1.;
      //return false;
      }

//return false;



































    ///      sf=sf/total(sf)                                    ; slit function
      if (sum(SFVecArr) < 0.00000000000000001)
        SFVecArr = 1.;
      SFVecArr /= sum(SFVecArr);           /** Slit Function **/
    #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 3.    Slit Function SFVecArr = SFVecArr / (sum(SFVecArr) = " << sum(SFVecArr) << ") = " << SFVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: 3.    Slit Function SFVecArr = SFVecArr / (sum(SFVecArr) = " << sum(SFVecArr) << ") = " << SFVecArr << endl;
    #endif

//return false;
    /** Initial guess for the spectrum **/
    /** Im_In * (*P_I_A2_Mask) **/

  ///  sp=total((imm*msk)*(replicate(1.,ncol)#sf),2)*norm ; Initial guess for
      TempArray.resize(I_NRows_Im, I_NCols_Im);
      TempArray = D_A2_Im;
      TempArray *= (*P_I_A2_Mask);
      #ifdef __DEBUG_FITS_SLITFUNC_A__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": (*P_I_A2_Mask) = " << (*P_I_A2_Mask) << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TempArray = ImM*(*P_I_A2_Mask) = " << TempArray << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: TempArray = ImM*(*P_I_A2_Mask) = " << TempArray << endl;
      #endif

    /** weight rows of im_in with slit function, sum to estimate the spectrum, multiply with Norm, take median over 5 pixels, normalize to sum(row)=1, and multiply with sum of im_in **/
      Array<double, 1> *p_d1rep = this->Replicate(1., I_NRows_Im);
      Array<double, 2> *p_d2mat = this->VecArrACrossB(*p_d1rep, SFVecArr);
      TempArray *= (*p_d2mat);
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TempArray = TempArray*(VecArrACrossB(Replicate(1.,D_A2_Im.rows(=" << I_NRows_Im << "))=" << *p_d1rep << ", SFVecArr(=" << SFVecArr << "))=" << *p_d2mat << ") = " << TempArray << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: TempArray = TempArray*(VecArrACrossB(Replicate(1.,D_A2_Im.rows(=" << I_NRows_Im << "))=" << *p_d1rep << ", SFVecArr(=" << SFVecArr << "))=" << *p_d2mat << ") = " << TempArray << endl;
      #endif
      delete p_d1rep;
      delete p_d2mat;

      SPVecArr.resize(TempArray.rows());
      SPVecArr = sum(TempArray, j);

      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        CS_SP.Set(CString("SPVecArr1"));
        CS_SP.Add(CS_DebugFilesSuffix);
        CS_SP.Add(CString(".fits"));
        D_A2_SPTemp.resize(SPVecArr.size(), 1);
        D_A2_SPTemp(Range::all(), 0) = SPVecArr;
        this->WriteFits(&D_A2_SPTemp, CS_SP);
      #endif
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": -3. SPVecArr (set to sum(D_A2_Im * (*P_I_A2_Mask), j)) = " << SPVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (set to sum(D_A2_Im * (*P_I_A2_Mask), j)) = " << SPVecArr << endl;
      #endif
      SPVecArr *= Norm;

      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        CS_SP.Set(CString("SPVecArr1TimesNorm"));
        CS_SP.Add(CS_DebugFilesSuffix);
        CS_SP.Add(CString(".fits"));
        D_A2_SPTemp.resize(SPVecArr.size(), 1);
        D_A2_SPTemp(Range::all(), 0) = SPVecArr;
        this->WriteFits(&D_A2_SPTemp, CS_SP);
      #endif
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": -2. SPVecArr (*Norm=" << Norm << ") = " << SPVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (*Norm=" << Norm << ") = " << SPVecArr << endl;
      #endif
















      SPVecArr = where(SPVecArr < 0., 0., SPVecArr);
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": -1. SPVecArr (*Norm=" << Norm << ") = " << SPVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (*Norm=" << Norm << ") = " << SPVecArr << endl;
      #endif





















  ///  sp=sp/total(sp)*total(imm*msk)
      SPVecArr /= sum(SPVecArr);
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 0. SPVecArr (set to /=sum(SPVecArr)) = " << SPVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (set to /=sum((SPVecArr)) = " << SPVecArr << endl;
      #endif

      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        CS_SP.Set(CString("SPVecArr1DivBySum"));
        CS_SP.Add(CS_DebugFilesSuffix);
        CS_SP.Add(CString(".fits"));
        D_A2_SPTemp.resize(SPVecArr.size(), 1);
        D_A2_SPTemp(Range::all(), 0) = SPVecArr;
        this->WriteFits(&D_A2_SPTemp, CS_SP);
      #endif






    /// used to be before SPVecArr /= sum(SPVecArr)
    ///  sp=median(sp,5)                                    ; the spectrum
////////    Array<double, 1> *p_d1sptemp = (MedianVec(SPVecArr, 5, (CString("NORMAL"))));
////////    SPVecArr = (*p_d1sptemp);
////////    delete p_d1sptemp;
////////    #ifdef __DEBUG_FITS_SLITFUNC_N__
////////      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": SPVecArr (set to MedianVec) = " << SPVecArr << endl;
////////      (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (set to MedianVec) = " << SPVecArr << endl;
////////    #endif
      if (abs(sum(SPVecArr)) < 0.000000001)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": WARNING: sum(SPVecArr=" << SPVecArr << ") == 0" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: WARNING: sum(SPVecArr=" << SPVecArr << ") == 0" << endl;
        SPVecArr = 1.;
      //      return false;
      }
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(SPVecArr) =" << sum(SPVecArr) << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: sum((SPVecArr) " << sum(SPVecArr) << endl;
      #endif

      SPVecArr *= sum(D_A2_Im * (*P_I_A2_Mask));

      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        CS_SP.Set(CString("SPVecArr1TimesSumImTimesMask"));
        CS_SP.Add(CS_DebugFilesSuffix);
        CS_SP.Add(CString(".fits"));
        D_A2_SPTemp.resize(SPVecArr.size(), 1);
        D_A2_SPTemp(Range::all(), 0) = SPVecArr;
        this->WriteFits(&D_A2_SPTemp, CS_SP);
      #endif
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": SPVecArr (set to *=sum(D_A2_Im * (*P_I_A2_Mask))(=" << sum(D_A2_Im * (*P_I_A2_Mask)) << ")) = " << SPVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (set to *=sum(D_A2_Im * (*P_I_A2_Mask))(=" << sum(D_A2_Im * (*P_I_A2_Mask)) << ")) = " << SPVecArr << endl;
      #endif
  //return false;
    #endif
  }/// end if (I_Telluric != 2)

  /** Add too noisy pixels to bad-pixel mask **/

///  if(keyword_set(noise)) then $
///    dev=noise $
///  else $
///    dev=sqrt(total(msk*(imm-sp#sf)^2)/total(msk))
///  j=where(abs(imm-sp#sf) gt 3.*dev,nj)
///  if(nj gt 0) then begin
///    msk(j)=0B
///  endif
  P_TempString->Set("NOISE");
  Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString);
  Array<double, 2> D_A2_TempBB(P_I_A2_Mask->rows(), P_I_A2_Mask->cols());
  if (Pos >= 0)
  {
    Dev = *(double*)ArgV_In[Pos];
    D_A1_Dev = Dev;
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(NOISE): Dev set to " << Dev << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(NOISE): Dev set to " << Dev << endl;
    #endif

  }
  if (Pos < 0 || (Pos >= 0 && abs(Dev) < 0.00000000000000001))
  {
    if (sum((*P_I_A2_Mask)) < 1)
    {
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: sum((*P_I_A2_Mask)=" << (*P_I_A2_Mask) << ") == 0" << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: ERROR: sum((*P_I_A2_Mask)=" << (*P_I_A2_Mask) << ") == 0" << endl;
      return false;
    }
  }
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 1. SPVecArr = " << SPVecArr << endl;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": SFVecArr = " << SFVecArr << endl;
  #endif
//    return false;
//  Array<int, 1> I_A1_Ind_SFNoZero(SFVecArr.size());
//  I_A1_Ind_SFNoZero = where(SFVecArr > 0., 1, 0);
//  int I_NSFNoZero = 0;
//  Array<int, 1> *P_I_A1_Ind_SFNoZero = this->GetIndex(I_A1_Ind_SFNoZero, I_NSFNoZero);

//  TempArray.resize(I_NRows_Im, I_NCols_Im);
  if (D_A2_Im.cols() != SFVecArr.size()){
    cout << "CFits::SlitFunc: ERROR: D_A2_Im.cols() != SFVecArr.size() => Returning FALSE" << endl;
    return false;
  }
  Array<double, 1> D_A1_SP_Tmp(D_A2_Im.rows());
//  Array<double, 1> D_A1_SP_times_SF_Temp(P_I_A1_Ind_SFNoZero->size());
  D_A1_SP_Tmp = 0.;
  double D_Reject = 4.;
  Array<CString, 1> CS_A1_Args_FitSig(3);
  void **PP_Void_FitSig = (void**)malloc(sizeof(void*) * 3);
  CS_A1_Args_FitSig(0) = CString("REJECT_IN");
  PP_Void_FitSig[0] = &D_Reject;
  CS_A1_Args_FitSig(1) = CString("MEASURE_ERRORS_IN");
  PP_Void_FitSig[1] = P_D_A2_Errors;
  Array<int, 2> I_A2_MaskFit(D_A2_Im.rows(), D_A2_Im.cols());
  I_A2_MaskFit = (*P_I_A2_Mask);
  CS_A1_Args_FitSig(2) = CString("MASK_INOUT");
  PP_Void_FitSig[2] = &I_A2_MaskFit;
  Array<double, 1> *p_Rep = this->Replicate(1., D_A2_Im.rows());
  Array<double, 2> *p_SFArr = this->VecArrACrossB(*p_Rep, SFVecArr);
  Array<double, 1> D_A1_Sky_Tmp(D_A2_Im.rows());
  bool B_WithSky = true;
  if (I_Telluric == 1 || I_Telluric == 3)
    B_WithSky = false;
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: Before FitSig: SFVecArr = " << SFVecArr << endl;
  #endif
  if (!this->LinFitBevington(D_A2_Im,
                             *p_SFArr,
                             D_A1_SP_Tmp,
                             D_A1_Sky_Tmp,
                             B_WithSky,
                             CS_A1_Args_FitSig,
                             PP_Void_FitSig)){
    cout << "CFits::SlitFunc: ERROR: FitSig returned FALSE" << endl;
    return false;
  }
  *P_I_A2_Mask = I_A2_MaskFit;
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    CString CS_MaskSig("MaskFitSig_");
    CS_MaskSig.Add(CS_DebugFilesSuffix);
    CS_MaskSig.Add(CString(".fits"));
    this->WriteFits(&I_A2_MaskFit, CS_MaskSig);
    cout << "CFits::SlitFunc: After FitSig: I_A2_MaskFit = " << I_A2_MaskFit << endl;
  #endif
//  return false;
  delete(p_Rep);
  delete(p_SFArr);
  free(PP_Void_FitSig);

  SFVecArr = where(SFVecArr < 0., 0., SFVecArr);
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 2c.    Slit Function SFVecArr = SFVecArr / (sum(SFVecArr) = " << sum(SFVecArr) << ") = " << SFVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: 3.    Slit Function SFVecArr = SFVecArr / (sum(SFVecArr) = " << sum(SFVecArr) << ") = " << SFVecArr << endl;
  #endif

  ///      sf=sf/total(sf)                                    ; slit function
  if (sum(SFVecArr) < 0.00000000000000001)
    SFVecArr = 1.;
  SFVecArr /= sum(SFVecArr);           /** Slit Function **/
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: c) SFVecArr = " << SFVecArr << endl;
//  return false;

//  for (int i_row=0; i_row < D_A2_Im.rows(); i_row++){
//    for (int i_col=0; i_col < I_NSFNoZero; i_col++){
//      D_A1_SP_times_SF_Temp(i_col) = D_A2_Im(i_row, (*P_I_A1_Ind_SFNoZero)(i_col)) / SFVecArr((*P_I_A1_Ind_SFNoZero)(i_col));
//    }
//    D_A1_SP_Tmp(i_row) = this->Median(D_A1_SP_times_SF_Temp);
//  }
    cout << "CFits::SlitFunc: D_A1_SP_Tmp = " << D_A1_SP_Tmp << endl;
  #endif
//  Array<double, 2> *p_tempMatA = this->VecArrACrossB(SPVecArr, SFVecArr);
  Array<double, 2> *p_tempMatA = this->VecArrACrossB(D_A1_SP_Tmp, SFVecArr);
  Array<double, 2> *p_tempMat = new Array<double, 2>(D_A2_Im.rows(), D_A2_Im.cols());
  Array<double, 2> *p_tempMatB = new Array<double, 2>(D_A2_Im.rows(), D_A2_Im.cols());
  *p_tempMat = D_A2_Im - (*p_tempMatA);
  #ifdef __DEBUG_FITS_SLITFUNC_FILES__
    CString CS_ImMinusRec("ImMinusRec_");
    CS_ImMinusRec.Add(CS_DebugFilesSuffix);
    CS_ImMinusRec.Add(CString(".fits"));
    this->WriteFits(p_tempMat, CS_ImMinusRec);
  #endif
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(NOISE): *p_tempMatA " << *p_tempMatA << endl;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(NOISE): *p_tempMat " << *p_tempMat << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(NOISE): Dev set to " << Dev << endl;
  #endif
  *p_tempMatB = pow2(*p_tempMat);
  for (int iter_sig = 0; iter_sig < this->I_MaxIterSig; iter_sig++)
  {
    this->CastIntArrToDblArr((*P_I_A2_Mask), D_A2_Mask);
//    cout << "CFits::SlitFunc: iter_sig = " << iter_sig << ": D_A2_Mask set to " << D_A2_Mask << endl;
    if (P_I_A2_Mask->rows() != D_A2_Mask.rows()){
      cout << "CFits::SlitFunc: ERROR: 1. P_I_A2_Mask->rows() != D_A2_Mask.rows()" << endl;
      return false;
    }
    Pos = this->KeyWord_Set(CS_A1_Args_In, CString("NOISE"));
    if (Pos < 0 || (Pos >= 0 && abs(Dev) < 0.00000000000000001))
    {
      for (int i_col=0; i_col < D_A2_Im.cols(); i_col++){
        if (sum((*P_I_A2_Mask)(Range::all(), i_col)) == 0){
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(NOISE): iter_sig = " << iter_sig << ": i_col = " << i_col << ": ERROR: sum((*P_I_A2_Mask)(Range::all(), i_col)) = " << sum((*P_I_A2_Mask)(Range::all(), i_col)) << endl;
          return false;
        }
        else{
          if (fabs(sum(D_A2_Mask)) < 0.000000000001){
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(NOISE): iter_sig = " << iter_sig << ": i_col = " << i_col << ": ERROR:  fabs(sum(D_A2_Mask)=" << sum(D_A2_Mask) << ") < 0.000000000001" << endl;
            return false;
          }
          ///dev=sqrt(total(msk*(imm-sp#sf)^2)/total(msk))
          D_A1_Dev(i_col) = sqrt(sum(D_A2_Mask(Range::all(), i_col) * ((*p_tempMatB)(Range::all(), i_col))) / sum(D_A2_Mask(Range::all(), i_col)));
        }
//        D_Dev = sqrt(sum(D_A2_Mask * ((*p_tempMatB))) / sum(D_A2_Mask));
      }
      #ifdef __DEBUG_FITS_SLITFUNC_N__
//        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(NOISE): iter_sig = " << iter_sig << ": (*P_I_A2_Mask) " << (*P_I_A2_Mask) << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(NOISE): iter_sig = " << iter_sig << ": D_A1_Dev set to " << D_A1_Dev << endl;
//        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": !KeyWord_Set(NOISE): iter_sig = " << iter_sig << ": D_Dev set to " << D_Dev << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(NOISE): Dev set to " << Dev << endl;
      #endif
//       return false;
    }
    else{
      cout << "CFits::SlitFunc: KeyWord_Set(NOISE): D_A1_Dev = " << D_A1_Dev << endl;
//      return false;
    }
  //    (*P_OFS_Log) << "CFits::SlitFunc: 3. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;










































    this->CastIntArrToDblArr((*P_I_A2_Mask), D_A2_Mask);
//    cout << "CFits::SlitFunc: 2. iter_sig = " << iter_sig << ": D_A2_Mask set to " << D_A2_Mask << endl;
    if (P_I_A2_Mask->rows() != D_A2_Mask.rows()){
      cout << "CFits::SlitFunc: ERROR: 0. P_I_A2_Mask->rows() != D_A2_Mask.rows()" << endl;
      return false;
    }
  //  (*P_I_A2_Mask) = where(fabs((*P_I_A2_Mask) * (*p_tempMat)) > (5. * Dev), 0, (*P_I_A2_Mask));
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      D_A2_TempBB = fabs(D_A2_Mask * (*p_tempMat));
      cout << " iter_sig = " << iter_sig << ": fabs(P_I_A2_Mask(= " << *P_I_A2_Mask << ") * p_tempMat(= " << *p_tempMat << ")) = " << D_A2_TempBB << ", D_A1_Dev = " << D_A1_Dev << endl;
    #endif

//      (*P_I_A2_Mask) = where((*P_I_A2_Mask) * ((*p_tempMatB)) > (4.5 * D_Dev), 0, (*P_I_A2_MaskIn));

    for (int i_col = 0; i_col < D_A2_Im.cols(); i_col++){
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": iter_sig = " << iter_sig << ": (*p_tempMatB)(Range::all(), i_col=" << i_col << ") = " << (*p_tempMatB)(Range::all(), i_col) << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": iter_sig = " << iter_sig << ": D_A1_Dev(i_col=" << i_col << ") = " << D_A1_Dev(i_col) << endl;
      #endif
//      (*P_I_A2_Mask)(Range::all(), i_col) = where(D_A2_Mask(Range::all(), i_col) * ((*p_tempMatB)(Range::all(), i_col)) > (4.5 * D_Dev), 0, (*P_I_A2_MaskIn)(Range::all(), i_col));
      #ifndef __PISKUNOV_ORIG__
        if (this->I_MaxIterSig > 0){
          (*P_I_A2_Mask)(Range::all(), i_col) = where(sqrt(D_A2_Mask(Range::all(), i_col) * ((*p_tempMatB)(Range::all(), i_col))) > (6.5 * D_A1_Dev(i_col)), 0, (*P_I_A2_Mask)(Range::all(), i_col));
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": iter_sig = " << iter_sig << ": (*P_I_A2_Mask)(Range::all(), i_col=" << i_col << ") = " << (*P_I_A2_Mask)(Range::all(), i_col) << endl;
          #endif
        }
      #endif
    }///end for (int i_col = 0; i_col < D_A2_Im.cols(); i_col++){
    #ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": iter_sig = " << iter_sig << ": (*P_I_A2_Mask) = " << (*P_I_A2_Mask) << endl;
    #endif
    this->CastIntArrToDblArr((*P_I_A2_Mask), D_A2_Mask);
//    cout << "CFits::SlitFunc: 3. iter_sig = " << iter_sig << ": D_A2_Mask set to " << D_A2_Mask << endl;
    if (P_I_A2_Mask->rows() != D_A2_Mask.rows()){
      cout << "CFits::SlitFunc: ERROR: P_I_A2_Mask->rows() != D_A2_Mask.rows()" << endl;
      return false;
    }
    for (int i_row=0; i_row<P_I_A2_Mask->rows(); i_row++){
      for (int i_col=0; i_col<P_I_A2_Mask->cols(); i_col++){
        if ((*P_I_A2_Mask)(i_row, i_col) != int(D_A2_Mask(i_row, i_col))){
          cout << "CFits::SlitFunc: ERROR: (*P_I_A2_Mask)(i_row, i_col)(=" << (*P_I_A2_Mask)(i_row, i_col) << ") != int(D_A2_Mask(i_row, i_col))(=" << int(D_A2_Mask(i_row, i_col)) << ")" << endl;
          return false;
        }
      }
    }
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "sum(*P_I_A2_MaskIn) = " << sum(*P_I_A2_MaskIn) << endl;
      cout << "sum(*P_I_A2_Mask) = " << sum(*P_I_A2_Mask) << endl;
//    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_Im = " << D_A2_Im << endl;
//    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": SPVecArr x SFVecArr = " << *p_tempMatA << endl;
      Array<double,2> D_A2_ImTemp(D_A2_Im.rows(), D_A2_Im.cols());
      D_A2_ImTemp = D_A2_Im - (*p_tempMatA);
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_Im[" << D_A2_Im.rows() << ", " << D_A2_Im.cols() << "]" << ", p_tempMatA[" << p_tempMatA->rows() << ", " << p_tempMatA->cols() << "]" << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_Im - SPVecArr x SFVecArr = " << D_A2_ImTemp << endl;
//    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(TempArray(where)) = " << sum(TempArray) << ", TempArray.size() = " << TempArray.size() << ", TempArray = " << TempArray << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: sum(TempArray(where)) = " << sum(TempArray) << ", TempArray.size() = " << TempArray.size() << endl;
     #endif

//    if (sum(TempArray) < TempArray.size())
//    {
//      (*P_I_A2_Mask) *= TempArray;
//    #ifdef __DEBUG_FITS_SLITFUNC_N__
//      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(TempArray(where)) = " << sum(TempArray) << " < TempArray.size() = " << TempArray.size() << ": (*P_I_A2_Mask) set to " << (*P_I_A2_Mask) << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: sum(TempArray(where)) = " << sum(TempArray) << " < TempArray.size() = " << TempArray.size() << ": (*P_I_A2_Mask) set to " << (*P_I_A2_Mask) << endl;
//    #endif
    #ifdef __DEBUG_FITS_SLITFUNC_FILES__
      CString *P_CS_Sig;
      CString CS_Mask("Mask_");
      CS_Mask.Add("IterSig");
      P_CS_Sig = CS_Mask.IToA(iter_sig);
      CS_Mask.Add(*P_CS_Sig);
      delete(P_CS_Sig);
      CS_Mask.Add(CS_DebugFilesSuffix);
      CS_Mask.Add(".fits");
      this->WriteFits(P_I_A2_Mask, CS_Mask);

      CS_Mask.Set("ImInTimesMask_IterSig");
      P_CS_Sig = CS_Mask.IToA(iter_sig);
      CS_Mask.Add(*P_CS_Sig);
      delete(P_CS_Sig);
      CS_Mask.Add(CS_DebugFilesSuffix);
      CS_Mask.Add(".fits");
      D_A2_ImTimesMask = D_A2_Im * (*P_I_A2_Mask);
      this->WriteFits(&D_A2_ImTimesMask, CS_Mask);
    #endif
//    }
  }/// for (int iter_sig = 0; iter_sig < this->I_MaxIterSig; iter_sig++)
  delete p_tempMat;
  delete p_tempMatA;
  delete p_tempMatB;

  /** --- just here to add another set of bad pixels per col to Mask
  if (I_Telluric > 1){
    Array<double, 2> D_A2_SFTemp(D_A2_Im.rows(), D_A2_Im.cols());
    D_A2_SFTemp = D_A2_Im;
    for (int o = 0; o < D_A2_Im.rows(); o++){
      if (sum(D_A2_SFTemp(o, Range::all())) > 0.)
        D_A2_SFTemp(o, Range::all()) /= sum(D_A2_SFTemp(o, Range::all()));
      else{
        D_A2_SFTemp(o, Range::all()) = 0.;
        (*P_I_A2_Mask)(o, Range::all()) = 0;
      }
    }
    for (int oo = 0; oo < this->I_MaxIterSig; oo++){
      for (int o = 0; o < P_I_A2_Mask->cols(); o++){
        double D_SF_ColMedian = Median(D_A2_Im(Range::all(), o));

        Dev = sqrt(sum((*P_I_A2_Mask)(Range::all(), o) * (D_A2_Im(Range::all(), o) - D_SF_ColMedian)) / double(sum((*P_I_A2_Mask)(Range::all(), o))));
        (*P_I_A2_Mask)(Range::all(), o) = where(fabs(D_A2_SFTemp(Range::all(), o) - D_SF_ColMedian) > 3. * Dev, 0, (*P_I_A2_Mask)(Range::all(), o));
      }
    }
    D_A2_SFTemp *= (*P_I_A2_Mask);
//  #ifdef __DEBUG_FITS_TELLURIC__
      this->WriteFits(&D_A2_SFTemp, CString(DEBUGDIR)+CString("D_A2_SFTempTimesMask_new.fits"));
//  #endif
  }**/

  /** Set XVecArr to vector containing the subpixel numbers **/

///  y=(dindgen(n)+0.5d0)/float(osample)-1.d0
  XVecArr.resize(I_NPixSlitF);
//  D_A2_SFO.resize(I_NRows_Im, I_NPixSlitF);
//  D_A2_SFO = 0.;
  XVecArr = (i + 0.5) / double(this->I_OverSample) - 1.;
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": XVecArr = " << XVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: XVecArr = " << XVecArr << endl;
//    return false;
  #endif
///  bklind=lindgen(osample+1)+n*osample
  BKLIndVecArr.resize(this->I_OverSample + 1);
  BKLIndVecArr = i;
  BKLIndVecArr += (I_NPixSlitF * this->I_OverSample);
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": BKLIndVecArr = " << BKLIndVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: BKLIndVecArr = " << BKLIndVecArr << endl;
  #endif

///  olind=oind(0:osample)
  OLIndVecArr.resize(this->I_OverSample + 1);
  if (OIndVecArr.size() < this->I_OverSample+1)
  {
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: size of OIndVecArr(=" << OIndVecArr.size() << " < this->I_OverSample + 1(=" << this->I_OverSample + 1 << ")" << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: ERROR: size of OIndVecArr(=" << OIndVecArr.size() << " < this->I_OverSample + 1(=" << this->I_OverSample + 1 << ")" << endl;
    return false;
  }
  OLIndVecArr = OIndVecArr(Range(0, this->I_OverSample));
  #ifdef __DEBUG_FITS_SLITFUNC_N__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": OLIndVecArr = " << OLIndVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: OLIndVecArr = " << OLIndVecArr << endl;
  #endif

  ///    for m=osample+1L,2L*osample do begin
  ///    endfor
  for (long m=this->I_OverSample + 1; m <= (2 * this->I_OverSample); m++)
  {
    ///      mm=m-osample
    long mm = m - this->I_OverSample;
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m=" << m << "): mm = " << mm << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): mm = " << mm << endl;
    #endif

    /// attach another Vector<int>(osample+1-mm) to BKLIndVecArr with values index + (N * m)
    ///      bklind=[bklind,lindgen(osample+1-mm)+n*m]
    TempIVecArr.resize(this->I_OverSample + 1 - mm);
    TempIVecArr = i + (I_NPixSlitF * m);
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m=" << m << "): TempIVecArr = " << TempIVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): TempIVecArr = " << TempIVecArr << endl;
    #endif

    int oldsize = BKLIndVecArr.size();
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m=" << m << "): oldsize(BKLIndVecArr) = " << oldsize << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): oldsize(BKLIndVecArr) = " << oldsize << endl;
    #endif
    BKLIndVecArr.resizeAndPreserve(oldsize + this->I_OverSample + 1 - mm);
// #ifdef __DEBUG_FITS_SLITFUNC__
//    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m=" << m << "): BKLIndVecArr = " << BKLIndVecArr << endl;
//    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): BKLIndVecArr = " << BKLIndVecArr << endl;
// #endif
    BKLIndVecArr(Range(oldsize, toEnd))//oldsize + 1 + this->I_OverSample - mm))
    = TempIVecArr(Range::all());
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m=" << m << "): BKLIndVecArr = " << BKLIndVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): BKLIndVecArr = " << BKLIndVecArr << endl;
    #endif

    ///      olind=[olind,oind(0:osample-mm)+mm]
    oldsize = OLIndVecArr.size();
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m=" << m << "): oldsize(OLIndVecArr) = " << oldsize << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): oldsize(OLIndVecArr) = " << oldsize << endl;
    #endif
    OLIndVecArr.resizeAndPreserve(OLIndVecArr.size() + this->I_OverSample + 1 - mm);
// #ifdef __DEBUG_FITS_SLITFUNC__
//    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m=" << m << "): OLIndVecArr = " << OLIndVecArr << endl;
//    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): OLIndVecArr = " << OLIndVecArr << endl;
// #endif
    if (OIndVecArr.size() < this->I_OverSample - mm + 1)
    {
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: size of OIndVecArr(=" << OIndVecArr.size() << ") < this->I_OverSample - mm + 1(=" << this->I_OverSample - mm + 1 << ")" << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: ERROR: size of OIndVecArr(=" << OIndVecArr.size() << ") < this->I_OverSample - mm + 1(=" << this->I_OverSample - mm + 1 << ")" << endl;
      return false;
    }
    OLIndVecArr(Range(oldsize, toEnd))
    = OIndVecArr(Range(0, this->I_OverSample - mm)) + mm;
    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m=" << m << "): OLIndVecArr = " << OLIndVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): OLIndVecArr = " << OLIndVecArr << endl;
    #endif

  }/// end for (long m=this->I_OverSample + 1; m <= (2 * this->I_OverSample); m++)

  ///    Bl=dblarr(n)                               ; and RHS
  ///    omega=replicate(weight,osample+1L)         ; Replicate constant weights

  /** Goto Label here!!!!!!!!! **/
  SPOldVecArr.resize(SPVecArr.size());
  SPOldVecArr = 0.;
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": SPOldVecArr = " << SPOldVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: SPOldVecArr = " << SPOldVecArr << endl;
  #endif
  ///    iter=0

  this->CastIntArrToDblArr((*P_I_A2_Mask), D_A2_Mask);
//  cout << "CFits::SlitFunc: 4. D_A2_Mask set to " << D_A2_Mask << endl;
//  cout << "CFits::SlitFunc: *P_I_A2_Mask = " << *P_I_A2_Mask << endl;
//  cout << "CFits::SlitFunc: D_A2_Mask = " << D_A2_Mask << endl;
//  return false;

  Array<double, 1> D_A1_SFO(2);
  D_A1_SFO = 0.;
  Array<double, 2> D_A2_Weights(D_A2_Im.rows(), this->I_OverSample + 1);
  D_A2_Weights = 0.;
  do
  {
    I_Iter_Sky++;
    I_Iter_SF = 0;
    ///    next:
    while(I_Iter_SF < this->I_MaxIterSF)   /** Iteration counter **/
    {

      //      (*P_OFS_Log) << "CFits::SlitFunc: 4. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

      ///    iter=iter+1                                ; Iteration counter
      I_Iter_SF++;

      #ifdef __DEBUG_FITS_SLITFUNC_SF_N__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": (max(abs(SPVecArr - SPOldVecArr=" << SPOldVecArr << ") / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": (max(abs(SPVecArr - SPOldVecArr=" << SPOldVecArr << ") / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << endl;
      #endif

      if ((I_Iter_SF == 1) || (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) > 0.00001))
      {

        ///    Akl=dblarr(n,2*osample+1)                  ; Initialize matrix
        AKLArr.resize(I_NPixSlitF, (2*this->I_OverSample) + 1); /** Initialize Matrix **/
        AKLArr = 0.;
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": if(max...): AKLArr initialized to 0.: size(AKLArr) = (" << AKLArr.rows() << "," << AKLArr.cols() << ")" << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: if(max...): AKLArr initialized to 0.: size(AKLArr) = (" << AKLArr.rows() << "," << AKLArr.cols() << ")" << endl;
        #endif

        ///    Bl=dblarr(n)                               ; and RHS
        BLVecArr.resize(I_NPixSlitF);                      /** and RHS **/
        BLVecArr = 0.;
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": if(max...): BLVecArr = " << BLVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: if(max...): BLVecArr = " << BLVecArr << endl;
        #endif

        ///    omega=replicate(weight,osample+1L)         ; Replicate constant weights
        OmegaVecArr.resize(this->I_OverSample + 1);
        OmegaVecArr = Weight;                    /** Replicate constant Weights **/
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": if(max...): OmegaVecArr = " << OmegaVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: if(max...): OmegaVecArr = " << OmegaVecArr << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": (max(abs(SPVecArr=" << SPVecArr << " - SPOldVecArr=" << SPOldVecArr << ") / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001: Resizing D_A2_XX to I_NRows_Im x I_NPixSlitF=" << I_NPixSlitF << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: (max(abs(SPVecArr=" << SPVecArr << " - SPOldVecArr=" << SPOldVecArr << ") / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001: Resizing D_A2_XX to I_NRows_Im x I_NPixSlitF=" << N << endl;
        #endif
        D_A2_XX.resize(I_NRows_Im, I_NPixSlitF);
        D_A2_XX = 0.;

        this->CastIntArrToDblArr((*P_I_A2_Mask), D_A2_Mask);
//    cout << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": I_Iter_Sky = " << I_Iter_Sky << ": D_A2_Mask set to " << D_A2_Mask << endl;
//  cout << "CFits::SlitFunc: *P_I_A2_Mask = " << *P_I_A2_Mask << endl;
//  cout << "CFits::SlitFunc: D_A2_Mask = " << D_A2_Mask << endl;
//  return false;
        ///    for i=0,ncol-1 do begin  */ /** i => m **/   /*               ; Fill up matrix and RHS
        for (int m = 0; m < I_NRows_Im; m++)  /** Fill up matrix and RHS **/
        {

          //          (*P_OFS_Log) << "CFits::SlitFunc: 5. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Begin for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++)" << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: Begin for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++)" << endl;
          #endif
          ///      yy=y+yycen(i)                            ; Offset SFVecArr
          if (D_A2_XX.cols() != XVecArr.size())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: D_A2_XX.cols(=" << D_A2_XX.cols() << ") != size of XVecArr(=" << XVecArr.size() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: D_A2_XX.cols(=" << D_A2_XX.cols() << ") != size of XVecArr(=" << XVecArr.size() << ")" << endl;
            return false;
          }
          D_A2_XX(m,Range::all()) = XVecArr + XCenVecArr(m);    /** Offset SFVecArr **/
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": line 10600: XVecArr = " << XVecArr << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": line 10600: XVecArr(0) = " << XVecArr(0) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": XCenVecArr(m=" << m << ") = " << XCenVecArr(m) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): D_A2_XX(" << m << ", *) set to " << D_A2_XX(m,Range::all()) << endl;
//	    return false;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): D_A2_XX(m, *) set to " << D_A2_XX(m,Range::all()) << endl;
          #endif

          /** Weights are the same for all pixels except for the first and the last subpixels **/
          ///      ind=where(yy ge 0 and yy lt 1, nind)
          TempIVecArr.resize(D_A2_XX.cols());
          TempIVecArr = where((D_A2_XX(m,Range::all()) > 0) && (D_A2_XX(m,Range::all()) < 1), 1, 0);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): TempIVecArr set to " << TempIVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): TempIVecArr set to " << TempIVecArr << endl;
          #endif
          this->GetIndex(TempIVecArr, NInd, IndVecArr);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): NInd = " << NInd << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): NInd = " << NInd << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): IndVecArr set to " << IndVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): IndVecArr set to " << IndVecArr << endl;
          #endif
          ///      i1=ind(0) & i2=ind(nind-1)               ; for the first and the last subpixels.
          IFirst = IndVecArr(0);

          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): IFirst = " << IFirst << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): IFirst set to " << IFirst << endl;
          #endif
          ILast  = IndVecArr(NInd - 1);
  //        IndVecArr.resize(1);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): ILast = " << ILast << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): ILast set to " << ILast << endl;
          #endif

          /** Fix the first and the last subpixels, here the weight is split between the two subpixels **/
          ///      omega(0)=yy(i1)
          OmegaVecArr(0) = D_A2_XX(m,IFirst);

          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
          #endif

          ///      omega(osample)=1.-yy(i2)
          OmegaVecArr(this->I_OverSample) = 1. - D_A2_XX(m, ILast);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OmegaVecArr(this->I_OverSample=" << this->I_OverSample << ") set to " << OmegaVecArr(this->I_OverSample) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OmegaVecArr(this->I_OverSample=" << this->I_OverSample << ") set to " << OmegaVecArr(this->I_OverSample) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OmegaVecArr set to " << OmegaVecArr << endl;
//	    return false;
          #endif
	  D_A2_Weights(m, Range::all()) = OmegaVecArr;

          /** Band-diagonal part that will contain omega#omega **/
          ///      bkl=dblarr(n,2*osample+1)
          BKLArr.resize(I_NPixSlitF, (2 * this->I_OverSample) + 1);
          BKLArr = 0.;

          ///      o=omega#omega
          Array<double, 2> *p_OArr = VecArrACrossB(OmegaVecArr, OmegaVecArr);
          OArr.resize(p_OArr->rows(),p_OArr->cols());//OmegaVecArr.size(), OmegaVecArr.size());
          OArr = (*p_OArr);
          delete p_OArr;
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): 1. OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
          #endif

          ///      o(osample,osample)=o(osample,osample)+o(0,0)
          tmpdbl = OArr(this->I_OverSample, this->I_OverSample);
          tmpdbl += OArr(0, 0);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): tmpdbl set to " << tmpdbl << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): tmpdbl set to " << tmpdbl << endl;
          #endif
          OArr(this->I_OverSample, this->I_OverSample) = tmpdbl;
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr(this->I_OverSample=" << this->I_OverSample << ", this->I_OverSample) set to " << OArr(this->I_OverSample, this->I_OverSample) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr = " << OArr << endl;
//	    return false;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr(this->I_OverSample=" << this->I_OverSample << ", this->I_OverSample) set to " << OArr(this->I_OverSample, this->I_OverSample) << endl;
          #endif

          ///      oo=o(olind)
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OLIndVecArr = " << OLIndVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OLIndVecArr = " << OLIndVecArr << endl;
          #endif
          OOVecArr.resize(OLIndVecArr.size());
          OOVecArr = 0.;
          for (int n = 0; n < OLIndVecArr.size(); n++)
          {
            tempcol = this->GetColFromIndex(OLIndVecArr(n), OArr.rows());
            temprow = this->GetRowFromIndex(OLIndVecArr(n), OArr.rows());
            #ifdef __DEBUG_FITS_SLITFUNC_N__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for (int n(=" << n << ") = 0; n < OLIndVecArr.size(=" << OLIndVecArr.size() << "); n++): setting OOVecArr(n) to OArr(OLIndVecArr(temprow(=" << temprow << "), tempcol(=" << tempcol << "))=" << OArr(temprow, tempcol) << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for (int n(=" << n << ") = 0; n < OLIndVecArr.size(=" << OLIndVecArr.size() << "); n++): setting OOVecArr(n) to OArr(OLIndVecArr(temprow(=" << temprow << "), tempcol(=" << tempcol << "))=" << OArr(temprow, tempcol) << endl;
            #endif
            if (temprow >= OArr.rows())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: temprow(=" << temprow << ") >= OArr.rows(=" << OArr.rows() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: temprow(=" << temprow << ") >= OArr.rows(=" << OArr.rows() << ")" << endl;
              return false;
            }
            if (tempcol >= OArr.cols())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: tempcol(=" << tempcol << ") >= OArr.cols(=" << OArr.cols() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: tempcol(=" << tempcol << ") >= OArr.cols(=" << OArr.cols() << ")" << endl;
              return false;
            }
            OOVecArr(n) = OArr(temprow, tempcol);
          }
          //          OLIndVecArr.resize(1);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OOVecArr set to " << OOVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OOVecArr set to " << OOVecArr << endl;
          #endif

          ///      for l=0,nrow-1 do begin
          for (int n = 0; n < I_NCols_Im; n++)
          {
            ///        bkl(l*osample+i1+bklind)=oo*msk(i,l)

            //            (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 6. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

            for (int o = 0; o < BKLIndVecArr.size(); o++)
            {
              //              (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 6. for(o(= " << o << "); o < BKLIndVecArr.size(=" << BKLIndVecArr.size() << "); o++)" << endl;
              #ifdef __DEBUG_FITS_SLITFUNC_N__
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": n(=" << n << ") * this->I_OverSample(=" << this->I_OverSample << ") + IFirst(=" << IFirst << ") + BKLIndVecArr(o=" << o << ")=" << BKLIndVecArr(o) << " = " << (n * this->I_OverSample) + IFirst + BKLIndVecArr(o) << endl;
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": BKLIndVecArr = " << BKLIndVecArr << endl;
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": OOVecArr = " << OOVecArr << endl;
  //            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": BKLArr = " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
            //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": n(=" << n << ") * this->I_OverSample(=" << this->I_OverSample << ") + IFirst(=" << IFirst << ") + BKLIndVecArr(o=" << o << ")=" << BKLIndVecArr(o) << " = " << (n * this->I_OverSample) + IFirst + BKLIndVecArr(o) << endl;
            //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": BKLIndVecArr = " << BKLIndVecArr << endl;
            //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": OOVecArr = " << OOVecArr << endl;
  //            (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": BKLArr = " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
              #endif

              tempcol = this->GetColFromIndex((n * this->I_OverSample) + IFirst + BKLIndVecArr(o), BKLArr.rows());
              temprow = this->GetRowFromIndex((n * this->I_OverSample) + IFirst + BKLIndVecArr(o), BKLArr.rows());

              if (temprow >= BKLArr.rows())
              {
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: temprow(=" << temprow << ") >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
                (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: temprow(=" << temprow << ") >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
                return false;
              }

              if (tempcol >= BKLArr.cols())
              {
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: tempcol(=" << tempcol << ") >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
                (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: tempcol(=" << tempcol << ") >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
                return false;
              }

              if (o >= OOVecArr.size())
              {
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: o(=" << o << ") >= OOVecArr.size(=" << OOVecArr.size() << ")" << endl;
                (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: o(=" << o << ") >= OOVecArr.size(=" << OOVecArr.size() << ")" << endl;
                return false;
              }
              if (m >= P_I_A2_Mask->rows())
              {
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: m(=" << m << ") >= P_I_A2_Mask->rows(=" << P_I_A2_Mask->rows() << ")" << ", P_I_A2_Mask->cols(=" << P_I_A2_Mask->cols() << ")" << ", I_NRows_Im = " << I_NRows_Im << endl;
                (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: m(=" << m << ") >= P_I_A2_Mask->rows(=" << P_I_A2_Mask->rows() << ")" << ", I_NRows_Im = " << I_NRows_Im << endl;
                return false;
              }
              if (n >= P_I_A2_Mask->cols())
              {
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: n(=" << n << ") >= P_I_A2_Mask->cols(=" << P_I_A2_Mask->cols() << "), (*P_I_A2_Mask).rows(=" << P_I_A2_Mask->rows() << "), P_I_A2_Mask->size() = " << P_I_A2_Mask->size() << ", I_NCols_Im = " << I_NCols_Im << endl;
                (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: n(=" << n << ") >= (*P_I_A2_Mask).rows(=" << P_I_A2_Mask->rows() << "), P_I_A2_Mask->size() = " << P_I_A2_Mask->size() << ", I_NCols_Im = " << I_NCols_Im << endl;
                return false;
              }

              BKLArr(temprow, tempcol) = OOVecArr(o) * D_A2_Mask(m,n);

              #ifdef __DEBUG_FITS_SLITFUNC_N__
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=0; n<NCols(=" << I_NCols_Im << "); n++): for(o(=" << o << ")=0; o<BKLIndVecArr(=" << BKLIndVecArr.size() << "); o++): BKLArr(((n * this->I_OverSample) + IFirst + BKLIndVecArr(o) = " << (n * this->I_OverSample) + IFirst + BKLIndVecArr(o) << ")(= temprow=" << temprow << ", tempcol=" << tempcol << ")) set to " << BKLArr(temprow, tempcol) << endl;
            //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=0; n<NCols(=" << I_NCols_Im << "); n++): for(o(=" << o << ")=0; o<BKLIndVecArr(=" << BKLIndVecArr.size() << "); o++): BKLArr(((n * this->I_OverSample) + IFirst + BKLIndVecArr(o) = " << (n * this->I_OverSample) + IFirst + BKLIndVecArr(o) << ")(=^ temprow=" << temprow << ", tempcol=" << tempcol << ") set to " << BKLArr(temprow, tempcol) << endl;
              #endif
              //              }
            }/// end for (int o = 0; o < BKLIndVecArr.size(); o++)
//  #ifdef __DEBUG_FITS_SLITFUNC_N__
//            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=0; n<NRows(=" << I_NRows_Im << "); n++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
  ///          (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=0; n<NRows(=" << I_NRows_Im << "); n++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
//  #endif

            //            CString bklfile("bkl");
            //            bklfile+=n;
            //            bklfile+=".dat";
            //            ofstream *ofs_bkl = new ofstream(bklfile.Get());
            //            (*ofs_bkl) << BKLArr << endl;
            ///      endfor
          }/// end for (int n = 0; n < I_NCols_Im; n++)
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
          #endif

          //          (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 7. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OOVecArr set to " << OOVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OOVecArr set to " << OOVecArr << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
          #endif

          ///      oo=o(osample,osample)
          OOVecArr.resize(1);
          OOVecArr(0) = OArr(this->I_OverSample, this->I_OverSample);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OOVecArr set to " << OOVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OOVecArr set to " << OOVecArr << endl;
          #endif

          ///      for l=1,nrow-1 do $
          for (int n = 1; n < I_NCols_Im; n++)
          {
            ///        bkl(l*osample+i1,osample)=oo*msk(i,l)
            if ((n*this->I_OverSample) + IFirst >= BKLArr.rows())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: (n*this->I_OverSample) + IFirst = " << (n*this->I_OverSample) + IFirst << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: (n*this->I_OverSample) + IFirst = " << (n*this->I_OverSample) + IFirst << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
              return false;
            }
            BKLArr((n * this->I_OverSample) + IFirst, this->I_OverSample) = OOVecArr(0) * D_A2_Mask(m, n);
          }/// end for (int n = 1; n < I_NCols_Im; n++)
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
          #endif

          ///      bkl(nrow*osample+i1,osample)=omega(osample)^2*msk(i,nrow-1)
          if (I_NCols_Im * this->I_OverSample + IFirst >= BKLArr.rows())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: I_NCols_Im(=" << I_NCols_Im << ") * this->I_OverSample(=" << this->I_OverSample << ") + IFirst(=" << IFirst << ") = " << I_NCols_Im * this->I_OverSample + IFirst << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: I_NCols_Im * this->I_OverSample + IFirst = " << I_NCols_Im * this->I_OverSample + IFirst << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
            return false;
          }
          BKLArr((I_NCols_Im * this->I_OverSample) + IFirst, this->I_OverSample) = pow(OmegaVecArr(this->I_OverSample),2) * D_A2_Mask(m, I_NCols_Im - 1);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr((I_NCols_Im * this->I_OverSample) + IFirst=" << (I_NCols_Im * this->I_OverSample) + IFirst << ", this->I_OverSample=" << this->I_OverSample << ") set to " << BKLArr((I_NCols_Im * this->I_OverSample) + IFirst, this->I_OverSample) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr((I_NCols_Im * this->I_OverSample) + IFirst=" << (I_NCols_Im * this->I_OverSample) + IFirst << ", this->I_OverSample=" << this->I_OverSample << ") set to " << BKLArr((I_NCols_Im * this->I_OverSample) + IFirst, this->I_OverSample) << endl;
          #endif
          ///      for m=0L,osample-1L do $
          for (int o = 0; o < this->I_OverSample; o++)
          {
            ///        bkl(osample-m:n-1L,m)=bkl(0L:n-1L-osample+m,2L*osample-m)
            if (I_NPixSlitF-1 >= BKLArr.rows())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: N-1 = " << I_NPixSlitF-1 << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: N-1 = " << I_NPixSlitF-1 << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
              return false;
            }
            if (o >= BKLArr.cols())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: o = " << o << " >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: o = " << o << " >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
              return false;
            }
            if (2*this->I_OverSample-o >= BKLArr.cols())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: 2*this->I_OverSample-o = " << 2*this->I_OverSample-o << " >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: 2*this->I_OverSample-o = " << 2*this->I_OverSample-o << " >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
              return false;
            }
            #ifdef __DEBUG_FITS_SLITFUNC_N__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(o(=" << o << ")=0; o<this->I_OverSample(=" << this->I_OverSample << "); o++): BKLARR(Range = (this->I_OverSample - o = " << this->I_OverSample - o << ", " << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(o(=" << o << ")=0; o<this->I_OverSample(=" << this->I_OverSample << "); o++): I_NPixSlitF(=" << I_NPixSlitF - 1 << " - 1 = " << I_NPixSlitF - 1 << "), o = " << o << ") = " << BKLArr(Range(this->I_OverSample-o, I_NPixSlitF - 1), o) << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(o(=" << o << ")=0; o<this->I_OverSample(=" << this->I_OverSample << "); o++): BKLARR(Range = (0, I_NPixSlitF(=" << I_NPixSlitF - 1 << " - 1 - this->I_OverSample + o) = " << I_NPixSlitF - 1 - this->I_OverSample + o << "), 2 * this->I_OverSample - o) = " << 2*this->I_OverSample - o << ") = " << BKLArr(Range(0, I_NPixSlitF - 1 - this->I_OverSample - o), 2 * this->I_OverSample - o) << endl;
            #endif

            BKLArr(Range(this->I_OverSample-o, I_NPixSlitF - 1), o) = BKLArr(Range(0, I_NPixSlitF - 1 - this->I_OverSample + o), 2 * this->I_OverSample - o);
            #ifdef __DEBUG_FITS_SLITFUNC_N__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(o(=" << o << ")=0; o<this->I_OverSample(=" << this->I_OverSample << "); o++): BKLArr(Range(this->I_OverSample-o=" << this->I_OverSample-o << ", I_NPixSlitF-1=" << I_NPixSlitF-1 << "),o=" << o << ") set to " << BKLArr(Range(this->I_OverSample-o, I_NPixSlitF - 1), o) << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(o(=" << o << ")=0; o<this->I_OverSample(=" << this->I_OverSample << "); o++): BKLArr(Range(this->I_OverSample-o=" << this->I_OverSample-o << ", N-1=" << N-1 << "),o=" << o << ") set to " << BKLArr(Range(this->I_OverSample-o, N - 1), o) << endl;
            #endif

          }/// end for (int o = 0; o < this->I_OverSample; o++)
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
          #endif

          ///      Akl=Akl+sp(i)^2*bkl
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): AKLArr = " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): AKLArr = " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
            D_SPVecPow = pow(SPVecArr(m), 2);
            D_A2_SPVecTimesBKLArr.resize(BKLArr.rows(), BKLArr.cols());
            D_A2_SPVecTimesBKLArr = 0.;
            D_A2_SPVecTimesBKLArr = D_SPVecPow * BKLArr;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): D_SPVecPow(= " << D_SPVecPow << ") * BKLArr(= " << BKLArr << ") = " << D_A2_SPVecTimesBKLArr << endl;
//	    return false;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): D_SPVecPow = " << D_SPVecPow << " * BKLArr(= " << BKLArr << ") = " << D_A2_SPVecTimesBKLArr << endl;
          #endif
          if (AKLArr.size() != BKLArr.size())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: size of AKLArr(=" << AKLArr.size() << ") != size of BKLArr(=" << BKLArr.size() << ")";
            (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: size of AKLArr(=" << AKLArr.size() << ") != size of BKLArr(=" << BKLArr.size() << ")";
            return false;
          }
          #ifdef __DEBUG_FITS_SLITFUNC_N__
        //  (*P_OFS_Log) << "CFits::slit_func: I_Iter_SF = " << I_Iter_SF << ": SPVecArr(m=" << m << ") = " << SPVecArr(m) << endl;
        //  (*P_OFS_Log) << "CFits::slit_func: I_Iter_SF = " << I_Iter_SF << ": BKLArr(10,8) = " << BKLArr(10,8) << endl;
        //  (*P_OFS_Log) << "CFits::slit_func: I_Iter_SF = " << I_Iter_SF << ": BKLArr(11,8) = " << BKLArr(11,8) << endl;
        //  (*P_OFS_Log) << "CFits::slit_func: I_Iter_SF = " << I_Iter_SF << ": AKLArr(10,8) = " << AKLArr(10,8) << endl;
        //  (*P_OFS_Log) << "CFits::slit_func: I_Iter_SF = " << I_Iter_SF << ": AKLArr(11,8) = " << AKLArr(11,8) << endl;
          #endif
          AKLArr += (pow(SPVecArr(m), 2) * BKLArr);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
        //  (*P_OFS_Log) << "CFits::slit_func: I_Iter_SF = " << I_Iter_SF << ": AKLArr+=(pow(SPVecArr(m), 2) * BKLArr)(10,8) = " << AKLArr(10,8) << endl;
        //  (*P_OFS_Log) << "CFits::slit_func: I_Iter_SF = " << I_Iter_SF << ": AKLArr+=(pow(SPVecArr(m), 2) * BKLArr)(11,8) = " << AKLArr(11,8) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): AKLArr(+= (pow(SPVecArr(m), 2) * BKLArr)) set to " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
          //for (int iakl=0; iakl < AKLArr.cols(); iakl++){
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): AKLArr(+= (pow(SPVecArr(m), 2) * BKLArr))(Range::all(),iakl=" << iakl << ") set to " << AKLArr(Range::all(),iakl) << endl;//.transpose(secondDim,firstDim) << endl;
          //}
          #endif
          ///      o=dblarr(n)
          OArr.resize(I_NPixSlitF, 1);
  ///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": OArr.rows() = " << OArr.rows() << ", OArr.cols() = " << OArr.cols() << endl;
          OArr = 0.;
          ///      for l=0,nrow-1 do $
          for (int n = 0; n < I_NCols_Im; n++)
          {
            ///        o(l*osample+i1:l*osample+i1+osample)= $
            ///        imm(i,l)*weight*msk(i,l)
            OArr(Range((n * this->I_OverSample) + IFirst, ((n+1) * this->I_OverSample) + IFirst), 0) = D_A2_Im(m, n) * Weight * D_A2_Mask(m, n);
            #ifdef __DEBUG_FITS_SLITFUNC_N__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr(Range(n * this->I_OverSample) + IFirst=" << (n * this->I_OverSample) + IFirst << ", n * this->I_OverSample + IFirst + this->I_OverSample=" << n * this->I_OverSample + IFirst + this->I_OverSample << "), 0) set to " << OArr(Range((n * this->I_OverSample) + IFirst, n * this->I_OverSample + IFirst + this->I_OverSample), 0) << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr(Range(n * this->I_OverSample) + IFirst=" << (n * this->I_OverSample) + IFirst << ", n * this->I_OverSample + IFirst + this->I_OverSample=" << n * this->I_OverSample + IFirst + this->I_OverSample << "), 0) set to " << OArr(Range((n * this->I_OverSample) + IFirst, n * this->I_OverSample + IFirst + this->I_OverSample), 0) << endl;
            #endif

          }
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): 2. OArr set to " << OArr << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): D_A2_Im(m,*) = " << D_A2_Im(m, Range::all()) << endl;
//            return false;
          #endif
          #ifdef __DEBUG_SLITFUNC_FILES__
            CString CS_OArr(DEBUGDIR);
	    CString *P_CS_NumB = CS_OArr.IToA(m);
	    CS_OArr += CString("OArrBySF_row");
	    CS_OArr += (*P_CS_NumB);
	    CS_OArr += CS_DebugFilesSuffix;
	    CS_OArr += CString("_Tel");
	    delete(P_CS_NumB);
	    P_CS_NumB = CS_OArr.IToA(I_Telluric);
	    CS_OArr += (*P_CS_NumB);
	    CS_OArr += CString(".dat");
	    Array<double, 1> D_A1_OArrBySF(OArr.rows());
	    D_A1_OArrBySF = OArr(Range::all(),0) * double(this->I_OverSample) / sum(D_A2_Im(m, Range::all()));
	    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Writing file " << CS_OArr << endl;
	    this->WriteArrayToFile(D_A1_OArrBySF, CS_OArr, CString("ascii"));
	    delete(P_CS_NumB);

  	    CS_OArr.Set(DEBUGDIR);
  	    P_CS_NumB = CS_OArr.IToA(m);
	    CS_OArr += CString("D_A2_Im_row");
	    CS_OArr += (*P_CS_NumB);
	    CS_OArr += CS_DebugFilesSuffix;
	    CS_OArr += CString("_Tel");
	    delete(P_CS_NumB);
	    P_CS_NumB = CS_OArr.IToA(I_Telluric);
	    CS_OArr += (*P_CS_NumB);
	    CS_OArr += CString(".dat");
	    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Writing file " << CS_OArr << endl;
	    this->WriteArrayToFile(D_A2_Im(m,Range::all()), CS_OArr, CString("ascii"));
	    delete(P_CS_NumB);
          #endif
          if (P_I_A2_Mask->rows() != D_A2_Mask.rows()){
            cout << "CFits::SlitFunc: ERROR: 2. P_I_A2_Mask->rows() != D_A2_Mask.rows()" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): 3. OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): *P_I_A2_Mask = " << *P_I_A2_Mask << endl;//.transpose(secondDim,firstDim) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): D_A2_Mask = " << D_A2_Mask << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
          #endif
          ///      for l=1,nrow-1 do $

          //          (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 8. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

          for (int n = 1; n < I_NCols_Im; n++)
          {
            ///        o(l*osample+i1)=imm(i,l-1)*omega(osample)*msk(i,l-1) +imm(i,l)*omega(0)*msk(i,l)
            #ifdef __DEBUG_FITS_SLITFUNC_N__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): (D_A2_Im(m,n-1)=" << D_A2_Im(m, n-1) << ")" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): ((*P_I_A2_Mask)(m,n-1)=" << (*P_I_A2_Mask)(m, n-1) << ")" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): OmegaVecArr(this->I_OverSample)=" << OmegaVecArr(this->I_OverSample) << ")" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): (D_A2_Im(m,n)=" << D_A2_Im(m, n) << ")" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): ((*P_I_A2_Mask)(m,n)=" << (*P_I_A2_Mask)(m, n) << ")" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): (OmegaVecArr(0)=" << OmegaVecArr(0) << ")" << endl;

          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): (D_A2_Im(m,n-1)=" << D_A2_Im(m, n-1) << ")" << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): ((*P_I_A2_Mask)(m,n-1)=" << (*P_I_A2_Mask)(m, n-1) << ")" << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): (OmegaVecArr(this->I_OverSample)=" << OmegaVecArr(this->I_OverSample) << ")" << endl;

          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): (D_A2_Im(m,n)=" << D_A2_Im(m, n) << ")" << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): ((*P_I_A2_Mask)(m,n)=" << (*P_I_A2_Mask)(m, n) << ")" << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): (OmegaVecArr(0)=" << OmegaVecArr(0) << ")" << endl;
            #endif
            OArr((n * this->I_OverSample) + IFirst, 0) = (D_A2_Im(m, n-1) * OmegaVecArr(this->I_OverSample) * D_A2_Mask(m, n-1)) + (D_A2_Im(m, n) * OmegaVecArr(0) * D_A2_Mask(m, n));
            #ifdef __DEBUG_FITS_SLITFUNC_N__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): OArr((n * this->I_OverSample) + IFirst=" << (n * this->I_OverSample) + IFirst << ", 0) set to " << OArr((n * this->I_OverSample) + IFirst, 0) << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): for(n(=" << n << ")=1; n<NCols(=" << I_NCols_Im << "); n++): OArr((n * this->I_OverSample) + IFirst=" << (n * this->I_OverSample) + IFirst << ", 0) set to " << OArr((n * this->I_OverSample) + IFirst, 0) << endl;
            #endif

          }/// end for (int n = 1; n < I_NCols_Im; n++)
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): 4. OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
//	    return false;
          #endif
          ///      o(i1)=imm(i,0)*omega(0)*msk(i,0)
          OArr(IFirst, 0) = D_A2_Im(m, 0) * OmegaVecArr(0) * D_A2_Mask(m, 0);
  ///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr(IFirst=" << IFirst << ", 0) set to " << OArr(IFirst, 0) << endl;//.transpose(secondDim,firstDim) << endl;

          ///      o(nrow*osample+i1)=imm(i,nrow-1)*omega(osample)*msk(i,nrow-1)
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): D_A2_Im(m, I_NCols_Im-1) = " << D_A2_Im(m, I_NCols_Im-1) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OmegaVecArr(this->I_OverSample) = " << OmegaVecArr(this->I_OverSample) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): (*P_I_A2_Mask)(m, I_NCols_Im-1) = " << (*P_I_A2_Mask)(m, I_NCols_Im-1) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): D_A2_Mask(m, I_NCols_Im-1) = " << D_A2_Mask(m, I_NCols_Im-1) << endl;
          #endif
          OArr((I_NCols_Im * this->I_OverSample) + IFirst, 0) = D_A2_Im(m, I_NCols_Im - 1) * OmegaVecArr(this->I_OverSample) * D_A2_Mask(m, I_NCols_Im - 1);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr((D_A2_Im.cols(=" << I_NCols_Im << ") * this->I_OverSample=" << I_OverSample << ") + IFirst=" << IFirst << ", 0) set to " << OArr((I_NCols_Im * this->I_OverSample) + IFirst, 0) << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr((I_NCols_Im * this->I_OverSample) + IFirst, 0) set to " << OArr((I_NCols_Im * this->I_OverSample) + IFirst, 0) << endl;//.transpose(secondDim,firstDim) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): 5. OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
//	    return false;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): SPVecArr(m) = " << SPVecArr(m) << endl;
          #endif
          ///      Bl=Bl+sp(i)*o
          BLVecArr(Range::all()) += ((SPVecArr(m) * OArr(Range::all(), 0)));
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": end for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BLVecArr set to " << BLVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": end for(m(=" << m << ")=0; m<NRows(=" << I_NRows_Im << "); m++): BLVecArr set to " << BLVecArr << endl;
          #endif
        } /** end for (int m = 0; m < I_NCols_Im; m++) **/

        //        (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 9. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": end for(m=0; m<NRows; m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": end for(m=0; m<NRows; m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": end for(m=0; m<NRows; m++): BLVecArr set to " << BLVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": end for(m=0; m<NRows; m++): BLVecArr set to " << BLVecArr << endl;
//	  return false;
        #endif

        ///    lambda = lamb_sf*total(Akl(*,osample))/n
        //Lambda = Lamb_SF * sum(AKLArr(Range::all(), this->I_OverSample)) / I_NPixSlitF;
        //#ifdef __DEBUG_FITS_SLITFUNC_N__
        //  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Lambda set to Lamb_SF(=" << Lamb_SF << ")*total(AKLArr(*,this->I_OverSample)=" << AKLArr(Range::all(), this->I_OverSample) << ")=" << sum(AKLArr(Range::all(), this->I_OverSample)) << " =>  =  " << Lambda << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": Lambda set to Lamb_SF(=" << Lamb_SF << ")*total(AKLArr(*,this->I_OverSample)=" << AKLArr(Range::all(), this->I_OverSample) << ")=" << sum(AKLArr(Range::all(), this->I_OverSample)) << " =>  =  " << Lambda << endl;
        //#endif
  /**
   *  if(keyword_set(wing_smooth_factor) and iter gt 1) then begin
;        lambda=lambda*(1.+wing_smooth_factor*(2.d0*dindgen(n)/(n-1)-1.d0)^2)
        lambda=lambda*(1.+wing_smooth_factor/(sf>1.d-5))
      endif else begin
        lambda=replicate(lambda,n)
      endelse
   **/
        Lambda = Lamb_SF * sum(AKLArr(Range::all(), I_OverSample)) / I_NPixSlitF;
        P_TempString->Set("WING_SMOOTH_FACTOR");
        Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString);
        Array<double, 1> D_A1_Lamb_SF(I_NPixSlitF);
        if (Pos >= 0)
        {
          D_WingSmoothFactor = *(double*)ArgV_In[Pos];
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(WING_SMOOTH_FACTOR): D_WingSmoothFactor set to " << D_WingSmoothFactor << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SF): Lamb_SF set to " << Lamb_SF << endl;
        }
        if (Pos >= 0 && D_WingSmoothFactor > 0.){
	  if (I_Iter_SF == 1){
            Array<double, 1> *P_D_A1_DIndGen = this->DIndGenArr(I_NPixSlitF);
	    D_A1_Lamb_SF = Lambda * (1. + D_WingSmoothFactor * pow2(2. * (*P_D_A1_DIndGen) / (I_NPixSlitF - 1) - 1.));
	    delete(P_D_A1_DIndGen);
	  }
	  else{
	    if (SFVecArr.size() != I_NPixSlitF){
	      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(WING_SMOOTH_FACTOR): ERROR: SFVecArr.size(=" << SFVecArr.size() << ") != I_NPixSlitF=" << I_NPixSlitF << " => Returning FALSE" << endl;
	      return false;
	    }
            SFVecArrTemp.resize(SFVecArr.size());
            SFVecArrTemp = SFVecArr;
            #ifdef __DEBUG_FITS_SLITFUNC_N__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(WING_SMOOTH_FACTOR): 1. SFVecArrTemp set to " << SFVecArrTemp << endl;
            #endif
            for (int m=0; m<SFVecArrTemp.size(); m++){
              if (SFVecArrTemp(m) < 0.00001)
	        SFVecArrTemp(m) = 0.00001;
	    }
            #ifdef __DEBUG_FITS_SLITFUNC_N__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(WING_SMOOTH_FACTOR): 2. SFVecArrTemp set to " << SFVecArrTemp << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(WING_SMOOTH_FACTOR): Lambda = " << Lambda << endl;
            #endif
            D_A1_Lamb_SF = Lambda * (1. + D_WingSmoothFactor / (SFVecArrTemp));
	  }
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(WING_SMOOTH_FACTOR): D_A1_Lamb_SF set to " << D_A1_Lamb_SF << endl;
          #endif
//          return false;
        }/// end if (Pos >= 0 && D_WingSmoothFactor > 0.){
        else{
          Array<double, 1> *P_D_A1_Lamb_SF = this->Replicate(Lambda, I_NPixSlitF);
          D_A1_Lamb_SF = (*P_D_A1_Lamb_SF);
          delete(P_D_A1_Lamb_SF);
        }

        /**
        1st order Tikhonov regularization (minimum 1st derivatives)
        Add the following 3-diagonal matrix * lambda:
          1 -1  0  0  0  0
        -1  2 -1  0  0  0
          0 -1  2 -1  0  0
          0  0 -1  2 -1  0
              .  .  .
        **/
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Start 1st order Tikhonov: AKLArr = " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Start 1st order Tikhonov: D_A1_Lamb_SF = " << D_A1_Lamb_SF << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: Start 1st order Tikhonov: AKLArr = " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        #endif
        //return false;

        ///    Akl(  0,osample)=Akl(  0,osample)+lambda   ; +lambda to the upper-left element
        AKLArr(0, this->I_OverSample) += D_A1_Lamb_SF(0); /** + Lambda to the upper-left element **/
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(0,this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(0,this->I_OverSample) << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(0,this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(0,this->I_OverSample) << endl;
        #endif

        ///    Akl(n-1,osample)=Akl(n-1,osample)+lambda   ; and to the lower-right
        AKLArr(I_NPixSlitF-1,this->I_OverSample) += D_A1_Lamb_SF(I_NPixSlitF - 1); /** and to the lower-right **/
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(I_NPixSlitF-1=" << I_NPixSlitF-1 << ",this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(I_NPixSlitF-1,this->I_OverSample) << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(N-1=" << N-1 << ",this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(N-1,this->I_OverSample) << endl;
        #endif

        ///    Akl(1L:n-2L,osample)=Akl(1L:n-2L,osample)+2.*lambda    ; +2*lambda to the rest of the main diagonal
        AKLArr(Range(1,I_NPixSlitF-2), this->I_OverSample) += 2. * D_A1_Lamb_SF(Range(1, I_NPixSlitF-2)); /** +2*Lambda to the rest of the main diagonal **/
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(Range(1,I_NPixSlitF-2=" << I_NPixSlitF-2 << "),this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(Range(1,I_NPixSlitF-2),this->I_OverSample) << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(Range(1,N-2=" << N-2 << "),this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(Range(1,N-2),this->I_OverSample) << endl;
        #endif

        ///    Akl(0L:n-2L,osample+1L)=Akl(0L:n-2L,osample+1L)-lambda ; -lambda to the upper sub-diagonal
        AKLArr(Range(0, I_NPixSlitF - 2), this->I_OverSample + 1) -= D_A1_Lamb_SF(Range(0, I_NPixSlitF - 2)); /** -Lambda to the upper sub-diagonal **/
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(Range(0,I_NPixSlitF-2=" << I_NPixSlitF-2 << "),this->I_OverSample+1=" << this->I_OverSample+1 << ") set to " << AKLArr(Range(0,I_NCols_Im-2),this->I_OverSample+1) << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(Range(0,N-2=" << N-2 << "),this->I_OverSample+1=" << this->I_OverSample+1 << ") set to " << AKLArr(Range(0,N-2),this->I_OverSample+1) << endl;
        #endif

        ///    Akl(1L:n-1L,osample-1L)=Akl(1L:n-1L,osample-1L)-lambda ; -lambda to the lower sub-diagonal
        AKLArr(Range(1, I_NPixSlitF - 1), this->I_OverSample - 1) -= D_A1_Lamb_SF(Range(1, I_NPixSlitF - 1)); /** -Lambda to the lower sub-diagonal **/
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(Range(1,I_NPixSlitF-1=" << I_NPixSlitF-1 << "),this->I_OverSample-1=" << this->I_OverSample-1 << ") set to " << AKLArr(Range(1,I_NPixSlitF-1),this->I_OverSample-1) << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 1st order Tikhonov: AKLArr(Range(1,N-1=" << N-1 << "),this->I_OverSample-1=" << this->I_OverSample-1 << ") set to " << AKLArr(Range(1,N-1),this->I_OverSample-1) << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Start. 1st order Tikhonov: AKLArr = " << AKLArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: 1st order Tikhonov: AKLArr = " << AKLArr << endl;
        #endif

        /**
        2nd order Tikhonov regularization (minimum 2nd derivative)
        Add the following 5-diagonal matrix * lambda:
          1 -2  1  0  0  0
        -2  5 -4  1  0  0
          1 -4  6 -4  1  0
          0  1 -4  6 -4  1
              .  .  .
        **/
        ///    m = CALL_EXTERNAL(band_solv_name, 'bandsol', $
        ///    Akl, Bl, n, 2*osample+1L)
        void **PP_Void = (void**)malloc(sizeof(void*) * 4);
        D_A2_AKLT.resize(AKLArr.cols(), AKLArr.rows());
  //      D_A1_AKL_Data.resize(AKLArr.cols() * AKLArr.rows());
  //      D_A1_AKL_Data = (double*)AKLArr.data();
        D_A2_AKLT = AKLArr.transpose(secondDim, firstDim);
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Start. 2nd order Tikhonov: AKLArr = " << AKLArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: AKLArr = " << AKLArr << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Start. 2nd order Tikhonov: D_A2_AKLT = " << D_A2_AKLT << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: D_A2_AKLT = " << D_A2_AKLT << endl;
        #endif
        PP_Void[0] = D_A2_AKLT.data();
        PP_Void[1] = BLVecArr.data();
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Start. 2nd order Tikhonov: BLVecArr = " << BLVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: BLVecArr = " << BLVecArr << endl;
        #endif
        PP_Void[2] = &I_NPixSlitF;
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Start. 2nd order Tikhonov: I_NPixSlitF = " << I_NPixSlitF << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: N = " << N << endl;
        #endif
        TempInt = (2 * this->I_OverSample) + 1;
        PP_Void[3] = &TempInt;
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: TempInt = " << TempInt << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: TempInt = " << TempInt << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: Starting BandSol(D_A2_AKLT=" << D_A2_AKLT << ", BLVecArr=" << BLVecArr << ", I_NPixSlitF=" << I_NPixSlitF << ", TempInt=" << TempInt << ")" << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: Starting BandSol(D_A2_AKLT=" << D_A2_AKLT << ", BLVecArr=" << BLVecArr << ", N=" << N << ", TempInt=" << TempInt << ")" << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ":     aa=a[o + n * (nd / 2)]: AKLArr.data()(N*(TempInt/2)=" << N*(TempInt/2) << ") = " << D_A1_AKL_Data[N*(TempInt/2)] << endl;

//        D_A1_AKL_Data = (double*)D_A2_AKLT.data();
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ":     aa=a[o + n * (nd / 2)]: D_A2_AKLT.data()(N*(TempInt/2)) = " << D_A1_AKL_Data[N*(TempInt/2)] << endl;

//        I_A2_Indarr_AKL = where(AKLArr > 1000000000000.,1,0);
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": sum(I_A2_Indarr_AKL) = " << sum(I_A2_Indarr_AKL) << endl;
        #endif
//          return false;
        int M = this->BandSol(4, PP_Void);
	free(PP_Void);
        AKLArr = D_A2_AKLT.transpose(secondDim, firstDim);
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: After BandSol: D_A2_AKLT=" << D_A2_AKLT << ", AKLArr=" << AKLArr << ", BLVecArr=" << BLVecArr << ", I_NPixSlitF=" << I_NPixSlitF << ", TempInt=" << TempInt << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: After BandSol: D_A2_AKLT=" << D_A2_AKLT << ", AKLArr=" << AKLArr << ", BLVecArr=" << BLVecArr << ", N=" << N << ", TempInt=" << TempInt << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: M(BandSol) = " << M << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: M(BandSol) = " << M << endl;
        #endif
//        return false;

        //        (*P_OFS_Log) << "CFits::SlitFunc: 10. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

        ///    sf=Bl/total(Bl)*osample
        SFVecArr.resize(BLVecArr.size());
        if (abs(sum(BLVecArr)) < 0.000000001)
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": WARNING: sum(BLVecArr) == 0 => Setting to 1." << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": WARNING: sum(BLVecArr) == 0 => Setting to 1." << endl;
          BLVecArr = 1.;
          //          return false;
        }
        double D_SumBLVecArr = sum(BLVecArr);
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(BLVecArr) = " << D_SumBLVecArr << endl;
        #endif
	if (D_SumBLVecArr == 0.){
	  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: sum(BLVecArr) == 0 => Returning FALSE" << endl;
	  return false;
	}
	SFVecArr = BLVecArr;
	for (int mmm=0; mmm < SFVecArr.size(); mmm++){
	  if (SFVecArr(mmm) < 0.)
	    SFVecArr(mmm) = 0.;
	}
        SFVecArr = SFVecArr / D_SumBLVecArr * this->I_OverSample;

//	cout << "CFits::SlitFunc: d): SFVecArr = " << SFVecArr << endl;
//	return false;

        #ifdef __DEBUG_FITS_SLITFUNC_N__
          CString CS_OArr("SFVecArr");
	  CS_OArr += CS_DebugFilesSuffix;
	  CS_OArr += CString("_Tel");
          CString *P_CS_NumB = CS_OArr.IToA(I_Telluric);
          CS_OArr += (*P_CS_NumB);
	  CS_OArr += CString(".dat");
	  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Writing File " << SFVecArr << endl;
          this->WriteArrayToFile(SFVecArr, CS_OArr, CString("ascii"));
          delete(P_CS_NumB);

          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 4.     2nd order Tikhonov: SFVecArr ( = BLVecArr / sum(BLVecArr)(=" << sum(BLVecArr) << ") * this->I_OverSample(=" << this->I_OverSample << ")) = " << SFVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 4.     2nd order Tikhonov: SFVecArr ( = BLVecArr / sum(BLVecArr)(=" << sum(BLVecArr) << ") * this->I_OverSample(=" << this->I_OverSample << ")) = " << SFVecArr << endl;
        #endif
//	  return false;

        ///    sp_old=sp
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: SPVecArr = " << SPVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: SPVecArr = " << SPVecArr << endl;
        #endif
        SPOldVecArr.resize(SPVecArr.size());
        SPOldVecArr = SPVecArr;
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: SPOldVecArr = " << SPOldVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: SPOldVecArr = " << SPOldVecArr << endl;
        #endif

        ///    r=sp
        RVecArr.resize(SPVecArr.size());
        RVecArr_Err.resize(SPVecArr.size());
        RVecArr = SPVecArr;
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: RVecArr = " << RVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: RVecArr = " << RVecArr << endl;
        #endif

        ///    omega=replicate(weight,osample)
        OmegaVecArr.resize(this->I_OverSample);
        OmegaVecArr = Weight;
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: OmegaVecArr = " << OmegaVecArr << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": 2nd order Tikhonov: OmegaVecArr = " << OmegaVecArr << endl;

          cout << "CFits::SlitFunc: Before TempDVecArrA: *P_I_A2_MaskIn = " << *P_I_A2_MaskIn << endl;
        #endif
        /** Evaluate the new Spectrum **/
        ///    for i=0,ncol-1 do begin                    ; Evaluate the new spectrum
        for (int m = 0; m < I_NRows_Im; m++)
        {
          ///      yy=y+yycen(i)                            ; Offset SF
/**          XXVecArr = XVecArr;
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): XXVecArr set to " << XXVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): XXVecArr set to = " << XXVecArr << endl;
          #endif
          XXVecArr += XCenVecArr(m);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): XXVecArr = " << XXVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): XXVecArr = " << XXVecArr << endl;
          #endif**/
          ///      i1=where(yy ge 0 and yy lt nrow, nind)
          TempIVecArr.resize(D_A2_XX.cols());
          TempIVecArr = where((D_A2_XX(m,Range::all()) >= 0.) && (D_A2_XX(m,Range::all()) < (double)(I_NCols_Im)), 1, 0);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): TempIVecArr(where) = " << TempIVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): TempIVecArr(where) = " << TempIVecArr << endl;
          #endif
          int i_temp_sum = sum(TempIVecArr);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            if (i_temp_sum == 0)
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": sum(TempIVecArr=" << TempIVecArr << ") = 0!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": sum(TempIVecArr=" << TempIVecArr << ") = 0!!!!!!!!!!!!!!!!!!!!!!!111!!!!!!";
            }
          #endif
          this->GetIndex(TempIVecArr, I_NInd, IFirstVecArr);
  //        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": TempIVecArr = " << TempIVecArr << endl;
  //        TempIVecArr.resize(1);
          ///      i2=i1(nind-1)
          ILast = IFirstVecArr(IFirstVecArr.size()-1);
          ///      i1=i1(0)
          IFirst = IFirstVecArr(0);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): IFirst = " << IFirst << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): IFirst = " << IFirst << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): ILast = " << ILast << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): ILast = " << ILast << endl;
          #endif

          ///      omega(0)=yy(i1)
          OmegaVecArr(0) = D_A2_XX(m,IFirst);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
          #endif

          ///      ssf=reform(sf(i1:i2),osample,nrow)
          //          SSFTArr.resize(I_NCols_Im, this->I_OverSample);
          //          SSFTArr = 0.;

//	  cout << "CFits::SlitFunc: ILast = " << ILast << ", IFirst = " << IFirst << endl;
//	  cout << "CFits::SlitFunc: before resize: TempDVecArr = " << TempDVecArr << endl;
          TempDVecArr.resize(ILast - IFirst + 1);
          TempDVecArr = SFVecArr(Range(IFirst, ILast));
          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): 1. TempDVecArr set to " << TempDVecArr << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Starting Reform: I_NCols_Im = " << I_NCols_Im << ", I_OverSample = " << I_OverSample << endl;
          #endif
          Array<double, 2> *p_SSFTArr = this->Reform(TempDVecArr, (int)I_NCols_Im, this->I_OverSample);
          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_IAperture_In = " << I_IAperture_In << endl;
	    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Reform finished: p_SSFTArr set to " << *p_SSFTArr << endl;
	    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_NCols_Im = " << I_NCols_Im << endl;
          #endif
          SSFArr.resize(this->I_OverSample, (int)I_NCols_Im);
          SSFArr = p_SSFTArr->transpose(secondDim, firstDim);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": SSFArr set to " << SSFArr << endl;
          #endif
          delete p_SSFTArr;
          TempDVecArr.resize(0);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): SSFArr set to " << SSFArr << endl;//.transpose(secondDim, firstDim) << endl;
          #endif

          ///      o=reform(ssf##omega)
          tempint = SSFArr.cols();

          D_A2_TempAA.resize(SSFArr.cols(), SSFArr.rows());
          D_A2_TempAA = SSFArr.transpose(secondDim,firstDim);

          //TempDVecArr.resize(tempint);
          Array<double, 1> *p_TempDVecArrBB = this->MatrixTimesVecArr(D_A2_TempAA,
                                                                      OmegaVecArr);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): 2. TempDVecArr set to " << *p_TempDVecArrBB << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): TempDVecArr set to " << *p_TempDVecArrBB << endl;
          #endif
          OArr.resize(tempint, 1);
          //          for (int n = 0; n < SSFArr.rows(); n++)
          OArr(Range(0,tempint-1), 0) = (*p_TempDVecArrBB)(Range(0,tempint-1));
          delete p_TempDVecArrBB;
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): OArr(Range(0,tempint-1), 0) set to " << OArr(Range(0,tempint-1), 0) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): OArr(Range(0,tempint-1), 0) set to " << OArr(Range(0,tempint-1), 0) << endl;//.transpose(secondDim, firstDim) << endl;
          #endif

          ///      yyy=nrow-yy(i2)
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): D_A2_Im.cols(=" << I_NCols_Im << ") - D_A2_XX(" << m << ",ILast=" << ILast << ")(=" << D_A2_XX(m,ILast) << ") = " << I_NCols_Im - D_A2_XX(m,ILast) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): D_A2_Im.cols(=" << I_NCols_Im << ") - D_A2_XX(m,ILast=" << ILast << ")(=" << D_A2_XX(m,ILast) << ") = " << I_NCols_Im - D_A2_XX(m,ILast) << endl;
          #endif
          XXX = I_NCols_Im - D_A2_XX(m,ILast);
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): XXX set to " << XXX << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): XXX set to " << XXX << endl;
          #endif

          ///      o(0:nrow-2)=o(0:nrow-2)+reform(ssf(0,1:nrow-1))*yyy
          TempDVecArr.resize(I_NCols_Im-1);
          TempDVecArr = SSFArr(0, Range(1, I_NCols_Im-1));
          TempDVecArr *= XXX;
          OArr(Range(0, I_NCols_Im - 2), 0) += TempDVecArr;
  ///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m==" << m << "): OArr(Range(0, D_A2_Im.cols(=" << I_NCols_Im << ") - 2), 0) set to " << OArr << endl;//.transpose(secondDim, firstDim) <<         ///      o(nrow-1)=o(nrow-1)+sf(i2+1)*yyy
          OArr(I_NCols_Im - 1, 0) += SFVecArr(ILast + 1) * XXX;
          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): OArr(I_NCols_Im - 1, 0) set to " << OArr(I_NCols_Im - 1, 0) << endl;//.transpose(secondDim, firstDim) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
          #endif

          //        (*P_OFS_Log) << "CFits::SlitFunc: 11. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): D_A2_Im(m, all()) = " << D_A2_Im(m, Range::all()) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): D_A2_Im(m, all()) = " << D_A2_Im(m, Range::all()) << endl;
          #endif

          ///      r(i)  = ((imm(i,*)*msk(i,*))#o)
          D_A1_TempDVecArr.resize(I_NCols_Im);
          D_A1_TempDVecArr = D_A2_Im(m, Range::all());
          D_A1_TempDVecArr *= D_A2_Mask(m, Range::all());
          #ifdef __DEBUG_FITS_SLITFUNC__
	    cout << "CFits::SlitFunc: D_A1_TempDVecArr: D_A2_Im(m=" << m << ", Range::all()) = " << D_A2_Im(m, Range::all()) << endl;
	    cout << "CFits::SlitFunc: D_A1_TempDVecArr: P_I_A2_Mask(m=" << m << ", Range::all()) = " << (*P_I_A2_Mask)(m, Range::all()) << endl;
	    cout << "CFits::SlitFunc: D_A1_TempDVecArr: D_A2_Mask(m=" << m << ", Range::all()) = " << D_A2_Mask(m, Range::all()) << endl;
          #endif
	  D_A1_TempDVecArr_Err.resize(I_NCols_Im);
	  D_A1_TempDVecArr_Err = (*P_D_A2_Errors)(m, Range::all());
          D_A1_TempDVecArr_Err *= D_A2_Mask(m, Range::all());

          D_A1_TempDVecArrAA.resize(OArr.rows());
          D_A1_TempDVecArrAA = OArr(Range::all(), 0);
          #ifdef __DEBUG_FITS_SLITFUNC__
  	    cout << "CFits::SlitFunc: D_A1_TempDVecArr = " << D_A1_TempDVecArr << endl;
	    cout << "CFits::SlitFunc: D_A1_TempDVecArrAA = " << D_A1_TempDVecArrAA << endl;
          #endif
          if (D_A1_TempDVecArr.size() != D_A1_TempDVecArrAA.size())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: D_A1_TempDVecArr.size(=" << D_A1_TempDVecArr.size() << ")=(" << D_A1_TempDVecArr << ") != D_A1_TempDVecArrAA.size(=" << D_A1_TempDVecArrAA.size() << ") = (" << D_A1_TempDVecArrAA << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: D_A1_TempDVecArr.size(=" << D_A1_TempDVecArr.size() << ")=(" << D_A1_TempDVecArr << ") != D_A1_TempDVecArrAA.size(=" << D_A1_TempDVecArrAA.size() << ") = (" << D_A1_TempDVecArrAA << ")" << endl;
            return false;
          }

          RVecArr(m) = this->VecArrAScalarB(D_A1_TempDVecArr, D_A1_TempDVecArrAA);
          RVecArr_Err(m) = this->VecArrAScalarB(D_A1_TempDVecArr_Err, D_A1_TempDVecArrAA);
          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): RVecArr(m) set to " << RVecArr(m) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): RVecArr(m) set to " << RVecArr(m) << endl;
          #endif
          ///      sp(i) = total(o^2*msk(i,*))
          TempDVecArr.resize(OArr.rows());
          TempDVecArr = (pow2(OArr(Range::all(), 0)));
          TempDVecArr(Range::all()) *= D_A2_Mask(m, Range::all());
//          #ifdef __DEBUG_FITS_SLITFUNC__
//            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): TempDVecArrA set to " << TempDVecArrA << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): TempDVecArrA set to " << TempDVecArrA << endl;
//          #endif
          SPVecArr(m) = sum(TempDVecArr);
          #ifdef __DEBUG_FITS_SLITFUNC_SF__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): SPVecArr(m=" << m << ") set to " << SPVecArr(m) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): SPVecArr(m=" << m << ") set to " << SPVecArr(m) << endl;
          #endif
//	    return false;
          ///      if(sp(i) eq 0.d0) then $
          ///        sp(i)=total(o^2)
          if (fabs(SPVecArr(m)) < 0.000001)
          {
            SPVecArr(m) = sum(pow2(OArr));
            #ifdef __DEBUG_FITS_SLITFUNC_SF__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): was == 0: SPVecArr(m=" << m << ") set to " << SPVecArr << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": for(m==" << m << "): was == 0: SPVecArr(m=" << m << ") set to " << SPVecArr(m) << endl;
            #endif

          }

          ///if(iter gt 1) then begin

          ///Locate and mask outliers
          if (I_Iter_SF > 1)
          {
  ///          P_TempString->Set("NOISE");
  ///          Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString);
  ///          if (Pos >= 0)
  ///          {
  ///            Dev = *(double*)ArgV_In[Pos];
  ///#ifdef __DEBUG_FITS_SLITFUNC_N__
  ///            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(NOISE): Dev set to " << Dev << endl;
  ///  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(NOISE): Dev set to " << Dev << endl;
  ///#endif
  ///          }
            TempDVecArr.resize(I_NCols_Im);
            TempDVecArr = 0.;
            //TempDVecArrA.resize(I_NCols_Im);
            //TempDVecArrA = 0.;
            TempDVecArrB.resize(OArr.rows());
            TempDVecArrB = 0.;
            TempDVecArrC.resize(OArr.rows());
            TempDVecArrC = 0.;
            TempDVecArrD.resize(OArr.rows());
            TempDVecArrD = 0.;

            TempDVecArr = D_A2_Im(m, Range::all());
            #ifdef __DEBUG_FITS_SLITFUNC__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: TempDVecArr set to " << TempDVecArr << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: TempDVecArr set to " << TempDVecArr << endl;
            #endif

  //          P_CS_MySF = new CString(DEBUGDIR);
  //          *P_CS_MySF += CString("D_A2_Im_Minus_Sky_new");
  //          P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
  //          *P_CS_MySF += *P_CS_MySFTemp;
  //          *P_CS_MySF += CString(".fits");
  //          this->WriteFits(&D_A2_Im, *P_CS_MySF);
  //          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": File " << *P_CS_MySF << " written" << endl;
  //          delete(P_CS_MySF);
  //          delete(P_CS_MySFTemp);
            TempDVecArrB = OArr(Range::all(), 0);
            #ifdef __DEBUG_FITS_SLITFUNC__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: TempDVecArrB set to " << TempDVecArrB << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: TempDVecArrB set to " << TempDVecArrB << endl;
            #endif

//  cout << "CFits::SlitFunc: *P_I_A2_Mask = " << *P_I_A2_Mask << endl;
//  cout << "CFits::SlitFunc: D_A2_Mask = " << D_A2_Mask << endl;
//  return false;
            this->CastIntArrToDblArr((*P_I_A2_Mask), D_A2_Mask);
//    cout << "CFits::SlitFunc: m=" << m << ": I_Iter_SF = " << I_Iter_SF << ": I_Iter_Sky = " << I_Iter_Sky << ": D_A2_Mask set to " << D_A2_Mask << endl;
            if (P_I_A2_Mask->rows() != D_A2_Mask.rows()){
              cout << "CFits::SlitFunc: ERROR: 3. P_I_A2_Mask->rows() != D_A2_Mask.rows()" << endl;
              return false;
            }
            if (fabs(mean(*P_I_A2_Mask) - mean(D_A2_Mask)) > 0.0000001){
              cout << "CFits::SlitFunc: ERROR: 3. mean(P_I_A2_Mask)(=" << mean(*P_I_A2_Mask) << ") != mean(D_A2_Mask)(=" << mean(D_A2_Mask) << ")" << endl;
              return false;
            }




            #ifdef __PISKUNOV_ORIG__
///        norm=(r[i]/sp[i])
///        j=where(abs((imm[i,*]-norm*o)) gt 6.*dev,nj,COMPLEMENT=b)
///        if(nj gt 0) then begin
///          msk(i,j)=0B
///        endif
///        if(nj lt nrow) then msk[i,b]=1B*(mmsk[use_col,*])[i,b]
///        dev_new=dev_new+total(msk[i,*]*(imm[i,*]-norm*o)^2)
              double D_Norm = RVecArr(m) / SPVecArr(m);
	      Array<int, 1> I_A1_IndArr(D_A2_Im.cols());
	      I_A1_IndArr = where(fabs(D_A2_Im(m, Range::all()) - (D_Norm * TempDVecArrB)) > 6. * D_Dev, 1, 0);
              for (int i_ind=0; i_ind<D_A2_Im.cols(); i_ind++){
                if (I_A1_IndArr(i_ind) == 1){
  		  (*P_I_A2_Mask)(m, i_ind) = 0;
		}
		else{
  		  (*P_I_A2_Mask)(m, i_ind) = (*P_I_A2_MaskIn)(m, i_ind);
		}
	      }
	      D_Dev_New += sum((*P_I_A2_Mask)(m, Range::all()) * pow2(D_A2_Im(m, Range::all()) - D_Norm * TempDVecArrB));
//              if (this->I_MaxIterSig > 0){
//                for (int i_col = 0; i_col < D_A2_Im.cols(); i_col++){
//                  if (fabs(TempDVecArr(i_col) - (TempDVecArrB(i_col) * (RVecArr(m)/SPVecArr(m)))) > 4.5 * D_A1_Dev(i_col)){
//              if (pow2(D_A2_Mask(m, i_col) * (TempDVecArr(i_col) - (TempDVecArrB(i_col) * (RVecArr(m)/SPVecArr(m))))) > 4.5 * D_Dev){
//                  (*P_I_A2_Mask)(m, i_col) = 0.;
//                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": TempDVecArr(i_col=" << i_col << ") = " << TempDVecArr(i_col) << endl;
//                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": TempDVecArrB(i_col=" << i_col << ")(=" << TempDVecArrB(i_col) << ") * RVecArr(m=" << m << ")(=" << RVecArr(m) << ") / SPVecArr(m)(=" << SPVecArr(m) << ") = " << TempDVecArrB(i_col) * (RVecArr(m)/SPVecArr(m)) << endl;
//                  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": D_A1_Dev(i_col=" << i_col << ") = " << D_A1_Dev(i_col) << endl;
//                  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": P_I_A2_Mask(m=" << m << ", i_col=" << i_col << ") set to 0" << endl;
//                  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": i_col = " << i_col << ": fabs(TempDVecArr(i_col)(=" << TempDVecArr(i_col) << ") - (TempDVecArrB(i_col)(=" << TempDVecArrB(i_col) << ") * (RVecArr(m)(=" << RVecArr(m) << ")/SPVecArr(m)(=" << SPVecArr(m) << "))(=" << TempDVecArrB(i_col) * (RVecArr(m) / SPVecArr(m)) << ")))(=" << TempDArr(i_col) - (TempDVecArrB(i_col) * RVecArr(m) / SPVecArr(m)) << " = " << fabs(TempDVecArr(i_col) - (TempDVecArrB(i_col) * (RVecArr(m)/SPVecArr(m)))) << " > 4.5 * D_A1_Dev(i_col)(=" << D_A1_Dev(i_col) << ") = " << 4.5*D_A1_Dev(i_col) << endl;
//                }
//              } /// end if (pow2(TempDVecArr(i_col) - (TempDVecArrB(i_col) * (RVecArr(m)/SPVecArr(m)))) > 3. * D_A1_Dev(i_col))
//            } /// end for (int i_col = 0; i_col < D_A2_Im.cols(); i_col++)

/**            if (sum(TempDVecArrA) < D_A2_Im.cols())
            {
              for (int n = 0; n < TempDVecArrA.size(); n++)
              {
                if (TempDVecArrA(n) == 0)
                {
                  (*P_I_A2_Mask)(m, n) = (*P_I_A2_MaskIn)(m,n);//1;
                }
              } /// end for (int n = 0; n < TempDVecArrA.size(); n++)
            }**/
              //#ifdef __DEBUG_FITS_SLITFUNC_N__
              //  cout << "sum(*P_I_A2_MaskIn) = " << sum(*P_I_A2_MaskIn) << endl;
              //  cout << "sum(*P_I_A2_Mask) = " << sum(*P_I_A2_Mask) << endl;
              //#endif
  ///          TempDVecArrD = TempDVecArr - (TempDVecArrB * (RVecArr(m)/SPVecArr(m)));
  ///          TempDVecArrC = pow2(TempDVecArrD);
              //for (int o = 0; o < this->I_MaxIterSig; o++)
              //{
  ///              j=where(abs((imm(i,*)-r(i)/sp(i)*o)) gt 3.*dev,nj,COMPLEMENT=b)
              //  if (sum((*P_I_A2_Mask)(m, Range::all())) > 0)
              //  (*P_I_A2_Mask)(m, Range::all()) = where(fabs(TempDVecArrD) > 3. * Dev, 0, (*P_I_A2_Mask)(m, Range::all()));
              //  #ifdef __DEBUG_FITS_SLITFUNC__
              //    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: P_I_A2_Mask(m=" << m << ", Range::all()) set to " << (*P_I_A2_Mask)(m, Range::all()) << endl;
  ///        //  (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: TempDVecArrA set to " << TempDVecArrA << endl;
              //  #endif
  ///        ///  if(nj gt 0) then begin
  ///        ///    msk(i,j)=0B
  ///        ///  endif
              //  if (sum(TempDVecArrA) > 0)
              //  {
  /// //              for (int n = 0; n < TempDVecArrA.size(); n++)
  /// //              {
  /// //                if (TempDVecArrA(n) == 1)
  /// //                {
  /// //                  (*P_I_A2_Mask)(m, n) = 0.;
  /// // #ifdef __DEBUG_FITS_SLITFUNC__
  /// //                  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: (*P_I_A2_Mask)(m=" << m << ", n=" << n << ") set to " << (*P_I_A2_Mask)(m,n) << endl;
  ///                //  (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: (*P_I_A2_Mask)(m=" << m << ", n=" << n << ") set to " << (*P_I_A2_Mask)(m,n) << endl;
  /// // #endif
  ///
  /// //                }
  /// //              } /// end for (int n = 0; n < TempDVecArrA.size(); n++)
              //  } /// end if (sum(TempDVecArrA) > 0)
  ///
  ///        ///  if(nj lt nrow) then msk(i,b)=1B
  /// //            if (sum(TempDVecArrA) < I_NCols_Im)
  /// //            {
  /// //              for (int n = 0; n < TempDVecArrA.size(); n++)
  /// //              {
  /// //                if (TempDVecArrA(n) == 0)
  /// //                {
  /// //                  (*P_I_A2_Mask)(m, n) = 1.;
  /// // #ifdef __DEBUG_FITS_SLITFUNC__
  /// //                  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: (*P_I_A2_Mask)(m=" << m << ", n=" << n << ") set to " << (*P_I_A2_Mask)(m,n) << endl;
  ///                //  (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): I_Iter_SF(=" << I_Iter_SF << ") > 1: (*P_I_A2_Mask)(m=" << m << ", n=" << n << ") set to " << (*P_I_A2_Mask)(m,n) << endl;
  /// // #endif
  ///
  /// //                }
  /// //              } /// end for (int n = 0; n < TempDVecArrA.size(); n++)
  /// //            }///endif
              //}/// end for (int o = 0; o < this->I_MaxIterSig; o++)
            #endif// __PISKUNOV_ORIG__
          } /// end if (I_Iter_SF > 1)
  ///        return false;
          ///endfor
        } ///end for (int m = 0; m < I_NRows_Im; m++)

        #ifdef __PISKUNOV_ORIG__
///    if(iter gt 1) then dev=sqrt(dev_new/total(msk))
          if (I_Iter_SF > 1)
	    D_Dev = sqrt(D_Dev_New / sum(*P_I_A2_Mask));
        #endif


        #ifdef __DEBUG_FITS_SLITFUNC_FILES__
	  CS_SP.Set(CString("SPVecArr1Rows"));
          CS_SP.Add(CS_DebugFilesSuffix);
          CS_SP.Add(CString(".fits"));
          D_A2_SPTemp.resize(SPVecArr.size(), 1);
          D_A2_SPTemp(Range::all(), 0) = SPVecArr;
          this->WriteFits(&D_A2_SPTemp, CS_SP);
        #endif
        #ifdef __DEBUG_FITS_SLITFUNC_N__
          cout << "CFits::SlitFunc: After TempDVecArrA: *P_I_A2_Mask = " << *P_I_A2_Mask << endl;
          cout << "sum(*P_I_A2_MaskIn) = " << sum(*P_I_A2_MaskIn) << endl;
          cout << "sum(*P_I_A2_Mask) = " << sum(*P_I_A2_Mask) << endl;
        #endif
//              if (sum(*P_I_A2_Mask) > P_I_A2_Mask->size() / 2)
//return false;

        //        (*P_OFS_Log) << "CFits::SlitFunc: 12. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

        ///    if(keyword_set(lamb_sp)) then begin
        ///    endif else sp=r/sp
        P_TempString->Set("LAMBDA_SP");
        if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)
        {
          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): Pos = " << Pos << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): Pos = " << Pos << endl;
          #endif
          Lamb_SP = double(*(int*)ArgV_In[Pos]);
          //atof(this->GetKeyWordValueFromCStringArray(const_cast<const CString**>(Args), NArgs, (*(new CString("Lamb_SP"))))->Get());
          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): Lamb_SP set to " << Lamb_SP << endl;
//          return false;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): Lamb_SP set to " << Lamb_SP << endl;
          #endif
          if (abs(Lamb_SP) > 0.0000001)
          {
            ///      lambda = lamb_sp*total(sp)/ncol
            Lambda = Lamb_SP * sum(SPVecArr) / I_NRows_Im;
            #ifdef __DEBUG_FITS_SLITFUNC__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): Lambda set to " << Lambda << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): Lambda set to " << Lambda << endl;
            #endif
            ///      a =[0.,replicate(-lambda,ncol-1)]
            a.resize(I_NRows_Im);
            a = 0. - Lambda;
            a(0) = 0.;
            #ifdef __DEBUG_FITS_SLITFUNC__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): a set to " << a << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): a set to " << a << endl;
            #endif
            ///      b =[lambda+1.,replicate(2.*lambda+1.,ncol-2),lambda+1.]
            b.resize(I_NRows_Im);
            b = (2. * Lambda) + 1.;
            b(0) = Lambda + 1.;
            b(I_NRows_Im - 1) = Lambda + 1.;
            #ifdef __DEBUG_FITS_SLITFUNC__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): b set to " << b << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): b set to " << b << endl;
            #endif
            ///      c =[replicate(-lambda,ncol-1),0.]
            c.resize(I_NRows_Im);
            c = 0. - Lambda;
            c(I_NRows_Im - 1) = 0.;
            #ifdef __DEBUG_FITS_SLITFUNC__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): c set to " << c << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): c set to " << c << endl;
            #endif

            ///      sp=trisol(a,b,c,r/sp)
            //          SPVecArr.resize(I_NRows_Im);
            //          SPVecArr = 0.;
            if (I_NRows_Im != SPVecArr.size())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": ERROR: D_A2_Im.rows(=" << I_NRows_Im << ") != SPVecArr.size(=" << SPVecArr.size() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": ERROR: D_A2_Im.rows(=" << I_NRows_Im << ") != SPVecArr.size(=" << SPVecArr.size() << ")" << endl;
              return false;
            }
            #ifdef __DEBUG_FITS_SLITFUNC__
              cout << "CFits::SlitFunc: Before TriDag: RVecArr = " << RVecArr << endl;
              cout << "CFits::SlitFunc: Before TriDag: SPVecArr = " << SPVecArr << endl;
              cout << "CFits::SlitFunc: Before TriDag: a = " << a << endl;
              cout << "CFits::SlitFunc: Before TriDag: b = " << b << endl;
              cout << "CFits::SlitFunc: Before TriDag: c = " << c << endl;
            #endif
            TempDVecArr.resize(I_NRows_Im);
            TempDVecArr = RVecArr / SPVecArr;
            #ifdef __DEBUG_FITS_SLITFUNC__
              cout << "CFits::SlitFunc: Before TriDag: TempDVecArr = " << TempDVecArr << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): TempDVecArr set to " << TempDVecArr << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): TempDVecArr set to " << TempDVecArr << endl;
            #endif
            this->TriDag(a, b, c, TempDVecArr, SPVecArr);
            #ifdef __DEBUG_FITS_SLITFUNC_SF__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): after TriDag: SPVecArr set to " << SPVecArr << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): after TriDag: SPVecArr set to " << SPVecArr << endl;
            #endif
//	    return false;

            #ifdef __DEBUG_FITS_SLITFUNC__
              CS_SP.Set(CString("SPVecArr1TriDag_IterSF"));
              CString *P_CS_IterSF = CS_SP.IToA(I_Iter_SF);
              CS_SP.Add(*P_CS_IterSF);
              delete(P_CS_IterSF);
              CS_SP.Add(CS_DebugFilesSuffix);
              CS_SP.Add(CString(".fits"));
              D_A2_SPTemp.resize(SPVecArr.size(), 1);
              D_A2_SPTemp(Range::all(), 0) = SPVecArr;
              this->WriteFits(&D_A2_SPTemp, CS_SP);
            #endif
//	    return false;

//            TempDVecArr = RVecArr_Err / SPVecArr;
//            #ifdef __DEBUG_FITS_SLITFUNC__
//              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): TempDVecArr set to " << TempDVecArr << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): TempDVecArr set to " << TempDVecArr << endl;
//            #endif
//            this->TriDag(a, b, c, TempDVecArr, *P_D_A1_SPErrOut);
//            #ifdef __DEBUG_FITS_SLITFUNC_SF__
//              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): after TriDag: *P_D_A1_SPErrOut set to " << *P_D_A1_SPErrOut << endl;
          //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": KeyWord_Set(LAMBDA_SP): after TriDag: SPVecArr set to " << SPVecArr << endl;
//            #endif

          }
        }
        ///else
        if (Pos < 0 || (Pos >= 0 && abs(Lamb_SP) < 0.0000001))
        {
          SPVecArr = RVecArr / SPVecArr;
//	  *P_D_A1_SPErrOut = RVecArr_Err / SPVecArr;
          #ifdef __DEBUG_FITS_SLITFUNC_SF__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": Not KeyWord_Set(LAMBDA_SP): SPVecArr set to " << SPVecArr << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": Not KeyWord_Set(LAMBDA_SP): SPVecArr set to " << SPVecArr << endl;
          #endif

          #ifdef __DEBUG_FITS_SLITFUNC__
            CS_SP.Set(CString("SPVecArr1NoLambSP_IterSF"));
            CString *P_CS_IterSF = CS_SP.IToA(I_Iter_SF);
            CS_SP.Add(*P_CS_IterSF);
            delete(P_CS_IterSF);
            CS_SP.Add(CS_DebugFilesSuffix);
            CS_SP.Add(CString(".fits"));
            D_A2_SPTemp.resize(SPVecArr.size(), 1);
            D_A2_SPTemp(Range::all(), 0) = SPVecArr;
            this->WriteFits(&D_A2_SPTemp, CS_SP);
//	    return false;
          #endif

        } /// end else if ((Pos = this->KeyWord_Set(const_cast<const CString**>(Args), NArgs, *P_TempString)) < 0)

        /**
        if(iter lt 8 and max(abs(sp-sp_old)/max(sp)) gt 1.d-5) then goto,next
        */
        #ifdef __DEBUG_FITS_SLITFUNC_SF__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": end if (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001)" << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: I_Iter_SF = " << I_Iter_SF << ": end if (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001)" << endl;
        #endif

        #ifdef __DEBUG_FITS_SLITFUNC_N__

          CS_TempFileName.Set("cfits_sp_");
          int TempIter = I_Iter_SF;
          if (TempIter > 9){
            CS_TempFileName += CString("1");
            TempIter -= 10;
          }

          if (TempIter == 0)
            CS_TempFileName += CString("0");
          if (TempIter == 1)
            CS_TempFileName += CString("1");
          if (TempIter == 2)
            CS_TempFileName += CString("2");
          if (TempIter == 3)
            CS_TempFileName += CString("3");
          if (TempIter == 4)
            CS_TempFileName += CString("4");
          if (TempIter == 5)
            CS_TempFileName += CString("5");
          if (TempIter == 6)
            CS_TempFileName += CString("6");
          if (TempIter == 7)
            CS_TempFileName += CString("7");
          if (TempIter == 8)
            CS_TempFileName += CString("8");
          if (TempIter == 9)
            CS_TempFileName += CString("9");
          CS_TempFileName += CS_DebugFilesSuffix;
          if (I_Telluric == 0)
            CS_TempFileName += CString("_Tel0.dat");
          if (I_Telluric == 1)
            CS_TempFileName += CString("_Tel1.dat");
          if (I_Telluric == 2)
            CS_TempFileName += CString("_Tel2.dat");
          if (I_Telluric == 3)
            CS_TempFileName += CString("_Tel3.dat");
          P_SP_Log = new ofstream(CS_TempFileName.Get());
          for (isp=0; isp < SPVecArr.rows(); isp++){
            (*P_SP_Log) << SPVecArr(isp) << endl;
          }
          delete(P_SP_Log);



          CS_TempFileName.Set("cfits_sf_");
          TempIter = I_Iter_SF;
          if (TempIter > 9){
            CS_TempFileName += CString("1");
            TempIter -= 10;
          }
          if (TempIter == 0)
            CS_TempFileName += CString("0");
          if (TempIter == 1)
            CS_TempFileName += CString("1");
          if (TempIter == 2)
            CS_TempFileName += CString("2");
          if (TempIter == 3)
            CS_TempFileName += CString("3");
          if (TempIter == 4)
            CS_TempFileName += CString("4");
          if (TempIter == 5)
            CS_TempFileName += CString("5");
          if (TempIter == 6)
            CS_TempFileName += CString("6");
          if (TempIter == 7)
            CS_TempFileName += CString("7");
          if (TempIter == 8)
            CS_TempFileName += CString("8");
          if (TempIter == 9)
            CS_TempFileName += CString("9");
          CS_TempFileName += CS_DebugFilesSuffix;
  	  CS_TempFileName += CString("_Tel");
          if (I_Telluric == 0)
            CS_TempFileName += CString("0.dat");
          if (I_Telluric == 1)
            CS_TempFileName += CString("1.dat");
          if (I_Telluric == 2)
            CS_TempFileName += CString("2.dat");
          if (I_Telluric == 3)
            CS_TempFileName += CString("3.dat");
          P_SF_Log = new ofstream(CS_TempFileName.Get());
          for (isf=0; isf < SFVecArr.rows(); isf++){
            (*P_SF_Log) << SFVecArr(isf) << endl;
          }
          delete(P_SF_Log);
        #endif
      } /// end if (I_Iter_SF == 1 || max(abs(SPVecArr-SPOldVecArr)/max(SPVecArr)) > 0.00001)
      else
      {
        if (I_Iter_SF != 1)
        {
          #ifdef __DEBUG_FITS_SLITFUNC_SF__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": !if (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001) => breaking while loop" << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: !if (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001) => breaking while loop" << endl;
          #endif
          break;
        }/// end if (I_Iter_SF != 1)
      }/// end else if (I_Iter_SF != 1 && max(abs(SPVecArr-SPOldVecArr)/max(SPVecArr)) <= 0.00001)
  //    return false;
      Array<double, 2> D_A2_ImTimesMask_SF(D_A2_Im.rows(), D_A2_Im.cols());
      D_A2_ImTimesMask_SF = D_A2_Im * (*P_I_A2_Mask);
      #ifdef __DEBUG_FITS_SLITFUNC_FILES__
        CString CS_ImTimesMaskSF("ImTimesMask_IterSF");
        CString *P_CS_IToA = CS_ImTimesMaskSF.IToA(I_Iter_SF);
        CS_ImTimesMaskSF.Add(*P_CS_IToA);
        delete(P_CS_IToA);
        CS_ImTimesMaskSF.Add(CS_DebugFilesSuffix);
        CS_ImTimesMaskSF.Add(".fits");
        this->WriteFits(&D_A2_ImTimesMask_SF, CS_ImTimesMaskSF);
      #endif
    } /// end while(I_Iter_SF < I_MaxIterSF)
//    return false;



    //    (*P_OFS_Log) << "CFits::SlitFunc: 13. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

    /// jbad=0L
    /// if(arg_present(im_out)) then begin
    ///  ncol=n_elements(ycen)
    (*P_I_A1_JBadVecArr)(0) = 0;
    P_TempString->Set("IM_OUT");
    if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)
    {
      if (P_D_A2_Im_Out != NULL)
        delete P_D_A2_Im_Out;
      P_D_A2_Im_Out = (Array<double, 2>*)ArgV_In[Pos];
      P_D_A2_Im_Out->resize(D_A2_Im.rows(), D_A2_Im.cols());
      (*P_D_A2_Im_Out) = 0.;
    }
//    NRowsOut = XCenVecArr.size();
    #ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): I_NRows_Im set to " << I_NRows_Im << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): I_NRows_Im set to " << I_NRows_Im << endl;
    #endif
    /**
    if(keyword_set(use_col)) then $
      sp=interpol(sp,use_col,findgen(ncol))
    */
    P_TempString->Set("USE_ROW");
    if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)// && TempIntB != 0)
    {
      /// Interpolate SPVecArr
      D_A1_Ind.resize(I_NRows_Im);
      D_A1_Ind = i;
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): KeyWord_Set(USE_ROW): MARK: INTERPOL: SPVecArr = " << SPVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: MARK: INTERPOL: KeyWord_Set(PROF_OUT): KeyWord_Set(USE_ROW): SPVecArr = " << SPVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): KeyWord_Set(USE_ROW): MARK: INTERPOL: D_A1_Ind = " << D_A1_Ind << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: MARK: INTERPOL: KeyWord_Set(PROF_OUT): KeyWord_Set(USE_ROW): D_A1_Ind = " << D_A1_Ind << endl;
      //        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): KeyWord_Set(USE_ROW): MARK: INTERPOL: FixD(UseRowVecArr) = " << FixD(UseRowVecArr) << endl;
      //        (*P_OFS_Log) << "CFits::SlitFunc: MARK: INTERPOL: KeyWord_Set(PROF_OUT): KeyWord_Set(USE_ROW): FixD(UseRowVecArr) = " << FixD(UseRowVecArr) << endl;
      #endif
      Array<double, 1> *p_tempDblVecArrA = FixD(UseRowVecArr);
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": p_tempDblVecArrA = " << *p_tempDblVecArrA << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A1_Ind = " << D_A1_Ind << endl;
      #endif
      Array<double, 1> tempDblVecArrB(1);
      if (!this->InterPol(SPVecArr, *p_tempDblVecArrA, D_A1_Ind, tempDblVecArrB)){
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: InterPol returned FALSE" << endl;
        return false;
      }
      SPVecArr = tempDblVecArrB;
      delete p_tempDblVecArrA;
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): KeyWord_Set(USE_ROW): MARK: INTERPOL: SPVecArr set to " << SPVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: MARK: INTERPOL: KeyWord_Set(PROF_OUT): KeyWord_Set(USE_ROW): SPVecArr set to " << SPVecArr << endl;
      #endif

    }///end if KeyWord_Set(USE_ROW)

    //      (*P_OFS_Log) << "CFits::SlitFunc: 13. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

    ///      omega=replicate(weight,osample)
    OmegaVecArr.resize(this->I_OverSample);
    OmegaVecArr = Weight;
    #ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): OmegaVecArr set to " << OmegaVecArr << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): OmegaVecArr set to " << OmegaVecArr << endl;
    #endif

    /*
    for i=0,ncol-1 do begin                    ; Evaluate the new spectrum
      yy=y+ycen(i)                             ; Offset SF
      i1=where(yy ge 0 and yy lt nrow, nind)
      i2=i1(nind-1)
      i1=i1(0)
    */
    D_A1_SFO.resize(SFVecArr.size());
    D_A1_SFO = SFVecArr;
    D_A1_SFO = where(D_A1_SFO < 0., 0., D_A1_SFO);
    D_A1_SFO = where(D_A1_SFO > (I_NCols_Im+1), 0., D_A1_SFO);
    double D_MinLeft = min(D_A1_SFO(Range(0, int(D_A1_SFO.size()/2))));
    double D_MinRight = min(D_A1_SFO(Range(int(D_A1_SFO.size()/2), D_A1_SFO.size()-1)));
    double D_MinWing = D_MinLeft;
    if (D_MinRight > D_MinLeft)
      D_MinWing = D_MinRight;
    if (I_Telluric == 3){
      D_A1_SFO = D_A1_SFO - D_MinWing;
      D_A1_SFO = where(D_A1_SFO < 0., 0., D_A1_SFO);
      //      D_A1_SFO = D_A1_SFO - min(D_A1_SFO);
    }

    for (int m = 0; m < I_NRows_Im; m++)  /// Evaluate the new spectrum
    {
      //        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << "); m < I_NRows_Im(=" << I_NRows_Im << "); m++): MARK MARK MARK" << endl;
//      XXVecArr = XVecArr + XCenVecArr(m);
      TempIVecArr.resize(D_A2_XX.cols());
      TempIVecArr = 0;

      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): D_A2_XX(m,*) = " << D_A2_XX(m,Range::all()) << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): D_A2_Im->cols = " << I_NCols_Im << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): D_A2_XX(m,*) = " << D_A2_XX(m,Range::all()) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): D_A2_Im->cols = " << I_NCols_Im << endl;
      #endif

      TempIVecArr = where((D_A2_XX(m,Range::all()) > 0.) && (D_A2_XX(m,Range::all()) < (double)(I_NCols_Im)), 1, 0);

      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): TempIVecArr(where) = " << TempIVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): TempIVecArr(where) = " << TempIVecArr << endl;
      #endif

      i_tmp_sum = sum(TempIVecArr);
      if (i_tmp_sum == 0)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): ERROR: i_tmp_sum == 0!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): ERROR: i_tmp_sum == 0!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
        return false;
      }
      this->GetIndex(TempIVecArr, I_NInd, IFirstVecArr);
      IFirst = IFirstVecArr(0);
      ILast = IFirstVecArr(IFirstVecArr.size() - 1);
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): IFirst set to " << IFirst << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): IFirst set to " << IFirst << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): ILast set to " << ILast << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): ILast set to " << ILast << endl;
      #endif

      ///        omega(0)=yy(i1)
      OmegaVecArr(0) = D_A2_XX(m,IFirst);
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
      #endif

      ///        ssf=reform(sf(i1:i2),osample,nrow) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      SSFArr.resize(this->I_OverSample, I_NCols_Im);
      SSFArr = 0.;
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): SFVecArr = " << SFVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): SFVecArr = " << SFVecArr << endl;
      #endif
      TempDVecArr.resize(ILast - IFirst + 1);
      TempDVecArr = SFVecArr(Range(IFirst, ILast));
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): TempDVecArr set to " << TempDVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): TempDVecArr set to " << TempDVecArr << endl;
      #endif
      if (TempDVecArr.size() != I_NCols_Im * this->I_OverSample)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: size of TempDVecArr(=" << TempDVecArr.size() << ") != D_A2_Im.cols(=" << I_NCols_Im << ") * this->I_OverSample(=" << this->I_OverSample << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: size of TempDVecArr(=" << TempDVecArr.size() << ") != D_A2_Im.cols(=" << I_NCols_Im << ") * this->I_OverSample(=" << this->I_OverSample << ")" << endl;
        return false;
      }
      Array<double, 2> *p_D_A2_SSFT = Reform(TempDVecArr, I_NCols_Im, this->I_OverSample);
      TempDVecArr.resize(0);
      SSFArr = p_D_A2_SSFT->transpose(secondDim, firstDim);
      delete p_D_A2_SSFT;
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): SSFArr set to " << SSFArr << endl;//.transpose(secondDim, firstDim) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): SSFArr set to " << SSFArr << endl;//.transpose(secondDim, firstDim) << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OmegaVecArr set to " << OmegaVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OmegaVecArr set to " << OmegaVecArr << endl;
      #endif

      ///        o=reform(reform(ssf##omega))
      OArr.resize(SSFArr.cols(), 1);
      D_A2_OT.resize(SSFArr.cols(), SSFArr.rows());
      D_A2_OT = SSFArr.transpose(secondDim, firstDim);
      if (OArr.rows() != D_A2_OT.rows())
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: OArr.rows(=" << OArr.rows() << ") != D_A2_OT.rows(=" << D_A2_OT.rows() << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: OArr.rows(=" << OArr.rows() << ") != D_A2_OT.rows(=" << D_A2_OT.rows() << ")" << endl;
        return false;
      }
      Array<double, 1> *p_TempDVecArrAA = this->MatrixTimesVecArr(D_A2_OT, OmegaVecArr);
      OArr(Range::all(), 0) = (*p_TempDVecArrAA);
      delete p_TempDVecArrAA;
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
      #endif

      ///        yyy=nrow-yy(i2)
      XXX = I_NCols_Im - D_A2_XX(m,ILast);
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): XXX set to " << XXX << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): XXX set to " << XXX << endl;
      #endif

      if (OArr.rows() < I_NCols_Im)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: OArr.rows(=" << OArr.rows() << ") < D_A2_Im.cols(=" << I_NCols_Im << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: OArr.rows(=" << OArr.rows() << ") < D_A2_Im.cols(=" << I_NCols_Im << ")" << endl;
        return false;
      }
      if (SSFArr.cols() < I_NCols_Im)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: SSFArr.cols(=" << SSFArr.cols() << ") < D_A2_Im.cols(=" << I_NCols_Im << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: SSFArr.cols(=" << SSFArr.cols() << ") < D_A2_Im.cols(=" << I_NCols_Im << ")" << endl;
        return false;
      }
      if (SFVecArr.size() < ILast + 2)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: SFVecArr.size(=" << SFVecArr.size() << ") < ILast(=" << ILast << ")+2" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: SFVecArr.size(=" << SFVecArr.size() << ") < ILast(=" << ILast << ") + 2" << endl;
        return false;
      }
      ///        o(0:nrow-2)=o(0:nrow-2)+reform(ssf(0,1:nrow-1))*yyy
      OArr(Range(0, I_NCols_Im - 2), 0) += (SSFArr(0, Range(1, I_NCols_Im - 1)) * XXX);
      ///        o(nrow-1)=o(nrow-1)+sf(i2+1)*yyy
      OArr(I_NCols_Im - 1, 0) += (SFVecArr(ILast + 1) * XXX);
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
      #endif

      ///        j=where(abs(im(i,*)-sp(i)*o) lt 3*dev,nj,COMPLEMENT=b)
      /** i => m, j => IFirstVecArr, b => TempIVecArr, nj => NInd **/
      if (OArr.rows() != I_NCols_Im)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: OArr.row(=" << OArr.rows() << ") < D_A2_Im.cols(=" << I_NCols_Im << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: OArr.rows(=" << OArr.rows() << ") < D_A2_Im.cols(=" << I_NCols_Im << ")" << endl;
        return false;
      }
      IVecArr.resize(I_NCols_Im);
  //      D_A2_ImTimesMask = D_A2_Im * (*P_I_A2_Mask);
  //      D_A2_SFTimesMask = D_A2_MySF * (*P_I_A2_Mask);
  ///      P_TempString->Set("NOISE");
  ///      if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)
  ///      {
  ///        Dev = *(double*)ArgV_In[Pos];
  ///#ifdef __DEBUG_FITS_SLITFUNC_N__
  ///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(NOISE): Dev set to " << Dev << endl;
  ///  //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(NOISE): Dev set to " << Dev << endl;
  ///#endif
  ///      }
  ///      if (Pos < 0 || (Pos >= 0 && abs(Dev) < 0.00000000000000001))
  ///      {
  ///        if (sum((*P_I_A2_Mask)(m, Range::all())) < 1 || Dev == 0.)
  ///        {
  ///          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 2. Warning: Mask(m=" << m << ",*) == 0" << endl;
  ///          Dev = 1.;
  ///        }
  ///        else{
  ///          Dev = sqrt(sum((*P_I_A2_Mask)(m, Range::all()) * pow2(D_A2_Im(m, Range::all()) - SPVecArr(m) * OArr(Range::all(), 0))) / double(sum((*P_I_A2_Mask)(m, Range::all()))));
  ///        }
  ///      }
  ///      if (sum((*P_I_A2_Mask)(m, Range::all())) < 1 || Dev == 0.)
  ///      {
  ///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 3. Warning: Mask(m=" << m << ",*) == 0" << endl;
  ///        Dev = 1.;
  ///      }
  ///#ifdef __DEBUG_FITS_SLITFUNC__
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): Dev set to " << Dev << endl;
  ///    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): IVecArr(where) set to " << IVecArr << endl;
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): P_I_A2_Mask(m, Range::all()) = " << (*P_I_A2_Mask)(m, Range::all()) << endl;
  ///#endif
  ///      if (sum((*P_I_A2_Mask)(m, Range::all())) > 0)
  ///        (*P_I_A2_Mask)(m, Range::all()) = where(fabs((D_A2_Im(m, Range::all()) - SPVecArr(m) * OArr(Range::all(), 0))) > 3. * Dev, 0, (*P_I_A2_Mask)(m, Range::all()));
  ///#ifdef __DEBUG_FITS_SLITFUNC__
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): P_I_A2_Mask(m, Range::all())(where) set to " << (*P_I_A2_Mask)(m, Range::all()) << endl;
  ///    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): IVecArr(where) set to " << IVecArr << endl;
  ///#endif
      ///        j=where(abs(im(i,*)-sp(i)*o) lt 3*dev,nj,COMPLEMENT=b)
      /** i => m, j => IFirstVecArr, b => TempIVecArr, nj => NInd **/
      #ifdef __PISKUNOV_ORIG__
//        if (I_Telluric == 1){
          Array<double, 1> D_A1_TempWhere(D_A2_Im.cols());
          Array<int, 1> I_A1_IndDev(D_A2_Im.cols());
	  I_A1_IndDev = where(fabs(D_A2_Im(m, Range::all()) - SPVecArr(m) * OArr(Range::all(), 0)) < 3. * D_Dev, 1, 0);
  	  Array<int, 1> *P_I_A1_IndDev = this->GetIndex(I_A1_IndDev, I_NInd);

//        (*P_I_A2_Mask)(m,Range::all())
///        if(nj gt 2) then begin
///          ss=total((im(i,j)-sp(i)*o(j))^2)
///          xx=total((o(j)-mean(o(j)))^2)*(nj-2)
///          unc(i)=ss/xx
///        endif else unc(i)=0.
          double D_SS = 0.;
	  double D_XX = 0.;
	  if (I_NInd > 2){
	    Array<double, 1> D_A1_OArr(I_NInd);
	    for (int i_ind=0; i_ind<I_NInd; i_ind++){
	      D_A1_OArr(i_ind) = OArr((*P_I_A1_IndDev)(i_ind), 0);
	    }
	    double D_MeanO = mean(D_A1_OArr);
	    for (int i_ind=0; i_ind<I_NInd; i_ind++){
	      D_SS += pow2(D_A2_Im(m, (*P_I_A1_IndDev)(i_ind)) - SPVecArr(m) * D_A1_OArr(i_ind));
	      D_XX += pow2(D_A1_OArr(i_ind) - D_MeanO) * (I_NInd-2);
	    }
//	    cout << "CFits
            (*P_D_A1_SPErrOut)(m) = D_SS / D_XX;
//	    cout << "CFits::SlitFunc: (*P_D_A1_SPErrOut)(m) set to " << (*P_D_A1_SPErrOut)(m) << endl;
	  }
	  else{
            (*P_D_A1_SPErrOut)(m) = 0.;
	  }
          cout << "CFits::SlitFunc: (*P_D_A1_SPErrOut)(m) set to " << (*P_D_A1_SPErrOut)(m) << endl;
//	}
//	  return false;
      #endif

      I_A1_Mask.resize(P_I_A2_Mask->cols());
      I_A1_Mask = (*P_I_A2_Mask)(m, Range::all());
      this->CastIntArrToDblArr(I_A1_Mask, D_A1_Mask);
      D_A2_Mask(m, Range::all()) = D_A1_Mask;
//    cout << "CFits::SlitFunc: m = " << m << ": I_Iter_SF = " << I_Iter_SF << ": I_Iter_Sky = " << I_Iter_Sky << ": D_A2_Mask(m, Range::all()) set to " << D_A2_Mask(m, Range::all()) << endl;
      if (P_I_A2_Mask->rows() != D_A2_Mask.rows()){
        cout << "CFits::SlitFunc: ERROR: 5. P_I_A2_Mask->rows() != D_A2_Mask.rows()" << endl;
        return false;
      }
//      (*P_I_A2_Mask)(m,Range::all()) = where(abs(D_A2_Im(m, Range::all()) - SPVecArr(m) * OArr(Range::all(), 0)) < 3. * D_Dev, (*P_I_A2_MaskIn)(m, Range::all()), 0);
//      for (int i_coltemp=0; i_coltemp < P_I_A2_Mask->cols(); i_coltemp++){
//	if ((*P_I_A2_Mask)(m,i_coltemp) == 1)
//	  (*P_I_A2_Mask)(m,i_coltemp) = (*P_I_A2_MaskIn)(m,i_coltemp);
//      }
      NInd = sum((*P_I_A2_Mask)(m, Range::all()));
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(*P_I_A2_MaskIn) = " << sum(*P_I_A2_MaskIn) << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(*P_I_A2_Mask) = " << sum(*P_I_A2_Mask) << endl;
      #endif
//      return false;
      //IVecArr = where(abs(D_A2_Im(m, Range::all()) - SPVecArr(m) * OArr(Range::all(), 0)) < 3. * Dev, 1, 0);
      //NInd = sum(IVecArr);

      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): P_I_A2_Mask->size() = " << P_I_A2_Mask->size() << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): IVecArr.size() = " << IVecArr.size() << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): NInd set to " << NInd << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): NInd set to " << NInd << endl;
      #endif
      ///if (NInd == 0){
      ///  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": m = " << m << ": WARNING: NInd == 0" << endl;
      ///  return false;
      ///}
      if (IVecArr.size() < NInd)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: IVecArr.size(=" << IVecArr.size() << ") < NInd(=" << NInd << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: IVecArr.size(=" << IVecArr.size() << ") < NInd(=" << NInd << ")" << endl;
        return false;
      }
      TempIVecArr.resize(IVecArr.size() - NInd);
      TempIVecArr = 0;
      if (NInd > 0)
        IFirstVecArr.resize(NInd);
      else
        IFirstVecArr.resize(1);
      IFirstVecArr = 0;
      TempInt = 0;
      TempIntA = 0;



      /// MARK MARK MARK!!!
      /// Indices below are still to be checked





      for (int n = 0; n < P_I_A2_Mask->cols(); n++)
      {
        if ((*P_I_A2_Mask)(m,n) > 0)
        {
          if (TempInt >= IFirstVecArr.size())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: TempInt(=" << TempInt << ") >= IFirstVecArr.size(=" << IFirstVecArr.size() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: TempInt(=" << TempInt << ") >= IFirstVecArr.size(=" << IFirstVecArr.size() << ")" << endl;
            return false;
          }
          IFirstVecArr(TempInt) = n;
          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): for(n(==" << n << ")=0; n< P_I_A2_Mask->cols(=" << P_I_A2_Mask->cols() << "; n++): IFirstVecArr(TempInt=" << TempInt << ") set to " << IFirstVecArr(TempInt) << endl;
            //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): for(n(==" << n << ")=0; n< IVecArr.size(=" << IVecArr.size() << "; n++): IFirstVecArr(TempInt=" << TempInt << ") set to " << IFirstVecArr(TempInt) << endl;
          #endif
          TempInt++;
        }
        else
        {
          if (TempIntA >= TempIVecArr.size())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: TempIntA(=" << TempIntA << ") >= TempIVecArr.size(=" << IFirstVecArr.size() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: TempIntA(=" << TempIntA << ") >= TempIVecArr.size(=" << TempIVecArr.size() << ")" << endl;
            return false;
          }
          TempIVecArr(TempIntA) = n;
          #ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): for(n(==" << n << ")=0; n< P_I_A2_Mask->cols(=" << P_I_A2_Mask->cols() << "; n++): TempIVecArr(TempIntA=" << TempIntA << ") set to " << TempIVecArr(TempIntA) << endl;
        //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): for(n(==" << n << ")=0; n< IVecArr.size(=" << IVecArr.size() << "; n++): TempIVecArr(TempIntA=" << TempIntA << ") set to " << TempIVecArr(TempIntA) << endl;
          #endif

          TempIntA++;
        }
      }/// end for (int n = 0; n < IVecArr.size(); n++)

      //        (*P_OFS_Log) << "CFits::SlitFunc: 14. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  ///      if(nj lt nrow) then $          ; Bad pixels in column i
  ///        jbad=[jbad,long(nrow)*i+b]
      if (NInd < I_NCols_Im)  /// Bad pixels in column m
      {
        TempLong = (*P_I_A1_JBadVecArr)(0);
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): NInd(=" << NInd << ") < D_A2_Im.cols(=" << I_NCols_Im << "): TempLong set to " << TempLong << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): NInd(=" << NInd << ") < D_A2_Im.cols(=" << I_NCols_Im << "): TempLong set to " << TempLong << endl;
        #endif
        P_I_A1_JBadVecArr->resize(1 + TempIVecArr.size());
        (*P_I_A1_JBadVecArr)(0) = TempLong;
        if (TempIVecArr.size() != P_I_A1_JBadVecArr->size()-1)
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: TempIVecArr.size(=" << TempIVecArr.size() << ") != P_I_A1_JBadVecArr->size(=" << P_I_A1_JBadVecArr->size() << ")-1" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: ERROR: TempIVecArr.size(=" << TempIVecArr.size() << ") != P_I_A1_JBadVecArr->size(=" << P_I_A1_JBadVecArr->size() << ")-1" << endl;
          return false;
        }
        (*P_I_A1_JBadVecArr)(Range(1, P_I_A1_JBadVecArr->size() - 1)) = TempIVecArr;
        (*P_I_A1_JBadVecArr)(Range(1, P_I_A1_JBadVecArr->size() - 1)) += (long)I_NCols_Im * m;
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): NInd(=" << NInd << ") < D_A2_Im.cols(=" << I_NCols_Im << "): P_I_A1_JBadVecArr set to " << (*P_I_A1_JBadVecArr) << ")" << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): NInd(=" << NInd << ") < D_A2_Im.cols(=" << I_NCols_Im << "): P_I_A1_JBadVecArr set to " << (*P_I_A1_JBadVecArr) << ")" << endl;
        #endif
      }

      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): 2. SPVecArr = " << SPVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): SPVecArr = " << SPVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): SPVecArr(m) = " << SPVecArr(m) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): SPVecArr(m) = " << SPVecArr(m) << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OArr = " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): OArr = " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
      #endif
  ///
  ///      im_out(i,*)=sp(i)*o
  ///      endfor
  ///      endif
      if (P_D_A2_Prof_Out->cols() != OArr.rows())
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: P_D_A2_Prof_Out->cols(=" << P_D_A2_Prof_Out->cols() << ") != OArr.rows(=" << OArr.rows() << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: P_D_A2_Prof_Out->cols(=" << P_D_A2_Prof_Out->cols() << ") != OArr.rows(=" << OArr.rows() << ")" << endl;
        return false;
      }
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": m=" << m << ": P_D_A2_Prof_Out->size() = " << P_D_A2_Prof_Out->size() << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": m=" << m << ": P_D_A2_Prof_Out->rows() = " << P_D_A2_Prof_Out->rows() << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": m=" << m << ": P_D_A2_Prof_Out->cols() = " << P_D_A2_Prof_Out->cols() << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": m=" << m << ": OArr.size() = " << OArr.size() << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": m=" << m << ": OArr.rows() = " << OArr.rows() << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": m=" << m << ": OArr.cols() = " << OArr.cols() << endl;
      #endif








  //      if (I_Telluric == 2)
  //      {
  //        (*P_D_A2_Prof_Out)(m,Range::all()) += (*P_D_A1_MySky)(m);
  //      }









//      if (D_A2_SFO.cols() != SFVecArr.size()){
//	cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: D_A2_SFO.cols(=" << D_A2_SFO.cols() << ") != SFVecArr.size(=" << SFVecArr.size() << ")" << endl;
//	return false;
//      }
      Array<double, 1> D_A1_XX(D_A2_XX.cols());
      double D_Error = 0.;
      double D_MinError = 10000000000000.;
      double D_Offset = -1.;
      if (I_XCorProf == 0)
	D_Offset = 0.;
      double D_MinOffset = 0.;
      D_A1_XX = D_A2_XX(m, Range::all());
      D_A1_SFO = D_A1_SFO * I_OverSample / sum(D_A1_SFO);
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_XCorProf = " << I_XCorProf << endl;
      #endif
      for (int i_cross=0; i_cross < I_XCorProf; i_cross++){
        D_A1_XX = D_A2_XX(m, Range::all()) + D_Offset;
        #ifdef __DEBUG_FITS_SLITFUNC__
	  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A1_XX = " << D_A1_XX << endl;
        #endif
        for (int mm=0; mm < I_NCols_Im; mm++)
        {
          D_A1_XProf(0) = mm + 0.5 + (1. / (2. * static_cast<double>(I_OverSample)));
          if (!this->InterPol(D_A1_SFO, D_A1_XX, D_A1_XProf, D_A1_YProf)){
            cout << "FiberTrace::SlitFunc: ERROR: InterPol(D_A1_SFO=" << D_A1_SFO << ", D_A1_XX=" << D_A1_XX << ", D_A1_XProf=" << D_A1_XProf << ", D_A1_YProf) returned FALSE => Returning FALSE" << endl;
            return false;
          }
          D_A2_SF(m, mm) = D_A1_YProf(0);
          //          if (!this->IntegralUnderCurve(D_A1_XX, D_A1_SFO, D_A1_Range, D_A2_SF(m,mm))){
//	    cout << "CFits::SlitFunc: 1. I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: IntegralUnderCurve(" << D_A1_XX << ", " << D_A1_SFO << ", " << D_A1_Range << ", D_A2_SF(m, mm)) returned FALSE" << endl;
//	    return false;
//	  }
        }
	D_Error = sqrt(sum(pow2(D_A2_Im(m, Range::all()) - (D_A2_SF(m, Range::all()) * SPVecArr(m)))));
	if (D_Error < D_MinError){
	  D_MinError = D_Error;
	  D_MinOffset = D_Offset;
	}
	D_Offset += 0.01;
      }
      (*P_D_A1_XCorProfOut)(m) = D_MinOffset;

      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": m=" << m << ": D_MinOffset = " << D_MinOffset << endl;
    } /// end for (int m = 0; m < I_NRows_Im; m++)

    Array<double, 1> D_A1_Fit(P_D_A1_XCorProfOut->size());
    D_A1_Fit = 0.;
    if (I_XCorProf > 0){
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        CString CS_DebugFileName("D_A1_XCorProfOut");
        CS_DebugFileName.Add(CS_DebugFilesSuffix);
        CS_DebugFileName.Add(CString(".fits"));
        this->WriteArrayToFile((*P_D_A1_XCorProfOut), CS_DebugFileName, CString("ascii"));
      #endif
      int I_NDeg = 3;
      Array<double, 1> *P_D_A1_PolyCoeffs = new Array<double, 1>(6);
      Array<CString, 1> CS_A1_Args_PolyFit(1);
      CS_A1_Args_PolyFit(0) = CString("YFIT");
      void **PP_Args_PolyFit = (void**)malloc(sizeof(void*) * 1);
      PP_Args_PolyFit[0] = &D_A1_Fit;
      Array<double, 1> *P_D_A1_X = this->DIndGenArr(P_D_A1_XCorProfOut->size());
      if (!this->PolyFit(*P_D_A1_X,
                         *P_D_A1_XCorProfOut,
                         I_NDeg,
	                 CS_A1_Args_PolyFit,
	                 PP_Args_PolyFit,
	                 P_D_A1_PolyCoeffs)){
        cout << "CFits::SlitFunc: ERROR: this->PolyFit(XCorProf) returned FALSE => Returning FALSE" << endl;
        delete(P_D_A1_PolyCoeffs);
        return false;
      }
      #ifdef __DEBUG_FITS_SLITFUNC_N__
        CS_DebugFileName.Set("D_A1_XCorProf_Fit");
        CS_DebugFileName.Add(CS_DebugFilesSuffix);
        CS_DebugFileName.Add(CString(".fits"));
        this->WriteArrayToFile(D_A1_Fit, CS_DebugFileName, CString("ascii"));
        cout << "CFits::SlitFunc: after PolyFit: P_D_A1_XCorProfOut = " << *P_D_A1_XCorProfOut << endl;
        cout << "CFits::SlitFunc: after PolyFit: D_A1_Fit = " << D_A1_Fit << endl;
        Array<double, 1> D_A1_Diff(P_D_A1_XCorProfOut->size());
        D_A1_Diff = (*P_D_A1_XCorProfOut) - D_A1_Fit;
        CS_DebugFileName.Set("D_A1_XCorProf_Diff");
        CS_DebugFileName.Add(CS_DebugFilesSuffix);
        CS_DebugFileName.Add(CString(".fits"));
	this->WriteArrayToFile(D_A1_Diff, CS_DebugFileName, CString("ascii"));
        cout << "CFits::SlitFunc: after PolyFit: D_A1_Diff = " << D_A1_Diff << endl;
        cout << "CFits::SlitFunc: after PolyFit: max(D_A1_Diff) = " << max(D_A1_Diff) << endl;
      #endif
      delete(P_D_A1_PolyCoeffs);
      free(PP_Args_PolyFit);
      (*P_D_A1_XCorProfOut) = D_A1_Fit;
    }
    for (int m=0; m < I_NRows_Im; m++){
      Array<double, 1> D_A1_XX(D_A2_XX.cols());
      D_A1_XX = D_A2_XX(m, Range::all()) + D_A1_Fit(m);
      for (int mm=0; mm < I_NCols_Im; mm++)
      {
        D_A1_XProf(0) = mm + 0.5 + (1. / (2. * static_cast<double>(I_OverSample)));
        if (!this->InterPol(D_A1_SFO, D_A1_XX, D_A1_XProf, D_A1_YProf)){
          cout << "FiberTrace::SlitFunc: ERROR: InterPol(D_A1_SFO=" << D_A1_SFO << ", D_A1_XX=" << D_A1_XX << ", D_A1_XProf=" << D_A1_XProf << ", D_A1_YProf) returned FALSE => Returning FALSE" << endl;
          return false;
        }
        D_A2_SF(m, mm) = D_A1_YProf(0);
//        if (!this->IntegralUnderCurve(D_A1_XX, D_A1_SFO, D_A1_Range, D_A2_SF(m,mm))){
//	  cout << "CFits::SlitFunc: 2. I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: IntegralUnderCurve returned FALSE" << endl;
//	  return false;
//	}
      }
      if (I_Telluric == 3){
	D_A2_SF(m, Range::all()) = D_A2_SF(m, Range::all()) - min(D_A2_SF(m, Range::all()));
	double D_SumSF = sum(D_A2_SF(m, Range::all()));
        if (D_SumSF > 0.){
          #ifdef __DEBUG_FITS_SLITFUNC_N__
            cout << "D_SumSF = " << D_SumSF << endl;
          #endif
          D_A2_SF(m, Range::all()) = D_A2_SF(m, Range::all()) / sum(D_A2_SF(m, Range::all()));
        }
      }

//    CS_SP.Set(CString("SPVecArr1Final"));
//    CS_SP.Add(CS_DebugFilesSuffix);
//    CS_SP.Add(CString(".fits"));
//    D_A2_SPTemp.resize(SPVecArr.size(), 1);
//    D_A2_SPTemp(Range::all(), 0) = SPVecArr;
//    this->WriteFits(&D_A2_SPTemp, CS_SP);

//      return false;
      (*P_D_A2_Prof_Out)(m, Range::all()) = D_A2_SF(m,Range::all());/// * SPVecArr(m)
      P_TempString->Set("IM_OUT");
      if ((Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString)) >= 0)
      {
        (*P_D_A2_Im_Out)(m, Range::all()) = D_A2_SF(m,Range::all()) * SPVecArr(m);
      }
      #ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): P_D_A2_Prof_Out(m=" << m << ", *) set to " << (*P_D_A2_Prof_Out)(m, Range::all()) << endl;
      //  (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(PROF_OUT): for(m(==" << m << ")=0; m< I_NRows_Im(=" << I_NRows_Im << "; m++): P_D_A2_Prof_Out(m=" << m << ", *) set to " << (*P_D_A2_Prof_Out)(m, Range::all()) << endl;
      #endif


    }


    #ifdef __DEBUG_FITS_SLITFUNC_N__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_SF set to " << D_A2_SF << endl;
    #endif
//    if (I_Telluric == 1)
//      return false;

  // #ifdef __TELLURIC_MINE__
    if (I_Telluric == 2)
    {
/*
      /// Interpolate SFVecArr
      D_A1_Ind.resize(I_NCols_Im);
      D_A1_Ind = i + 0.5;
//      D_A1_Ind = i + 0.35 - 0.003157;
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: before INTERPOL: SFVecArr = " << SFVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: before INTERPOL: SFVecArr = " << SFVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: before INTERPOL: SPVecArr = " << SPVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: before INTERPOL: SPVecArr = " << SPVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: before INTERPOL: XVecArr = " << XVecArr << endl;
    //  (*P_OFS_Log) << "CFits::SlitFunc: before INTERPOL: D_A1_Ind = " << D_A1_Ind << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: before INTERPOL: D_A1_Ind = " << D_A1_Ind << endl;
      //(*P_OFS_Log) << "CFits::SlitFunc: before INTERPOL: FixD(UseRowVecArr) = " << FixD(UseRowVecArr) << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: D_A1_Ind = " << D_A1_Ind << endl;
      #endif

  ///    y=(dindgen(n)+0.5d0)/float(osample)-1.d0
      Array<double, 1> *p_tempDblVecArrB = new Array<double,1>(1);
      Array<int, 1> I_A1_WhereA(XVecArr.size());
      Array<int, 1> *P_I_A1_IndA;
      for (int m=0; m < I_NRows_Im, m++){
        for (int mm=0; mm < I_NCols_Im; mm++)
        {
          I_A1_WhereA = where((D_A2_XX(m,Range::all()) > mm) && (D_A2_XX(m,Range::all()) < mm+1), 1, 0);
          P_I_A1_IndA = GetIndex(I_A1_WhereA, I_NInd);
          #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Settung D_A1_MySF(mm=" << mm << ") to sum(" << GetSubArr(SFVecArr, *P_I_A1_IndA) << ") / I_NInd(=" << I_NInd << ")" << endl;
          #endif
          D_A1_MySF(mm) = sum(GetSubArr(SFVecArr, *P_I_A1_IndA)) / I_NInd;
          delete(P_I_A1_IndA);
        }
        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: D_A1_MySF set to " << D_A1_MySF << endl;
        #endif

        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": SFVecArr = " << SFVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": XVecArr = " << XVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A1_Ind = " << D_A1_Ind << endl;
//      return false;
      ///  XVecArr = (i + 0.5) / double(this->I_OverSample) - 1.;
/// ////////////      if (!this->InterPol(SFVecArr, XVecArr, D_A1_Ind, p_tempDblVecArrB))
        if (!this->InterPol(SFVecArr, D_A2_XX(m,Range::all()), D_A1_Ind, p_tempDblVecArrB))
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: ERROR: InterPol returned FALSE" << endl;
          return false;
        }
        D_A1_MySF = (*p_tempDblVecArrB);
        D_A1_MySF = where(D_A1_MySF < 0., 0., D_A1_MySF);
//        #ifdef __DEBUG_FITS_TELLURIC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: after InterPol: D_A1_MySF set to " << D_A1_MySF << endl;
//        #endif
        delete p_tempDblVecArrB;










        /// TODO: 2D SF must be shifted relative to center position of the aperture, this is WRONG!!!
        P_D_A2_MySF = this->VecArrACrossB(*P_D_A1_IndGen,D_A1_MySF);
        D_A2_MySF.resize(P_D_A2_MySF->rows(), P_D_A2_MySF->cols());
        D_A2_MySF = *P_D_A2_MySF;
        delete(P_D_A2_MySF);
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_SF = " << I_Iter_SF << ": __TELLURIC_MINE__: D_A2_MySF set to " << D_A2_MySF << endl;
        return false;
  ///      if (!this->LinearRegression(D_A2_Im, D_A2_MySF, D_A1_MySP, D_A1_Sky, D_A1_STDDEV, D_A1_Covariance)){
  ///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: ERROR: LinearRegression returned FALSE!" << endl;
  ///        return false;
  ///      }
//return false;
      }
      */
      argpos = 0;
      if (this->ErrorsRead)
      {
  //      CS_A1_Args_LinFit(argpos) = CString("MEASURE_ERRORS");
  //      PP_Args_LinFit[argpos] = P_D_A2_Errors;
        CS_A1_Args_Fit(argpos) = CString("MEASURE_ERRORS_IN");
        PP_Args_Fit[argpos] = P_D_A2_Errors;
        argpos++;
      }

  //    CS_A1_Args_LinFit(argpos) = CString("CHISQ");
  //    PP_Args_LinFit[argpos] = &D_A1_ChiSquare_LinFit;
      CS_A1_Args_Fit(argpos) = CString("CHISQ_OUT");
      PP_Args_Fit[argpos] = &D_A1_ChiSquare_LinFit;
      argpos++;

  //    CS_A1_Args_LinFit(argpos) = CString("SIGMA");
  //    PP_Args_LinFit[argpos] = &D_A2_Sigma_LinFit;
      CS_A1_Args_Fit(argpos) = CString("SIGMA_OUT");
      PP_Args_Fit[argpos] = &D_A2_Sigma_LinFit;
      argpos++;

  //    CS_A1_Args_LinFit(argpos) = CString("COVAR");
  //    PP_Args_LinFit[argpos] = &D_A3_CoVar_LinFit;
      CS_A1_Args_Fit(argpos) = CString("Q_OUT");
      PP_Args_Fit[argpos] = &D_A1_Probability_LinFit;
      argpos++;

  //    CS_A1_Args_LinFit(argpos) = CString("PROB");
  //    PP_Args_LinFit[argpos] = &D_A1_Probability_LinFit;
  //    argpos++;

  ///      if (!this->LinFit(D_A2_ImBak, D_A2_MySF, D_A1_MySP, D_A1_Sky, CS_A1_Args_LinFit, PP_Args_LinFit))
  ///      {
  ///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: LinFit returned FALSE!" << endl;
  ///        return false;
  ///      }
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": LinFit returned TRUE" << endl;
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A1_MySP = " << D_A1_MySP << endl;
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A1_Sky = " << D_A1_Sky << endl;
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A1_ChiSquare_LinFit = " << D_A1_ChiSquare_LinFit << endl;
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A1_Probability_LinFit = " << D_A1_Probability_LinFit << endl;
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A2_Sigma_LinFit = " << D_A2_Sigma_LinFit << endl;

      #ifdef __DEBUG_FITS_TELLURIC__
        cout << endl << "CFits::SlitFunc: before Fit: D_A2_MySF = " << D_A2_MySF << endl << endl;
      #endif

      for (int pppp=0; pppp < P_D_A2_Prof_Out->rows(); pppp++){
        if (sum((*P_D_A2_Prof_Out)(pppp, Range::all())) < 0.00000000000000001)
          (*P_D_A2_Prof_Out)(pppp, Range::all()) = 1.;
        (*P_D_A2_Prof_Out)(pppp, Range::all()) /= sum((*P_D_A2_Prof_Out)(pppp, Range::all()));
      }

      /// --- WHAT TODO?!?

      int I_RangeMinRow, I_RangeMaxRow, I_RangeMinCol, I_RangeMaxCol;
      int I_RangeWidth = 5;
      int xxx, yyy, zzz, indexRange, i_nrows, i_ncols, i_row, i_col, i_indexTemp;
      Array<int,1> I_A1_IndicesRange(2 * I_RangeWidth + 1);
      Array<int,3> I_A3_IndicesRange(1,1,1);//(2 * I_RangeWidth + 1, 2 * I_RangeWidth + 1, 2);
      Array<int, 2> I_A2_TempArrA(1,1);
      Array<int, 2> I_A2_TempArr(1,1);
      Array<int, 2> I_A2_Temp(1,1);

      for (xxx = 0; xxx < P_I_A2_Mask->rows(); xxx++){
        for (yyy = 0; yyy < P_I_A2_Mask->cols(); yyy++){
          I_RangeMinRow = xxx - I_RangeWidth;
          if (I_RangeMinRow < 0)
            I_RangeMinRow = 0;
          I_RangeMaxRow = xxx + I_RangeWidth;
          if (I_RangeMaxRow >= P_I_A2_Mask->rows())
            I_RangeMaxRow = P_I_A2_Mask->rows() - 1;
          #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": xxx = " << xxx << ", yyy = " << yyy << ": I_RangeMinRow = " << I_RangeMinRow << ", I_RangeMaxRow = " << I_RangeMaxRow << endl;
          #endif

          I_RangeMinCol = yyy - I_RangeWidth;
          if (I_RangeMinCol < 0)
            I_RangeMinCol = 0;
          I_RangeMaxCol = yyy + I_RangeWidth;
  //      if (I_RangeMaxCol >= (*this->P_D_A1_YCenter)(I_IAperture_In) + (*this->P_D_A1_YLow)(I_IAperture_In))
          if (I_RangeMaxCol >= P_I_A2_Mask->cols())
            I_RangeMaxCol = P_I_A2_Mask->cols() - 1;
          #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": xxx = " << xxx << ", yyy = " << yyy << " I_RangeMinCol = " << I_RangeMinCol << ", I_RangeMaxCol = " << I_RangeMaxCol << endl;
          #endif

          i_nrows = (I_RangeMaxRow - I_RangeMinRow + 1);
          i_ncols = (I_RangeMaxCol - I_RangeMinCol + 1);
          #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": i_nrows = " << i_nrows << ", i_ncols = " << i_ncols << endl;
          #endif

  /*        I_A1_IndicesRange.resize(i_nrows * i_ncols);
          for (zzz = 0; zzz < I_A1_IndicesRange.size(); zzz++){
            i_row = I_RangeMinRow + xxx;
            i_col = I_RangeMinCol + yyy;
  #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": i_row = " << i_row << ", i_col = " << i_col << endl;
  #endif
            i_indexTemp = int(this->Floor(double(zzz) / double(i_nrows)));
  #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": i_indexTemp set to " << i_indexTemp << endl;
  #endif
            I_A1_IndicesRange(zzz) = i_indexTemp + (zzz - i_indexTemp);//(yyy * i_ncols) + xxx;
  #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_A1_IndicesRange(zzz = " << zzz << ") set to " << I_A1_IndicesRange(zzz) << endl;
  #endif
          }

          I_A2_TempArrA.resize(i_nrows, i_ncols);
          I_A2_TempArrA= this->GetSubArr((*P_I_A2_Mask),I_A1_IndicesRange,3);
          */

          I_A3_IndicesRange.resize(i_nrows, i_ncols, 2);
          for (int zzz = 0; zzz < i_nrows; zzz++){
            for (int qqq = 0; qqq < i_ncols; qqq++){
              I_A3_IndicesRange(zzz,qqq,0) = I_RangeMinRow + zzz;
              I_A3_IndicesRange(zzz,qqq,1) = I_RangeMinCol + qqq;
            }
          }
          #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_A3_IndicesRange(Subarr) set to " << I_A3_IndicesRange << endl;
          #endif
          I_A2_Temp.resize(P_I_A2_Mask->rows(), P_I_A2_Mask->cols());
          I_A2_Temp = (*P_I_A2_Mask);
          I_A2_TempArr.resize(I_A3_IndicesRange.rows(), I_A3_IndicesRange.cols());
          I_A2_TempArr = this->GetSubArr(I_A2_Temp, I_A3_IndicesRange);
          #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_A2_TempArr(Subarr) set to " << I_A2_TempArr << endl;
          #endif

  //        if (sum(I_A2_TempArrA) != sum(I_A2_TempArr)){
  //          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: I_A2_TempArrA(=" << I_A2_TempArrA << ") != I_A2_TempArr(=" << I_A2_TempArr << endl;
  //          return false;
  //        }

          if (((*P_I_A2_Mask)(xxx,yyy) == 1) ||
              (sum(I_A2_TempArr) < I_A2_TempArr.size() / 1.5) ||
              (sum((*P_I_A2_Mask)(xxx,Range::all())) == 0)){
            D_A2_ImTimesMask(xxx,yyy) = D_A2_ImBak(xxx,yyy);
            D_A2_SFTimesMask(xxx,yyy) = (*P_D_A2_Prof_Out)(xxx,yyy);
            #ifdef __DEBUG_FITS_TELLURIC__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": (*P_I_A2_Mask)(xxx,yyy) = " << (*P_I_A2_Mask)(xxx,yyy) << " == 1 ||" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(I_A2_TempArr) = " << sum(I_A2_TempArr) << " < I_A2_TempArr.size() / 1.5 = " << I_A2_TempArr.size() / 1.5 << " ||" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum((*P_I_A2_Mask)(xxx,Range::all())) = " << sum((*P_I_A2_Mask)(xxx,Range::all())) << " == 0" << endl;
            #endif
          }
          else{
            D_A2_ImTimesMask(xxx,yyy) = D_A1_Sky(xxx);
            D_A2_SFTimesMask(xxx,yyy) = 0.;
            #ifdef __DEBUG_FITS_TELLURIC__
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": (*P_I_A2_Mask)(xxx,yyy) = " << (*P_I_A2_Mask)(xxx,yyy) << " != 1 &&" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum(I_A2_TempArr) = " << sum(I_A2_TempArr) << " >= I_A2_TempArr.size() / 1.5 = " << I_A2_TempArr.size() / 1.5 << " &&" << endl;
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": sum((*P_I_A2_Mask)(xxx,Range::all())) = " << sum((*P_I_A2_Mask)(xxx,Range::all())) << " != 0" << endl;
            #endif
  ///          return false;
          }
          #ifdef __DEBUG_FITS_TELLURIC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_ImTimesMask(xxx=" << xxx << ",yyy=" << yyy << ") set to " << D_A2_ImTimesMask(xxx, yyy) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_SFTimesMask(xxx=" << xxx << ",yyy=" << yyy << ") set to " << D_A2_SFTimesMask(xxx, yyy) << endl;
          #endif
        }
      }
      ///D_A2_ImTimesMask = D_A2_ImBak;/// * (*P_I_A2_Mask);
      ///D_A2_SFTimesMask = (*P_D_A2_Prof_Out);/// * (*P_I_A2_Mask);

      D_A1_Sky = 1.;


      ///D_A2_SFTimesMask = D_A2_MySF * (*P_I_A2_Mask);
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_ImTimesMask = " << D_A2_ImTimesMask << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": *P_D_A2_Prof_Out = " << *P_D_A2_Prof_Out << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": D_A2_SFTimesMask = " << D_A2_SFTimesMask << endl;
        P_CS_MySF = new CString("D_A2_ImTimesMask_beforeFit");
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CString("_");
	delete(P_CS_MySFTemp);
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Iter_Sky);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CS_DebugFilesSuffix;
        *P_CS_MySF += CString(".fits");
        this->WriteFits(&D_A2_ImTimesMask, *P_CS_MySF);
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": File " << *P_CS_MySF << " written" << endl;
        delete(P_CS_MySF);
        delete(P_CS_MySFTemp);

        P_CS_MySF = new CString("D_A2_SFTimesMask_beforeFit");
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CString("_");
        delete(P_CS_MySFTemp);
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Iter_Sky);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CS_DebugFilesSuffix;
        *P_CS_MySF += CString(".fits");
        this->WriteFits(&D_A2_SFTimesMask, *P_CS_MySF);
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": File " << *P_CS_MySF << " written" << endl;
        delete(P_CS_MySF);
        delete(P_CS_MySFTemp);

      #endif

      if (!this->LinFitBevington(D_A2_ImTimesMask,
                                 D_A2_SFTimesMask,
                                 D_A1_MySP,
                                 D_A1_Sky,
                                 CS_A1_Args_Fit,
                                 PP_Args_Fit))
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": ERROR: Fit returned FALSE!" << endl;
        return false;
      }

      #ifdef __DEBUG_FITS_TELLURIC__
        P_CS_MySF = new CString("D_A2_ImTimesMask_afterFit");
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CString("_");
	delete(P_CS_MySFTemp);
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Iter_Sky);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CS_DebugFilesSuffix;
        *P_CS_MySF += CString(".fits");
        this->WriteFits(&D_A2_ImTimesMask, *P_CS_MySF);
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": File " << *P_CS_MySF << " written" << endl;
        delete(P_CS_MySF);
        delete(P_CS_MySFTemp);

        P_CS_MySF = new CString("D_A2_SFTimesMask_afterFit");
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CString("_");
        delete(P_CS_MySFTemp);
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Iter_Sky);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CS_DebugFilesSuffix;
        *P_CS_MySF += CString(".fits");
        this->WriteFits(&D_A2_SFTimesMask, *P_CS_MySF);
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": File " << *P_CS_MySF << " written" << endl;
        delete(P_CS_MySF);
        delete(P_CS_MySFTemp);
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": 3. SPVecArr = " << SPVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": Fit returned TRUE" << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after Fit: D_A1_MySP = " << D_A1_MySP << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after Fit: D_A1_Sky = " << D_A1_Sky << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after Fit: D_A1_ChiSquare_LinFit = " << D_A1_ChiSquare_LinFit << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after Fit: D_A1_Probability_LinFit = " << D_A1_Probability_LinFit << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after Fit: D_A2_Sigma_LinFit = " << D_A2_Sigma_LinFit << endl;
      #endif
  if (I_Stop > 0)
    return false;

  //    return false;
  //      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A3_CoVar_LinFit = " << D_A3_CoVar_LinFit << endl;
  //      D_A2_ImBak_minus_Im = D_A2_ImBak - D_A2_Im;
  //      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": after LinFit: D_A2_ImBak - D_A2_Im = " << D_A2_ImBak_minus_Im << endl;

      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: SPVecArr = " << SPVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: D_A1_MySP set to " << D_A1_MySP << endl;
      #endif
      TempDVecArr.resize(D_A1_MySP.size());
      TempDVecArr = SPVecArr - D_A1_MySP;
  ///  #ifdef __DEBUG_FITS_TELLURIC__













        /// remove again!!!!
  ///      if (!this->LinearRegression(D_A2_ImBak, D_A2_MySF, D_A1_MySP, D_A1_Sky, D_A1_STDDEV, D_A1_Covariance))
  ///      {
  ///        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: ERROR: LinearRegression returned FALSE!" << endl;
  ///        return false;
  ///      }
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: SPVecArr - D_A1_MySP = " << TempDVecArr << endl;
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: D_A1_Sky set to " << D_A1_Sky << endl;
  ///      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: D_A1_MySP set to " << D_A1_MySP << endl;
  //      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: D_A1_STDDEV set to " << D_A1_STDDEV << endl;
  //      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": __TELLURIC_MINE__: D_A1_Covariance set to " << D_A1_Covariance << endl;
  ///  #endif
  //    return false;




      ///    SPVecArr = D_A1_MySP;




      /// subtract new sky from D_A2_Im
      for (int p=0; p < D_A1_Sky.size(); p++)
      {
        D_A2_Im(p,Range::all()) = D_A2_ImBak(p, Range::all()) - D_A1_Sky(p);
      }
      #ifdef __DEBUG_FITS_TELLURIC__
        CS_TempFileName.Set(DEBUGDIR);
        CS_TempFileName += CString("D_A1_MySky_");
	CString *P_CS_IntCS = CS_TempFileName.IntToCString(I_Iter_Sky);
	CS_TempFileName += (*P_CS_IntCS);
	delete(P_CS_IntCS);
	CS_TempFileName += CS_DebugFilesSuffix;
	CS_TempFileName += CString(".dat");
        P_SP_Log = new ofstream(CS_TempFileName.Get());
        for (isp=0; isp < P_D_A1_MySky->size(); isp++)
        {
          (*P_SP_Log) << (*P_D_A1_MySky)(isp) << endl;
        }
        delete(P_SP_Log);


        P_CS_MySF = new CString(DEBUGDIR);
        *P_CS_MySF += CString("D_A2_Im_Minus_Sky_new");
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Bin);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CString("_");
        delete(P_CS_MySFTemp);
        P_CS_MySFTemp = P_CS_MySF->IToA(I_Iter_Sky);
        *P_CS_MySF += *P_CS_MySFTemp;
        *P_CS_MySF += CS_DebugFilesSuffix;
        *P_CS_MySF += CString(".fits");
        this->WriteFits(&D_A2_Im, *P_CS_MySF);
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": File " << *P_CS_MySF << " written" << endl;
        delete(P_CS_MySF);
        delete(P_CS_MySFTemp);

      #endif


    /// /////////////////////////////


      P_TempString->Set("STOP");
      Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString);
      if (Pos >= 0)
      {
  //      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(STOP)" << endl;
        if (*(int*)ArgV_In[Pos] == 1)
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(STOP) == 1" << endl;
          if (I_Iter_SF == 1){
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": KeyWord_Set(STOP) == 1, I_Iter_SF == " << I_Iter_SF << " => returning false" << endl;
            return false;
          }
        }
      }


    /// /////////////////////////////


  //      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": While(I_Iter_Sky < 18): Run " << I_Iter_Sky << " finished" << endl;
  //  }/// end while(I_Iter < 8)
    }/// end if (I_TELLURIC == 2)
//return false;
    if (I_Telluric != 2)
      break;
    D_A1_OldSky = abs(D_A1_Sky - D_A1_OldSky) / D_A1_Sky;
    D_A1_OldSky = where(D_A1_Sky > 0., D_A1_OldSky, 0.);
    #ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": I_Iter_Sky = " << I_Iter_Sky << ": D_A1_OldSky - D_A1_Sky = " << D_A1_OldSky << endl;
    #endif
    if (mean(D_A1_OldSky) < 0.005)
      break;
    D_A1_OldSky = D_A1_Sky;
  } while(I_Iter_Sky < this->I_MaxIterSky);
//    }
//  }///end if KeyWord_Set(TELLURIC)
// #endif///__TELLURIC_MINE__



  Array<double, 1> D_A1_CY(D_A2_Im.rows());
  D_A1_CY = 0.;
  Array<double, 1> D_A1_CY_SP(D_A2_Im.rows());
  D_A1_CY_SP = 0.;
  Array<double, 1> D_A1_DY(D_A2_Im.rows());
  D_A1_DY = 0.;

  Array<double, 1> D_A1_SumMaskProf(D_A2_Im.rows());
  D_A1_SumMaskProf = 0.;
  Array<double, 1> D_A1_SumMaskProfSquaredDivByErr(D_A2_Im.rows());
  D_A1_SumMaskProfSquaredDivByErr = 0.;
  Array<double, 1> D_A1_SPErrHorne(D_A2_Im.rows());
  D_A1_SPErrHorne = 0.;


  double D_Sum_ProfTimesWeight = 0.;
  int I_SubPix = 0;
  #ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: D_A2_Im.rows() = " << D_A2_Im.rows() << endl;
    cout << "CFits::SlitFunc: D_A2_Im.cols() = " << D_A2_Im.cols() << endl;
//    cout << "CFits::SlitFunc: SFVecArr.size() = " << SFVecArr.size() << endl;
    cout << "CFits::SlitFunc: SFVecArr = " << SFVecArr << endl;
    cout << "CFits::SlitFunc: D_A2_Weights(0:3, *) = " << D_A2_Weights(Range(0,3), Range::all()) << endl;
  #endif
//    return false;

  if (I_Telluric == 3)
    SFVecArr = SFVecArr - min(SFVecArr);





  #ifdef __DEBUG_FITS_SLITFUNC_FILES__
    CString CS_SF("SFVecArr_Out");
    CS_SF.Add(CS_DebugFilesSuffix);
    CS_SF.Add(CString(".fits"));
    this->WriteFits(&SFVecArr, CS_SF);
  #endif

/**    Array<double, 1> *P_D_A1_XX = this->DIndGenArr(SFVecArr.size());
    SFVecArrTemp.resize(SFVecArr.size());
    SFVecArrTemp = 0.;
    if (!this->IntegralNormalise(*P_D_A1_XX, SFVecArr, SFVecArrTemp)){
      cout << "CFits::SlitFunc: ERROR: IntegralNormalise returned FALSE" << endl;
      return false;
    }
    SFVecArr = SFVecArrTemp;**/
  SFVecArr = SFVecArr / sum(SFVecArr);



//  Array<double, 1> D_A1_Axy(D_A2_Im.rows());
//  D_A1_Axy = 0.;
  double D_Sum_AxySquared = 0.;
  double D_Sum_SigmaSquared_AxySquared = 0.;

  for (int i_row=0; i_row<D_A2_Im.rows(); i_row++){
    D_A1_CY = 0.;
    D_A1_DY = 0.;
//    D_A1_SumMaskProf = 0.;
//    D_A1_SumMaskProfSquaredDivByErr = 0.;
    D_Sum_AxySquared = 0.;
    D_Sum_SigmaSquared_AxySquared = 0.;
    double sumProfTimesWeightRow = 0.;
    for (int i_col=0; i_col<D_A2_Im.cols(); i_col++){
      D_Sum_ProfTimesWeight = 0.;
      I_SubPix = 0;
      for (int i_j=0; i_j<SFVecArr.size()-1; i_j++){
        #ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": I_SubPix = " << I_SubPix << ": i_j = " << i_j << ": D_A2_XX(i_row, i_j) = " << D_A2_XX(i_row, i_j) << ": int(D_A2_XX(i_row, i_j)) = " << int(D_A2_XX(i_row, i_j)) << endl;
        #endif
	if ((int(D_A2_XX(i_row, i_j)) == i_col) || (D_A2_XX(i_row, i_j) <= i_col) && (D_A2_XX(i_row, i_j+1) > i_col)){
          #ifdef __DEBUG_FITS_TELLURIC__
	    cout << "CFits::SlitFunc: SubPixel found" << endl;
          #endif
          D_Sum_ProfTimesWeight += SFVecArr(i_j) * D_A2_Weights(i_row, I_SubPix);
          #ifdef __DEBUG_FITS_TELLURIC__
	    cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": I_SubPix = " << I_SubPix << ": i_j = " << i_j << ": SFVecArr(i_j) = " << SFVecArr(i_j) << ": D_A2_Weights(i_row, I_SubPix) = " << D_A2_Weights(i_row, I_SubPix) << ": D_Sum_ProfTimesWeight = " << D_Sum_ProfTimesWeight << endl;
          #endif
	  I_SubPix++;
	  if (I_SubPix == I_OverSample + 1)
	    i_j = SFVecArr.size();
	}
//        cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": I_SubPix = " << I_SubPix << ": i_j = " << i_j << ": D_A2_XX(i_row, i_j) = " << D_A2_XX(i_row, i_j) << endl;
      }/// end for (int i_j=0; i_j<SFVecArr.size()-1; i_j++){


      D_Sum_AxySquared += (*P_I_A2_Mask)(i_row, i_col) * pow2(D_Sum_ProfTimesWeight);
      D_Sum_SigmaSquared_AxySquared += (*P_I_A2_Mask)(i_row, i_col) * pow2((*P_D_A2_Errors)(i_row, i_col)) * pow2(D_Sum_ProfTimesWeight);


//      cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": P_I_A2_Mask(i_row, i_col) = " << (*P_I_A2_Mask)(i_row, i_col) << endl;
//      cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": D_A2_Im(i_row, i_col) = " << D_A2_Im(i_row, i_col) << endl;
//      cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": D_Sum_ProfTimesWeight = " << D_Sum_ProfTimesWeight << endl;
      sumProfTimesWeightRow += D_Sum_ProfTimesWeight;
      cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": sumProfTimesWeightRow = " << sumProfTimesWeightRow << endl;
      D_A1_CY_SP(i_row) += (*P_I_A2_Mask)(i_row, i_col) * D_A2_Im(i_row, i_col) * D_Sum_ProfTimesWeight;
//      D_A1_CY(i_row) += (*P_I_A2_Mask)(i_row, i_col) * pow2((*P_D_A2_Errors)(i_row, i_col)) * D_Sum_ProfTimesWeight;
//      D_A1_CY(i_row) += (*P_I_A2_Mask)(i_row, i_col) * pow2((*P_D_A2_Errors)(i_row, i_col) * pow2(D_Sum_ProfTimesWeight));
      D_A1_DY(i_row) += (*P_I_A2_Mask)(i_row, i_col) * pow2(D_Sum_ProfTimesWeight);
      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": D_A1_CY_SP(i_row) = " << D_A1_CY_SP(i_row) << endl;
//      cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": D_A1_CY(i_row) = " << D_A1_CY(i_row) << endl;
        cout << "CFits::SlitFunc: i_row = " << i_row << ": i_col = " << i_col << ": D_A1_DY(i_row) = " << D_A1_DY(i_row) << endl;
      #endif

      D_A1_SumMaskProf(i_row) += (*P_I_A2_Mask)(i_row, i_col) * D_Sum_ProfTimesWeight;
      D_A1_SumMaskProfSquaredDivByErr(i_row) += (*P_I_A2_Mask)(i_row, i_col) * pow2(D_Sum_ProfTimesWeight) / pow2((*P_D_A2_Errors)(i_row, i_col));

    }/// end for (int i_col=0; i_col<D_A2_Im.cols(); i_col++){
//    (*P_D_A1_SPErrOut)(i_row) = sqrt(D_A1_CY(i_row)) / (D_A2_Im.cols() * D_A1_DY(i_row));

    #ifndef __PISKUNOV_ORIG__
      (*P_D_A1_SPErrOut)(i_row) = sqrt(D_Sum_SigmaSquared_AxySquared / pow2(D_Sum_AxySquared)) / I_OverSample;



      #ifdef __DEBUG_FITS_TELLURIC__
        cout << "CFits::SlitFunc: (*P_D_A1_SPErrOut)(i_row = " << i_row << ") = " << (*P_D_A1_SPErrOut)(i_row) << endl;
      #endif
    #endif

    (*P_D_A1_SPOut)(i_row) = (D_A1_CY_SP(i_row) / D_A1_DY(i_row)) / I_OverSample;
//    #ifdef __DEBUG_FITS_TELLURIC__
      cout << "CFits::SlitFunc: (*P_D_A1_SPOut)(i_row = " << i_row << ") = " << (*P_D_A1_SPOut)(i_row) << endl;
//    #endif



//    D_A1_SPErrHorne(i_row) = sqrt(D_A1_SumMaskProf(i_row) / D_A1_SumMaskProfSquaredDivByErr(i_row));
//    D_A1_SPErrHorne(i_row) = D_A1_SumMaskProf(i_row) / D_A1_SumMaskProfSquaredDivByErr(i_row);
//    cout << "CFits::SlitFunc: D_A1_SPErrHorne(i_row = " << i_row << ") = " << D_A1_SPErrHorne(i_row) << endl;
  }
//  cout << "CFits::SlitFunc: SFVecArr = " << SFVecArr << endl;
//  cout << "CFits::SlitFunc: D_A2_XX(0:3,*) = " << D_A2_XX(Range(0,3), Range::all()) << endl;
//  #ifdef __DEBUG_FITS_TELLURIC__
    cout << "CFits::SlitFunc: D_A1_CY_SP = " << D_A1_CY_SP << endl;
    cout << "CFits::SlitFunc: D_A1_DY = " << D_A1_DY << endl;
    cout << "CFits::SlitFunc: SPVecArr = " << SPVecArr << endl;
    cout << "CFits::SlitFunc: P_D_A1_SPOut = " << *P_D_A1_SPOut << endl;
    cout << "CFits::SlitFunc: P_D_A1_SPErrOut = " << *P_D_A1_SPErrOut << endl;
    Array<double, 1> D_A1_SNR(SPVecArr.size());
    D_A1_SNR = SPVecArr / (*P_D_A1_SPErrOut);
    cout << "CFits::SlitFunc: SNR(SPVecArr / P_D_A1_SPErrOut) = " << D_A1_SNR << endl;
    D_A1_SNR = (*P_D_A1_SPOut) / (*P_D_A1_SPErrOut);
    cout << "CFits::SlitFunc: SNR(P_D_A1_SPOut / P_D_A1_SPErrOut) = " << D_A1_SNR << endl;
//  #endif
  //D_A1_SNR = (*P_D_A1_SPOut) / D_A1_SPErrHorne;
  //cout << "CFits::SlitFunc: SNR = " << D_A1_SNR << endl;
//  return false;




//  SPVecArr = (*P_D_A1_SPOut);






  if (I_Telluric == 2)
  {
    /// set P_D_A1_MySky to new sky
    (*P_D_A1_MySky) = D_A1_Sky;
///      (*P_D_A1_MySky) = where(*P_D_A1_MySky < 0., 0., *P_D_A1_MySky);
    P_D_A1_ErrSky->resize(D_A2_Im.rows());
    *P_D_A1_ErrSky = D_A2_Sigma_LinFit(Range::all(), 1);

    P_D_A1_ErrOut->resize(D_A2_Im.rows());
    *P_D_A1_ErrOut = D_A2_Sigma_LinFit(Range::all(), 0);

    for (int pp=0; pp < D_A2_Im.rows(); pp++)
      (*P_D_A2_Errors)(pp, Range::all()) += (*P_D_A1_ErrSky)(pp);
  }

  //    (*P_OFS_Log) << "CFits::SlitFunc: 15. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;
  //}/** end while(true) **/

  /*
  endfor
  if(n_elements(jbad) gt 1) then $
  jbad=jbad(1:n_elements(jbad)-1) $
  else $
  jbad=-1

  return
  end
  */
  cout << "start P_I_A1_BadVecArr" << endl;
  if (P_I_A1_JBadVecArr->size() > 1)
  {
    //TempIVecArr.resize(P_I_A1_JBadVecArr->size());
    //TempIVecArr = FixLI(*P_I_A1_JBadVecArr);
    (*P_I_A1_JBadVecArr)(Range(0, P_I_A1_JBadVecArr->size() - 2)) = (*P_I_A1_JBadVecArr)(Range(1, P_I_A1_JBadVecArr->size() - 1));
    P_I_A1_JBadVecArr->resizeAndPreserve(P_I_A1_JBadVecArr->size() - 1);
  }
  else
  {
    P_I_A1_JBadVecArr->resize(1);
    (*P_I_A1_JBadVecArr) = -1;
  }
  SPVecArr = where(SPVecArr < 0., 0., SPVecArr);
  cout << "SPVecArr (final) = " << SPVecArr << endl;
  #ifdef __DEBUG_FITS_SLITFUNC_SF__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": READY: P_I_A1_JBadVecArr set to " << (*P_I_A1_JBadVecArr) << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: READY: P_I_A1_JBadVecArr set to " << (*P_I_A1_JBadVecArr) << endl;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": READY: SFVecArr set to " << SFVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: READY: SFVecArr set to " << SFVecArr << endl;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": READY: SPVecArr set to " << SPVecArr << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: READY: SPVecArr set to " << SPVecArr << endl;
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": I_Bin = " << I_Bin << ": READY: P_D_A2_Prof_Out set to " << *P_D_A2_Prof_Out << endl;//->transpose(secondDim, firstDim) << endl;
//  (*P_OFS_Log) << "CFits::SlitFunc: READY: P_D_A2_Prof_Out set to " << *P_D_A2_Prof_Out << endl;//->transpose(secondDim, firstDim) << endl;
  #endif

  if (this->KeyWord_Set(CS_A1_Args_In, CString("PROF_OUT")) < 0)
  {
    delete P_D_A2_Prof_Out;
  }

  if (this->KeyWord_Set(CS_A1_Args_In, CString("XCOR_PROF")) < 0){
    delete(P_D_A1_XCorProfOut);
  }

  Pos = this->KeyWord_Set(CS_A1_Args_In,CString("SP_FIT"));
  if (Pos >= 0)
  {
    Array<double, 1> *P_D_A1_SPFit = (Array<double, 1>*)ArgV_In[Pos];
    P_D_A1_SPFit->resize(D_A1_MySP.size());
    *P_D_A1_SPFit = D_A1_MySP;
  }

  cout << "deleting pointers" << endl;

  //  (*P_OFS_Log) << "CFits::SlitFunc: End: 16. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;
  delete P_Delimiter;
  delete P_Prefix;
  if ((Pos = this->KeyWord_Set(CS_A1_Args_In, CString("IM_OUT"))) < 0)
  {
    if (P_D_A2_Im_Out != NULL)
      delete P_D_A2_Im_Out;
  }

  #ifdef __DEBUG_FITS_TELLURIC__
    CS_SP.Set(CString("SPVecArr1Out"));
    CS_SP.Add(CS_DebugFilesSuffix);
    CS_SP.Add(CString(".fits"));
    D_A2_SPTemp.resize(SPVecArr.size(), 1);
    D_A2_SPTemp(Range::all(), 0) = SPVecArr;
    this->WriteFits(&D_A2_SPTemp, CS_SP);
  #endif

  #ifdef __DEBUG_SEDM__
    CString CS_FileName_SPVecArrOut = CString(DEBUGDIR);
    CS_FileName_SPVecArrOut += CString("SEDM_SPVecArrOut.dat");
    this->WriteArrayToFile(SPVecArr, CS_FileName_SPVecArrOut, CString("ascii"));

    CString CS_FileName_SFVecArrOut = CString(DEBUGDIR);
    CS_FileName_SFVecArrOut += CString("SEDM_SFVecArrOut.dat");
    this->WriteArrayToFile(SFVecArr, CS_FileName_SFVecArrOut, CString("ascii"));
//    return false;

    CString CS_MaskOut("Mask");
    CS_MaskOut.Add(CS_DebugFilesSuffix);
    CS_MaskOut.Add(CString("_SF.fits"));
    if (!this->WriteFits(P_I_A2_Mask, CS_MaskOut)){
      cout << "CFits::SlitFunc: ERROR: WriteFits(Mask) returned FALSE" << endl;
      return false;
    }
    cout << "CFits::SlitFunc: " << CS_MaskOut << " written" << endl;
  #endif
  if ((sum(*P_I_A2_Mask) > P_I_A2_Mask->size() / 2) && (sum(*P_I_A2_Mask) == sum(*P_I_A2_MaskIn))){
    cout << "CFits::SlitFunc: WARNING: No cosmics detected" << endl;
//    return false;
  }
  P_D_A1_SFO_Out->resize(D_A1_SFO.size());
  (*P_D_A1_SFO_Out) = D_A1_SFO;

  cout << "deleting parameters" << endl;
  a.resize(0);
  AKLArr.resize(0,0);
  b.resize(0);
  BKLArr.resize(0,0);
  BKLIndVecArr.resize(0);
  BLVecArr.resize(0);
  c.resize(0);
  D_A1_Ind.resize(0);
  D_A2_AKLT.resize(0,0);
  D_A2_OT.resize(0,0);
  D_A2_SPVecTimesBKLArr.resize(0, 0);
  //  D_A2_SSFT.resize(0,0);
  IFirstVecArr.resize(0);
  ILastVecArr.resize(0);
  IndVecArr.resize(0);
//  Mask.resize(0,0);
  OArr.resize(0,0);
  OIndVecArr.resize(0);
  OLIndVecArr.resize(0);
  OOVecArr.resize(0);
  OmegaVecArr.resize(0);
  OmegaArr.resize(0,0);
  D_A2_TempAA.resize(0,0);
  D_A1_TempDVecArr.resize(0);
//  ProductArr.resize(0,0);
  RVecArr.resize(0);
  SPOldVecArr.resize(0);
  SSFArr.resize(0,0);
  TempArray.resize(0,0);
  TempDVecArr.resize(0);
  //TempDVecArrA.resize(0);
  TempDVecArrB.resize(0);
  TempDVecArrC.resize(0);
  TempDArr.resize(0,0);
  TempIVecArr.resize(0);
  UseRowVecArr.resize(0);
  IVecArr.resize(0);
  XVecArr.resize(0);
  XCenVecArr.resize(0);
//  XXVecArr.resize(0);
  *P_I_A2_MaskIn = *P_I_A2_Mask;
  delete(P_I_A2_Mask);
  P_TempString->Set("MASK");
  Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString);
  if (Pos < 0)
    delete(P_I_A2_MaskIn);
  delete P_TempString;
  cout << "deleting P_D_A1_SFO_Out" << endl;
//  P_TempString->Set("SFO_OUT");
//  Pos = this->KeyWord_Set(CS_A1_Args_In, *P_TempString);
//  if (Pos < 0)
//    delete(P_D_A1_SFO_Out);
//  P_D_A1_SFO_Out->resize(0);
  cout << "P_D_A1_SFO_Out deleted" << endl;
//S  delete P_TempString;
  delete(P_D_A1_IndGen);
  P_D_A1_ErrSky->resize(0);
  P_D_A1_MySky->resize(0);
  P_I_A1_JBadVecArr->resize(0);
  free(PP_Args_LinFit);
  free(PP_Args_Fit);
  return true;
}



bool CFits::fitSpline(const blitz::Array<double, 2> &fiberTraceSwath_In,
                      const blitz::Array<int, 1> &iFirst_In,
                      const blitz::Array<double, 1> &xOverSampled_In,
                      blitz::Array<double, 1> &profileOverSampled_Out,
                      const blitz::Array<double, 2> &profileXValuesPerRowOverSampled_In,
                      const blitz::Array<double, 1> &profileXValuesAllRows_In,
                      blitz::Array<double, 2> &profilePerRow_Out)
{
  #ifdef __DEBUG_SPLINE__
  cout << "FiberTrace::fitSpline: fiberTraceSwath_In = " << fiberTraceSwath_In << endl;
  cout << "FiberTrace::fitSpline: iFirst_In = " << iFirst_In << endl;
  cout << "FiberTrace::fitSpline: xOverSampled_In = " << xOverSampled_In << endl;
  cout << "FiberTrace::fitSpline: profileXValuesPerRowOverSampled_In = " << profileXValuesPerRowOverSampled_In << endl;
  cout << "FiberTrace::fitSpline: profileXValuesAllRows_In = " << profileXValuesAllRows_In << endl;
  #endif
  /// check input paramters
  if (static_cast<int>(iFirst_In.size()) != fiberTraceSwath_In.rows()){
    cout << "FiberTrace::fitSpline: ERROR: iFirst_In.size(=" << iFirst_In.size() << ") != fiberTraceSwath_In.rows(=" << fiberTraceSwath_In.rows() << ") => Returning FALSE" << endl;
    return false;
  }
  if (fiberTraceSwath_In.cols() != static_cast<int>(profileXValuesAllRows_In.size())){
    cout << "FiberTrace::fitSpline: ERROR: profileXValuesAllRows_In.size(=" << profileXValuesAllRows_In.size() << ") != fiberTraceSwath_In.cols(=" << fiberTraceSwath_In.cols() << ") => Returning FALSE" << endl;
    return false;
  }
  if (fiberTraceSwath_In.rows() != profileXValuesPerRowOverSampled_In.rows()){
    cout << "FiberTrace::fitSpline: ERROR: profileXValuesPerRowOverSampled_In.size(=" << profileXValuesPerRowOverSampled_In.size() << ") != fiberTraceSwath_In.rows(=" << fiberTraceSwath_In.rows() << ") => Returning FALSE" << endl;
    return false;
  }
  blitz::Array<double, 1> ccdRow(fiberTraceSwath_In.cols());
  std::vector<double> xVec(fiberTraceSwath_In.rows() * fiberTraceSwath_In.cols());
  std::vector<double> yVec(xVec.size());
  std::vector<double>::iterator iter_xVec = xVec.begin();
  std::vector<double>::iterator iter_yVec = yVec.begin();
  for (int i = 0; i < fiberTraceSwath_In.rows(); ++i){
    ccdRow = fiberTraceSwath_In(i,blitz::Range::all()) / blitz::sum(fiberTraceSwath_In(i,blitz::Range::all()));
    for (int j = 0; j < fiberTraceSwath_In.cols(); ++j){
      //        *iter_xVec = profileXValuesPerRowOverSampled_In(i,j);
      *iter_xVec = double(j) * double(this->I_OverSample) + double(iFirst_In(i)) + (double(this->I_OverSample)/2.);
      *iter_yVec = ccdRow(j);
      ++iter_xVec;
      ++iter_yVec;
    }
  }
  
  blitz::Array<double, 1> D_A1_xVec(xVec.data(), blitz::shape(xVec.size()), blitz::neverDeleteData);
  blitz::Array<double, 1> D_A1_yVec(yVec.data(), blitz::shape(yVec.size()), blitz::neverDeleteData);
  blitz::Array<int, 1> I_A1_Uniq(1);
  if (!this->Uniq(D_A1_xVec, I_A1_Uniq)){
    cout << "FiberTrace::fitSpine: ERROR: Uniq returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_SPLINE__
  cout << "FiberTrace::fitSpline: I_A1_Uniq = " << I_A1_Uniq << endl;
  #endif
  std::vector<double> xVecSorted(I_A1_Uniq.size());
  std::vector<double> yVecSorted(I_A1_Uniq.size());
  std::vector<double>::iterator iter_xVecSorted = xVecSorted.begin();
  std::vector<double>::iterator iter_yVecSorted = yVecSorted.begin();
  blitz::Array<int, 1> I_A1_Where(D_A1_xVec.size());
  blitz::Array<int, 1> *P_I_A1_Where;
  blitz::Array<double, 1> D_A1_SubArr(1);
  int count = 0;
  double median = 0.;
  blitz::Array<double, 1> *P_D_A1_XTemp = this->DIndGenArr(xOverSampled_In.size());
  blitz::Array<double, 1> D_X(1);
  blitz::Array<double, 1> D_Y(1);
  for (size_t i = 0; i < I_A1_Uniq.size(); ++i){
    D_X(0) = D_A1_xVec(I_A1_Uniq(i));
    if (!this->InterPol(xOverSampled_In, *P_D_A1_XTemp, D_X, D_Y)){
      cout << "FiberTrace::fitSpline: ERROR: InterPol(xOverSampled_In=" << xOverSampled_In << ", P_D_A1_XTemp=" << *P_D_A1_XTemp << ", D_X=" << D_X << ", D_Y) returned FALSE" << endl;
      delete(P_D_A1_XTemp);
      return false;
    }
    delete(P_D_A1_XTemp);
    *iter_xVecSorted = D_Y(0);
    I_A1_Where = blitz::where(fabs(D_A1_xVec - D_A1_xVec(I_A1_Uniq(i))) < 0.000001, 1, 0);
    P_I_A1_Where = this->GetIndex(I_A1_Where, count);
    if (!this->GetSubArrCopy(D_A1_yVec, *P_I_A1_Where, D_A1_SubArr)){
      cout << "FiberTrace::fitSpline: i=" << i << ": ERROR: GetSubArrCopy returned false" << endl;
      return false;
    }
    median = this->Median(D_A1_SubArr);
    #ifdef __DEBUG_SPLINE__
    cout << "FiberTrace::fitSpline: i=" << i << ": D_A1_xVec(I_A1_Uniq(i)=" << I_A1_Uniq(i) << ") = " << D_A1_xVec(I_A1_Uniq(i)) << ": *P_I_A1_Where = " << *P_I_A1_Where << endl;
    cout << "FiberTrace::fitSpline: i=" << i << ": D_A1_SubArr = " << D_A1_SubArr << endl;
    cout << "FiberTrace::fitSpline: i=" << i << ": median = " << median << endl;
    #endif
    *iter_yVecSorted = median;
    ++iter_xVecSorted;
    ++iter_yVecSorted;
    delete(P_I_A1_Where);
  }
  #ifdef __DEBUG_SPLINE__
  blitz::Array<double, 1> D_A1_XVecSorted(xVecSorted.data(), blitz::shape(xVecSorted.size()), blitz::neverDeleteData);
  blitz::Array<double, 1> D_A1_YVecSorted(yVecSorted.data(), blitz::shape(yVecSorted.size()), blitz::neverDeleteData);
  cout << "FiberTrace::fitSpline: xVecSorted = " << D_A1_XVecSorted << endl;
  cout << "FiberTrace::fitSpline: yVecSorted = " << D_A1_YVecSorted << endl;
  #endif
  spline spline;
  spline.set_points(xVecSorted,yVecSorted);    // currently it is required that X is already sorted
  
  /// calculate oversampled profile for each x in xOverSampled_In
  if (profileOverSampled_Out.size() != xOverSampled_In.size())
    profileOverSampled_Out.resize(xOverSampled_In.size());
  for (int i=0; i < static_cast<int>(xOverSampled_In.size()); ++i){
    if ((xOverSampled_In(i) < xVecSorted[0]) || (xOverSampled_In(i) > xVecSorted[xVecSorted.size()-1]))
      profileOverSampled_Out(i) = 0.;
    else
      profileOverSampled_Out(i) = spline(xOverSampled_In(i));
  }
  #ifdef __DEBUG_SPLINE__
  cout << "FiberTrace::fitSpline: xOverSampled_In = " << xOverSampled_In << endl;
  cout << "FiberTrace::fitSpline: profileOverSampled_Out = " << profileOverSampled_Out << endl;
  #endif
  profileOverSampled_Out = profileOverSampled_Out * double(this->I_OverSample) / blitz::sum(profileOverSampled_Out);
  
  if ((profilePerRow_Out.rows() != fiberTraceSwath_In.rows()) || (profilePerRow_Out.cols() != fiberTraceSwath_In.cols()))
    profilePerRow_Out.resize(fiberTraceSwath_In.rows(), fiberTraceSwath_In.cols());
  
  blitz::Array<double, 1> yProf(profileXValuesAllRows_In.size());
  for (int i_row = 0; i_row < fiberTraceSwath_In.rows(); i_row++){
    if (!this->InterPol(profileOverSampled_Out, 
                        profileXValuesPerRowOverSampled_In(i_row, blitz::Range::all()), 
                        profileXValuesAllRows_In, 
                        yProf)){
      cout << "FiberTrace::fitSpline: ERROR: InterPol(profileOverSampled_Out=" << profileOverSampled_Out << ", profileXValuesPerRowOverSampled_In(i_row=" << i_row << ", blitz::Range::all())=" << profileXValuesPerRowOverSampled_In(i_row, blitz::Range::all()) << ", profileXValuesAllRows_In=" << profileXValuesAllRows_In << ", yProf) returned FALSE => Returning FALSE" << endl;
      return false;
    }
    profilePerRow_Out(i_row, blitz::Range::all()) = blitz::where(yProf < 0., 0., yProf);
    profilePerRow_Out(i_row, blitz::Range::all()) = profilePerRow_Out(i_row, blitz::Range::all()) / blitz::sum(profilePerRow_Out(i_row, blitz::Range::all()));
  }
  #ifdef __DEBUG_SPLINE__
  cout << "FiberTrace::fitSpline: profilePerRow_Out = " << profilePerRow_Out << endl;
  #endif
  return true;
}





/**
Pro slit_func_2d,im,ycen,sp,sf,delta_x,shear_x,OVERSAMPLE=oversample $
             ,LAMBDA_SF=lamb_sf,LAMBDA_SP=lamb_sp,IM_OUT=im_out $
             ,USE_COL=use_col,MASK=mask,NOISE=noise,BAD=jbad $
             ,MODEL_ONLY=model,WING_SMOOTH_FACTOR=wing_smooth_factor $
             ,UNCERTAINTY=unc
             **/
bool CFits::SlitFunc_2D(//const Array<double, 2> &D_A2_Im_In,
			//const Array<double, 1> &D_A1_XCenters_In,
			//Array<double, 1> &D_A1_SP_Out,
			//Array<double, 2> &D_A2_SF_Out,
			//int I_Delta_X_In,
			//double D_Shear_X_In,
			const Array<CString, 1> &CS_A1_Args_In,            ///: in
                        void *PP_ArgsV_In[]){
  Array<double, 1> D_A1_SF(8);
  D_A1_SF(0) = 1.;
  D_A1_SF(1) = 2.;
  D_A1_SF(2) = 3.;
  D_A1_SF(3) = 4.;
  D_A1_SF(4) = 3.;
  D_A1_SF(5) = 2.;
  D_A1_SF(6) = 1.;
  D_A1_SF(7) = 0.;
  Array<double, 1> D_A1_SP(6);
  D_A1_SP(0) = 100.;
  D_A1_SP(1) = 120.;
  D_A1_SP(2) = 140.;
  D_A1_SP(3) = 150.;
  D_A1_SP(4) = 160.;
  D_A1_SP(5) = 170.;
  Array<double, 2> D_A2_Im_In(D_A1_SP.size(), D_A1_SF.size());
  Array<double, 2> *P_D_A2_Im_In = this->VecArrACrossB(D_A1_SP, D_A1_SF);
  cout << "CFits::SlitFunc_2D: P_D_A2_Im_In = " << *P_D_A2_Im_In << endl;
  if (P_D_A2_Im_In->rows() != D_A2_Im_In.rows()){
    cout << "rows wrong" << endl;
    return false;
  }
  if (P_D_A2_Im_In->cols() != D_A2_Im_In.cols()){
    cout << "cols wrong" << endl;
    return false;
  }
  D_A2_Im_In = (*P_D_A2_Im_In);
  Array<double, 1> D_A1_XCenters_In(D_A1_SP.size());
  D_A1_XCenters_In(0) = 0.1;
  D_A1_XCenters_In(1) = 0.25;
  D_A1_XCenters_In(2) = 0.32;
  D_A1_XCenters_In(3) = 0.4;
  D_A1_XCenters_In(4) = 0.45;
  D_A1_XCenters_In(5) = 0.48;
			//Array<double, 1> &D_A1_SP_Out,
			//Array<double, 2> &D_A2_SF_Out,
  int I_Delta_X_In = 2;
  Array<double, 1> D_A1_Shear_X_In(D_A1_SP.size());
  D_A1_Shear_X_In (0) = 1.7;
  D_A1_Shear_X_In (1) = 1.6;
  D_A1_Shear_X_In (2) = 1.5;
  D_A1_Shear_X_In (3) = 1.4;
  D_A1_Shear_X_In (4) = 1.3;
  D_A1_Shear_X_In (5) = 1.2;
  int I_OverSample = 7;
  double D_Lambda_SF = 0.1;
  double D_Lambda_SP = 1.;
  double D_Lambda = 0.;
  Array<double, 1> D_A1_Lambda(1);
  D_A1_Lambda = 0.;
  double D_WingSmoothFactor = 0.;

/// int oversample                        -> int I_OverSample
/// long osample                          -> int I_OverSample
/// Array<int, 2> mask (input mask)       -> Array<int, 2> *P_I_A2_Mask_In
/// Array<int, 2> mmsk (working mask)     -> Array<int, 2> I_A2_Mask
/// Array<long, 1> oind                   -> Array<long, 1> P_L_A1_OInd
/// double weight                         -> double D_Weight
/// int ncol                              -> int I_NCols_Im
/// int nrow                              -> int I_NRows_Im
/// long n_sf                             -> int I_NSF
/// long nx                               -> int I_NX
/// double norm                           -> double D_Norm

  /**
common bandsolv,band_solv_name

  if(not keyword_set(band_solv_name)) then begin
    help,calls=a
    delimiter=path_sep()
;    i1=strpos(a[0],delimiter)
    i1=strpos(a[0],'<')+1
    prefix=file_dirname(strmid(a[0],i1))
;    a=strmid(a(0),strpos(a(0),'<')+1,strlen(a(0))-strpos(a(0),'<')-1)
;    if(strpos(a,'/nfs') eq 0) then a=strmid(a,4)
;    if(strpos(a,'/export') eq 0) then a=strmid(a,7)
;    if(!VERSION.OS eq 'Win32') then delimiter='\' else delimiter='/'
;    prefix=strmid(a,0,strpos(a,delimiter,/REVERSE_SEARCH))   ;slit_func directory
;    if(strpos(a,delimiter) lt 0) then cd,CURRENT=prefix
    band_solv_name=prefix+delimiter+'bandsol.so.' $
                                   +!version.os+strtrim(!version.MEMORY_BITS,2)
  endif
  if(not keyword_set(oversample)) then oversample=1
  if(oversample lt 1) then oversample=1
  osample=long(oversample)
  oind=lindgen(osample+1L)*(osample+2L)
  weight=1./double(osample)
    **/

//  int I_OverSample = 1;
  CString CS_KeyWord("OVERSAMPLE");
  int I_Pos;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
  if (I_Pos >= 0){
    I_OverSample = *(int*)PP_ArgsV_In[I_Pos];
    cout << "CFits::SlitFunc_2D: KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
  }
  if (I_OverSample < 1)
    I_OverSample = 1;
  cout << "CFits::SlitFunc_2D: I_OverSample set to " << I_OverSample << endl;

  Array<long, 1> *P_L_A1_OInd = this->LIndGenArr(I_OverSample+1);
  *P_L_A1_OInd = (*P_L_A1_OInd) * (I_OverSample + 2);
  cout << "CFits::SlitFunc_2D: P_L_A1_OInd set to " << *P_L_A1_OInd << endl;
  double D_Weight = 1. / double(I_OverSample);

/**
  if(not keyword_set(mask)) then begin
    mmsk=byte(im*0)+1B
  endif else begin
    if((size(mask))(0) ne (size(im))(0) or $
       (size(mask))(1) ne (size(im))(1) or $
       (size(mask))(2) ne (size(im))(2)) then begin
      print,'SLIT_FUNC: Mask must have the same size as the image'
      stop
    endif
    mmsk=mask
  endelse
  **/

  Array<int, 2> *P_I_A2_Mask_In = new Array<int, 2>(D_A2_Im_In.rows(), D_A2_Im_In.cols());
  *P_I_A2_Mask_In = 1;
  CS_KeyWord.Set("MASK");
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
  if (I_Pos >= 0){
    delete(P_I_A2_Mask_In);
    P_I_A2_Mask_In = (Array<int, 2>*)PP_ArgsV_In[I_Pos];
    cout << "CFits::SlitFunc_2D: KeyWord_Set(MASK): P_I_A2_Mask_In set to " << *P_I_A2_Mask_In << endl;
  }
  if ((P_I_A2_Mask_In->size() != D_A2_Im_In.size()) ||
      (P_I_A2_Mask_In->rows() != D_A2_Im_In.rows()) ||
      (P_I_A2_Mask_In->cols() != D_A2_Im_In.cols())){
    cout << "CFits::SlitFunc_2D: ERROR: Mask must have the same size as the image! => Returning FALSE" << endl;
    delete(P_I_A2_Mask_In);
    return false;
  }
  Array<int, 2> I_A2_Mask(D_A2_Im_In.rows(), D_A2_Im_In.cols());
  I_A2_Mask = (*P_I_A2_Mask_In);
//  delete(P_I_A2_Mask_In)
  cout << "CFits::SlitFunc_2D: I_A2_Mask set to " << I_A2_Mask << endl;

/**
  if(not keyword_set(lamb_sf)) then lamb_sf=0.1
**/
//  double D_Lambda_SF = 0.1;
  CS_KeyWord.Set("LAMBDA_SF");
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
  if (I_Pos >= 0){
    D_Lambda_SF = *(double*)PP_ArgsV_In[I_Pos];
    cout << "CFits::SlitFunc_2D: KeyWord_Set(LAMBDA_SF): D_Lambda_SF set to " << D_Lambda_SF << endl;
  }
  cout << "CFits::SlitFunc_2D: D_Lambda_SF set to " << D_Lambda_SF << endl;
/**
  for reject=1,1 do begin
    if(keyword_set(use_col)) then begin
      imm=im(use_col,*)
      yycen=ycen(use_col)
      msk=mmsk(use_col,*)
    endif else begin
      use_col=indgen(n_elements(im(*,0)))
      imm=im
      yycen=ycen
      msk=mmsk
    endelse
    sz=size(imm)
    ncol=sz(1)
    nrow=sz(2)
    n_sf=(nrow+1L)*osample+1L
    nx=2L*delta_x+1L

    norm=n_elements(msk)/total(long(msk))
**/
  int I_NCols_Im = D_A2_Im_In.cols();
  cout << "CFits::SlitFunc_2D: I_NCols_Im set to " << I_NCols_Im << endl;

  int I_NRows_Im = D_A2_Im_In.rows();
  cout << "CFits::SlitFunc_2D: I_NRows_Im set to " << I_NRows_Im << endl;

  int I_NSF = (I_NCols_Im + 1) * I_OverSample + 1;
  cout << "CFits::SlitFunc_2D: I_NSF set to " << I_NSF << endl;

  int I_NX = 2 * I_Delta_X_In + 1;
  cout << "CFits::SlitFunc_2D: I_NX set to " << I_NX << endl;

  double D_Norm = double(D_A2_Im_In.size()) / double(sum(I_A2_Mask));
  cout << "CFits::SlitFunc_2D: D_Norm set to " << D_Norm << endl;


/**
    yslit=dindgen(n_sf)/float(osample)-1.
**/
  Array<double, 1> *P_D_A1_IndGen_NSF = this->DIndGenArr(I_NSF);
  Array<double, 1> D_A1_YSlit(I_NSF);
  D_A1_YSlit = (*P_D_A1_IndGen_NSF) / double(I_OverSample) - 1.;
  cout << "CFits::SlitFunc_2D: D_A1_YSlit set to " << D_A1_YSlit << endl;
  delete(P_D_A1_IndGen_NSF);

/**
    Akl_ind_sf=(lindgen(osample+1L)*n_sf)#replicate(1L,osample+1L)
    for i=0L,osample do Akl_ind_sf[*,i]=Akl_ind_sf[*,i]+(osample-i)*n_sf+i
    Akl_ind_sf=reform(Akl_ind_sf,n_elements(Akl_ind_sf))
**/
  Array<int, 1> *P_I_A1_IndGen_OSample = this->IndGenArr(I_OverSample+1);
  *P_I_A1_IndGen_OSample = (*P_I_A1_IndGen_OSample) * I_NSF;
  Array<int, 1> *P_I_A1_Rep = this->Replicate(1, I_OverSample+1);
  Array<int, 2> *P_I_A2_AKL_Ind_SF = this->VecArrACrossB(*P_I_A1_Rep,*P_I_A1_IndGen_OSample);
  cout << "CFits::SlitFunc_2D: P_I_A2_AKL_Ind_SF set to " << *P_I_A2_AKL_Ind_SF << endl;
  delete(P_I_A1_IndGen_OSample);
  delete(P_I_A1_Rep);
  for (int ii=0; ii<=I_OverSample; ii++){
    (*P_I_A2_AKL_Ind_SF)(ii, Range::all()) = (*P_I_A2_AKL_Ind_SF)(ii, Range::all()) + ((I_OverSample-ii) * I_NSF) + ii;
  }
  cout << "CFits::SlitFunc_2D: P_I_A2_AKL_Ind_SF set to " << *P_I_A2_AKL_Ind_SF << endl;
  Array<int, 1> *P_I_A1_AKL_Ind_SF = this->Reform(*P_I_A2_AKL_Ind_SF);
  cout << "CFits::SlitFunc_2D: P_I_A1_AKL_Ind_SF set to " << *P_I_A1_AKL_Ind_SF << endl;
  delete(P_I_A2_AKL_Ind_SF);

/**
    Akl_ind_sp=(lindgen(nx+1L)*ncol)#replicate(1L,nx+1L)
    for i=0L,nx do Akl_ind_sp[*,i]=Akl_ind_sp[*,i]+(nx-i)*ncol+i
**/
  P_I_A1_IndGen_OSample = this->IndGenArr(I_NX+1);
  *P_I_A1_IndGen_OSample = (*P_I_A1_IndGen_OSample) * I_NRows_Im;
  cout << "CFits::SlitFunc_2D: P_I_A1_IndGen = " << *P_I_A1_IndGen_OSample << endl;
  P_I_A1_Rep = this->Replicate(1, I_NX+1);
  cout << "CFits::SlitFunc_2D: P_I_A1_Rep = " << *P_I_A1_Rep << endl;
  Array<int, 2> *P_I_A2_AKL_Ind_SP = this->VecArrACrossB(*P_I_A1_Rep, *P_I_A1_IndGen_OSample);
  cout << "CFits::SlitFunc_2D: P_I_A2_AKL_Ind_SP set to " << *P_I_A2_AKL_Ind_SP << endl;
  for (int ii=0; ii<=I_NX; ii++){
    int I_Temp = ((I_NX - ii)*I_NRows_Im) + ii;
    cout << "CFits::SlitFunc_2D: ii=" << ii << ": I_Temp = " << I_Temp << endl;
    (*P_I_A2_AKL_Ind_SP)(ii, Range::all()) = (*P_I_A2_AKL_Ind_SP)(ii, Range::all()) + I_Temp;
  }
  delete(P_I_A1_IndGen_OSample);
  delete(P_I_A1_Rep);
  cout << "CFits::SlitFunc_2D: P_I_A2_AKL_Ind_SP set to " << *P_I_A2_AKL_Ind_SP << endl;

/**                                                      ; We assume that sp and sf are supplied
    if(not keyword_set(model)) then begin                ; if only a model is requested
      sf=total(imm*msk,1)
      if(osample gt 2 and n_elements(sf) gt 5) then sf=median(sf,5) ; the spectrum
      if(mean(total(imm,2)) lt 1.d3) then $              ; robust guess for sf
      sf=exp(-((dindgen(nrow)-nrow/2.)/(nrow/4.))^2)     ; in case of low S/N
      sf=sf/total(sf)                                    ; slit function
      sp=total((imm*msk)*(replicate(1.,ncol)#sf),2)*norm ; Initial guess for
      if(osample gt 2) then sp=median(sp,5)              ; the spectrum
      sp=sp/total(sp)*total(imm*msk)
    endif
**/
//  Array<double, 1> D_A1_SF(I_NCols_Im);

  firstIndex i;
  secondIndex j;
  CS_KeyWord.Set("MODEL");
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
  if (I_Pos < 0){
    Array<double, 2> D_A2_ImTimesMask(I_NRows_Im, I_NCols_Im);
    D_A2_ImTimesMask = D_A2_Im_In * I_A2_Mask;
    D_A1_SF = sum(D_A2_ImTimesMask(j,i), j);
    cout << "CFits::SlitFunc_2D: 1. D_A1_SF set to " << D_A1_SF << endl;
    if (D_A1_SF.size() != I_NCols_Im){
      cout << "CFits::SlitFunc_2D: ERROR: D_A1_SF.size(=" << D_A1_SF.size() << ") != I_NCols_Im(=" << I_NCols_Im << ") => Returning FALSE" << endl;
      return false;
    }
    if ((I_OverSample > 2) && (D_A1_SF.size() > 5)){
      Array<double, 1> *P_D_A1_SFMedian = this->MedianVec(D_A1_SF, 5);
      D_A1_SF = (*P_D_A1_SFMedian);
      delete(P_D_A1_SFMedian);
    }
    cout << "CFits::SlitFunc_2D: 2. D_A1_SF set to " << D_A1_SF << endl;
    Array<double, 1> D_A1_Im_Mean_Rows(I_NCols_Im);
    D_A1_Im_Mean_Rows = sum(D_A2_Im_In(j,i),j);
    cout << "CFits::SlitFunc_2D: D_A1_Im_Mean_Rows to " << D_A1_Im_Mean_Rows << endl;
    Array<double, 1> *P_D_A1_Moment = this->Moment(D_A1_Im_Mean_Rows, 1);
    cout << "CFits::SlitFunc_2D: P_D_A1_Moment set to " << *P_D_A1_Moment << endl;
    if ((*P_D_A1_Moment)(0) < 1000.){
      Array<double, 1> *P_D_A1_IndGenArr = this->DIndGenArr(I_NCols_Im);
      *P_D_A1_IndGenArr = pow2(((*P_D_A1_IndGenArr) - I_NCols_Im/2.) / (I_NCols_Im/4.));
      cout << "CFits::SlitFunc_2D: P_D_A1_IndGenArr set to " << *P_D_A1_IndGenArr << endl;
      D_A1_SF = exp(0.-(*P_D_A1_IndGenArr));
      cout << "CFits::SlitFunc_2D: 3. D_A1_SF set to " << D_A1_SF << endl;
      delete(P_D_A1_IndGenArr);
    }
    D_A1_SF = D_A1_SF / sum(D_A1_SF);
    cout << "CFits::SlitFunc_2D: 4. D_A1_SF set to " << D_A1_SF << endl;


//      sp=total((imm*msk)*(replicate(1.,ncol)#sf),2)*norm ; Initial guess for
//      if(osample gt 2) then sp=median(sp,5)              ; the spectrum
//      sp=sp/total(sp)*total(imm*msk)
    Array<double, 1> *P_D_A1_Rep = this->Replicate(1.,I_NRows_Im);
    Array<double, 2> *P_D_A2_Temp = this->VecArrACrossB(D_A1_SF, *P_D_A1_Rep);
    cout << "CFits::SlitFunc_2D: P_D_A2_Temp = " << *P_D_A2_Temp << endl;
    cout << "CFits::SlitFunc_2D: D_A2_ImTimesMask = " << D_A2_ImTimesMask << endl;
    Array<double, 2> D_A2_Temp(P_D_A2_Temp->rows(), P_D_A2_Temp->cols());
    ///(imm*msk)*(replicate(1.,ncol)#sf)
    Array<double, 2> D_A2_TempA(D_A2_ImTimesMask.cols(), D_A2_ImTimesMask.rows());
    D_A2_TempA = D_A2_ImTimesMask.transpose(secondDim, firstDim);
    cout << "CFits::SlitFunc_2D: D_A2_TempA = " << D_A2_TempA << endl;
    D_A2_Temp = D_A2_TempA * (*P_D_A2_Temp);
    delete(P_D_A1_Rep);
    delete(P_D_A2_Temp);
    cout << "CFits::SlitFunc_2D: D_A2_Temp = " << D_A2_Temp << endl;
    D_A1_SP = sum(D_A2_Temp(j,i),j) * D_Norm;
    cout << "CFits::SlitFunc_2D: 1. D_A1_SP = " << D_A1_SP << endl;
    if (I_OverSample > 2){
      Array<double, 1> *P_D_A1_SPMedian = this->MedianVec(D_A1_SP, 5);
      D_A1_SP = (*P_D_A1_SPMedian);
      delete(P_D_A1_SPMedian);
    }
    cout << "CFits::SlitFunc_2D: 2. D_A1_SP = " << D_A1_SP << endl;
    D_A1_SP = D_A1_SP * sum(D_A2_ImTimesMask) / sum(D_A1_SP);
    cout << "CFits::SlitFunc_2D: 3. D_A1_SP = " << D_A1_SP << endl;
  }
/**
;    outliers=0L
    if(keyword_set(noise)) then dev=noise $
    else                        dev=sqrt(total(msk*(imm-sp#sf)^2)/total(msk))
      **/
  int I_Outliers = 0;
  double D_Dev = 0.;
  Array<double, 2> *P_D_A2_SP_X_SF = this->VecArrACrossB(D_A1_SP, D_A1_SF);
  Array<double, 2> D_A2_Im_Minus_Rec(I_NRows_Im, I_NCols_Im);
  D_A2_Im_Minus_Rec = D_A2_Im_In - (*P_D_A2_SP_X_SF);
  delete(P_D_A2_SP_X_SF);
  cout << "CFits::SlitFunc_2D: D_A2_Im_In - (*P_D_A2_SP_X_SF) = " << D_A2_Im_Minus_Rec << endl;

  CS_KeyWord.Set("NOISE");
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
  if (I_Pos >= 0){
    D_Dev = *(double*)PP_ArgsV_In[I_Pos];
    cout << "CFits::SlitFunc_2D: KeyWord_Set(NOISE): D_Dev set to " << D_Dev << endl;
  }
  else{
    Array<double, 2> D_A2_Temp(I_NRows_Im, I_NCols_Im);
    D_A2_Temp = pow2(D_A2_Im_Minus_Rec);
    cout << "CFits::SlitFunc_2D: pow2(D_A2_Im_In - (*P_D_A2_SP_X_SF)) = " << D_A2_Temp << endl;
    D_A2_Temp = I_A2_Mask * D_A2_Temp;
    cout << "CFits::SlitFunc_2D: Mask * pow2(D_A2_Im_In - (*P_D_A2_SP_X_SF)) = " << D_A2_Temp << endl;
    D_Dev = sqrt(sum(D_A2_Temp) / sum(I_A2_Mask));
    cout << "CFits::SlitFunc_2D: D_Dev = " << D_Dev << endl;
  }
/**
    j=where(abs(imm-sp#sf) gt 3.*dev,nj)
    if(nj gt 0) then begin
      msk(j)=0B
;      outliers=outliers+nj
;      stop
    endif
    **/
  Array<int, 2> I_A2_Where_Outliers(I_NRows_Im, I_NCols_Im);
  I_A2_Where_Outliers = where(fabs(D_A2_Im_Minus_Rec) > 3. * D_Dev, 1, 0);
  Array<int, 2> I_A2_Indarr_Outliers(2,2);
  int I_NInd = 0;
  if (!this->GetIndex(I_A2_Where_Outliers, I_NInd, I_A2_Indarr_Outliers)){
    cout << "CFits::SlitFunc_2D: ERROR: GetIndex(I_A2_Where_Outliers) returned FALSE => Returning FALSE" << endl;
    return false;
  }
  cout << "CFits::SlitFunc_2D: I_A2_Indarr_Outliers = " << I_A2_Indarr_Outliers << endl;
  cout << "CFits::SlitFunc_2D: I_NInd = " << I_NInd << endl;
/**

;
; Computing the omega
;
; S_xy = Sum_(ix=-delta_x,delta_x) P_(x+ix) Sum_iy omega(ix,iy,x,y) * L(iy)
;
; Define omega and usefull indexing arrays used for optimization below
; {x,y} is the CCD pixel where the signal is computed, iy is subpixel index
; and ix is the contribution from the PSF centered on pixel x+ix
;
    omega=dblarr(nx,osample+1,ncol,nrow)      ; Intermediate values of omega are identical
    omega[delta_x,*,*,*]=weight
    **/
  Array<double, 4> D_A4_Omega(I_NX, I_OverSample+1, I_NRows_Im, I_NCols_Im);
  D_A4_Omega = 0.;
  D_A4_Omega(I_Delta_X_In, Range::all(), Range::all(), Range::all()) = D_Weight;
  cout << "CFits::SlitFunc_2D: D_A4_Omega = " << D_A4_Omega << endl;

/**
;
; We start by computing the omega. Note, that omega only depends on the geometry and therefore,
; does not change throughout the iterations:
;
    ix=delta_x
    sf_ind=0L                                  ; Index of slit function falling to row Y in cols x-delta_x:x+delta_x
    sf_ind_ind=lonarr(ncol)                    ; Starting point of indeces corresponding to pixel x
    iybottom=intarr(ncol)
    **/
  int I_IX = I_Delta_X_In;
  Array<int, 1> I_A1_SF_Ind(1);
  I_A1_SF_Ind = 0;
  Array<int, 1> I_A1_SF_Ind_Ind(I_NRows_Im);
  Array<int, 1> I_A1_IYBottom(I_NRows_Im);

/**
    for x=0L,ncol-1L do begin                  ; Omega depends on x through the shift of the central line
      ix1=-(x<delta_x)
      ix2=(ncol-x-1L)<delta_x
      sf_ind_ind[x]=n_elements(sf_ind)
      **/
  int I_IX1;
  int I_IX2;
  for (int i_x=0; i_x<I_NRows_Im; i_x++){
    I_IX1 = i_x;
    if (i_x > I_Delta_X_In)
      I_IX1 = I_Delta_X_In;
    I_IX1 = 0 - I_IX1;
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_IX1 = " << I_IX1 << endl;
    I_IX2 = I_NRows_Im - i_x - 1;
    if (I_IX2 > I_Delta_X_In)
      I_IX2 = I_Delta_X_In;
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_IX2 = " << I_IX2 << endl;
    I_A1_SF_Ind_Ind(i_x) = I_A1_SF_Ind.size();
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_A1_SF_Ind_Ind(i_x=" << i_x << ") = " << I_A1_SF_Ind_Ind(i_x) << endl;
/**
      for ix=ix1,ix2 do begin
        jx=ix+delta_x
        weight_bottom=yycen[x+ix] mod weight   ; Bottom of a pixel weight is the amount by which a
                                               ; subpixel sticks out into the pixel above
        weight_top=weight-weight_bottom        ; Top of a pixel weight is the amount of a subpixel
                                               ; left in the current pixel
        omega[jx,0,x,*]=weight_bottom          ; Correct bottom weights
        omega[jx,osample,x,*]=weight_top       ; Correct top weights
        **/
    for (int i_ix = I_IX1; i_ix <= I_IX2; i_ix++){
      int I_JX = i_ix + I_Delta_X_In;
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": I_JX = " << I_JX << endl;
      double D_Weight_Bottom = fmod(D_A1_XCenters_In(i_x + i_ix), D_Weight);
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": D_Weight_Bottom = " << D_Weight_Bottom << endl;
      double D_Weight_Top = D_Weight - D_Weight_Bottom;
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": D_Weight_Top = " <<
      D_Weight_Top << endl;
      D_A4_Omega(I_JX, 0, i_x, Range::all()) = D_Weight_Bottom;
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": D_A4_Omega(I_JX=" << I_JX << ", 0, i_x, *) = " << D_A4_Omega(I_JX, 0, i_x, Range::all()) << endl;

/**
        i1=fix((1.d0-yycen[x+ix])*osample)     ; The very bottom part of the PSF sticks below the last
        if(ix eq 0) then iybottom[x]=i1        ; The coordinate of the bottom subpixel is needed for setting up SLEs
        if(i1 gt 0) then omega[jx,0:i1-1,x,0]=0; CCD pixel. If yycen==0 this part is exactly osample
        omega[jx,0:i1,x,0]=weight_bottom       ; subpixels. Larger yycen shifts the PSF up leaving smaller tail
        sf_ind=[sf_ind,i1+lindgen(osample+1L)]
        **/
      D_A4_Omega(I_JX, I_OverSample, i_x, Range::all()) = D_Weight_Top;
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": D_A4_Omega(I_JX=" << I_JX << ", I_OverSample, i_x, *) = " << D_A4_Omega(I_JX, I_OverSample, i_x, Range::all()) << endl;
      int I_I1 = this->Fix((1. - D_A1_XCenters_In(i_x + i_ix)) * I_OverSample);
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": I_I1 = " << I_I1 << endl;

      if (i_ix == 0){
	I_A1_IYBottom(i_x) = I_I1;
        cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": i_ix == 0: I_A1_IYBottom(i_x) = " << I_A1_IYBottom(i_x) << endl;
      }
      if (I_I1 > 0){
	D_A4_Omega(I_JX, Range(0, I_I1-1), i_x, 0) = 0.;
        cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": I_I1 > 0: D_A4_Omega(I_JX=" << I_JX << ", Range(0, I_I1-1), i_x, 0) = " << D_A4_Omega(I_JX, Range(0, I_I1-1), i_x, 0) << endl;
      }
      D_A4_Omega(I_JX, Range(0, I_I1), i_x, 0) = D_Weight_Bottom;
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": D_A4_Omega(I_JX=" << I_JX << ", Range(0, I_I1), i_x, 0) = " << D_A4_Omega(I_JX, Range(0, I_I1), i_x, 0) << endl;
      Array<int, 1> *P_I_A1_IndGenTemp = this->IndGenArr(I_OverSample+1);
      Array<int, 1> I_A1_SF_Ind_Temp(I_A1_SF_Ind.size()+P_I_A1_IndGenTemp->size());
      I_A1_SF_Ind_Temp(Range(0, I_A1_SF_Ind.size()-1)) = I_A1_SF_Ind;
      I_A1_SF_Ind_Temp(Range(I_A1_SF_Ind.size(),I_A1_SF_Ind_Temp.size()-1)) = (*P_I_A1_IndGenTemp) + I_I1;
      I_A1_SF_Ind.resize(I_A1_SF_Ind_Temp.size());
      I_A1_SF_Ind = I_A1_SF_Ind_Temp;
      I_A1_SF_Ind_Temp.resize(0);
      delete(P_I_A1_IndGenTemp);
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": I_A1_SF_Ind = " << I_A1_SF_Ind << endl;

      /**
        i1=fix(yycen[x+ix]*osample)            ; The very top pixel behaves in the opposite way. Larger yycen
        if(i1 lt osample) then omega[jx,i1+1:*,x,0]=0 ; leaves larger tail sticking outside the data.
        omega[jx,i1:*,x,0]=weight_top
        if(ix ne 0) then omega[jx,*,x,*]=0.d0
      endfor
    endfor
    **/
      I_I1 = this->Fix(D_A1_XCenters_In(i_x + i_ix) * I_OverSample);
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": I_I1 = " << I_I1 << endl;
      if (I_I1 < I_OverSample){
	D_A4_Omega(I_JX, Range(I_I1+1, toEnd), i_x, 0) = 0.;
        cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": I_I1 < I_OverSample: D_A4_Omega(I_JX=" << I_JX << ", Range(I_I1+1, toEnd), i_x, 0) = " << D_A4_Omega(I_JX, Range(I_I1+1, toEnd), i_x, 0) << endl;
      }
      D_A4_Omega(I_JX, Range(I_I1, toEnd), i_x, 0) = D_Weight_Top;
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": D_A4_Omega(I_JX=" << I_JX << ", Range(I_I1, toEnd), i_x, 0) = " << D_A4_Omega(I_JX, Range(I_I1, toEnd), i_x, 0) << endl;
      if (i_ix != 0){
	D_A4_Omega(I_JX, Range::all(), i_x, Range::all()) = 0.;
        cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_ix = " << i_ix << ": i_ix != 0: D_A4_Omega(I_JX=" << I_JX << ", *, i_x, *) = " << D_A4_Omega(I_JX, Range::all(), i_x, Range::all()) << endl;
      }
    }/// end for (int i_ix = I_IX1; i_ix <= I_IX2; i_ix++){
  }/// end for (int i_x=0; i_x<I_NRows_Im; i_x++){
/**

    sf_ind=sf_ind[1:*]
    sf_ind_ind=[sf_ind_ind-1L,n_elements(sf_ind)]
    **/
  Array<int, 1> I_A1_SF_Ind_Temp(I_A1_SF_Ind.size()-1);
  I_A1_SF_Ind_Temp = I_A1_SF_Ind(Range(1,toEnd));
  I_A1_SF_Ind.resize(I_A1_SF_Ind_Temp.size());
  I_A1_SF_Ind = I_A1_SF_Ind_Temp;
  cout << "CFits::SlitFunc_2D: I_A1_SF_Ind = " << I_A1_SF_Ind << endl;

  I_A1_SF_Ind_Temp.resize(I_A1_SF_Ind_Ind.size()+1);
  I_A1_SF_Ind_Temp(Range(0, I_A1_SF_Ind_Temp.size()-2)) = I_A1_SF_Ind_Ind - 1;
  I_A1_SF_Ind_Temp(I_A1_SF_Ind_Temp.size()-1) = I_A1_SF_Ind.size();
  I_A1_SF_Ind_Ind.resize(I_A1_SF_Ind_Temp.size());
  I_A1_SF_Ind_Ind = I_A1_SF_Ind_Temp;
  cout << "CFits::SlitFunc_2D: I_A1_SF_Ind_Ind = " << I_A1_SF_Ind_Ind << endl;

/**
;
; For a tilted slit we assume that the angle is known as function of x
; so we can modify the omega accordingly
;
    for x=0L,ncol-1L do begin
      ix1=-(x<delta_x)
      ix2=(ncol-x-1L)<delta_x
      yy=dblarr((osample+1L)*nrow)
      o=reform(omega[delta_x,*,x,*],(osample+1L)*nrow)
      **/
  cout << "CFits::SlitFunc_2D: D_A4_Omega = " << D_A4_Omega << endl;
//  return false;
  for (int i_x=0; i_x<I_NRows_Im; i_x++){
    I_IX1 = 0-i_x;
    if (i_x > I_Delta_X_In)
      I_IX1 = 0 - I_Delta_X_In;
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_IX1 = " << I_IX1 << endl;
    I_IX2 = I_NRows_Im - i_x - 1;
    if (I_IX2 > I_Delta_X_In)
      I_IX2 = I_Delta_X_In;
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_IX2 = " << I_IX2 << endl;
    Array<double, 1> D_A1_YY((I_OverSample + 1) * I_NCols_Im);
    D_A1_YY = 0.;
    Array<double, 2> D_A2_Om(D_A4_Omega.extent(1), D_A4_Omega.extent(3));
    D_A2_Om = D_A4_Omega(I_Delta_X_In, Range::all(), i_x, Range::all());
    D_A2_Om.transposeSelf(secondDim, firstDim);
    Array<double, 1> *P_D_A1_Ref = this->Reform(D_A2_Om);
    Array<double, 1> D_A1_O(P_D_A1_Ref->size());
    D_A1_O = (*P_D_A1_Ref);
    delete(P_D_A1_Ref);
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": D_A1_O = " << D_A1_O << endl;


/**
      for iy=0L,(osample+1L)*nrow-1L do yy[iy]=total(o[0:iy])-o[iy]*0.5d0-nrow*0.5d0-yycen[x]
      shear=shear_x[x]*yy
      ix1=fix(shear)
      ii=where(shear ge 0, nii, complement=jj, ncomplement=njj)
      ix2=ix1
      if(nii gt 0) then ix2[ii]=ix2[ii]+1
      if(njj gt 0) then ix2[jj]=ix2[jj]-1
	**/
    for (int i_iy=0; i_iy < (I_OverSample+1)*I_NCols_Im; i_iy++){
      D_A1_YY(i_iy) = sum(D_A1_O(Range(0,i_iy))) - D_A1_O(i_iy)*0.5 - I_NCols_Im*0.5 - D_A1_XCenters_In(i_x);
    }
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": D_A1_YY = " << D_A1_YY << endl;

    Array<double, 1> D_A1_Shear(D_A1_YY.size());
    D_A1_Shear = D_A1_Shear_X_In(i_x) * D_A1_YY;
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": D_A1_Shear = " << D_A1_Shear << endl;
    Array<int, 1> *P_I_A1_IX1 = this->Fix(D_A1_Shear);
    Array<int, 1> I_A1_IX1(P_I_A1_IX1->size());
    I_A1_IX1 = (*P_I_A1_IX1);
    delete(P_I_A1_IX1);
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_A1_IX1 = " << I_A1_IX1 << endl;
    Array<int, 1> I_A1_Where(D_A1_Shear.size());
    I_A1_Where = where(D_A1_Shear >= 0., 1, 0);
    int I_NII = 0;
    int I_NJJ = 0;
    Array<int, 1> *P_I_A1_II = this->GetIndex(I_A1_Where, I_NII);
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_NII = " << I_NII << endl;
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": P_I_A1_II = " << *P_I_A1_II << endl;
    I_A1_Where = where(D_A1_Shear < 0., 1, 0);
    Array<int, 1> *P_I_A1_JJ = this->GetIndex(I_A1_Where, I_NJJ);
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_NJJ = " << I_NJJ << endl;
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": P_I_A1_JJ = " << *P_I_A1_JJ << endl;
    Array<int, 1> I_A1_IX2(I_A1_IX1.size());
    I_A1_IX2 = I_A1_IX1;
    if (I_NII > 0){
      for (int i_ind = 0; i_ind < P_I_A1_II->size(); i_ind++){
	I_A1_IX2((*P_I_A1_II)(i_ind)) = I_A1_IX2((*P_I_A1_II)(i_ind)) + 1;
      }
    }
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_A1_IX2 = " << I_A1_IX2 << endl;
    if (I_NJJ > 0){
      for (int i_ind = 0; i_ind < P_I_A1_JJ->size(); i_ind++){
	I_A1_IX2((*P_I_A1_JJ)(i_ind)) = I_A1_IX2((*P_I_A1_JJ)(i_ind)) - 1;
      }
    }
    cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": I_A1_IX2 = " << I_A1_IX2 << endl;
/**
      omega[delta_x,*,x,*]=0.d0
      for iy=0L,(osample+1L)*nrow-1L do begin
        y=iy/(osample+1L)
        iyy=iy mod (osample+1L)
        if(x+ix1[iy] ge 0L and x+ix1[iy] lt ncol) then $
          omega[ix1[iy]+delta_x,iyy,x+ix1[iy],y]=o[iy]*(1.d0-abs(shear[iy]-fix(shear[iy])))
        if(x+ix2[iy] ge 0L and x+ix2[iy] lt ncol) then $
          omega[ix2[iy]+delta_x,iyy,x+ix2[iy],y]=o[iy]*abs(shear[iy]-fix(shear[iy]))
      endfor
    endfor
    **/

    D_A4_Omega(I_Delta_X_In, Range::all(), i_x, Range::all()) = 0.;
    for (int i_y = 0; i_y < (I_OverSample + 1) * I_NCols_Im; i_y++){
      int I_Y = i_y / (I_OverSample + 1);
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": I_Y = " << I_Y << endl;
      int I_YY = fmod(double(i_y), double(I_OverSample+1));
      cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": I_YY = " << I_YY << endl;
      if ((I_A1_IX1(i_y) + I_Delta_X_In >= 0) && (I_A1_IX1(i_y) + I_Delta_X_In < I_NX) && (i_x + I_A1_IX1(i_y) >= 0) && (i_x + I_A1_IX1(i_y) < I_NRows_Im)){
	D_A4_Omega(I_A1_IX1(i_y) + I_Delta_X_In, I_YY, i_x + I_A1_IX1(i_y), I_Y) = D_A1_O(i_y) * (1. - fabs(D_A1_Shear(i_y) - this->Fix(D_A1_Shear(i_y))));
        cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": D_A4_Omega(" << I_A1_IX1(i_y) + I_Delta_X_In << ", " << I_YY << ", " << i_x + I_A1_IX1(i_y) << ", " << I_Y << ") = " << D_A4_Omega(I_A1_IX1(i_y) + I_Delta_X_In, I_YY, i_x + I_A1_IX1(i_y), I_Y) << endl;
      }
      if ((I_A1_IX2(i_y) + I_Delta_X_In >= 0) && (I_A1_IX2(i_y) + I_Delta_X_In < I_NX) && (i_x + I_A1_IX2(i_y) >= 0) && (i_x + I_A1_IX2(i_y) < I_NRows_Im)){
	D_A4_Omega(I_A1_IX2(i_y) + I_Delta_X_In, I_YY, i_x + I_A1_IX2(i_y), I_Y) = D_A1_O(i_y) * fabs(D_A1_Shear(i_y) - this->Fix(D_A1_Shear(i_y)));
//	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": D_A1_O(" << i_y << ") = " << D_A1_O(i_y) << ", D_A1_Shear(" << i_y << ") = " << D_A1_Shear(i_y) << endl;
//	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": fabs(D_A1_Shear(" << i_y << ") - Fix(D_A1_Shear[" << i_y << "])(=" << this->Fix(D_A1_Shear(i_y)) << ")) = " << fabs(D_A1_Shear(i_y) - this->Fix(D_A1_Shear(i_y))) << endl;
        cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": D_A4_Omega(" << I_A1_IX2(i_y) + I_Delta_X_In << ", " << I_YY << ", " << i_x + I_A1_IX2(i_y) << ", " << I_Y << ") = " << D_A4_Omega(I_A1_IX2(i_y) + I_Delta_X_In, I_YY, i_x + I_A1_IX2(i_y), I_Y) << endl;
      }
    }/// end for (int i_y = 0; i_y < (I_OverSample + 1) * I_NCols_Im; i_y++){
  }/// end for (int i_x=0; i_x<I_NRows_Im; i_x++){

/**
    u=replicate(1,osample+1)
    if(keyword_set(model)) then  goto,model_only
;
; Iterations start here
;
    iter=0
next:
    iter=iter+1                                ; Iteration counter

;===============================================================================
; (A) Detailed version
;     Compute the new PSF
;
      **/
  Array<double, 1> *P_D_A1_U = this->Replicate(1., I_OverSample+1);
  Array<double, 1> D_A1_SP_Old(1);
  Array<double, 1> D_A1_R(1);

  void **PP_Args_BandSol;
  PP_Args_BandSol = (void**)malloc(sizeof(void*) * 4);
  Array<int, 1> I_A1_Ind(P_I_A1_AKL_Ind_SF->size());
  Array<int, 2> I_A2_Ind(P_I_A1_AKL_Ind_SF->size(),2);
  Array<double, 2> D_A2_Akl(I_NSF, 2*I_OverSample+1);
  Array<double, 1> D_A1_Bl(I_NSF);
  int I_X1 = 0;
  int I_X2 = 0;
  int I_JX1 = 0;
  int I_JX2 = 0;
  int I_IY1 = 0;
  int I_IY2 = 0;
  int I_Row, I_Col;
  int I_Iter = 0;

  CS_KeyWord.Set("MODEL");
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
  if (I_Pos < 0){
    do{
      I_Iter = I_Iter + 1;
/**
;time0=systime(1)
    Akl=dblarr(n_sf,2*osample+1)               ; Initialize compact matrix
    Bl=dblarr(n_sf)                            ; and RHS
    **/
      D_A2_Akl.resize(I_NSF, 2*I_OverSample+1);
      D_A2_Akl = 0.;
      D_A1_Bl.resize(I_NSF);
      D_A1_Bl = 0.;
/**
    for x=0L,ncol-1L do begin
      ix1=-(x<delta_x)
      ix2=(ncol-x-1L)<delta_x
      jx1=ix1+delta_x
      jx2=ix2+delta_x
      iy1=iybottom[x]-osample
      iy2=iy1+osample
      **/
      for (int i_x = 0; i_x < I_NRows_Im; i_x++){
        I_IX1 = 0 - i_x;
        if (i_x > I_Delta_X_In)
	  I_IX1 = 0 - I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_IX1 = " << I_IX1 << endl;
        I_IX2 = I_NRows_Im - i_x - 1;
        if (I_IX2 > I_Delta_X_In)
	  I_IX2 = I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_IX2 = " << I_IX2 << endl;
        I_JX1 = I_IX1 + I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_JX1 = " << I_JX1 << endl;
        I_JX2 = I_IX2 + I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_JX2 = " << I_JX2 << endl;
        I_IY1 = I_A1_IYBottom(i_x) - I_OverSample;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_IY1 = " << I_IY1 << endl;
        I_IY2 = I_IY1 + I_OverSample;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_IY2 = " << I_IY2 << endl;
/**
      for y=0L,nrow-1L do begin
        iy1=iy1+osample
        iy2=iy1+osample
        ind=Akl_ind_sf+iy1
        dummy=total((sp[x+ix1:x+ix2]#u) $
                    *reform(omega[jx1:jx2,*,x,y]),1)
                    **/
        for (int i_y = 0; i_y < I_NCols_Im; i_y++){
	  I_IY1 = I_IY1 + I_OverSample;
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": I_IY1 = " << I_IY1 << endl;
	  I_IY2 = I_IY1 + I_OverSample;
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": I_IY2 = " << I_IY2 << endl;
	  I_A1_Ind = (*P_I_A1_AKL_Ind_SF) + I_IY1;
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": I_A1_Ind = " << I_A1_Ind << endl;
	  I_A2_Ind.resize(I_A1_Ind.size(), 2);
	  for (int i_ind=0; i_ind < I_A1_Ind.size(); i_ind++){
	    I_A2_Ind(i_ind, 0) = this->GetRowFromIndex(I_A1_Ind(i_ind), D_A2_Akl.rows());
	    I_A2_Ind(i_ind, 1) = this->GetColFromIndex(I_A1_Ind(i_ind), D_A2_Akl.rows());
	    cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": AKL=(" << D_A2_Akl.rows() << "x" << D_A2_Akl.cols() << "): I_A1_Ind(" << i_ind << ") = " << I_A1_Ind(i_ind) << ": I_A2_Ind(" << i_ind << ", *) = " << I_A2_Ind(i_ind, Range::all()) << endl;
	  }
//	return false;
	  Array<double, 1> D_A1_SPTemp(I_IX2 - I_IX1 + 1);
	  D_A1_SPTemp = D_A1_SP(Range(i_x + I_IX1, i_x + I_IX2));
	  Array<double, 2> *P_D_A2_Tmp = this->VecArrACrossB(D_A1_SPTemp, *P_D_A1_U);
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": *P_D_A2_Tmp = " << *P_D_A2_Tmp << endl;
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A4_Omega(I_JX1:I_JX2,*,i_x,i_y) = " << D_A4_Omega(Range(I_JX1, I_JX2), Range::all(), i_x, i_y) << endl;
	  Array<double, 2> D_A2_DummyTemp(P_D_A2_Tmp->rows(), P_D_A2_Tmp->cols());
	  D_A2_DummyTemp = (*P_D_A2_Tmp) * D_A4_Omega(Range(I_JX1, I_JX2), Range::all(), i_x, i_y);
	  Array<double, 1> D_A1_Dummy(D_A2_DummyTemp.cols());
	  D_A1_Dummy = sum(D_A2_DummyTemp(j,i),j);
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A1_Dummy = " << D_A1_Dummy << endl;
          delete(P_D_A2_Tmp);
	  P_D_A2_Tmp = this->VecArrACrossB(D_A1_Dummy, D_A1_Dummy);
	  if (P_D_A2_Tmp->size() != I_A1_Ind.size()){
	    cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": ERROR: P_D_A2_Tmp->size() != I_A1_Ind.size() => Returning FALSE" << endl;
	    return false;
	  }
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Dummy = " << *P_D_A2_Tmp << endl;
	/**
        Akl[ind]=Akl[ind]+(dummy#dummy)*msk[x,y]
        Bl[iy1:iy2]=Bl[iy1:iy2]+dummy*msk[x,y]*imm[x,y]
      endfor
    endfor
    **/
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Akl.size() = " << D_A2_Akl.size() << endl;
	  for (int i_ind = 0; i_ind < I_A1_Ind.size(); i_ind++){
//          cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": I_A1_Ind(" << i_ind << ") = " << I_A1_Ind(i_ind) << endl;
	    D_A2_Akl(I_A2_Ind(i_ind, 0), I_A2_Ind(i_ind, 1)) = D_A2_Akl(I_A2_Ind(i_ind, 0), I_A2_Ind(i_ind, 1)) + (*P_D_A2_Tmp)(this->GetRowFromIndex(i_ind, P_D_A2_Tmp->rows()), this->GetColFromIndex(i_ind, P_D_A2_Tmp->rows())) * I_A2_Mask(i_x, i_y);
            cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": i_ind = " << i_ind << ": I_A1_Ind(" << i_ind << ") = " << I_A1_Ind(i_ind) << ": D_A2_Akl(" << I_A2_Ind(i_ind, 0) << ", " << I_A2_Ind(i_ind, 1) << ") = " << D_A2_Akl(I_A2_Ind(i_ind, 0), I_A2_Ind(i_ind, 1)) << endl;
            if ((i_x > 4) && (I_A2_Ind(i_ind, 1) == 0) && (I_A2_Ind(i_ind, 0) == 38))
	      return false;
	  }
	  D_A1_Bl(Range(I_IY1, I_IY2)) = D_A1_Bl(Range(I_IY1, I_IY2)) + D_A1_Dummy * I_A2_Mask(i_x, i_y) * (*P_D_A2_Im_In)(i_x, i_y);
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": P_D_A2_Im_In = " << *P_D_A2_Im_In << endl;
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": P_D_A2_Im_In(" << i_x << ", " << i_y << ") = " << (*P_D_A2_Im_In)(i_x, i_y) << endl;
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": I_A2_Mask(" << i_x << ", " << i_y << ") = " << I_A2_Mask(i_x, i_y) << endl;
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A1_Bl(Range(" << I_IY1 << ", " << I_IY2 << ")) = " << D_A1_Bl(Range(I_IY1, I_IY2)) << endl;
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Akl = " << D_A2_Akl << endl;
        }/// end for (int i_y = 0; i_y < I_NCols_Im; i_y++){
      }/// end for (int i_x = 0; i_x < I_NRows_Im; i_x++){

	  if (I_Iter == 2)
	    return false;

/**

;time1=systime(1)

    lambda = lamb_sf*total(Akl(*,osample))/n_sf
    if(keyword_set(wing_smooth_factor)) then $
      lambda=lambda*(1.+wing_smooth_factor*(2.d0*dindgen(n)/(n-1)-1.d0)^2) $
    else $
      lambda=replicate(lambda,n)
**/
      D_Lambda = D_Lambda_SF * sum(D_A2_Akl(Range::all(), I_OverSample)) / I_NSF;
      D_A1_Lambda.resize(I_NSF);
      CS_KeyWord.Set("WING_SMOOTH_FACTOR");
      I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
      if (I_Pos >= 0){
        D_WingSmoothFactor = *(double*)PP_ArgsV_In[I_Pos];
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": KeyWord_Set(WING_SMOOTH_FACTOR): D_WingSmoothFactor = " << D_WingSmoothFactor << endl;
        Array<double, 1> *P_D_A1_IndGenN = this->DIndGenArr(I_NSF);
        D_A1_Lambda = D_Lambda * (1. + D_WingSmoothFactor * pow2(2. * (*P_D_A1_IndGenN) / (I_NSF - 1) - 1.));
        delete(P_D_A1_IndGenN);
      }
      else{
        Array<double, 1> *P_D_A1_RepL = this->Replicate(D_Lambda, I_NSF);
        D_A1_Lambda = (*P_D_A1_RepL);
       delete(P_D_A1_RepL);
      }
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": D_A1_Lambda = " << D_A1_Lambda << endl;

/**
; 1st order Tikhonov regularization (minimum 1st derivatives)
; Add the following 3-diagonal matrix * lambda:
;  1 -1  0  0  0  0
; -1  2 -1  0  0  0
;  0 -1  2 -1  0  0
;  0  0 -1  2 -1  0
;      .  .  .

;    main_diag=lindgen(n_sf)*(n_sf+1L)
;    uppX_diag=lindgen(n_sf-1L)*(n_sf+1L)+1L
;    lowX_diag=lindgen(n_sf-1L)*(n_sf+1L)+n_sf
;    Aij[0,0]=Aij[0,0]+lambda
;    Aij[n_sf-1,n_sf-1]=Aij[n_sf-1,n_sf-1]+lambda
;    Aij[main_diag[1:n_sf-2]]=Aij[main_diag[1:n_sf-2]]+2.d0*lambda
;    Aij[uppX_diag]=Aij[uppX_diag]-lambda
;    Aij[lowX_diag]=Aij[lowX_diag]-lambda

;    for i=0L,osample do Akl[osample-i:*,i]=Aij[lindgen(n_sf-osample+i)*(n_sf+1L)+n_sf*(osample-i)]
;    for i=1L,osample do Akl[0:n_sf-i-1,i+osample]=Aij[lindgen(n_sf-i)*(n_sf+1L)+i]

;    la_ludc,Aij,index,/DOUBLE
;    sf1=la_lusol(Aij,index,Bl,/DOUBLE)
;    sf1=sf1/total(sf1)*osample


;    i=CALL_EXTERNAL(band_solv_name, 'bandsol', $
;                    Akl, Bl, n_sf, 2L*osample+1L)
;    sf=Bl/total(Bl)*osample

;    Akl(        0L,osample)=Akl(           0L,osample)+lambda    ; +lambda to the upper-left element
;    Akl(   n_sf-1L,osample)=Akl(      n_sf-1L,osample)+lambda    ; and to the lower-right
;    Akl(1L:n_sf-2L,osample)=Akl(   1L:n_sf-2L,osample)+2.*lambda ; +2*lambda to the rest of the main diagonal
;    Akl(0L:n_sf-2L,osample+1L)=Akl(0L:n_sf-2L,osample+1L)-lambda ; -lambda to the upper sub-diagonal
;    Akl(1L:n_sf-1L,osample-1L)=Akl(1L:n_sf-1L,osample-1L)-lambda ; -lambda to the lower sub-diagonal
    Akl(  0,osample)=Akl(  0,osample)+lambda(  0); +lambda to the upper-left element
    Akl(n-1,osample)=Akl(n-1,osample)+lambda(n-1L); and to the lower-right
    Akl(1L:n-2L,osample)=Akl(1L:n-2L,osample)+2.*lambda(1L:n-2L); +2*lambda to the rest of the main diagonal
    Akl(0L:n-2L,osample+1L)=Akl(0L:n-2L,osample+1L)-lambda(0L:n-2L); -lambda to the upper sub-diagonal
    Akl(1L:n-1L,osample-1L)=Akl(1L:n-1L,osample-1L)-lambda(1L:n-1L); -lambda to the lower sub-diagonal
**/
      D_A2_Akl(0, I_OverSample) = D_A2_Akl(0, I_OverSample) + D_A1_Lambda(0);
      D_A2_Akl(I_NSF-1, I_OverSample) = D_A2_Akl(I_NSF-1, I_OverSample) + D_A1_Lambda(I_NSF - 1);
      D_A2_Akl(Range(1, I_NSF-2), I_OverSample) = D_A2_Akl(Range(1, I_NSF-2), I_OverSample) + 2. * D_A1_Lambda(Range(1, I_NSF - 2));
      D_A2_Akl(Range(0, I_NSF-2), I_OverSample + 1) = D_A2_Akl(Range(0, I_NSF-2), I_OverSample + 1) - D_A1_Lambda(Range(0, I_NSF - 2));
      D_A2_Akl(Range(1, I_NSF-1), I_OverSample-1) = D_A2_Akl(Range(1, I_NSF - 1), I_OverSample - 1) - D_A1_Lambda(Range(1, I_NSF-1));
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": D_A2_Akl = " << D_A2_Akl << endl;

/**
;
; 2nd order Tikhonov regularization (minimum 2nd derivative)
; Add the following 5-diagonal matrix * lambda:
;  1 -2  1  0  0  0
; -2  5 -4  1  0  0
;  1 -4  6 -4  1  0
;  0  1 -4  6 -4  1
;      .  .  .
    i=CALL_EXTERNAL(band_solv_name, 'bandsol', $
                    Akl, Bl, n_sf, 2L*osample+1L)
    sf=Bl/total(Bl)*osample
**/
      Array<double, 2> D_A2_AklT(D_A2_Akl.cols(), D_A2_Akl.rows());
      D_A2_AklT = D_A2_Akl.transpose(secondDim, firstDim);
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": Before BandSol: D_A2_AklT = " << D_A2_AklT << endl;
      PP_Args_BandSol[0] = D_A2_AklT.data();
      PP_Args_BandSol[1] = D_A1_Bl.data();
      PP_Args_BandSol[2] = &I_NSF;
      int I_ND = 2 * I_OverSample + 1;
      PP_Args_BandSol[3] = &I_ND;
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": Before BandSol: D_A1_Bl = " << D_A1_Bl << endl;
      int I_M = this->BandSol(4, PP_Args_BandSol);
      D_A2_Akl = D_A2_AklT.transpose(secondDim, firstDim);
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": After BandSol: I_M = " << I_M << ": D_A2_AklT = " << D_A2_AklT << endl;
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": After BandSol: I_M = " << I_M << ": D_A1_Bl = " << D_A1_Bl << endl;

//    return false;


      D_A1_SF.resize(D_A1_Bl.size());
      D_A1_SF = D_A1_Bl / sum(D_A1_Bl) * double(I_OverSample);
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": After BandSol: D_A1_SF = " << D_A1_SF << endl;
/**
;time2=systime(1)

    sp_old=sp
    r=sp

    Akl=dblarr(ncol,2*nx+1)
;    Aij=dblarr(ncol,ncol)
    Bl=dblarr(ncol)
    **/
      D_A1_SP_Old.resize(D_A1_SP.size());
      D_A1_SP_Old = D_A1_SP;
      D_A1_R.resize(D_A1_SP.size());
      D_A1_R = D_A1_SP;
      D_A2_Akl.resize(I_NRows_Im, 2 * I_NX + 1);
      D_A2_Akl = 0.;
      D_A1_Bl.resize(I_NRows_Im);
      D_A1_Bl = 0.;

/**
    for x=0L,ncol-1L do begin
      x1=(x-delta_x)>0L
      x2=(x+delta_x)<(ncol-1L)
      ix1=-(x<delta_x)
      ix2=(ncol-x-1L)<delta_x
      jx1=ix1+delta_x
      jx2=ix2+delta_x
      ind=Akl_ind_sp[0:x2-x1,0:x2-x1]+x1
      **/
      for (int i_x=0; i_x < I_NRows_Im; i_x++){
        I_X1 = i_x - I_Delta_X_In;
        if (I_X1 < 0)
	  I_X1 = 0;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_X1 = " << I_X1 << endl;
        I_X2 = i_x + I_Delta_X_In;
        if (I_X2 > I_NRows_Im - 1)
	  I_X2 = I_NRows_Im - 1;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_X2 = " << I_X2 << endl;
        I_IX1 = 0 - i_x;
        if (i_x > I_Delta_X_In)
          I_IX1 = 0 - I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_IX1 = " << I_IX1 << endl;
        I_IX2 = I_NRows_Im - i_x - 1;
        if (I_IX2 > I_Delta_X_In)
	  I_IX2 = I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_IX2 = " << I_IX2 << endl;
        I_JX1 = I_IX1 + I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_JX1 = " << I_JX1 << endl;
        I_JX2 = I_IX2 + I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_JX2 = " << I_JX2 << endl;
        I_A2_Ind.resize(I_X2 - I_X1 + 1, I_X2 - I_X1 + 1);
        I_A2_Ind = (*P_I_A2_AKL_Ind_SP)(Range(0, I_X2-I_X1), Range(0, I_X2 - I_X1)) + I_X1;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_A2_Ind = " << I_A2_Ind << endl;

/**
      for y=0L,nrow-1L do begin
        dummy =total(transpose(reform(omega[jx1:jx2,*,x,y])) $
                    *reform(sf[sf_ind[sf_ind_ind[x]:sf_ind_ind[x+1]-1L]+y*osample] $
                    ,osample+1,ix2-ix1+1),1)
     **/
        for (int i_y = 0; i_y < I_NCols_Im; i_y++){
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A4_Omega(Range(I_JX1, I_JX2), Range::all(), i_x, i_y) = " << D_A4_Omega(Range(I_JX1, I_JX2), Range::all(), i_x, i_y) << endl;
	  Array<double, 2> D_A2_Om(I_JX2 - I_JX1 + 1, D_A4_Omega.cols());
	  D_A2_Om = D_A4_Omega(Range(I_JX1, I_JX2), Range::all(), i_x, i_y);
	  Array<int, 1> I_A1_SF_Ind_Temp(I_A1_SF_Ind_Ind(i_x+1)-I_A1_SF_Ind_Ind(i_x));
	  I_A1_SF_Ind_Temp = I_A1_SF_Ind(Range(I_A1_SF_Ind_Ind(i_x), I_A1_SF_Ind_Ind(i_x+1) - 1)) + i_y * I_OverSample;
//	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": I_A1_SF_Ind = " << I_A1_SF_Ind << endl;
//	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": I_A1_SF_Ind_Ind = " << I_A1_SF_Ind_Ind << endl;
          cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": I_A1_SF_Ind_Temp = " << I_A1_SF_Ind_Temp << endl;
	  Array<double, 1> D_A1_SF_Temp(1);
	  if (!this->GetSubArrCopy(D_A1_SF, I_A1_SF_Ind_Temp, D_A1_SF_Temp)){
	    cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": ERROR: GetSubArrCopy returned FALSE => Returning FALSE" << endl;
	    return false;
	  }
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A1_SF_Temp = " << D_A1_SF_Temp << endl;
	  Array<double, 2> *P_D_A2_SF_Ref = this->Reform(D_A1_SF_Temp, I_IX2-I_IX1+1, I_OverSample+1);
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": *P_D_A2_SF_Ref = " << *P_D_A2_SF_Ref << endl;
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Om = " << D_A2_Om << endl;
	  Array<double, 1> D_A1_Dummy(P_D_A2_SF_Ref->rows());
	  Array<double, 2> D_A2_Om_times_SF_Ref(D_A2_Om.rows(), D_A2_Om.cols());
	  D_A2_Om_times_SF_Ref = D_A2_Om*(*P_D_A2_SF_Ref);
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Om_times_SF_Ref = " << D_A2_Om_times_SF_Ref << endl;
	  D_A1_Dummy = sum(D_A2_Om_times_SF_Ref,j);
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A1_Dummy = " << D_A1_Dummy << endl;
	  delete(P_D_A2_SF_Ref);
	  Array<double, 2> *P_D_A2_Dum = this->VecArrACrossB(D_A1_Dummy, D_A1_Dummy);

	/**
;        Aij[x1:x2,x1:x2]=Aij[x1:x2,x1:x2]+(dummy#dummy)*msk[x,y]
        Akl[ind]=Akl[ind]+(dummy#dummy)*msk[x,y]
        Bl[x1:x2]=Bl[x1:x2]+dummy*msk[x,y]*imm[x,y]
      endfor
    endfor
**/
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Akl = (" << D_A2_Akl.rows() << ", " << D_A2_Akl.cols() << ")" << endl;
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": P_D_A2_Dum = " << *P_D_A2_Dum << endl;
	  int I_Row_Akl = 0;
	  int I_Col_Akl = 0;
	  int I_Row_Dum = 0;
	  int I_Col_Dum = 0;
	  for (int i_ind_row = 0; i_ind_row < I_A2_Ind.rows(); i_ind_row++){
	    for (int i_ind_col = 0; i_ind_col < I_A2_Ind.cols(); i_ind_col++){
  	      I_Row_Akl = this->GetRowFromIndex(I_A2_Ind(i_ind_row, i_ind_col), D_A2_Akl.rows());
	      I_Col_Akl = this->GetColFromIndex(I_A2_Ind(i_ind_row, i_ind_col), D_A2_Akl.rows());
              cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": I_A2_Ind(" << i_ind_row << ", " << i_ind_col << ") = " << I_A2_Ind(i_ind_row, i_ind_col) << ": ind_Akl = " << I_Row_Akl << ", " << I_Col_Akl << endl;

              D_A2_Akl(I_Row_Akl, I_Col_Akl) = D_A2_Akl(I_Row_Akl, I_Col_Akl) + (*P_D_A2_Dum)(i_ind_row, i_ind_col) * I_A2_Mask(i_x, i_y);
	    }
	  }
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Akl = " << D_A2_Akl << endl;
	  D_A1_Bl(Range(I_X1, I_X2)) = D_A1_Bl(Range(I_X1, I_X2)) + D_A1_Dummy * I_A2_Mask(i_x, i_y) * (*P_D_A2_Im_In)(i_x, i_y);
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A1_Bl = " << D_A1_Bl << endl;
        }/// end for (int i_y = 0; i_y < I_NCols_Im; i_y++){
      }/// end for (int i_x=0; i_x < I_NRows_Im; i_x++){
      D_A2_AklT.resize(D_A2_Akl.cols(), D_A2_Akl.rows());
      D_A2_AklT = D_A2_Akl.transpose(secondDim, firstDim);
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": D_A2_AklT = " << D_A2_AklT << endl;

/**

;Smoothing in the spectral direction is requested
    if(keyword_set(lamb_sp)) then begin
      lambda = lamb_sp*total(sp)/ncol
      Akl(        0L,delta_x)=Akl(           0L,delta_x)+lambda    ; +lambda to the upper-left element
      Akl(   ncol-1L,delta_x)=Akl(      ncol-1L,delta_x)+lambda    ; and to the lower-right
      Akl(1L:ncol-2L,delta_x)=Akl(   1L:ncol-2L,delta_x)+2.*lambda ; +2*lambda to the rest of the main diagonal
      Akl(0L:ncol-2L,delta_x+1L)=Akl(0L:ncol-2L,delta_x+1L)-lambda ; -lambda to the upper sub-diagonal
      Akl(1L:ncol-1L,delta_x-1L)=Akl(1L:ncol-1L,delta_x-1L)-lambda ; -lambda to the lower sub-diagonal
    endif
    **/
      CS_KeyWord.Set("LAMBDA_SP");
      I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
      if (I_Pos >= 0){
        D_Lambda_SP = *(double*)PP_ArgsV_In[I_Pos];
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": KeyWord_Set(LAMBDA_SP): D_Lambda_SP = " << D_Lambda_SP << endl;
        D_Lambda = D_Lambda_SP * sum(D_A1_SP) / I_NRows_Im;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": KeyWord_Set(LAMBDA_SP): D_Lambda = " << D_Lambda << endl;
        D_A2_Akl(0, I_Delta_X_In) = D_A2_Akl(0, I_Delta_X_In) + D_Lambda;
        D_A2_Akl(I_NRows_Im-1, I_Delta_X_In) = D_A2_Akl(I_NRows_Im-1, I_Delta_X_In) + D_Lambda;
        D_A2_Akl(Range(1, I_NRows_Im-2), I_Delta_X_In) = D_A2_Akl(Range(1, I_NRows_Im-2), I_Delta_X_In) + 2. * D_Lambda;
        D_A2_Akl(Range(0, I_NRows_Im-2), I_Delta_X_In + 1) = D_A2_Akl(Range(0, I_NRows_Im-2), I_Delta_X_In + 1) - D_Lambda;
        D_A2_Akl(Range(1, I_NRows_Im-1), I_Delta_X_In - 1) = D_A2_Akl(Range(1, I_NRows_Im-1), I_Delta_X_In - 1) - D_Lambda;
      }
      D_A2_AklT = D_A2_Akl.transpose(secondDim, firstDim);
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": D_A2_AklT = " << D_A2_AklT << endl;

/**

;Get the new spectrum
;    sp=bandsol(Akl,Bl,/DOUBLE)
    i=CALL_EXTERNAL(band_solv_name, 'bandsol', $
                    Akl, Bl, ncol, 2L*nx+1L)
    sp=Bl
**/
      PP_Args_BandSol[0] = D_A2_AklT.data();
      PP_Args_BandSol[1] = D_A1_Bl.data();
      PP_Args_BandSol[2] = &I_NRows_Im;
      I_ND = 2 * I_NX + 1;
      PP_Args_BandSol[3] = &I_ND;
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": Before BandSol: D_A1_Bl = " << D_A1_Bl << endl;
      I_M = this->BandSol(4, PP_Args_BandSol);
      D_A2_Akl = D_A2_AklT.transpose(secondDim, firstDim);
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": After BandSol: I_M = " << I_M << ": D_A2_AklT = " << D_A2_AklT << endl;
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": After BandSol: I_M = " << I_M << ": D_A1_Bl = " << D_A1_Bl << endl;
      D_A1_SP.resize(D_A1_Bl.size());
      D_A1_SP = D_A1_Bl;

/**
;Reconstruct the model
    dev_new=0.d0 ; New deviation estimate
    model=imm*0
    for x=0L,ncol-1L do begin
      ix1=-(x<delta_x)
      ix2=(ncol-x-1L)<delta_x
      jx1=ix1+delta_x
      jx2=ix2+delta_x
      **/
      double D_Dev_New = 0.;
      Array<double, 2> D_A2_Model(D_A2_Im_In.rows(), D_A2_Im_In.cols());
      D_A2_Model = 0.;
      for (int i_x = 0; i_x < I_NRows_Im; i_x++){
        I_IX1 = 0 - i_x;
        if (i_x > I_Delta_X_In)
	  I_IX1 = 0 - I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_IX1 = " << I_IX1 << endl;
        I_IX2 = (I_NRows_Im - i_x - 1);
        if (I_IX2 > I_Delta_X_In)
	  I_IX2 = I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_IX2 = " << I_IX2 << endl;
        I_JX1 = I_IX1 + I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_JX1 = " << I_JX1 << endl;
        I_JX2 = I_IX2 + I_Delta_X_In;
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": I_JX2 = " << I_JX2 << endl;

/**
      for y=0L,nrow-1L do begin
        model[x,y]=total((sp[x+ix1:x+ix2]#u)*reform(omega[jx1:jx2,*,x,y]) $
              *reform(sf[sf_ind[sf_ind_ind[x]:sf_ind_ind[x+1]-1L]+y*osample] $
              ,osample+1,ix2-ix1+1))
      endfor
      dev_new=dev_new+total((imm[i,*]-model[x,*])^2)
    endfor
    **/
        for (int i_y = 0; i_y < I_NCols_Im; i_y++){
  	  Array<double, 1> D_A1_SP_Temp(I_IX2 - I_IX1 + 1);
	  D_A1_SP_Temp = D_A1_SP(Range(i_x + I_IX1, i_x + I_IX2));
	  Array<double, 2> *P_D_A2_SP_x_U = this->VecArrACrossB(D_A1_SP_Temp, (*P_D_A1_U));
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": *P_D_A2_SP_x_U = " << *P_D_A2_SP_x_U << endl;
	  Array<double, 2> D_A2_Om(I_JX2 - I_JX1 + 1, D_A4_Omega.cols());
	  D_A2_Om = D_A4_Omega(Range(I_JX1, I_JX2), Range::all(), i_x, i_y);
	  Array<int, 1> I_A1_SF_Ind_Temp(I_A1_SF_Ind_Ind(i_x+1)-I_A1_SF_Ind_Ind(i_x));
	  I_A1_SF_Ind_Temp = I_A1_SF_Ind(Range(I_A1_SF_Ind_Ind(i_x), I_A1_SF_Ind_Ind(i_x+1) - 1)) + i_y * I_OverSample;
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": I_A1_SF_Ind_Temp = " << I_A1_SF_Ind_Temp << endl;
	  Array<double, 1> D_A1_SF_Temp(1);
	  if (!this->GetSubArrCopy(D_A1_SF, I_A1_SF_Ind_Temp, D_A1_SF_Temp)){
	    cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": ERROR: GetSubArrCopy returned FALSE => Returning FALSE" << endl;
	    return false;
	  }
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A1_SF_Temp = " << D_A1_SF_Temp << endl;
	  Array<double, 2> *P_D_A2_SF_Ref = this->Reform(D_A1_SF_Temp, I_IX2-I_IX1+1, I_OverSample+1);
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": *P_D_A2_SF_Ref = " << *P_D_A2_SF_Ref << endl;
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Om = " << D_A2_Om << endl;
	  Array<double, 2> D_A2_TempC(D_A2_Om.rows(), D_A2_Om.cols());
	  D_A2_TempC = (*P_D_A2_SP_x_U) * D_A2_Om * (*P_D_A2_SF_Ref);
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_TempC = " << D_A2_TempC << endl;
	  D_A2_Model(i_x, i_y) = sum(D_A2_TempC);
	  cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Model(" << i_x << ", " << i_y << ") = " << D_A2_Model(i_x, i_y) << endl;
  	  delete(P_D_A2_SP_x_U);
	  delete(P_D_A2_SF_Ref);
        }/// end for (int i_y = 0; i_y < I_NCols_Im; i_y++){
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": D_A2_Model(" << i_x << ", *) = " << D_A2_Model(i_x, Range::all()) << endl;
        D_Dev_New = D_Dev_New + sum(pow2(D_A2_Im_In(i_x, Range::all()) - D_A2_Model(i_x, Range::all())));
        cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": i_x = " << i_x << ": D_Dev_New = " << D_Dev_New << endl;
      }/// end for (int i_x = 0; i_x < I_NRows_Im; i_x++){
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": D_A2_Im_In = " << D_A2_Im_In << endl;
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": D_A2_Model = " << D_A2_Model << endl;

/**
    if(iter gt 1) then dev=sqrt(dev_new/total(msk))
**/
      D_Dev = sqrt(D_Dev_New / sum(I_A2_Mask));
      cout << "CFits::SlitFunc_2D: I_Iter = " << I_Iter << ": D_Dev = " << D_Dev << endl;
      if (I_Iter > 1)
	return false;
/**
;Locate and mask outliers
    for x=0,ncol-1L do begin
      if(iter gt 1) then begin
        j=where(abs((imm[x,*]-model[x,*])) gt 3.*dev,nj,COMPLEMENT=b)
        if(nj gt 0) then begin
          msk[x,j]=0B
;          outliers=outliers+nj
;          stop
        endif
;        if(nj lt nrow) then msk(x,b)=1B
        if(nj lt nrow) then msk[x,b]=1B*(mmsk[use_col,*])[x,b]
      endif
    endfor
**/
      for (int i_x = 0; i_x < I_NRows_Im; i_x++){
        Array<int, 1> I_A1_WhereB(D_A2_Im_In.cols());
        I_A1_WhereB = where(fabs(D_A2_Im_In(i_x, Range::all()) - D_A2_Model(i_x, Range::all())) > 3. * D_Dev, 1, 0);
        int I_NIndB = 0;
        Array<int, 1> *P_I_A1_Ind_Where = this->GetIndex(I_A1_WhereB, I_NIndB);
        if (I_NIndB > 0){
	  for (int i_ind = 0; i_ind < I_NIndB; i_ind++){
            I_A2_Mask(i_x, (*P_I_A1_Ind_Where)(i_ind)) = 0;
	    I_Outliers++;
          }
        }

        delete(P_I_A1_Ind_Where);
        if (I_NIndB < I_NCols_Im){
          I_A1_WhereB = where(fabs(D_A2_Im_In(i_x, Range::all()) - D_A2_Model(i_x, Range::all())) <= 3. * D_Dev, 1, 0);
          I_NIndB = 0;
          P_I_A1_Ind_Where = this->GetIndex(I_A1_WhereB, I_NIndB);
          if (I_NIndB > 0){
            for (int i_ind = 0; i_ind < I_NIndB; i_ind++){
              I_A2_Mask(i_x, (*P_I_A1_Ind_Where)(i_ind)) = 1 * (*P_I_A2_Mask_In)(i_x, (*P_I_A1_Ind_Where)(i_ind));
            }
          }
          delete(P_I_A1_Ind_Where);
        }
      }/// end for (int i_x = 0; i_x < I_NRows_Im; i_x++){
/**
;    if(iter lt 4 and (max(abs(sp-sp_old)/max(sp)) gt 1.d-4 or outliers gt 0L)) then goto,next
    if(iter lt 8 and max(abs(sp-sp_old)/max(sp)) gt 1.d-5) then goto,next
**/
    } while ((I_Iter < 8) && (max(fabs(D_A1_SP - D_A1_SP_Old) / max(D_A1_SP)) >  0.00001));
  }/// end if !KeyWord_Set(MODEL)
  /**
model_only:
    jbad=0L
    if(arg_present(im_out)) then begin
      **/
  int I_JBad = 0;
  CS_KeyWord.Set("JBAD");
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
  if (I_Pos >= 0)
    I_JBad = *(int*)PP_ArgsV_In[I_Pos];

  CS_KeyWord.Set("IM_OUT");
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_KeyWord);
  if (I_Pos >= 0){
  /**
      ;Reconstruct the model
      unc=fltarr(ncol)
      im_out=im*0
      for x=0L,ncol-1L do begin
        ix1=-(x<delta_x)
        ix2=(ncol-x-1L)<delta_x
        jx1=ix1+delta_x
        jx2=ix2+delta_x
        **/
    Array<double, 1> D_A1_Unc(I_NRows_Im);
    D_A1_Unc = 0.;
    Array<double, 2> *P_D_A2_Im_Out = (Array<double, 2>*)PP_ArgsV_In[I_Pos];
    P_D_A2_Im_Out->resize(I_NRows_Im, I_NCols_Im);
    (*P_D_A2_Im_Out) = 0.;
    for (int i_x = 0; i_x < I_NRows_Im; i_x++){
      I_IX1 = 0 - i_x;
      if (i_x > I_Delta_X_In)
	I_IX1 = 0 - I_Delta_X_In;
      cout << "CFits::SlitFunc_2D: KeyWord_Set(IM_OUT): i_x = " << i_x << ": I_IX1 set to " << I_IX1 << endl;

      I_IX2 = I_NRows_Im - i_x - 1;
      if (I_IX2 > I_Delta_X_In)
	I_IX2 = I_Delta_X_In;
      cout << "CFits::SlitFunc_2D: KeyWord_Set(IM_OUT): i_x = " << i_x << ": I_IX2 set to " << I_IX2 << endl;

      I_JX1 = I_IX1 + I_Delta_X_In;
      cout << "CFits::SlitFunc_2D: KeyWord_Set(IM_OUT): i_x = " << i_x << ": I_JX1 set to " << I_JX1 << endl;

      I_JX2 = I_IX2 + I_Delta_X_In;
      cout << "CFits::SlitFunc_2D: KeyWord_Set(IM_OUT): i_x = " << i_x << ": I_JX2 set to " << I_JX2 << endl;


  /**
        for y=0L,nrow-1L do begin
          im_out[x,y]=total((sp[x+ix1:x+ix2]#u)*reform(omega[jx1:jx2,*,x,y]) $
                *reform(sf[sf_ind[sf_ind_ind[x]:sf_ind_ind[x+1]-1L]+y*osample] $
                ,osample+1,ix2-ix1+1))
        endfor
      endfor
      **/
      for (int i_y = 0; i_y < I_NCols_Im; i_y++){
	Array<double, 1> D_A1_SP_Temp(I_IX2 - I_IX1 + 1);
	D_A1_SP_Temp = D_A1_SP(Range(i_x + I_IX1, i_x + I_IX2));
	Array<double, 2> *P_D_A2_SP_x_U = this->VecArrACrossB(D_A1_SP_Temp, (*P_D_A1_U));
	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": *P_D_A2_SP_x_U = " << *P_D_A2_SP_x_U << endl;
	Array<double, 2> D_A2_Om(I_JX2 - I_JX1 + 1, D_A4_Omega.cols());
	D_A2_Om = D_A4_Omega(Range(I_JX1, I_JX2), Range::all(), i_x, i_y);
	Array<int, 1> I_A1_SF_Ind_Temp(I_A1_SF_Ind_Ind(i_x+1)-I_A1_SF_Ind_Ind(i_x));
	I_A1_SF_Ind_Temp = I_A1_SF_Ind(Range(I_A1_SF_Ind_Ind(i_x), I_A1_SF_Ind_Ind(i_x+1) - 1)) + i_y * I_OverSample;
	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": I_A1_SF_Ind_Temp = " << I_A1_SF_Ind_Temp << endl;
	Array<double, 1> D_A1_SF_Temp(1);
	if (!this->GetSubArrCopy(D_A1_SF, I_A1_SF_Ind_Temp, D_A1_SF_Temp)){
	  cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": ERROR: GetSubArrCopy returned FALSE => Returning FALSE" << endl;
	  return false;
	}
	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": D_A1_SF_Temp = " << D_A1_SF_Temp << endl;
	Array<double, 2> *P_D_A2_SF_Ref = this->Reform(D_A1_SF_Temp, I_IX2-I_IX1+1, I_OverSample+1);
	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": *P_D_A2_SF_Ref = " << *P_D_A2_SF_Ref << endl;
	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": D_A2_Om = " << D_A2_Om << endl;
	Array<double, 2> D_A2_TempC(D_A2_Om.rows(), D_A2_Om.cols());
	D_A2_TempC = (*P_D_A2_SP_x_U) * D_A2_Om * (*P_D_A2_SF_Ref);
	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": D_A2_TempC = " << D_A2_TempC << endl;
	(*P_D_A2_Im_Out)(i_x, i_y) = sum(D_A2_TempC);
	cout << "CFits::SlitFunc_2D: i_x = " << i_x << ": i_y = " << i_y << ": (*P_D_A2_Im_Out)(" << i_x << ", " << i_y << ") = " << (*P_D_A2_Im_Out)(i_x, i_y) << endl;
	delete(P_D_A2_SP_x_U);
	delete(P_D_A2_SF_Ref);
	return false;
      }
    }
/**;      stop

;Locate and mask outliers
      for x=0,ncol-1L do begin
        j=where(abs((im[x,*]-im_out[x,*])) gt 3.*dev,nj,COMPLEMENT=b)
        if(nj gt 0) then begin
          msk[x,j]=0B
          unc[x]=sqrt(total((im[x,j]-im_out[x,j])^2)/nj)
        endif else unc[x]=-1
        if(nj lt nrow) then msk[x,b]=1B*(mmsk[use_col,*])[x,b]
      endfor

    endif
  endfor
  **/
  }
  return true;
/**
  if(n_elements(jbad) gt 1) then jbad=jbad(1:n_elements(jbad)-1) $
  else                           jbad=-1

  return
end
**/
}








/**
  KeyWord_Set(const CString &cstr) const
  Returns Position of <cstr> in Array of CStrings <p_cstr>, if <p_cstr> contains CString <cstr>, else returns -1.
 **/
int CFits::KeyWord_Set(const Array<CString, 1> &CS_A1_In, const CString &cstr) const
{
  //CString KeyWord("");
  for (int m = 0; m < CS_A1_In.size(); m++)
  {
//    cout << "CFits::KeyWord_Set: CS_A1_In(m=" << m << ") = " << CS_A1_In(m) << endl;
    //KeyWord.Copy(CS_A1_In(m)));
    //KeyWord.Trim(2);
    if (CS_A1_In(m).EqualValue(cstr))
      return m;
  }
  return -1;
}

/**
  GetKeyWordValueFromArrays(const CString **PP_CStr, void *ArgV_In[], int NArgs, const CString &CStr) const
  Returns Value of KeyWord <cstr> in Array <p_cstr> if found, else returns NULL.
 **
CString* CFits::GetKeyWordValueFromArrays(const CString **PP_CStr, void *ArgV_In[], int NArgs, const CString &CStr) const
{
  int pos = this->KeyWord_Set(PP_CStr, NArgs, CStr);
  if (pos < 0)
    return NULL;
  CString *P_KeyWordValue = new CString();
  P_KeyWordValue->Set(PP_CStr[pos]->SubString(PP_CStr[pos]->StrPos(CString("=")) + 1)->Get());
  P_KeyWordValue->Trim(2);
  return P_KeyWordValue;
}

/**
 GetKeyWordValueFromParameterArray(void *p_cstr[], int len, const CString &cstr) const
 Returns Value of KeyWord <cstr> in Array <p_cstr> if found, else returns NULL.
 **
void* CString::GetKeyWordValueFromParameterArray(void *Argv[], int len, const CString &cstr) const
{

}

/**
 CharArrayToCStringArray
**/
CString** CFits::CharArrayToCStringArray(char* p_chArr[], int len) const
{
  CString **PP_Str;
  PP_Str = (CString**)malloc(sizeof(CString*) * len);
  for (int i = 0; i < len; i++)
  {
    //    P_Str[i] = (CString*)malloc(sizeof(CString));
    PP_Str[i] = new CString(p_chArr[i]);
  }
  return PP_Str;
}

/**
 FIndGen(int len) const
 Returns Pointer to Array<float> with
 **/
Vector<float>* CFits::FIndGen(int len) const
{
  //firstIndex i;
  Vector<float> *P_TempVecLong = new Vector<float>(len);
  //  (*P_TempVecLong) = i;
  for (int i=0; i<len; i++)
    (*P_TempVecLong)(i) = float(i);   // [ -3 -2 -1  0  1  2  3 ]
  return (P_TempVecLong);
}

/**
 FIndGenArr(int len) const
 Returns Pointer to Array<float> with
 **/
Array<float, 1>* CFits::FIndGenArr(int len) const
{
  Array<float, 1> *P_D_A1_Return = new Array<float, 1>(len);
  for (int i=0; i<len; i++)
    (*P_D_A1_Return)(i) = float(i);   // [ -3 -2 -1  0  1  2  3 ]
  return (P_D_A1_Return);
}

/**
DIndGen(int len) const
Returns Pointer to Array<double> with
**/
Vector<double>* CFits::DIndGen(int len) const
{
  //firstIndex i;
  Vector<double> *P_TempVecLong = new Vector<double>(len);
  //  (*P_TempVecLong) = i;
  for (int i=0; i<len; i++)
    (*P_TempVecLong)(i) = double(i);   // [ -3 -2 -1  0  1  2  3 ]
    return (P_TempVecLong);
}

/**
DIndGenArr(int len) const
Returns Pointer to Array<double> with
**/
Array<double, 1>* CFits::DIndGenArr(int len) const
{
  Array<double, 1> *P_D_A1_Return = new Array<double, 1>(len);
  for (int i=0; i<len; i++)
    (*P_D_A1_Return)(i) = double(i);   // [ -3 -2 -1  0  1  2  3 ]
    return (P_D_A1_Return);
}

/**
 LIndGen(int len) const
 Returns Pointer to Array<long> with
 **/
Vector<long>* CFits::LIndGen(int len) const
{
  Vector<long> *P_TempVecLong = new Vector<long>(len);
  (*(P_TempVecLong)) = Range(0,len-1);   // [ -3 -2 -1  0  1  2  3 ]
  return (P_TempVecLong);
}

/**
 LIndGenArr(int len) const
 Returns Pointer to Array<long> with
 **/
Array<long, 1>* CFits::LIndGenArr(int len) const
{
  Array<long, 1> *P_L_A1_Return = new Array<long, 1>(len);
  (*(P_L_A1_Return)) = Range(0,len-1);   // [ -3 -2 -1  0  1  2  3 ]
  return (P_L_A1_Return);
}

/**
 IndGen(int len) const
 Returns Pointer to Array<long> with
 **/
Vector<int>* CFits::IndGen(int len) const
{
  Vector<int> *P_TempVecLong = new Vector<int>(len);
  for (int i=0; i<len; i++){
    (*(P_TempVecLong))(i) = i;   // [ -3 -2 -1  0  1  2  3 ]
  }
  return (P_TempVecLong);
}

/**
 IndGenArr(int len) const
 Returns Pointer to Array<long> with
 **/
Array<int, 1>* CFits::IndGenArr(int len) const
{
  Array<int, 1> *P_I_A1_Result = new Array<int, 1>(len);
  for (int i=0; i<len; i++){
    (*(P_I_A1_Result))(i) = i;   // [ -3 -2 -1  0  1  2  3 ]
  }
  #ifdef __DEBUG_FITS_INDGENARR__
    cout << "CFits::IndGenArr: len = " << len << ": (*P_I_A1_Result) set to " << *P_I_A1_Result << endl;
  #endif
  return (P_I_A1_Result);
}

/**
 double Moment(Array<double, 1>) const;
 **/
Array<double,1>* CFits::Moment(const Array<double, 1> &D_A1_Arr_In, int I_MaxMoment_In) const
{
  Array<double,1>* P_D_A1_Out = new Array<double,1>(4);
  *P_D_A1_Out = 0.;
  if ((I_MaxMoment_In < 1) && (D_A1_Arr_In.size() < 2)){
    cout << "CFits::Moment: ERROR: D_A1_Arr_In must contain 2 OR more elements." << endl;
    return P_D_A1_Out;
  }
  int I_NElements = D_A1_Arr_In.size();
  double D_Mean = sum(D_A1_Arr_In) / I_NElements;
  double D_Kurt = 0.;
  double D_Var = 0.;
  double D_Skew = 0.;

  if (I_MaxMoment_In > 1){
    Array<double,1> D_A1_Resid(I_NElements);
    D_A1_Resid = D_A1_Arr_In - D_Mean;

    Array<double,1> D_A1_Pow(D_A1_Resid.size());
    D_A1_Pow = pow(D_A1_Resid,2);
    D_Var = (sum(D_A1_Pow) - (pow2(sum(D_A1_Resid)))/double(I_NElements)) / (double(I_NElements)-1.);

    double D_SDev = 0.;
    D_SDev = sqrt(D_Var);

    if (D_SDev != 0.){
      if (I_MaxMoment_In > 2)
        D_Skew = sum(pow(D_A1_Resid,3)) / (I_NElements * pow(D_SDev,3));

      if (I_MaxMoment_In > 3)
        D_Kurt = sum(pow(D_A1_Resid,4)) / (I_NElements * pow(D_SDev,4)) - 3.;
    }
  }
  (*P_D_A1_Out)(0) = D_Mean;
  (*P_D_A1_Out)(1) = D_Var;
  (*P_D_A1_Out)(2) = D_Skew;
  (*P_D_A1_Out)(3) = D_Kurt;
  return P_D_A1_Out;
}

/**
 double Moment(Array<double, 1>) const;
 **/
Array<double,1>* CFits::Moment(const Array<double, 2> &D_A2_Arr_In, int I_MaxMoment_In) const
{
  Array<double, 1> D_A1_Temp(D_A2_Arr_In.rows() * D_A2_Arr_In.cols());
  for (int i=0; i<D_A2_Arr_In.cols(); i++){
    D_A1_Temp(Range(i*D_A2_Arr_In.rows(), (i+1)*D_A2_Arr_In.rows()-1)) = D_A2_Arr_In(Range::all(), i);
  }
  return this->Moment(D_A1_Temp, I_MaxMoment_In);
}

/**
 double StdDev(Array<double, 1>) const;
 **/
double CFits::StdDev(const Array<double, 1> &D_A1_Arr_In) const
{
  Array<double,1>* P_D_A1_Moment = this->Moment(D_A1_Arr_In, 2);
  double D_Out = sqrt((*P_D_A1_Moment)(1));
  delete(P_D_A1_Moment);
  return D_Out;
}

double CFits::StdDev(const Array<double, 2> &D_A2_Arr_In) const
{
  Array<double, 1> D_A1_Temp(D_A2_Arr_In.rows() * D_A2_Arr_In.cols());
  for (int i=0; i<D_A2_Arr_In.cols(); i++){
    D_A1_Temp(Range(i*D_A2_Arr_In.rows(), (i+1)*D_A2_Arr_In.rows()-1)) = D_A2_Arr_In(Range::all(), i);
  }
  return this->StdDev(D_A1_Temp);
}

double CFits::StdDev(const Array<double, 2> &D_A2_Arr_In, bool B_IgnoreZeros) const
{
  Array<double, 1> D_A1_Temp(D_A2_Arr_In.rows() * D_A2_Arr_In.cols());
  int I_NGood = 0;
  if (!B_IgnoreZeros){
    for (int i=0; i<D_A2_Arr_In.cols(); i++){
      D_A1_Temp(Range(i*D_A2_Arr_In.rows(), (i+1)*D_A2_Arr_In.rows()-1)) = D_A2_Arr_In(Range::all(), i);
    }
  }
  else{
    Array<double, 1> D_A1_Tem(D_A2_Arr_In.rows() * D_A2_Arr_In.cols());
    D_A1_Tem = 0.;
    for (int i_row = 0; i_row<D_A2_Arr_In.rows(); i_row++){
      for (int i_col = 0; i_col<D_A2_Arr_In.cols(); i_col++){
        if (fabs(D_A2_Arr_In(i_row, i_col)) > 0.00000000000000001){
          D_A1_Tem(I_NGood) = D_A2_Arr_In(i_row, i_col);
          I_NGood++;
        }
      }
    }
    D_A1_Temp.resize(I_NGood);
    D_A1_Temp = D_A1_Tem(Range(0, I_NGood-1));
  }
  return this->StdDev(D_A1_Temp);
}

/**
 double Median(Array<double, int>) const;
 **/
int CFits::Median(const Array<int, 1> &Arr) const
{
  Array<CString, 1> CS_A1_Args_Median(1);
  void **PP_Args_Median;
  PP_Args_Median = (void**)malloc(sizeof(void*) * 1);

  CS_A1_Args_Median = CString(" ");

  CS_A1_Args_Median(0) = CString("MODE");
  CString Mode("NORMAL");
  PP_Args_Median[0] = &Mode;

  int I_Out = this->Median(Arr, CS_A1_Args_Median, PP_Args_Median);
//  free(*PP_Args_Median);
  free(PP_Args_Median);
  return I_Out;
}

double CFits::Median(const Array<double, 1> &Arr) const
{
  Array<CString, 1> CS_A1_Args_Median(1);
  void **PP_Args_Median;
  PP_Args_Median = (void**)malloc(sizeof(void*) * 1);

  CS_A1_Args_Median = CString(" ");

  CS_A1_Args_Median(0) = CString("MODE");
  CString Mode("NORMAL");
  PP_Args_Median[0] = &Mode;

  double D_Out = this->Median(Arr, CS_A1_Args_Median, PP_Args_Median);
//  free(*PP_Args_Median);
  free(PP_Args_Median);
  return D_Out;
}

/**
double Median(Array<double, 2>) const;
**/
double CFits::Median(const Array<double, 2> &Arr, bool B_IgnoreZeros) const{
  Array<double, 1> D_A1_Arr(Arr.rows() * Arr.cols());
  int I_Pos=0;
  int I_N_NoZeros = 0;
  for (int i_row=0; i_row<Arr.rows(); i_row++){
    for (int i_col=0; i_col<Arr.cols(); i_col++){
      if ((B_IgnoreZeros && (fabs(Arr(i_row, i_col)) > 0.0000001)) || (!B_IgnoreZeros)){
          D_A1_Arr(I_Pos) = Arr(i_row, i_col);
          I_Pos++;
          I_N_NoZeros++;
      }
    }
  }
  if (I_N_NoZeros > 0){
    D_A1_Arr.resizeAndPreserve(I_N_NoZeros);
    return (this->Median(D_A1_Arr));
  }
  else{
    return 0.;
  }
}

/**
  double Median(Array<double, int> &Arr, CString &Mode) const;
  Args: MODE(CString)
        ERRORS_IN(Array<double, 1>)
        ERR_OUT(double)
 **/
int CFits::Median(const Array<int, 1> &Arr, const Array<CString, 1> &CS_A1_Args_In, void *PP_Args_In[]) const
{
  int Length = Arr.size();
  int median;
  CString Mode("NORMAL");
  Array<double, 1> *P_D_A1_Errors;
  double *P_D_ErrOut;

  int I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("MODE"));
  if (I_Pos >= 0)
    Mode = *(CString*)PP_Args_In[I_Pos];

  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN"));
  if (I_Pos >= 0){
    P_D_A1_Errors = (Array<double, 1>*)PP_Args_In[I_Pos];

    I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("ERR_OUT"));
    if (I_Pos >= 0)
      P_D_ErrOut = (double*)PP_Args_In[I_Pos];
    else{
      cout << "CFits::Median: ERROR: KeyWord 'ERRORS_IN' set, but 'ERR_OUT' is not" << endl;
      return 0.;
    }
  }

  /** Odd Array **/
  if (this->IsOddNumber(Length))
  {
    median = this->Select(Arr, (int)((double)Length / 2.)+1);
//    if (this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN")) >= 0){
//      *P_D_ErrOut = this->Select(*P_D_A1_Errors, (int)((double)Length / 2.) + 1);
//    }
#ifdef __DEBUG_FITS_MEDIAN__
    cout << "CFits::Median(Array<double, int Length = " << Length << ">, Mode = " << Mode << "): IsOddNumber: median(Arr=" << Arr << ") from Select(" << (int)((double)Length / 2.) + 1 << ") = " << median << endl;
#endif
//    return (median);
  }
  else /** Even Array **/
  {
    /** Return Mean of both Numbers next to Length / 2. **/
    if (Mode.EqualValue(CString("NORMAL")))
    {
      median = ((this->Select(Arr, (int)((double)Length / 2.))) +
                (this->Select(Arr, (int)((double)Length / 2.) + 1))) / 2.;
#ifdef __DEBUG_FITS_MEDIAN__
      cout << "CFits::Median(Array<double, int Length = " << Length << ">, Mode = " << Mode << "): !IsOddNumber: mean of medians(" << this->Select(Arr, (int)((double)Length / 2.)) << " and " << this->Select(Arr, (int)((double)Length / 2.) + 1) << ") from Select() = " << median << endl;
#endif
//      if (this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN")) >= 0){
//        *P_D_ErrOut = ((this->Select(*P_D_A1_Errors, (int)((double)Length / 2.))) +
//            (this->Select(*P_D_A1_Errors, (int)((double)Length / 2.) + 1))) / 2.;
//      }
//      return (median);
    }
    else/** Return Number lower next to Length / 2. **/
    {
      median = this->Select(Arr, (int)((double)Length / 2.));
#ifdef __DEBUG_FITS_MEDIAN__
      cout << "CFits::Median(Array<double, int Length = " << Length << ">, Mode = " << Mode << "): !IsOddNumber: median from Select(" << (int)((double)Length / 2.) << ") = " << median << endl;
#endif
//      if (this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN")) >= 0){
//        *P_D_ErrOut = this->Select(*P_D_A1_Errors, (int)((double)Length / 2.));
//      }
//      return (median);
    }
  }
  //  return Median;

  if (this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN")) >= 0){
    *P_D_ErrOut = 0.;
    for (int i=0; i<Arr.size(); i++){
      *P_D_ErrOut += pow2((Arr)(i) - median);
    }
    *P_D_ErrOut = sqrt(*P_D_ErrOut) / Arr.size();
  }

  return (median);
}

double CFits::Median(const Array<double, 1> &Arr, const Array<CString, 1> &CS_A1_Args_In, void *PP_Args_In[]) const
{
  int Length = Arr.size();
  double median;
  CString Mode("NORMAL");
  Array<double, 1> *P_D_A1_Errors;
  double *P_D_ErrOut;

  int I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("MODE"));
  if (I_Pos >= 0)
    Mode = *(CString*)PP_Args_In[I_Pos];

  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN"));
  if (I_Pos >= 0){
    P_D_A1_Errors = (Array<double, 1>*)PP_Args_In[I_Pos];

    I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("ERR_OUT"));
    if (I_Pos >= 0)
      P_D_ErrOut = (double*)PP_Args_In[I_Pos];
    else{
      cout << "CFits::Median: ERROR: KeyWord 'ERRORS_IN' set, but 'ERR_OUT' is not" << endl;
      return 0.;
    }
  }

  /** Odd Array **/
  if (this->IsOddNumber(Length))
  {
    median = this->Select(Arr, (int)((double)Length / 2.)+1);
//    if (this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN")) >= 0){
//      *P_D_ErrOut = this->Select(*P_D_A1_Errors, (int)((double)Length / 2.) + 1);
//    }
#ifdef __DEBUG_FITS_MEDIAN__
    cout << "CFits::Median(Array<double, int Length = " << Length << ">, Mode = " << Mode << "): IsOddNumber: median(Arr=" << Arr << ") from Select(" << (int)((double)Length / 2.) + 1 << ") = " << median << endl;
#endif
//    return (median);
  }
  else /** Even Array **/
  {
    /** Return Mean of both Numbers next to Length / 2. **/
    if (Mode.EqualValue(CString("NORMAL")))
    {
      median = ((this->Select(Arr, (int)((double)Length / 2.))) +
                (this->Select(Arr, (int)((double)Length / 2.) + 1))) / 2.;
#ifdef __DEBUG_FITS_MEDIAN__
      cout << "CFits::Median(Array<double, int Length = " << Length << ">, Mode = " << Mode << "): !IsOddNumber: mean of medians(" << this->Select(Arr, (int)((double)Length / 2.)) << " and " << this->Select(Arr, (int)((double)Length / 2.) + 1) << ") from Select() = " << median << endl;
#endif
//      if (this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN")) >= 0){
//        *P_D_ErrOut = ((this->Select(*P_D_A1_Errors, (int)((double)Length / 2.))) +
//            (this->Select(*P_D_A1_Errors, (int)((double)Length / 2.) + 1))) / 2.;
//      }
//      return (median);
    }
    else/** Return Number lower next to Length / 2. **/
    {
      median = this->Select(Arr, (int)((double)Length / 2.));
#ifdef __DEBUG_FITS_MEDIAN__
      cout << "CFits::Median(Array<double, int Length = " << Length << ">, Mode = " << Mode << "): !IsOddNumber: median from Select(" << (int)((double)Length / 2.) << ") = " << median << endl;
#endif
//      if (this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN")) >= 0){
//        *P_D_ErrOut = this->Select(*P_D_A1_Errors, (int)((double)Length / 2.));
//      }
//      return (median);
    }
  }
  //  return Median;

  if (this->KeyWord_Set(CS_A1_Args_In, CString("ERRORS_IN")) >= 0){
    *P_D_ErrOut = 0.;
    for (int i=0; i<Arr.size(); i++){
      *P_D_ErrOut += pow2((Arr)(i) - median);
    }
    *P_D_ErrOut = sqrt(*P_D_ErrOut) / Arr.size();
  }

  return (median);
}

/**
  MedianVec(Array<double, int>, int Width, CString &Mode) const;
 **/
Array<double, 1>* CFits::MedianVec(const Array<double, 1> &VecArr, int Width, const CString &Mode) const
{
#ifdef __DEBUG_FITS_MEDIAN__
  cout << "CFits::MedianVec: VecArr = " << VecArr << endl;
#endif
  //  CString *P_TempMode = new CString(Mode);
  Array<double, 1> *P_TempVecArr = new Array<double, 1>(VecArr.size());
  (*P_TempVecArr) = VecArr;
#ifdef __DEBUG_FITS_MEDIAN__
  cout << "CFits::MedianVec: TempVecArr = " << TempVecArr << endl;
#endif
  firstIndex       i;
  int              m;
  int              Start, End, Length;
  bool             Odd;
  Array<CString, 1> CS_A1_Args_Median(1);
  CS_A1_Args_Median = CString(" ");
  CS_A1_Args_Median(0) = CString("MODE");
  void **PP_Args_Median = (void**)malloc(sizeof(void*) * 1);
  PP_Args_Median[0] = const_cast<CString*>(&Mode);

  Length = VecArr.size();
  Odd = this->IsOddNumber(Width);
  //  if (Odd)
  //    (*P_TempMode).Set("NORMAL");

  if (Width < 2)
    return (P_TempVecArr);
  /** Calculate Median for every Pixel**/
  Array<double, 1> *P_TmpVecArr = new Array<double, 1>(Length);
  (*P_TmpVecArr) = (*P_TempVecArr);
  for (m = Width/2; m < Length - Width/2; m++)
  {
    /** Check Start end End Indizes **/
    Start = m - (int)((Width) / 2.);
    End   = m + (int)((Width-1) / 2.);
    if (Start < 0)
      Start = 0;
    if (End > Length - 1)
      End = Length - 1;
#ifdef __DEBUG_FITS_MEDIAN__
    cout << "CFits::MedianVec: run m = " << m << ": Start = " << Start << ", End = " << End << endl;
#endif
    Range tempRange(Start, End);/**!!!!!!!!!!!!!!!!!!!!!!!**/
#ifdef __DEBUG_FITS_MEDIAN__
    cout << "CFits::MedianVec: run m = " << m << ": tempRange set to " << tempRange << endl;
    cout << "CFits::MedianVec: TempVecArr(tempRange) = " << (*P_TempVecArr)(tempRange) << endl;
#endif
    (*P_TmpVecArr)(m) = this->Median((*P_TempVecArr)(tempRange), CS_A1_Args_Median, PP_Args_Median);
    if (!Odd)
    {
      /** Mode == "NORMAL" **/
      if (Mode.EqualValue(CString("NORMAL")) && (End + 1 < Length))
      {
        if (Start != End)
        {
          (*P_TmpVecArr)(m) += this->Median((*P_TempVecArr)(Range(Start+1, End+1)), CS_A1_Args_Median, PP_Args_Median);
          (*P_TmpVecArr)(m) /= 2.;
        }
#ifdef __DEBUG_FITS_MEDIAN__
        cout << "CFits::MedianVec: run m = " << m << ": Odd = false: Mode == Normal: OutArr(m) set to " << (*P_TmpVecArr)(m) << endl;
#endif

      }
    }
  }
  delete P_TempVecArr;
//  free(*PP_Args_Median);
  free(PP_Args_Median);
  return (P_TmpVecArr);
}

/**
 MedianVec(Array<double, int>, int Width") const;
**/
Array<double, 1>* CFits::MedianVec(const Array<double, 1> &arr, int Width) const
{
  CString Mode("NORMAL");
  return this->MedianVec(arr, Width, Mode);
}

bool CFits::Bottom(const Array<double,1> D_A1_Arr_In, int I_Filter_In, const Array<CString, 1> &CS_A1_Args_In, ///: in
                   void *ArgV_In[], Array<double,1>* P_D_A1_Out) const
{
#ifdef __DEBUG_FITS_BOTTOM__
  cout << "CFits::Bottom: D_A1_Arr_In = " << D_A1_Arr_In << endl;
  cout << "CFits::Bottom: I_Filter_In = " << I_Filter_In << endl;
#endif

  CString CS_Temp(" ");
  CS_Temp.Set("ITER");
  int I_Iter,I_Pos;
  int I_NElements = D_A1_Arr_In.size();
#ifdef __DEBUG_FITS_BOTTOM__
  cout << "CFits::Bottom: I_NElements set to " << I_NElements << endl;
#endif

  double D_Eps, D_MN, D_MX;
  P_D_A1_Out->resize(D_A1_Arr_In.size());
  (*P_D_A1_Out) = D_A1_Arr_In;
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_Iter = *(int*)ArgV_In[I_Pos];
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(ITER): I_Iter set to " << I_Iter << endl;
#endif
  }
  else{
    I_Iter = 40;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(ITER): I_Iter set to " << I_Iter << endl;
#endif
  }

  CS_Temp.Set("EPS");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_Eps = *(double*)ArgV_In[I_Pos];
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(EPS): D_Eps set to " << D_Eps << endl;
#endif
  }
  else{
    D_Eps = 0.001;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(EPS): D_Eps set to " << D_Eps << endl;
#endif
  }

  CS_Temp.Set("MIN");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_MN = *(double*)ArgV_In[I_Pos];
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(MIN): D_MN set to " << D_MN << endl;
#endif
  }
  else{
    D_MN = min(D_A1_Arr_In);
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(MIN): D_MN set to " << D_MN << endl;
#endif
  }

  CS_Temp.Set("MAX");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_MX = *(double*)ArgV_In[I_Pos];
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(MAX): D_MX set to " << D_MX << endl;
#endif
  }
  else{
    D_MX = max(D_A1_Arr_In);
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(MAX): D_MX set to " << D_MX << endl;
#endif
  }

  /**
  if(not keyword_set(iter)) then iter=40
  if(not keyword_set(eps)) then eps=0.001
  if(not keyword_set(mn1)) then mn=min(f) else mn=mn1
  if(not keyword_set(mx1)) then mx=max(f) else mx=mx1
  if(keyword_set(pol)) then begin**/

  Array<double,1> D_A1_Temp(1);
  Array<double,1> D_A1_XX(1);
  Array<double,1> D_A1_F(1);
  Array<double,1> D_A1_FF(1);
  Array<double,1> *P_D_A1_FFF = new Array<double,1>(1);
  Array<double,1> *P_D_A1_TempB;
  Array<double,1> D_A1_FF_Old(1);
  Array<int,1> I_A1_Ind(D_A1_Arr_In.size());
  Array<CString, 1> CS_A1_Args_Middle(10);
  CS_A1_Args_Middle = CString(" ");
  void **PP_Args = (void**)malloc(sizeof(void*) * 10);
  int I_Sum,I_N;
  int j = 0;
  int i;
  double D_FMin, D_FMax;
  CS_Temp.Set("POLY");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
///    j=where(f ge mn and f le mx, n)
    I_A1_Ind = where(D_A1_Arr_In >= D_MN && D_A1_Arr_In <= D_MX,1,0);
    I_Sum = sum(I_A1_Ind);
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(POLY): I_Sum set to " << I_Sum << endl;
#endif

///    if(n le round(filter)) then return,f
    if (I_Sum <= I_Filter_In){
      cout << "CFits::Bottom: KeyWord_Set(POLY): I_Sum <= I_Filter_In " << I_Filter_In << " => Returning P_D_A1_Out" << endl;
      return true;
    }

///    xx=(2*dindgen(n_elements(f))/(n_elements(f)-1)-1)(j)
    P_D_A1_Out->resize(D_A1_Arr_In.size());
    D_A1_XX.resize(I_Sum);
    D_A1_F.resize(I_Sum);
    j=0;
    for (i=0;i<I_NElements;i++){
      (*P_D_A1_Out)(i) = 2.*double(i)/(double(I_NElements)-1.)-1.;
      if (I_A1_Ind(i) == 1){
        D_A1_XX(j) = (*P_D_A1_Out)(i);
        D_A1_F(j) = D_A1_Arr_In(i);
        j++;
      }
    }
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(POLY): D_A1_XX set to " << D_A1_XX << endl;
    cout << "CFits::Bottom: KeyWord_Set(POLY): D_A1_F set to " << D_A1_F << endl;
#endif

///    fmin=min(f(j))-1
    D_FMin = min(D_A1_F)-1.;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(POLY): D_FMin set to " << D_FMin << endl;
#endif

///    fmax=max(f(j))+1
    D_FMax = max(D_A1_F)+1.;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(POLY): D_FMax set to " << D_FMax << endl;
#endif

///    ff=(f(j)-fmin)/(fmax-fmin)
    D_A1_FF.resize(D_A1_F.size());
    D_A1_FF = (D_A1_F-D_FMin) / (D_FMax - D_FMin);
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(POLY): D_A1_FF set to " << D_A1_FF << endl;
#endif

///    ff_old=ff
    D_A1_FF_Old.resize(D_A1_FF.size());
    D_A1_FF_Old = D_A1_FF;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(POLY): D_A1_FF_Old set to " << D_A1_FF_Old << endl;
#endif
  }
  else{
///    fff=middle(f,filter,ITER=iter,EPS=eps)

    CS_A1_Args_Middle(0).Set("ITER");
    int iter = I_Iter;
    PP_Args[0] = &iter;

    CS_A1_Args_Middle(1).Set("EPS");
    double eps = D_Eps;
    PP_Args[1] = &eps;

#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): starting this->Middle(D_A1_F,I_Filter_In,(*const_cast<const Array<CString, 1>*>(&CS_A1_Args_Middle)),PP_Args, P_D_A1_FFF) " << D_A1_FF_Old << endl;
#endif
    D_A1_F.resize(D_A1_Arr_In.size());
    D_A1_F = D_A1_Arr_In;

    if (!this->Middle(D_A1_F,I_Filter_In,(*const_cast<const Array<CString, 1>*>(&CS_A1_Args_Middle)),PP_Args, P_D_A1_FFF)){
      cout << "CFits::Bottom: ERROR: 1. Middle(D_A1_F,I_Filter_In,(*const_cast<const Array<CString, 1>*>(&CS_A1_Args_Middle)),PP_Args, P_D_A1_FFF) retuned FALSE" << endl;
      P_D_A1_FFF->resize(D_A1_F.size());
      (*P_D_A1_FFF) = -100000;
      return false;
    }
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): *P_D_A1_FFF set to " << *P_D_A1_FFF << endl;
#endif

///        fmin=min(f)-1
    D_FMin = min(D_A1_F) - 1.;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): D_FMin set to " << D_FMin << endl;
#endif

///        fmax=max(f)+1
    D_FMax = max(D_A1_F) + 1.;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): D_FMax set to " << D_FMax << endl;
#endif

///        fff=(fff-fmin)/(fmax-fmin)
    (*P_D_A1_FFF) = ((*P_D_A1_FFF) - D_FMin) / (D_FMax - D_FMin);
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): *P_D_A1_FFF set to " << *P_D_A1_FFF << endl;
#endif

///        ff=(f-fmin)/(fmax-fmin)/fff
    D_A1_FF.resize(D_A1_F.size());
    D_A1_FF = (D_A1_F - D_FMin) / (D_FMax - D_FMin) / (*P_D_A1_FFF);
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): D_A1_FF set to " << D_A1_FF << endl;
#endif
///        ff_old=ff
    D_A1_FF_Old.resize(D_A1_FF.size());
    D_A1_FF_Old = D_A1_FF;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): D_A1_FF_Old set to " << D_A1_FF_Old << endl;
#endif
///        n=n_elements(f)
    I_N = D_A1_F.size();
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): I_N set to " << I_N << endl;
#endif
  }

///        i=0
  i = 0;
  j = 0;
///        next:i=i+1
//  Array<double,1> *P_D_A1_T = new Array<double,1>(1);
  Array<double,1> *P_D_A1_PolyFitRes = new Array<double,1>(1);
  Array<double,1> *P_D_A1_PolyRes;
  Array<double,1> D_A1_Dev(1);
  //Array<double,1> D_A1_Temp(1);
  double D_Dev;
//  CS_Temp.Set("POLY");
//  I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp);
  while (j < 1){
    i = i+1;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: while: i set to " << i << endl;
#endif
///        if(keyword_set(pol)) then begin
    if (I_Pos >= 0){
///          order=round(filter)
#ifdef __DEBUG_FITS_BOTTOM__
      cout << "CFits::Bottom: while: KeyWord_Set(POLY)" << endl;
#endif

///          if(order gt 0) then begin ; This is a bug in RSI poly routine
      if (I_Filter_In > 0){
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: KeyWord_Set(POLY): I_Filter_In(=" << I_Filter_In << ") > 0" << endl;
#endif
///            t=median(poly(xx,poly_fit(xx,ff,order,/DOUBLE)),3)
//        delete(P_D_A1_PolyFitRes);
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In(= " << I_Filter_In << ") > 0: D_A1_XX = " << D_A1_XX << endl;
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In(= " << I_Filter_In << ") > 0: D_A1_FF =  " << D_A1_FF << endl;
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In(= " << I_Filter_In << ") > 0: I_Filter_In =  " << I_Filter_In << endl;
#endif
        if (!this->PolyFit(D_A1_XX,D_A1_FF,I_Filter_In,P_D_A1_PolyFitRes)){
          cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In(= " << I_Filter_In << ") > 0: ERROR: 1. PolyFit(D_A1_XX,D_A1_FF,I_Filter_In,P_D_A1_PolyFitRes) returned FALSE" << endl;
          return false;
        }
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In(= " << I_Filter_In << ") > 0: *P_D_A1_PolyFitRes set to " << (*P_D_A1_PolyFitRes) << endl;
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In(= " << I_Filter_In << ") > 0: D_A1_XX = " << D_A1_XX << endl;
#endif
        P_D_A1_PolyRes = this->Poly(D_A1_XX,*P_D_A1_PolyFitRes);
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In(= " << I_Filter_In << ") > 0: *P_D_A1_PolyRes set to " << (*P_D_A1_PolyRes) << endl;
#endif
//        return false;

        P_D_A1_TempB = this->MedianVec(*P_D_A1_PolyRes,3);
        P_D_A1_Out->resize(P_D_A1_TempB->size());
        (*P_D_A1_Out) = (*P_D_A1_TempB);
        delete(P_D_A1_TempB);
        delete(P_D_A1_PolyRes);
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: 1. *P_D_A1_Out set to " << *P_D_A1_Out << endl;
#endif

///            dev=sqrt(poly(xx,poly_fit(xx,((t-ff)>0.)^2,order,/DOUBLE))>0.)
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: 1. *P_D_A1_PolyFitRes set to " << *P_D_A1_PolyFitRes << endl;
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: 1. D_A1_FF.size() = " << D_A1_FF.size() << endl;
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: 1. D_A1_FF = " << D_A1_FF << endl;
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: 1. P_D_A1_Out->size() = " << P_D_A1_Out->size() << endl;
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: 1. P_D_A1_Out = " << *P_D_A1_Out << endl;
#endif
        D_A1_Temp.resize(D_A1_FF.size());
        D_A1_Temp = (*P_D_A1_Out) - D_A1_FF;
        D_A1_Temp = where(D_A1_Temp < 0., 0., D_A1_Temp);
        D_A1_Temp = pow(D_A1_Temp,2);
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: D_A1_Temp set to " << D_A1_Temp << endl;
#endif
//        delete(P_D_A1_PolyFitRes);
        if (!this->PolyFit(D_A1_XX,D_A1_Temp,I_Filter_In, P_D_A1_PolyFitRes)){
          cout << "CFits::Bottom: while: i = " << i << ":: KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: ERROR: 2. PolyFit(D_A1_XX,D_A1_Temp,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
          return false;
        }
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: a) *P_D_A1_PolyFitRes set to " << *P_D_A1_PolyFitRes << endl;
#endif
        P_D_A1_PolyRes = this->Poly(D_A1_XX,*P_D_A1_PolyFitRes);
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " > 0: a) *P_D_A1_PolyRes set to " << *P_D_A1_PolyRes << endl;
#endif
///          endif else begin
      }
      else{

        ///            t=replicate(poly_fit(xx,ff,order,/DOUBLE),n_elements(f))
//        delete(P_D_A1_PolyFitRes);
        if (!this->PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes)){
          cout << "CFits::Bottom: while: i = " << i << ":: KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " <= 0: ERROR: 3. PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
          return false;
        }

        P_D_A1_TempB = this->Replicate((*P_D_A1_PolyFitRes)(0),D_A1_F.size());
        P_D_A1_Out->resize(P_D_A1_TempB->size());
        (*P_D_A1_Out) = (*P_D_A1_TempB);
        delete(P_D_A1_TempB);
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " <= 0: 2. *P_D_A1_Out set to " << *P_D_A1_Out << endl;
#endif

///            dev=sqrt(replicate(poly_fit(xx,(t-ff)^2,order,/DOUBLE),n_elements(f))>0.)
///            dev=sqrt(replicate(poly_fit(xx,((t-ff)>0.)^2,order,/DOUBLE),n_elements(f))>0.)

//        delete(P_D_A1_PolyFitRes);
        D_A1_Temp.resize(D_A1_FF.size());
        D_A1_Temp = (*P_D_A1_Out) - D_A1_FF;
        D_A1_Temp = where(D_A1_Temp < 0., 0., D_A1_Temp);
        D_A1_Temp = pow(D_A1_Temp,2);
        if (!this->PolyFit(D_A1_XX,D_A1_Temp,I_Filter_In, P_D_A1_PolyFitRes)){
          cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " <= 0: ERROR: 4. PolyFit(D_A1_XX,D_A1_Temp,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
          return false;
        }
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " <= 0: *P_D_A1_PolyFitRes set to " << *P_D_A1_PolyFitRes << endl;
#endif
        P_D_A1_PolyRes = this->Replicate((*P_D_A1_PolyFitRes)(0),D_A1_F.size());
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): I_Filter_In = " << I_Filter_In << " <= 0: *P_D_A1_PolyRes set to " << *P_D_A1_PolyRes << endl;
#endif

///          endelse
      }
      D_A1_Dev.resize(P_D_A1_PolyRes->size());
      D_A1_Dev = sqrt(where((*P_D_A1_PolyRes) > 0., (*P_D_A1_PolyRes), 0.));
      delete(P_D_A1_PolyRes);
#ifdef __DEBUG_FITS_BOTTOM__
      cout << "CFits::Bottom: while: i = " << i << ": KeyWord_Set(POLY): D_A1_Dev set to " << D_A1_Dev << endl;
#endif
///        endif else begin
    }
    else{
///          t=median(opt_filter(ff,filter),3)
      P_D_A1_PolyRes = this->OptFilter(D_A1_FF, I_Filter_In);
      P_D_A1_TempB = this->MedianVec((*P_D_A1_PolyRes),3);
      P_D_A1_Out->resize(P_D_A1_TempB->size());
      (*P_D_A1_Out) = (*P_D_A1_TempB);
      delete(P_D_A1_TempB);
      delete(P_D_A1_PolyRes);
#ifdef __DEBUG_FITS_BOTTOM__
      cout << "CFits::Bottom: while: i = " << i << ": !KeyWord_Set(POLY): *P_D_A1_Out set to " << *P_D_A1_Out << endl;
#endif

///          dev=sqrt(opt_filter((t-ff)^2,filter))
      delete(P_D_A1_PolyFitRes);
      P_D_A1_PolyFitRes = new Array<double,1>(P_D_A1_Out->size());
      (*P_D_A1_PolyFitRes) = (*P_D_A1_Out)-D_A1_FF;
      (*P_D_A1_PolyFitRes) = where((*P_D_A1_PolyFitRes) < 0., 0., (*P_D_A1_PolyFitRes));

      D_A1_Temp.resize(P_D_A1_PolyFitRes->size());
      D_A1_Temp = pow((*P_D_A1_PolyFitRes),2);
      P_D_A1_PolyRes = this->OptFilter(D_A1_Temp, I_Filter_In);
      (*P_D_A1_PolyRes) = where((*P_D_A1_PolyRes) < 0., 0., (*P_D_A1_PolyRes));
      D_A1_Dev.resize(P_D_A1_PolyRes->size());
      D_A1_Dev = sqrt(*P_D_A1_PolyRes);
      delete(P_D_A1_PolyRes);
#ifdef __DEBUG_FITS_BOTTOM__
      cout << "CFits::Bottom: while: i = " << i << ": !KeyWord_Set(POLY): D_A1_Dev set to " << D_A1_Dev << endl;
#endif
///        endelse
    }
///        ff=((t-dev)>ff)<t
    for (int l=0; l < D_A1_FF.size(); l++){
      if (D_A1_FF(l) < (*P_D_A1_Out)(l)-D_A1_Dev(l)){
        D_A1_FF(l) = (*P_D_A1_Out)(l)-D_A1_Dev(l);
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": for (int l=0(=" << l << "); l < D_A1_FF.size(=" << D_A1_FF.size() << "); l++): 1. D_A1_FF(l=" << l << ") set to " << D_A1_FF(l) << endl;
#endif
      }
      if (D_A1_FF(l) > (*P_D_A1_Out)(l)){
        D_A1_FF(l) = (*P_D_A1_Out)(l);
#ifdef __DEBUG_FITS_BOTTOM__
        cout << "CFits::Bottom: while: i = " << i << ": for (int l=0(=" << l << "); l < D_A1_FF.size(=" << D_A1_FF.size() << "); l++): 2. D_A1_FF(l=" << l << ") set to " << D_A1_FF(l) << endl;
#endif
      }
    }
///        dev2=max(abs(ff-ff_old)/ff)
    D_Dev = max(abs(D_A1_FF - D_A1_FF_Old)/D_A1_FF);
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: while: i = " << i << ": D_Dev set to " << D_Dev << endl;
#endif
///        ff_old=ff
    D_A1_FF_Old = D_A1_FF;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: while: i = " << i << ": D_A1_FF_Old set to " << D_A1_FF_Old << endl;
#endif
///        if(dev2 gt eps and i lt iter) then goto,next
    if (D_Dev < D_Eps or i > I_Iter){
#ifdef __DEBUG_FITS_BOTTOM__
      cout << "CFits::Bottom: while: i = " << i << ": D_Dev(=" << D_Dev << ") < D_Eps(=" << D_Eps << ") or i(=" << i << ") > I_Iter(=" << I_Iter << "): breaking while loop " << endl;
#endif
      break;
    }
  }
///        if(keyword_set(pol)) then begin
  if (I_Pos >= 0){
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(POLY)" << endl;
#endif
///          x=(2*dindgen(n_elements(f))/(n_elements(f)-1)-1)
    /// --- ??? x never gets used
///          if(order gt 0) then begin ; This is a bug in RSI poly routine
    if (I_Filter_In > 0){
///            t=median(poly(xx,poly_fit(xx,ff,order,/DOUBLE)),3)
//      delete(P_D_A1_PolyFitRes);
      if (!this->PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes)){
        cout << "CFits::Bottom: ERROR: 5. PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
        return false;
      }
      P_D_A1_PolyRes = this->Poly(D_A1_XX,*P_D_A1_PolyFitRes);
      P_D_A1_TempB = this->MedianVec((*P_D_A1_PolyRes),3);
      P_D_A1_Out->resize(P_D_A1_TempB->size());
      (*P_D_A1_Out) = (*P_D_A1_TempB);
      delete(P_D_A1_TempB);
      delete(P_D_A1_PolyRes);
#ifdef __DEBUG_FITS_BOTTOM__
      cout << "CFits::Bottom: KeyWord_Set(POLY): I_Filter_In > 0: *P_D_A1_Out set to " << *P_D_A1_Out << endl;
#endif
///          endif else begin
    }
    else{
///            t=replicate(poly_fit(xx,ff,order,/DOUBLE),n_elements(f))
//      delete(P_D_A1_PolyFitRes);
      if (!this->PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes)){
        cout << "CFits::Bottom: ERROR: 6. PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
        return false;
      }
//      delete(P_D_A1_Out);
      P_D_A1_TempB = this->Replicate((*P_D_A1_PolyFitRes)(0),D_A1_F.size());
      P_D_A1_Out->resize(P_D_A1_TempB->size());
      (*P_D_A1_Out) = (*P_D_A1_TempB);
      delete(P_D_A1_TempB);
#ifdef __DEBUG_FITS_BOTTOM__
      cout << "CFits::Bottom: KeyWord_Set(POLY): I_Filter_In <= 0: *P_D_A1_Out set to " << *P_D_A1_Out << endl;
#endif
///          endelse
    }
///    return,t*(fmax-fmin)+fmin
    (*P_D_A1_Out) = (*P_D_A1_Out) * (D_FMax - D_FMin) + D_FMin;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: KeyWord_Set(POLY): 3. *P_D_A1_Out set to " << *P_D_A1_Out << endl;
#endif
///        endif
  }
  else{
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: not KeyWord_Set(POLY)" << endl;
#endif
///        return,t*fff*(fmax-fmin)+fmin
    (*P_D_A1_Out) = (*P_D_A1_Out) * (*P_D_A1_FFF) * (D_FMax - D_FMin) + D_FMin;
#ifdef __DEBUG_FITS_BOTTOM__
    cout << "CFits::Bottom: !KeyWord_Set(POLY): *P_D_A1_Out set to " << *P_D_A1_Out << endl;
#endif
  }
  delete(P_D_A1_PolyFitRes);
  return true;
  /**

  i=0
  next:i=i+1
  if(keyword_set(pol)) then begin
  order=round(filter)
  if(order gt 0) then begin ; This is a bug in RSI poly routine
  t=median(poly(xx,poly_fit(xx,ff,order,/DOUBLE)),3)
  dev=sqrt(poly(xx,poly_fit(xx,((t-ff)>0.)^2,order,/DOUBLE))>0.)
  endif else begin
  t=replicate(poly_fit(xx,ff,order,/DOUBLE),n_elements(f))
  dev=sqrt(replicate(poly_fit(xx,((t-ff)>0.)^2,order,/DOUBLE),n_elements(f))>0.)
  endelse
  endif else begin
  t=median(opt_filter(ff,filter),3)
  dev=sqrt(opt_filter((t-ff)>0.,filter)>0.)
  endelse
  ff=((t-dev)>ff)<t
  dev2=max(abs(ff-ff_old)/ff)
           ff_old=ff
           if(dev2 gt eps and i lt iter) then goto,next

           if(keyword_set(pol)) then begin
           x=(2*dindgen(n_elements(f))/(n_elements(f)-1)-1)
           if(order gt 0) then begin ; This is a bug in RSI poly routine
           t=median(poly(xx,poly_fit(xx,ff,order,/DOUBLE)),3)
           endif else begin
           t=replicate(poly_fit(xx,ff,order,/DOUBLE),n_elements(f))
           endelse
           return,t*(fmax-fmin)+fmin
           endif else $
           return,t*fff*(fmax-fmin)+fmin
  **/
}

/** **********************************************************************/

/** if(n_params() lt 2) then begin
    print,'syntax: middle,f,{filter/order}[,ITER=iter[,EPS=eps $'
    print,'               [,MIN=mn[,[MAX=mx[,/POLY]]]]]]'
    print,'where f      is the function to fit,'
    print,'      filter is the smoothing parameter for the optimal filter.'
    print,'             If POLY is set, it is interpreted as the order'
    print,'             of the smoothing polynomial,'
    print,'      iter   is the maximum number of iterations [def: 40]'
    print,'      eps    is convergence level [def: 0.001]'
    print,'      mn     minimum function values to be considered [def: min(f)]'
    print,'      mx     maximum function values to be considered [def: max(f)]'
    return,0
  endif**/
bool CFits::Middle(const Array<double,1> D_A1_Arr_In, int I_Filter_In, const Array<CString, 1> &CS_A1_Args_In, ///: in
                   void *ArgV[], Array<double,1>* P_D_A1_Out) const
{
  #ifdef __DEBUG_FITS_MIDDLE__
  cout << "CFits::Middle started" << endl;
  cout << "CFits::Middle: D_A1_Arr_In = " << D_A1_Arr_In << endl;
  cout << "CFits::Middle: I_Filter_In = " << I_Filter_In << endl;
  cout << "CFits::Middle: CS_A1_Args_In = " << CS_A1_Args_In << endl;
  #endif
  ///        if(not keyword_set(iter)) then iter=40
  CString CS_Temp(" ");
  int I_Iter;
  int I_Sum,I_Pos;
  int I_NElements = D_A1_Arr_In.size();
  int i,j;
  double D_Eps, D_MN, D_MX;
  double D_FMin, D_FMax;
  P_D_A1_Out->resize(D_A1_Arr_In.size());
  Array<double,1> D_A1_F(1);
  Array<double,1> D_A1_FF(1);
  Array<double,1> D_A1_FF_Old(1);
  Array<double,1> D_A1_XX(1);
  Array<double,1> *P_D_A1_TempB;
  (*P_D_A1_Out) = D_A1_Arr_In;

  cout << "CFits::Middle: checking for keywords" << endl;

  CS_Temp.Set("ITER");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    I_Iter = *(int*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(ITER) => I_Iter set to " << I_Iter << endl;
    #endif
  }
  else{
    I_Iter = 40;
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(ITER) => I_Iter set to " << I_Iter << endl;
    #endif
  }

  ///        if(not keyword_set(eps)) then eps=0.001
  CS_Temp.Set("EPS");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_Eps = *(double*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(EPS) => D_Eps set to " << D_Eps << endl;
    #endif
  }
  else{
    D_Eps = 0.001;
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(EPS) => D_Eps set to " << D_Eps << endl;
    #endif
  }

  ///        if(not keyword_set(mn1)) then mn=min(f) else mn=mn1
  CS_Temp.Set("MIN");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_MN = *(double*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(MIN) => D_MN set to " << D_MN << endl;
    #endif
  }
  else{
    D_MN = min(D_A1_Arr_In);
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(MIN) => D_MN set to " << D_MN << endl;
    #endif
  }

///        if(not keyword_set(mx1)) then mx=max(f) else mx=mx1
  CS_Temp.Set("MAX");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    D_MX = *(double*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(MAX) => D_MX set to " << D_MX << endl;
    #endif
  }
  else{
    D_MX = max(D_A1_Arr_In);
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(MAX) => D_MX set to " << D_MX << endl;
    #endif
  }
///        if(keyword_set(pol)) then begin

  Array<int, 1> I_A1_Ind(D_A1_Arr_In.size());

  CS_Temp.Set("POLY");
  cout << "CFits::Middle: CS_A1_Args_In = " << CS_A1_Args_In << endl;
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(POLY) " << endl;
    #endif
    ///        j=where(f ge mn and f le mx, n)
    I_A1_Ind = where(D_A1_Arr_In >= D_MN && D_A1_Arr_In <= D_MX,1,0);
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(POLY): I_A1_Ind set to " << I_A1_Ind << endl;
#endif
    I_Sum = sum(I_A1_Ind);
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(POLY): I_Sum set to " << I_Sum << endl;
#endif

///    if(n le round(filter)) then return,f
    if (I_Sum <= I_Filter_In){
#ifdef __DEBUG_FITS_MIDDLE__
      cout << "CFits::Middle: KeyWord_Set(POLY): I_Sum(=" << I_Sum << ") <= I_Filter_In(=" << I_Filter_In << ") => returning (*P_D_A1_Out) = " << *P_D_A1_Out << endl;
#endif
      return true;
    }

///    xx=(2*dindgen(n_elements(f))/(n_elements(f)-1)-1)(j)
    P_D_A1_TempB = new Array<double,1>(D_A1_Arr_In.size());
    P_D_A1_Out->resize(P_D_A1_TempB->size());
    (*P_D_A1_Out) = (*P_D_A1_TempB);
    delete(P_D_A1_TempB);
    for (i=0;i<I_NElements;i++){
      (*P_D_A1_Out)(i) = 2*i/(I_NElements-1)-1;
#ifdef __DEBUG_FITS_MIDDLE__
      cout << "CFits::Middle: KeyWord_Set(POLY): (*P_D_A1_Out)(i=" << i << ") set to " << (*P_D_A1_Out)(i) << endl;
#endif
    }
    D_A1_XX.resize(I_Sum);
    D_A1_F.resize(I_Sum);
    j = 0;
    for (i=0;i<I_NElements; i++){
      if (I_A1_Ind(i) == 1){
        D_A1_XX(j) = (*P_D_A1_Out)(i);
        D_A1_F(j) = D_A1_Arr_In(i);
#ifdef __DEBUG_FITS_MIDDLE__
        cout << "CFits::Middle: KeyWord_Set(POLY): D_A1_XX(j=" << j << ") set to " << D_A1_XX(j) << endl;
        cout << "CFits::Middle: KeyWord_Set(POLY): D_A1_F(j=" << j << ") set to " << D_A1_F(j) << endl;
#endif
        j++;
      }
    }

///    fmin=min(f(j))-1
    D_FMin = min(D_A1_F)-1.;
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(POLY): D_FMin set to " << D_FMin << endl;
#endif

///    fmax=max(f(j))+1
    D_FMax = max(D_A1_F)+1.;
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(POLY): D_FMax set to " << D_FMax << endl;
#endif

///    ff=(f(j)-fmin)/(fmax-fmin)
    D_A1_FF.resize(D_A1_F.size());
    D_A1_FF = (D_A1_F-D_FMin) / (D_FMax - D_FMin);
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: KeyWord_Set(POLY): D_A1_FF set to " << D_A1_FF << endl;
#endif

///    ff_old=ff
    D_A1_FF_Old.resize(D_A1_FF.size());
    D_A1_FF_Old = D_A1_FF;
  }
  else{
    #ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(POLY) " << endl;
    #endif
    ///      endif else begin
///        fmin=min(f)-1
    D_FMin = min(D_A1_Arr_In)-1.;
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(POLY): D_FMin set to " << D_FMin << endl;
#endif

///        fmax=max(f)+1
    D_FMax = max(D_A1_Arr_In)+1.;
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(POLY): D_FMax set to " << D_FMax << endl;
#endif

///        ff=(f-fmin)/(fmax-fmin)
    D_A1_FF.resize(D_A1_Arr_In.size());
    D_A1_FF = (D_A1_Arr_In - D_FMin) / (D_FMax - D_FMin);
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(POLY): D_A1_FF set to " << D_A1_FF << endl;
#endif

///        ff_old=ff
    D_A1_FF_Old.resize(D_A1_FF.size());
    D_A1_FF_Old = D_A1_FF;

///        n=n_elements(f)
    I_NElements = D_A1_Arr_In.size();
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: !KeyWord_Set(POLY): I_NElements set to " << I_NElements << endl;
#endif
///      endelse
  }

///        i=0
  i = 0;
  j = 0;
///        next:i=i+1
///  Array<double,1> *P_D_A1_T = new Array<double,1>(1);
  Array<double,1> *P_D_A1_PolyFitRes = new Array<double,1>(1);
  Array<double,1> *P_D_A1_PolyRes = new Array<double,1>(1);
  Array<double,1> D_A1_Dev(1);
  Array<double,1> D_A1_Temp(1);
  double D_Dev;
  CS_Temp.Set("POLY");
  I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp);
  while (j < 1){
    i = i+1;
///        if(keyword_set(pol)) then begin
    if (I_Pos >= 0){
#ifdef __DEBUG_FITS_MIDDLE__
      cout << "CFits::Middle: while(i=" << i << "): KeyWord_Set(POLY)" << endl;
#endif
///          order=round(filter)

///          if(order gt 0) then begin ; This is a bug in RSI poly routine
      if (I_Filter_In > 0){
///            t=median(poly(xx,poly_fit(xx,ff,order,/DOUBLE)),3)
//        delete(P_D_A1_PolyFitRes);
#ifdef __DEBUG_FITS_MIDDLE__
        cout << "CFits::Middle: while(i=" << i << "): Starting PolyFit" << endl;
#endif
        if (!this->PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes)){
          cout << "CFits::Middle: ERROR: 1. PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
          return false;
        }
        delete(P_D_A1_PolyRes);
        P_D_A1_PolyRes = this->Poly(D_A1_XX,*P_D_A1_PolyFitRes);
        P_D_A1_TempB = this->MedianVec(*P_D_A1_PolyRes,3);
        P_D_A1_Out->resize(P_D_A1_TempB->size());
        (*P_D_A1_Out) = (*P_D_A1_TempB);
        delete(P_D_A1_TempB);
///            dev=sqrt(poly(xx,poly_fit(xx,(t-ff)^2,round(filter),/DOUBLE))>0.)
//        delete(P_D_A1_PolyFitRes);
        D_A1_Temp.resize(P_D_A1_Out->size());
        D_A1_Temp = pow((*P_D_A1_Out) - D_A1_FF,2);
        if (!this->PolyFit(D_A1_XX,D_A1_Temp,I_Filter_In, P_D_A1_PolyFitRes)){
          cout << "CFits::Middle: ERROR: 2. PolyFit(D_A1_XX,D_A1_Temp,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
          return false;
        }
        delete(P_D_A1_PolyRes);
        P_D_A1_PolyRes = this->Poly(D_A1_XX,*P_D_A1_PolyFitRes);
///          endif else begin
      }
      else{
///            t=replicate(poly_fit(xx,ff,order,/DOUBLE),n_elements(f))
//        delete(P_D_A1_PolyFitRes);
        if (!this->PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes)){
          cout << "CFits::Middle: ERROR: 3. PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
          return false;
        }
        P_D_A1_TempB = this->Replicate((*P_D_A1_PolyFitRes)(0),D_A1_F.size());
        P_D_A1_Out->resize(P_D_A1_TempB->size());
        (*P_D_A1_Out) = (*P_D_A1_TempB);
        delete(P_D_A1_TempB);
///            dev=sqrt(replicate(poly_fit(xx,(t-ff)^2,order,/DOUBLE),n_elements(f))>0.)
//        delete(P_D_A1_PolyFitRes);
        D_A1_Temp.resize(P_D_A1_Out->size());
        D_A1_Temp = pow((*P_D_A1_Out) - D_A1_FF,2);
        if (!this->PolyFit(D_A1_XX,D_A1_Temp,I_Filter_In, P_D_A1_PolyFitRes)){
          cout << "CFits::Middle: ERROR: 4. PolyFit(D_A1_XX,D_A1_Temp,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
          return false;
        }
        delete(P_D_A1_PolyRes);
        P_D_A1_PolyRes = this->Replicate((*P_D_A1_PolyFitRes)(0),D_A1_F.size());

///          endelse
      }
      D_A1_Dev.resize(P_D_A1_PolyRes->size());
      D_A1_Dev = sqrt(where((*P_D_A1_PolyRes) > 0., (*P_D_A1_PolyRes), 0.));
///        endif else begin
    }
    else{
///          t=median(opt_filter(ff,filter),3)
      delete(P_D_A1_PolyRes);
      P_D_A1_PolyRes = this->OptFilter(D_A1_FF, I_Filter_In);
      P_D_A1_TempB = this->MedianVec((*P_D_A1_PolyRes),3);
      P_D_A1_Out->resize(P_D_A1_TempB->size());
      (*P_D_A1_Out) = (*P_D_A1_TempB);
#ifdef __DEBUG_FITS_MIDDLE__
      cout << "CFits::Middle: !KeyWord_Set(POLY): (*P_D_A1_Out) set to " << (*P_D_A1_Out) << endl;
#endif
      delete(P_D_A1_TempB);
///          dev=sqrt(opt_filter((t-ff)^2,filter))
      delete(P_D_A1_PolyRes);
      D_A1_Temp.resize(P_D_A1_Out->size());
      D_A1_Temp = pow((*P_D_A1_Out) - D_A1_FF,2);
      P_D_A1_PolyRes = this->OptFilter(D_A1_Temp, I_Filter_In);
      D_A1_Dev.resize(P_D_A1_PolyRes->size());
      D_A1_Dev = sqrt(*P_D_A1_PolyRes);
#ifdef __DEBUG_FITS_MIDDLE__
      cout << "CFits::Middle: !KeyWord_Set(POLY): D_A1_Dev set to " << D_A1_Dev << endl;
#endif
///        endelse
    }
///        ff=((t-dev)>ff)<(t+dev)
    for (int l=0; l < D_A1_FF.size(); l++){
      if (D_A1_FF(l) < (*P_D_A1_Out)(l)-D_A1_Dev(l))
        D_A1_FF(l) = (*P_D_A1_Out)(l)-D_A1_Dev(l);
      if (D_A1_FF(l) > (*P_D_A1_Out)(l)+D_A1_Dev(l))
        D_A1_FF(l) = (*P_D_A1_Out)(l)+D_A1_Dev(l);
    }
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: D_A1_FF set to " << D_A1_FF << endl;
#endif
///        dev2=max(abs(ff-ff_old)/ff)
    D_Dev = max(abs(D_A1_FF - D_A1_FF_Old)/D_A1_FF);
#ifdef __DEBUG_FITS_MIDDLE__
    cout << "CFits::Middle: D_Dev set to " << D_Dev << endl;
#endif
///        ff_old=ff
    D_A1_FF_Old = D_A1_FF;
///        if(dev2 gt eps and i lt iter) then goto,next
    if (D_Dev < D_Eps or i > I_Iter)
      break;
  }
///        if(keyword_set(pol)) then begin
  if (I_Pos >= 0){
///          x=(2*dindgen(n_elements(f))/(n_elements(f)-1)-1)
    /// --- ??? x never gets used
///          if(order gt 0) then begin ; This is a bug in RSI poly routine
    if (I_Filter_In > 0){
///            t=median(poly(xx,poly_fit(xx,ff,order,/DOUBLE)),3)
//      delete(P_D_A1_PolyFitRes);
      if (!this->PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes)){
        cout << "CFits::Middle: ERROR: 5. PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
        return false;
      }
      delete(P_D_A1_PolyRes);
      P_D_A1_PolyRes = this->Poly(D_A1_XX,*P_D_A1_PolyFitRes);
      P_D_A1_TempB = this->MedianVec((*P_D_A1_PolyRes),3);
      P_D_A1_Out->resize(P_D_A1_TempB->size());
      (*P_D_A1_Out) = (*P_D_A1_TempB);
#ifdef __DEBUG_FITS_MIDDLE__
      cout << "CFits::Middle: KeyWord_Set(POLY): I_Filter_In > 0: (*P_D_A1_Out) set to " << (*P_D_A1_Out) << endl;
#endif
      delete(P_D_A1_TempB);
///          endif else begin
    }
    else{
///            t=replicate(poly_fit(xx,ff,order,/DOUBLE),n_elements(f))
//      delete(P_D_A1_PolyFitRes);
      if (!this->PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes)){
        cout << "CFits::Middle: ERROR: 6. PolyFit(D_A1_XX,D_A1_FF,I_Filter_In, P_D_A1_PolyFitRes) returned FALSE" << endl;
        return false;
      }
      P_D_A1_TempB = this->Replicate((*P_D_A1_PolyFitRes)(0),D_A1_F.size());
      P_D_A1_Out->resize(P_D_A1_TempB->size());
      (*P_D_A1_Out) = (*P_D_A1_TempB);
#ifdef __DEBUG_FITS_MIDDLE__
      cout << "CFits::Middle: KeyWord_Set(POLY): I_Filter_In <= 0: (*P_D_A1_Out) set to " << (*P_D_A1_Out) << endl;
#endif
      delete(P_D_A1_TempB);
///          endelse
    }
///        endif
  }
///        return,t*(fmax-fmin)+fmin
  (*P_D_A1_Out) = (*P_D_A1_Out) * (D_FMax - D_FMin) + D_FMin;
#ifdef __DEBUG_FITS_MIDDLE__
  cout << "CFits::Middle: (*P_D_A1_Out) set to " << (*P_D_A1_Out) << endl;
#endif
  delete(P_D_A1_PolyFitRes);
  delete(P_D_A1_PolyRes);
  return true;
}

/** ********************************************************************************/

Array<double,1>* CFits::OptFilter(const Array<double,1> &D_A1_In, int I_Width) const{
///  if((size(y))(0) eq 1 or $
///      ((size(y))(0) eq 2 and ((size(y))(1) eq n_elements(y) or $
///      (size(y))(2) eq n_elements(y)))) then begin**/

///  n=n_elements(y)
  int I_N = D_A1_In.size();

  Array<double,1> *P_D_A1_Out = new Array<double,1>(I_N);
  (*P_D_A1_Out) = D_A1_In;
///  if(par eq 0) then return,y
  if (I_Width == 0)
    return P_D_A1_Out;

///  if(keyword_set(dbl)) then begin
///  a=replicate(-double(abs(par)),n)
  Array<double,1>* P_D_A1_A = this->Replicate(-double(abs(I_Width)),I_N);

  ///  b=[1.d0+abs(par),replicate(1.d0+2.d0*abs(par),n-2),1.d0+abs(par)]
  Array<double,1>* P_D_A1_B = this->Replicate(1. + 2.*abs(I_Width),I_N);
  (*P_D_A1_B)(0) = 1.+abs(I_Width);
  (*P_D_A1_B)(I_N-1) = 1.+abs(I_Width);
///  endif else begin
///  a=replicate(-float(abs(par)),n)
///  b=[1.0+abs(par),replicate(1.0+2.0*abs(par),n-2),1.0+abs(par)]
///  endelse

///  f = trisol(a, b, a, double(reform(y)), DOUBLE=dbl)
  Array<double,1> *P_D_A1_Temp = new Array<double,1>(D_A1_In.size());
  (*P_D_A1_Temp) = D_A1_In;///NO REFORM NEEDED HERE!
  Array<double,1> *P_D_A1_F = new Array<double,1>(P_D_A1_Temp->size());
  if (!this->TriDag(*P_D_A1_A, *P_D_A1_B, *P_D_A1_A, *P_D_A1_Temp, *P_D_A1_F)){
    cout << "CFits::OptFilter: ERROR: TriDag retuned FALSE!" << endl;
    exit(EXIT_FAILURE);
  }
///  return,f
  delete(P_D_A1_Out);
  delete(P_D_A1_A);
  delete(P_D_A1_B);
  delete(P_D_A1_Temp);
  return(P_D_A1_F);
}

Array<double,2>* CFits::OptFilter(const Array<double,2> &D_A2_In, int I_XWidth, int I_YWidth, int I_MaxIter) const{
/**
  Function Opt_Filter,y,par,par1,DOUBLE=dbl,MAXIT=maxiter
  print,'Optimal filtering routine:'
  print,'Syntax: r=Opt_Filter(f,xwidth[,ywidth[,/DOUBLE[,MAXIT=maxiter]]])'
  print,'where:  f      - 1D or 2D array of type I,F or D'
  print,'        xwidth - filter width (for 2D array width in X direction (1st index)'
  print,'        ywidth - (for 2D array only) filter width in Y direction (2nd index)'
  print,'                 if ywidth is missing for 2D array, it set equal to xwidth'
  print,'        DOUBLE - perform calculations in double precision'
  print,'        maxiter- maximum number of iteration for filtering of 2D array'
  print,'Opt_Filter solves the optimization problem for r:'
  print,'        total((f - r)^2) + width*total((r(i) - r(i-1))^2) = min'
  if(keyword_set(y)) then return,y else return,0
  endif
**/
///  endif else if((size(y))(0) eq 2) then begin
///    if(not keyword_set(par1)) then par1=par
  if (I_YWidth == 0)
    I_YWidth = I_XWidth;
  Array<double,2> *P_D_A2_Out = new Array<double,2>(D_A2_In.rows(), D_A2_In.cols());
  (*P_D_A2_Out) = D_A2_In;
///    if(par eq 0 and par1 eq 0) then return,y
//  if (I_XWidth == 0 and I_YWidth == 0)
    return P_D_A2_Out;

///    n=n_elements(y)
///    nc=(size(y))(1)
///    nr=(size(y))(2)
//  int I_N = D_A2_In.size();
//  int I_NC = D_A2_In.cols();
//  int I_NR = D_A2_In.rows();

///    if(keyword_set(dbl)) then begin
///      adiag=double(abs(par ))
//  double D_ADiag = double(abs(I_XWidth));
///      bdiag=double(abs(par1))
//  double D_BDiag = double(abs(I_YWidth));
///    endif else begin
///      adiag=float(abs(par ))
///      bdiag=float(abs(par1))
///    endelse
///                                                    ;Main diagonal first:
///    aa=[1.+adiag+bdiag,                           $ ; upper-left corner
///    replicate(1.+2.*adiag+   bdiag,nc-2),     $ ; first row
///    1.+adiag+bdiag,                           $ ; upper-right corner
///    replicate(1.+2.*adiag+2.*bdiag,n-2*nc),   $ ; all other points
///    1.+adiag+bdiag,                           $ ; lower-left corner
///    replicate(1.+2.*adiag+   bdiag,nc-2),     $ ; last row
///    1.+adiag+bdiag,                           $ ; lower-right corner
///    replicate(-adiag,n-1),                    $ ;Upper sub-diagonal for X
///    replicate(-adiag,n-1),                    $ ;Lower sub-diagonal for X
///    replicate(-bdiag,n-nc),                   $ ;Upper sub-diagonal for Y
///    replicate(-bdiag,n-nc)]                     ;Lower sub-diagonal for Y

///    col=lindgen(nr-2)*nc+nc                         ;Special cases:
///    aaa=replicate(1.+adiag+2.*bdiag,nr-2)
///    aa(col     )=aaa                                ; last columns
///    aa(col+nc-1)=aaa                                ; first column
///    col=n+lindgen(nr-1)*nc+nc-1
///    aa(col    )=0.
///    aa(col+n-1)=0.

///    col=[lindgen(n),           $                    ;Main diagonal
///    lindgen(n-1)+1,       $                    ;Upper sub-diagonal for X
///    lindgen(n-1),         $                    ;Lower sub-diagonal for X
///    lindgen(n-nc)+nc,     $                    ;Upper sub-diagonal for Y
///    lindgen(n-nc)]                             ;Lower sub-diagonal for Y

///    row=[lindgen(n),           $                    ;Main diagonal
///    lindgen(n-1),         $                    ;Upper sub-diagonal for X
///    lindgen(n-1)+1,       $                    ;Lower sub-diagonal for X
///    lindgen(n-nc),        $                    ;Upper sub-diagonal for Y
///    lindgen(n-nc)+nc]                          ;Lower sub-diagonal for Y

///    aaa=sprsin(col,row,aa,n,DOUBLE=dbl,THRESH=-2.*(adiag>bdiag))
///    col=bdiag
///    row=adiag
///    aa=reform(y,n)                ;Start with an initial guess at the solution.

///    if(keyword_set(maxiter)) then maxit=maxiter else maxit=50
///    aaa=linbcg(aaa,reform(y,n),aa,ITMAX=maxit,DOUBLE=dbl);Solve the linear system Ax=b.
///    aaa=reform(aaa,nc,nr)                        ;Restore the shape of the result.
///    return,aaa
///  endif else begin
///    return,y
///  endelse
}

/**
  Select(Array<double, int> &Arr, int KThSmallest) const;
  Returns the <KThSmallest> value of <Arr>.
 **/
int CFits::Select(const Array<int, 1> &Arr, int KThSmallest) const
{
  Array<int, 1> *p_TempArr = this->BubbleSort(Arr);
  if (KThSmallest == 0)
    KThSmallest = 1;
  int result = (*p_TempArr)(KThSmallest-1);
//  cout << "Select: Arr = " << Arr << ": Arr_sorted = " << *p_TempArr << ", result = " << result << endl;
  delete p_TempArr;
  return result;
}
double CFits::Select(const Array<double, 1> &Arr, int KThSmallest) const
{
  Array<double, 1> *p_TempArr = this->BubbleSort(Arr);
  if (KThSmallest == 0)
    KThSmallest = 1;
  double result = (*p_TempArr)(KThSmallest-1);
//  cout << "Select: Arr = " << Arr << ": Arr_sorted = " << *p_TempArr << ", result = " << result << endl;
  delete p_TempArr;
  return result;
}

/**
  bool IsOddNumber(long No) const
  Returns TRUE, if <No> is an Odd Number, FALSE if <No> is an Even Number.
**/
bool CFits::IsOddNumber(long No) const
{
  return (fabs((double)(((double)No) / 2.) - (double)(int)(((double)No) / 2.)) > 0.3);
}

/**
  Swap values of both doubles
 **/
void CFits::Swap(double &A,double &B) const{
  double tmp = A;

  A = B;
  B = tmp;
}

/**
  Swap values of both integers
 **/
void CFits::Swap(int &A,int &B) const{
  int tmp = A;

  A = B;
  B = tmp;
}

/**
  Replicate(double Val, int Len);
 **/
Array<double, 1>* CFits::Replicate(double Val, int Len) const
{
  Array<double, 1> *P_TempVecArr = new Array<double, 1>(Len);
  (*P_TempVecArr) = Val;
  return (P_TempVecArr);
}

/**
  Replicate(int Val, int Len);
 **/
Array<int, 1>* CFits::Replicate(int Val, int Len) const
{
  Array<int, 1> *P_TempVecArr = new Array<int, 1>(Len);
  (*P_TempVecArr) = Val;
  return (P_TempVecArr);
}

/**
 MatrixATimesB(Array<double, 2> &Arr, Array<double, 2> &B);
 **/
Array<double, 2>* CFits::MatrixATimesB(Array<double, 2> &A, Array<double, 2> &B) const
{
#ifdef __DEBUG_FITS_MULT__
  cout << "CFits::MatrixATimesB(A = " << A << ", B = " << B << ") started" << endl;
#endif
  Array<double, 2> *P_TempArray = new Array<double, 2>(A.rows(), B.cols());
  int m, n, o;
  double dtemp;
  (*P_TempArray) = 0.;
#ifdef __DEBUG_FITS_MULT__
  cout << "CFits::MatrixATimesB: TempArray = " << TempArray << endl;
#endif
  for (m = 0; m < A.rows(); m++)
  {
    for (n = 0; n < B.cols(); n++)
    {
      for (o = 0; o < A.cols(); o++)
      {
        dtemp = A(m, o);
        dtemp = dtemp * B(o, n);
        (*P_TempArray)(m, n) += dtemp;
      }
    }
  }
#ifdef __DEBUG_FITS_MULT__
  cout << "CFits::MatrixATimesB: End: TempArray = " << *P_TempArray << endl;
#endif
  return (P_TempArray);
}

/**
 MatrixBTimesA(Array<double, 2> &Arr, Array<double, 2> &B);
 **/
Array<double, 2>* CFits::MatrixBTimesA(Array<double, 2> &A, Array<double, 2> &B) const
{
  return this->MatrixATimesB(B, A);
}

/**
 MatrixTimesVecArr(Array<double, 2> &Arr, Array<double, 1> &B);
 **/
Array<double, 1>* CFits::MatrixTimesVecArr(Array<double, 2> &A, Array<double, 1> &B) const
{
  if (B.size() != A.extent(secondDim))
    return (new Array<double, 1>(A.extent(firstDim)));
  Array<double, 2> ProductArr(B.size(), 1);
  for (int m = 0; m < B.size(); m++)
    ProductArr(m, 0) = B(m);
#ifdef __DEBUG_FITS_MULT__
  cout << "CFits::MatrixTimesVecArr: A = " << A << endl;
  cout << "CFits::MatrixTimesVecArr: B = " << B << endl;
  cout << "CFits::MatrixTimesVecArr: ProductArr = " << ProductArr << endl;
#endif
  //  Array<double, 2> TempMatrix(A.rows(), ProductArr.cols());
  Array<double, 2> *p_TempMatrix = this->MatrixATimesB(A, ProductArr);
#ifdef __DEBUG_FITS_MULT__
  cout << "CFits::MatrixTimesVecArr: TempMatrix = " << *p_TempMatrix << endl;
#endif
//  ProductArr.resize(0,0);
  Array<double, 1> *p_RefArr = this->Reform(*p_TempMatrix);
  delete p_TempMatrix;
  return p_RefArr;
}

/**
 VecArrTimesMatrix(Array<double, 1> &Arr, Array<double, 2> &B);
 **/
Array<double, 1>* CFits::VecArrTimesMatrix(Array<double, 1> &A, Array<double, 2> &B) const
{
  if (A.size() != B.extent(firstDim))
  {
#ifdef __DEBUG_FITS_MULT__
    cout << "CFits::VecArrTimesMatrix: A(=" << A << ").size(=" << A.size() << ") != B(=" << B << ").extent(firstDim)=" << B.extent(firstDim) << " => Returning new VecArr(" << B.extent(secondDim) << ")" << endl;
#endif
    return (new Array<double, 1>(B.extent(secondDim)));
  }
  Array<double, 2> ProductArr(1, A.size());
  for (int m = 0; m < A.size(); m++)
    ProductArr(0, m) = A(m);
#ifdef __DEBUG_FITS_MULT__
  cout << "CFits::VecArrTimesMatrix: A = " << A << endl;
  cout << "CFits::VecArrTimesMatrix: B = " << B << endl;
  cout << "CFits::VecArrTimesMatrix: ProductArr = " << ProductArr << endl;
#endif
  Array<double, 2> *p_temp = this->MatrixATimesB(ProductArr, B);
  Array<double, 1> *p_tempA = this->Reform(*p_temp);
  delete p_temp;
  return p_tempA;
}

/**
 VecArrACrossB(Array<double, 1> &Arr, Array<double, 1> &B);
 **/
Array<double, 2>* CFits::VecArrACrossB(Array<double, 1> &A, Array<double, 1> &B) const
{
  //  if (this->P_TempArray != NULL)
  //    delete(this->P_TempArray);

  Array<double, 2> *P_TempArray = new Array<double, 2>(A.size(), B.size());
  int m, n;
  double dtemp;
  (*P_TempArray) = 0.;
  for (m = 0; m < A.size(); m++)
  {
    for (n = 0; n < B.size(); n++)
    {
      dtemp = A(m);
      dtemp = dtemp * B(n);
      (*P_TempArray)(m, n) = dtemp;
    }
  }
  return (P_TempArray);
}

/**
 VecArrACrossB(Array<int, 1> &Arr, Array<int, 1> &B);
 **/
Array<int, 2>* CFits::VecArrACrossB(Array<int, 1> &A, Array<int, 1> &B) const
{
  //  if (this->P_TempArray != NULL)
  //    delete(this->P_TempArray);

  Array<int, 2> *P_TempArray = new Array<int, 2>(A.size(), B.size());
  int m, n;
  int dtemp;
  (*P_TempArray) = 0.;
  for (m = 0; m < A.size(); m++)
  {
    for (n = 0; n < B.size(); n++)
    {
      dtemp = A(m);
      dtemp = dtemp * B(n);
      (*P_TempArray)(m, n) = dtemp;
    }
  }
  return (P_TempArray);
}

/**
 VecArrAScalarB(Array<double, 1> &Arr, Array<double, 1> &B);
 **/
double CFits::VecArrAScalarB(Array<double, 1> &A, Array<double, 1> &B) const
{
  if (A.extent(firstDim) != B.extent(firstDim))
    return 0.;
  return sum(A * B);
}

/**
 Reform(Array<double, 1> &Arr, int DimA, int DimB);
 **/
Array<double, 2>* CFits::Reform(Array<double, 1> &VecArr, int NRow, int NCol) const
{
  double *data = //(double*)malloc(sizeof(double) * VecArr.size());
    //data =
    VecArr.data();
  #ifdef __DEBUG_FITS_REFORM__
    cout << "CFits::Reform(VecArr, NRow, NCol): VecArr.data() returns data=<" << *data << ">" << endl;
    for (int m = 0; m < VecArr.size(); m++)
      cout << "CFits::Reform(VecArr, NRow, NCol): data[m=" << m << "]=<" << data[m] << ">" << endl;
  #endif
//  Array<double, 2> *P_TempArray = new Array<double, 2>(data, shape(NRow, NCol), duplicateData);
  Array<double, 2> *P_TempArray = new Array<double, 2>(NRow, NCol);
  for (int i_row=0; i_row < NRow; i_row++){
    for (int i_col=0; i_col < NCol; i_col++){
      (*P_TempArray)(i_row, i_col) = data[(i_row*NCol) + i_col];
    }
  }
  //  for (int m = 0; m < VecArr.size(); m++)
  //    delete (data[m]);
  //  delete[] data;
  #ifdef __DEBUG_FITS_REFORM__
    cout << "CFits::Reform(VecArr, NRow=" << NRow << ", NCol=" << NCol << "): returning <" << *P_TempArray << ">" << endl;
  #endif
//  return false;
  return P_TempArray;
}

/**
 Reform(Array<double, 1> &Arr, int DimA, int DimB);
 Reformates a 2-dimensional array into a vector
 **/
Array<double, 1>* CFits::Reform(Array<double, 2> &Arr) const
{
  int na = Arr.extent(firstDim);
  int nb = Arr.extent(secondDim);
  int n;
  if (na == 1)
  {
    n = nb;
  }
  else if (nb == 1)
  {
    n = na;
  }
  else
    n = na * nb;
  Array<double, 1> *P_TempVecArr = new Array<double, 1>(n);
  if (na == 1 || nb == 1)
  {
    for (int m = 0; m < n; m++)
    {
      if (na == 1)
        (*P_TempVecArr)(m) = Arr(0, m);
      else if (nb == 1)
        (*P_TempVecArr)(m) = Arr(m, 0);
    }
  }
  else
  {
    int pos = 0;
    for (int m = 0; m < na; m++)
    {
      for (int n = 0; n < nb; n++)
      {
        (*P_TempVecArr)(pos) = Arr(m, n);
        pos++;
      }
    }
  }
  return (P_TempVecArr);
}

/**
 Reform(Array<int, 1> &Arr, int DimA, int DimB);
 Reformates a 2-dimensional array into a Vector
 **/
Array<int, 1>* CFits::Reform(Array<int, 2> &Arr) const
{
  int na = Arr.extent(firstDim);
  int nb = Arr.extent(secondDim);
  int n;
  if (na == 1)
  {
    n = nb;
  }
  else if (nb == 1)
  {
    n = na;
  }
  else
    n = na * nb;
  Array<int, 1> *P_TempVecArr = new Array<int, 1>(n);
  if (na == 1 || nb == 1)
  {
    for (int m = 0; m < n; m++)
    {
      if (na == 1)
        (*P_TempVecArr)(m) = Arr(0, m);
      else if (nb == 1)
        (*P_TempVecArr)(m) = Arr(m, 0);
    }
  }
  else
  {
    int pos = 0;
    for (int m = 0; m < na; m++)
    {
      for (int n = 0; n < nb; n++)
      {
        (*P_TempVecArr)(pos) = Arr(m, n);
        pos++;
      }
    }
  }
  return (P_TempVecArr);
}

/**
  Reform(Array<double, 2> &Arr, int DimA, int DimB);
  Reformates an Array
 **
Array<double, 2>* CFits::Reform(Array<double, 2> &Arr, int DimA, int DimB) const{

}**/

/**
 void TriDag
 Solves for a vector Array<double, N> UVecArr the tridiagonal linear set given by equation
  [ b_1  c_1  0  ...                       ]   [  u_1  ]   [  r_1  ]
  [ a_2  b_2  c_2 ...                      ]   [  u_2  ]   [  r_2  ]
  [            ...                         ] * [  ...  ] = [  ...  ]
  [            ...  a_(N-1) b_(N-1) c_(N-1)]   [u_(N-1)]   [r_(N-1)]
  [            ...     0     a_N      b_N  ]   [  u_N  ]   [  r_N  ]
 BVecArr(0..N-1), CVecArr(0..N-1), and RVecArr(0..N-1) are input vectors and are not modified.
 **/
bool CFits::TriDag(Array<double, 1> &AVecArr, Array<double, 1> &BVecArr, Array<double, 1> &CVecArr, Array<double, 1> &RVecArr, Array<double, 1> &UVecArr) const
{
  int m;
  double Bet;
  int N = UVecArr.size();
  Array<double, 1> Gam(N);

  if (BVecArr(0) == 0.0)
  {
    cout << "CFits::TriDag: Error 1 in TriDag: BVecArr(0) == 0" << endl;
    (*P_OFS_Log) << "CFits::TriDag: Error 1 in TriDag: BVecArr(0) == 0" << endl;
    /// If this happens then you should rewrite your equations as a set of order N-1, with u2 trivially eliminated
    return false;
  }
  UVecArr(0) = RVecArr(0) / (Bet = BVecArr(0));
  for (m = 1; m < N; m++) /// Decomposition and forward substitution
  {
    Gam(m) = CVecArr(m-1) / Bet;
    Bet = BVecArr(m) - AVecArr(m) * Gam(m);
    if (Bet == 0.0)
    {
      cout << "CFits::TriDag: Error 2 in TriDag: Bet == 0.0" << endl;
      (*P_OFS_Log) << "CFits::TriDag: Error 2 in TriDag: Bet == 0.0" << endl;
      /// Algorithm fails, see below
      return false;
    }
    UVecArr(m) = (RVecArr(m) - AVecArr(m) * UVecArr(m-1)) / Bet;
  }
  for (m = (N-2); m >= 0; m--)
  {
    UVecArr(m) -= Gam(m+1) * UVecArr(m+1); /// Backsubstitution
  }
  Gam.resize(0);

  return true;
}

/**
  LsToFit
 **/
bool CFits::LsToFit(const Array<double, 1> &XXVecArr, const Array<double, 1> &YVecArr, const double &XM, double &D_Out) const
{
#ifdef __DEBUG_FITS_INTERPOL__
  (*P_OFS_Log) << "CFits::LsToFit(XXVecArr = " << XXVecArr << ", YVecArr = " << YVecArr << ", XM = " << XM << ") Started" << endl;
#endif
  //  Function ls2fit, xx, y, xm

  //COMPILE_OPT hidden, strictarr

  //x = xx - xx[0]
  ///Normalize to preserve significance.
  Array<double, 1> XVecArr(XXVecArr.size());
  XVecArr = XXVecArr - XXVecArr(0);

  //ndegree = 2L
  long NDegree = 2;
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: NDegree set to " << NDegree << endl;
#endif

  //n = n_elements(xx)
  long N = XXVecArr.size();
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: N set to " << N << endl;
#endif

  //corrm = fltarr(ndegree+1, ndegree+1)
  ///Correlation matrix
  Array<double, 2> CorrMArr(NDegree + 1, NDegree + 1);

  //b = fltarr(ndegree+1)
  Array<double, 1> BVecArr(NDegree + 1);

  //corrm[0,0] = n
  ///0 - Form the normal equations
  CorrMArr(0, 0) = N;
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: CorrMArr(0,0) set to " << CorrMArr(0,0) << endl;
#endif

  //b[0] = total(y)
  BVecArr(0) = sum(YVecArr);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: BVecArr(0) set to " << BVecArr(0) << endl;
#endif

  //z = x
  ///1
  Array<double, 1> ZVecArr(XXVecArr.size());
  ZVecArr = XVecArr;
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: ZVecArr set to " << ZVecArr << endl;
#endif

  //b[1] = total(y*z)
  Array<double, 1> TempVecArr(YVecArr.size());
  TempVecArr = YVecArr;
  TempVecArr *= ZVecArr;
  BVecArr(1) = sum(TempVecArr);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: BVecArr(1) set to " << BVecArr(1) << endl;
#endif

  //corrm[[0,1],[1,0]] = total(z)
  CorrMArr(0, 1) = sum(ZVecArr);
  CorrMArr(1, 0) = sum(ZVecArr);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: CorrMArr(0,1) set to " << CorrMArr(0,1) << endl;
  cout << "CFits::LsToFit: CorrMArr(1,0) set to " << CorrMArr(1,0) << endl;
#endif

  //z = z * x
  ///2
  ZVecArr *= XVecArr;
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: ZVecArr set to " << ZVecArr << endl;
#endif

  //b[2] = total(y*z)
  TempVecArr.resize(YVecArr.size());
  TempVecArr = YVecArr;
  TempVecArr *= ZVecArr;
  BVecArr(2) = sum(TempVecArr);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: BVecArr(2) set to " << BVecArr(2) << endl;
#endif

  //corrm[[0,1,2], [2,1,0]] = total(z)
  CorrMArr(0, 2) = sum(ZVecArr);
  CorrMArr(1, 1) = sum(ZVecArr);
  CorrMArr(2, 0) = sum(ZVecArr);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: CorrMArr(0,2) set to " << CorrMArr(0,2) << endl;
  cout << "CFits::LsToFit: CorrMArr(1,1) set to " << CorrMArr(1,1) << endl;
  cout << "CFits::LsToFit: CorrMArr(2,0) set to " << CorrMArr(2,0) << endl;
#endif

  //z = z * x
  ///3
  ZVecArr *= XVecArr;
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: ZVecArr set to " << ZVecArr << endl;
#endif

  //corrm[[1,2],[2,1]] = total(z)
  CorrMArr(1, 2) = sum(ZVecArr);
  CorrMArr(2, 1) = sum(ZVecArr);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: CorrMArr(1,2) set to " << CorrMArr(1,2) << endl;
  cout << "CFits::LsToFit: CorrMArr(2,1) set to " << CorrMArr(2,1) << endl;
#endif

  //corrm[2,2] = total(z*x)
  ///4
  TempVecArr.resize(ZVecArr.size());
  TempVecArr = ZVecArr;
  TempVecArr *= XVecArr;
  CorrMArr(2, 2) = sum(TempVecArr);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: CorrMArr(2,2) set to " << CorrMArr(2,2) << endl;
#endif

  //c = b # invert(corrm)
  Array<double, 2> CorrInvMArr;
  CorrInvMArr.resize(CorrMArr.rows(), CorrMArr.cols());
  CorrInvMArr = CorrMArr;
  if (!InvertGaussJ(CorrInvMArr)){
    cout << "CFits::LsToFit: ERROR: InvertGaussJ(CorrInvMArr) returned FALSE" << endl;
    return false;
  }
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: CorrInvMArr set to " << CorrInvMArr << endl;
#endif
  Array<double, 1> *p_CVecArr = this->VecArrTimesMatrix(BVecArr, CorrInvMArr);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: p_CVecArr set to " << *p_CVecArr << endl;
#endif

  //xm0 = xm - xx[0]
  double XM0 = XM - XXVecArr(0);
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: XM0 set to " << XM0 << endl;
#endif

  D_Out = (*p_CVecArr)(0) + ((*p_CVecArr)(1) * XM0) + ((*p_CVecArr)(2) * pow(XM0, 2));
#ifdef __DEBUG_FITS_LSTOFIT__
  cout << "CFits::LsToFit: D_Out set to " << D_Out << endl;
#endif
  XVecArr.resize(0);
  CorrMArr.resize(0,0);
  BVecArr.resize(0);
  ZVecArr.resize(0);
  TempVecArr.resize(0);
  delete p_CVecArr;
  CorrInvMArr.resize(0,0);
  return true;
}

/**
  HInterPol
 **/
bool CFits::HInterPol(const Array<double, 1> &VVecArr,
                      const Array<double, 1> &XVecArr,
                      Array<int, 1> &SVecArr,
                      const Array<double, 1> &UVecArr,
                      const Array<CString, 1> &CS_A1_In,
                      Array<double,1> &D1_Out) const
{
#ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::HInterPol: VVecArr.size() = " << VVecArr.size() << endl;
  cout << "CFits::HInterPol: XVecArr.size() = " << XVecArr.size() << endl;
  cout << "CFits::HInterPol: SVecArr.size() = " << SVecArr.size() << endl;
  cout << "CFits::HInterPol: UVecArr.size() = " << UVecArr.size() << endl;
  cout << "CFits::HInterPol: CS_A1_In.size() = " << CS_A1_In.size() << endl;
#endif

//  int NArgs = CS_A1_In.size();
  int M = VVecArr.size();
  firstIndex i;

  Array<int, 1> IA1_Temp(SVecArr.size());
  IA1_Temp = 0;

  Array<double, 1> DA1_Temp(SVecArr.size());
  DA1_Temp = 0.;

  Array<double, 1> DA1_TempA(SVecArr.size());
  DA1_TempA = 0.;

  Array<double, 1> DA1_VTempP1(SVecArr.size());
  DA1_VTempP1 = 0.;

  Array<double, 1> DA1_VTemp(SVecArr.size());
  DA1_VTemp = 0.;

  Array<double, 1> DA1_XTempP1(SVecArr.size());
  DA1_XTempP1 = 0.;

  Array<double, 1> DA1_XTemp(SVecArr.size());
  DA1_XTemp = 0.;

  Array<int, 1> IA1_STemp(SVecArr.size());
  IA1_STemp = 0;

  Array<double, 1> PVecArr(SVecArr.size());
  PVecArr = 0.;

  Array<double, 1> TmpVecArr(4);
  TmpVecArr = i;

  Array<double, 1> T1VecArr(4);
  T1VecArr = 0.;

  Array<double, 1> T2VecArr(4);
  T2VecArr = 0.;

  Array<double, 1> X1VecArr(SVecArr.size());
  X1VecArr = 0.;

  Array<double, 1> X0VecArr(SVecArr.size());
  X0VecArr = 0.;

  Array<double, 1> X2VecArr(SVecArr.size());
  X2VecArr = 0.;

  Array<double, 1> X0Arr(4);
  X0Arr = 0.;

  Array<double, 1> V0Arr(4);
  V0Arr = 0.;

  Array<double, 1> QArr(SVecArr.size());
  QArr = 0.;

  /**
  Clip interval, which forces extrapolation.
  u[i] is between x[s[i]] and x[s[i]+1].
   **/
  /*
  CASE (1) OF
  KEYWORD_SET(ls2): BEGIN  ;Least square fit quadratic, 4 points
    s = s > 1L < (m-3)          ;Make in range.
    p = replicate(v[0], n_elements(s)) ;Result
    for i=0L, n_elements(s)-1 do begin
      s0 = s[i]-1
      p[i] = ls2fit(regular ? s0+findgen(4) : x[s0:s0+3], v[s0:s0+3], u[i])
    endfor
  END
  */
  int s0int;
  double s0;
  /// Least square fit quadratic, 4 points
  if (this->KeyWord_Set(CS_A1_In, CString("LSQUADRATIC")) >= 0)
  {
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: KeywordSet(LSQUADRATIC)" << endl;
#endif
    SVecArr = where(SVecArr < 1, 1, SVecArr);
    SVecArr = where(SVecArr > M-3, M-3, SVecArr);
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: LSQUADRATIC: SVecArr.size() set to " << SVecArr.size() << endl;
#endif
    PVecArr = VVecArr(0);   /// Result
    for (int m = 0; m < SVecArr.size(); m++)
    {
      s0 = double(SVecArr(m)) - 1.;
      s0int = (int)s0;
      TmpVecArr += s0;
      T1VecArr = XVecArr(Range(s0int, (s0int)+3));
      T2VecArr = VVecArr(Range(s0int, (s0int)+3));
#ifdef __DEBUG_FITS_INTERPOL__
      cout << "CFits::HInterPol: Starting LsToFit(T1VecArr, T2VecArr, UVecArr(m)" << endl;
#endif
      if (!LsToFit(*(const_cast<const Array<double, 1>*>(&T1VecArr)), *(const_cast<const Array<double, 1>*>(&T2VecArr)), UVecArr(m), PVecArr(m)))
        return false;
    }
  }
  /*
  KEYWORD_SET(quad): BEGIN ;Quadratic.
  s = s > 1L < (m-2)          ;In range
  x1 = regular ? float(s) : x[s]
  x0 = regular ? x1-1.0 : x[s-1]
  x2 = regular ? x1+1.0 : x[s+1]
  p = v[s-1] * (u-x1) * (u-x2) / ((x0-x1) * (x0-x2)) + $
  v[s] *   (u-x0) * (u-x2) / ((x1-x0) * (x1-x2)) + $
  v[s+1] * (u-x0) * (u-x1) / ((x2-x0) * (x2-x1))
  END
  */
  else if (this->KeyWord_Set(CS_A1_In, CString("QUADRATIC")) >= 0)
  {
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: KeywordSet(QUADRATIC)" << endl;
#endif
    SVecArr = where(SVecArr < 1, 1, SVecArr);
    SVecArr = where(SVecArr > M-2, M-2, SVecArr);
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: QUADRATIC: SVecArr.size() set to " << SVecArr.size() << endl;
#endif

    if (!this->GetSubArrCopy(XVecArr,
                             SVecArr,
                             X1VecArr)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(XVecArr, SVecArr, X1VecArr) returned FALSE" << endl;
      return false;
    }

    IA1_Temp = SVecArr - 1;

    if (!this->GetSubArrCopy(XVecArr,
                             IA1_Temp,
                             X0VecArr)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(XVecArr, IA1_Temp, X0VecArr) returned FALSE" << endl;
      return false;
    }

    IA1_Temp = SVecArr + 1;
    if (!this->GetSubArrCopy(XVecArr,
                             IA1_Temp,
                             X2VecArr)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(XVecArr, IA1_Temp, X2VecArr) returned FALSE" << endl;
      return false;
    }

    //    p = v[s-1] * (u-x1) * (u-x2) / ((x0-x1) * (x0-x2)) + $
    //    v[s] *   (u-x0) * (u-x2) / ((x1-x0) * (x1-x2)) + $
    //    v[s+1] * (u-x0) * (u-x1) / ((x2-x0) * (x2-x1))
    IA1_Temp = SVecArr - 1;
    if (!this->GetSubArrCopy(VVecArr,
                             IA1_Temp,
                             DA1_Temp)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(VVecArr, IA1_Temp, DA1_Temp) returned FALSE" << endl;
      return false;
    }
    IA1_Temp = SVecArr + 1;
    if (!this->GetSubArrCopy(VVecArr,
                             IA1_Temp,
                             DA1_TempA)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(VVecArr, IA1_Temp, DA1_TempA) returned FALSE" << endl;
      return false;
    }
    PVecArr = DA1_Temp
              * (UVecArr - X1VecArr) * (UVecArr - X2VecArr)
              / ((X0VecArr - X1VecArr) * (X0VecArr - X2VecArr))
              + DA1_TempA
              * (UVecArr - X0VecArr) * (UVecArr - X1VecArr)
              / ((X2VecArr - X0VecArr) * (X2VecArr - X1VecArr));
  }
  /*
  KEYWORD_SET(spline): BEGIN
  s = s > 1L < (m-3)          ;Make in range.
  p = replicate(v[0], n_elements(s)) ;Result
  sold = -1
  for i=0L, n_elements(s)-1 do begin
  s0 = s[i]-1
  if sold ne s0 then begin
  x0 = regular ? s0+findgen(4): x[s0: s0+3]
  v0 = v[s0: s0+3]
  q = spl_init(x0, v0)
  sold = s0
  endif
  p[i] = spl_interp(x0, v0, q, u[i])
  endfor
  END
  */
  else if (this->KeyWord_Set(CS_A1_In, CString("SPLINE")) >= 0)
  {
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: KeywordSet(SPLINE)" << endl;
#endif
    SVecArr = where(SVecArr < 1, 1, SVecArr);
    SVecArr = where(SVecArr > M-3, M-3, SVecArr);
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: SPLINE: SVecArr.size() set to " << SVecArr.size() << endl;
#endif
    PVecArr.resize(SVecArr.size());
    PVecArr = VVecArr(0);
    int SOld = -1;
    for (int m = 0; m < SVecArr.size(); m++)
    {
      s0 = SVecArr(m) - 1.;
      s0int = (int)s0;
      if (abs(SOld - s0int) > 0)
      {
        X0Arr.resize(4);
        X0Arr = XVecArr(Range(s0int, (s0int)+3));
        V0Arr.resize(4);
        V0Arr(Range::all()) = XVecArr(Range(s0int, (s0int)+3));
        if (!this->Spline(X0Arr, V0Arr, QArr)){
          cout << "CFits::HInterPol: ERROR: Spline(X0Arr, V0Arr, QArr) returned FALSE" << endl;
          return false;
        }
        SOld = s0int;
      }
      //p[i] = spl_interp(x0, v0, q, u[i])
      if (!this->SplInt(X0Arr, V0Arr, QArr, UVecArr(m), &(PVecArr(m)))){
        cout << "CFits::HInterPol: ERROR: SplInt(X0Arr, V0Arr, QArr, UVecArr(m), PVecArr(m)) returned FALSE" << endl;
        return false;
      }
    }
  }
  /*
  ELSE: $              ;Linear, not regular
  p = (u-x[s])*(v[s+1]-v[s])/(x[s+1] - x[s]) + v[s]
  ENDCASE

  RETURN, p
  end
  */
  else  /// Linear, not regular
  {
///    p = (u-x[s])*(v[s+1]-v[s])/(x[s+1] - x[s]) + v[s]

    if (!this->GetSubArrCopy(XVecArr,
                             SVecArr,
                             DA1_XTemp)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(XVecArr, SVecArr, DA1_XTemp) returned FALSE" << endl;
      return false;
    }
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: DA1_XTemp set to " << DA1_XTemp << endl;
#endif
    if (!this->GetSubArrCopy(VVecArr,
                             SVecArr,
                             DA1_VTemp)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(VVecArr, SVecArr, DA1_VTemp) returned FALSE" << endl;
      return false;
    }
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: DA1_VTemp set to " << DA1_VTemp << endl;
#endif

    IA1_STemp = SVecArr + 1;
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: IA1_STemp set to " << IA1_STemp << endl;
#endif

    if (!this->GetSubArrCopy(XVecArr,
                             IA1_STemp,
                             DA1_XTempP1)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(XVecArr, IA1_STemp, DA1_XTempP1) returned FALSE" << endl;
      return false;
    }
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: DA1_XTempP1 set to " << DA1_XTempP1 << endl;
#endif

    if (!this->GetSubArrCopy(VVecArr,
                             IA1_STemp,
                             DA1_VTempP1)){
      cout << "CFits::HInterPol: ERROR: GetSubArrCopy(VVecArr, IA1_STemp, DA1_VTempP1) returned FALSE" << endl;
      return false;
    }
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::HInterPol: DA1_VTempP1 set to " << DA1_VTempP1 << endl;
#endif

    //    IA1_STemp = SVecArr - 1;
    //    this->GetSubArrCopy(XVecArr, IA1_STemp, DA1_XTempM1);
    //    this->GetSubArrCopy(VVecArr, IA1_STemp, DA1_VTempM1);

    PVecArr = (UVecArr - DA1_XTemp)
              * (DA1_VTempP1 - DA1_VTemp)
              / (DA1_XTempP1 - DA1_XTemp)
              + DA1_VTemp;
  }
#ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::HInterPol: Ready: Returning PVecArr = " << PVecArr << endl;
#endif

/**  IA1_Temp.resize(0);
  DA1_Temp.resize(0);
  DA1_TempA.resize(0);
  DA1_VTempP1.resize(0);
  DA1_VTemp.resize(0);
  DA1_XTempP1.resize(0);
  DA1_XTemp.resize(0);
  IA1_STemp.resize(0);
  TmpVecArr.resize(0);
  T1VecArr.resize(0);
  T2VecArr.resize(0);
  X1VecArr.resize(0);
  X0VecArr.resize(0);
  X2VecArr.resize(0);
  X0Arr.resize(0);
  V0Arr.resize(0);
  QArr.resize(0);
**/
  Array<double, 1> *P_PVecArr = new Array<double, 1>(PVecArr.size());
  (*P_PVecArr) = PVecArr;

  PVecArr.resize(0);

  D1_Out.resize(P_PVecArr->size());
  D1_Out = (*P_PVecArr);
  delete(P_PVecArr);
  return true;
}

/**
  InterPol linear, not regular
 **/
bool CFits::InterPol(const Array<double, 1> &VVecArr,
                     const Array<double, 1> &XVecArr,
                     const Array<double, 1> &UVecArr,
                     Array<double,1> &D_A1_Out) const
{
  return this->InterPol(VVecArr, XVecArr, UVecArr, D_A1_Out, false);
}

bool CFits::InterPol(const Array<double, 1> &VVecArr,
                     const Array<double, 1> &XVecArr,
                     const Array<double, 1> &UVecArr,
                     Array<double,1> &D_A1_Out,
                     bool B_PreserveFlux) const
{
  Array<CString, 1> cs_a1(1);
  cs_a1 = CString(" ");
  D_A1_Out.resize(UVecArr.size());
  if (B_PreserveFlux){
    Array<double, 1> D_A1_U(2);
    Array<double, 1> D_A1_X(XVecArr.size() + 1);
    D_A1_X(0) = XVecArr(0) - ((XVecArr(1) - XVecArr(0))/2.);
    D_A1_X(D_A1_X.size()-1) = XVecArr(XVecArr.size()-1) + ((XVecArr(XVecArr.size()-1) - XVecArr(XVecArr.size()-2))/2.);
    for (int i_pix=1; i_pix<XVecArr.size(); i_pix++){
      D_A1_X(i_pix) = XVecArr(i_pix-1) + ((XVecArr(i_pix) - XVecArr(i_pix-1))/2.);
    }
    #ifdef __DEBUG_FITS_INTERPOL__
      cout << "CFits::InterPol: XVecArr = " << XVecArr << endl;
      cout << "CFits::InterPol: D_A1_X = " << D_A1_X << endl;
    #endif

    Array<int, 1> I_A1_Ind(D_A1_X.size());
    Array<int, 1> *P_I_A1_Ind;
    int I_Start = 0;
    int I_End = 0;
    int I_NInd = 0;
    double D_Start, D_End;
    for (int i_pix=0; i_pix<UVecArr.size(); i_pix++){
      if (i_pix == 0){
        D_A1_U(0) = UVecArr(0) - ((UVecArr(1) - UVecArr(0)) / 2.);
        D_A1_U(1) = UVecArr(0) + ((UVecArr(1) - UVecArr(0)) / 2.);
//        if (!this->IntegralUnderCurve(XVecArr, VVecArr, D_A1_X, (*P_A1_Out)(i_pix))){
//          cout << "CFits::InterPol: ERROR: IntegralUnderCurve(XVecArr = " << XVecArr << ", VVecArr = " << VVecArr << ", D_A1_X = " << D_A1_X << ") returned FALSE" << endl;
//          return false;
//        }
      }
      else if (i_pix == UVecArr.size()-1){
        D_A1_U(0) = UVecArr(UVecArr.size()-1) - ((UVecArr(UVecArr.size()-1) - UVecArr(UVecArr.size()-2)) / 2.);
        D_A1_U(1) = UVecArr(UVecArr.size()-1) + ((UVecArr(UVecArr.size()-1) - UVecArr(UVecArr.size()-2)) / 2.);
//        if (!this->IntegralUnderCurve(XVecArr, VVecArr, D_A1_X, (*P_A1_Out)(i_pix))){
//          cout << "CFits::InterPol: ERROR: IntegralUnderCurve(XVecArr = " << XVecArr << ", VVecArr = " << VVecArr << ", D_A1_X = " << D_A1_X << ") returned FALSE" << endl;
//          return false;
//        }

      }
      else{
        D_A1_U(0) = UVecArr(i_pix) - ((UVecArr(i_pix) - UVecArr(i_pix-1)) / 2.);
        D_A1_U(1) = UVecArr(i_pix) + ((UVecArr(i_pix+1) - UVecArr(i_pix)) / 2.);
//        if (!this->IntegralUnderCurve(XVecArr, VVecArr, D_A1_X, (*P_A1_Out)(i_pix))){
//          cout << "CFits::InterPol: ERROR: IntegralUnderCurve(XVecArr = " << XVecArr << ", VVecArr = " << VVecArr << ", D_A1_X = " << D_A1_X << ") returned FALSE" << endl;
//          return false;
//        }
      }
      I_A1_Ind = where(D_A1_X < D_A1_U(0), 1, 0);
      P_I_A1_Ind = this->GetIndex(I_A1_Ind, I_NInd);
      if (I_NInd < 1){
        #ifdef __DEBUG_FITS_INTERPOL__
          cout << "CFits::InterPol: WARNING: 1. I_A1_Ind = " << I_A1_Ind << ": I_NInd < 1" << endl;
        #endif
	I_Start = 0;
      }
      else{
        I_Start = (*P_I_A1_Ind)(P_I_A1_Ind->size()-1);
      }
      #ifdef __DEBUG_FITS_INTERPOL__
        cout << "CFits::InterPol: i_pix = " << i_pix << ": D_A1_U = " << D_A1_U << endl;
      #endif
      delete(P_I_A1_Ind);
      I_A1_Ind = where(D_A1_X > D_A1_U(1), 1, 0);
      P_I_A1_Ind = this->GetIndex(I_A1_Ind, I_NInd);
      if (I_NInd < 1){
        #ifdef __DEBUG_FITS_INTERPOL__
          cout << "CFits::InterPol: WARNING: 2. I_A1_Ind = " << I_A1_Ind << ": I_NInd < 1" << endl;
        #endif
	I_End = D_A1_X.size()-1;
      }
      else{
        I_End = (*P_I_A1_Ind)(0);
      }
      delete(P_I_A1_Ind);
      #ifdef __DEBUG_FITS_INTERPOL__
        cout << "CFits::InterPol: i_pix = " << i_pix << ": D_A1_X(" << I_Start << ":" << I_End << ") = " << D_A1_X(Range(I_Start, I_End)) << endl;
      #endif

      D_Start = D_A1_U(0);
      if (D_A1_X(I_Start) > D_A1_U(0))
	D_Start = D_A1_X(I_Start);
      D_A1_Out(i_pix) = 0.;
      if ((D_A1_U(1) > D_A1_X(0)) && (D_A1_U(0) < D_A1_X(D_A1_X.size()-1))){
        do {
          if (D_A1_U(1) < D_A1_X(I_Start + 1)){
            D_End = D_A1_U(1);
          }
          else{
	    D_End = D_A1_X(I_Start + 1);
          }
          #ifdef __DEBUG_FITS_INTERPOL__
            cout << "CFits::InterPol: i_pix = " << i_pix << ": I_Start = " << I_Start << ", I_End = " << I_End << endl;
            cout << "CFits::InterPol: i_pix = " << i_pix << ": D_Start = " << D_Start << ", D_End = " << D_End << endl;
          #endif
          D_A1_Out(i_pix) += VVecArr(I_Start) * (D_End - D_Start) / (D_A1_X(I_Start + 1) - D_A1_X(I_Start));
          D_Start = D_End;
	  if (D_A1_U(1) >= D_A1_X(I_Start + 1))
            I_Start++;
          #ifdef __DEBUG_FITS_INTERPOL__
	    cout << "CFits::InterPol: i_pix = " << i_pix << ": D_A1_Out(" << i_pix << ") = " << D_A1_Out(i_pix) << endl;
          #endif
	  if (I_Start + 1 >= D_A1_X.size())
	    break;
        } while (D_End < D_A1_U(1)-((D_A1_U(1) - D_A1_U(0)) / 100000000.));
      }
//      for (int i_p=I_Start; i_p<I_End; i_p++){
//      }
//      return false;
    }
    return true;
  }

  if (!this->InterPol(VVecArr, XVecArr, UVecArr, *(const_cast<const Array<CString, 1>*>(&cs_a1)), D_A1_Out)){
    cout << "CFits::InterPol: ERROR: InterPol returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::InterPol(D_A1_V, D_A1_X, D_A1_U, D_A1_Out): Ready " << endl;
  #endif

  cs_a1.resize(0);
  //  delete pp_cstr;

  return true;
}

/**
  InterPol irregular
 **/
bool CFits::InterPol(const Array<double, 1> &VVecArr,
                     const Array<double, 1> &XVecArr,
                     const Array<double, 1> &UVecArr,
                     const Array<CString, 1> &CS_A1_In,
                     Array<double,1> &D_A1_Out) const
{
#ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::InterPol: VVecArr.size() = " << VVecArr.size() << endl;
  cout << "CFits::InterPol: XVecArr.size() = " << XVecArr.size() << endl;
  cout << "CFits::InterPol: UVecArr.size() = " << UVecArr.size() << endl;
  cout << "CFits::InterPol: CS_A1_In.size() = " << CS_A1_In.size() << endl;
#endif

  /**
  FUNCTION INTERPOL, V, X, U, SPLINE=spline, LSQUADRATIC=ls2, QUADRATIC=quad
  ;+
  ; NAME:
  ;       INTERPOL
  ;
  ; PURPOSE:
  ;       Linearly interpolate vectors with a regular or irregular
  ;       grid.
  ;       Quadratic or a 4 point least-square fit to a quadratic
  ;       interpolation may be used as an option.
  ;
  ; CATEGORY:
  ;       E1 - Interpolation
  ;
  ; CALLING SEQUENCE:
  ;       Result = INTERPOL(V, N)         ;For regular grids.
  ;
  ;       Result = INTERPOL(V, X, U)      ;For irregular grids.
  ;
  ; INPUTS:
  ;       V:      The input vector can be any type except
  .
  ;
  ;       For regular grids:
  ;       N:      The number of points in the result when both
  ;               input and output grids are regular.
  ;
  ;       Irregular grids:
  ;       X:      The absicissae values for V.  This vector must
  ;               have same # of elements as V.  The values MUST be
  ;               monotonically ascending or descending.
  ;
  ;       U:      The absicissae values for the result.  The result
  ;               will have the same number of elements as U.  U
  ;               does not need to be monotonic.  If U is outside
  ;               the range of X, then the closest two endpoints of
  ;               (X,V) are linearly extrapolated.
  ;
  ; Keyword Input Parameters:
  ;       LSQUADRATIC = if set, interpolate using a least squares
  ;         quadratic fit to the equation y = a + bx + cx^2, for
  ;         each 4 point neighborhood (x[i-1], x[i], x[i+1], x[i+2])
  ;         surrounding the interval, x[i] <= u < x[i+1].
  ;
  ;       QUADRATIC = if set, interpolate by fitting a quadratic
  ;         y = a + bx + cx^2, to the three point neighborhood
  ;         (x[i-1], x[i], x[i+1]) surrounding the interval
  ;         x[i] <= u < x[i+1].
  ;
  ;       SPLINE = if set, interpolate by fitting a cubic spline to
  ;         the 4 point neighborhood (x[i-1], x[i], x[i+1], x[i+2])
  ;         surrounding the interval, x[i] <= u < x[i+1].
  ;
  ;       Note: if LSQUADRATIC or QUADRATIC or SPLINE is not set,
  ;       the default linear interpolation is used.
  ;
  ; OUTPUTS:
  ;       INTERPOL returns a floating-point vector of N points
  ;       determined by interpolating the input vector by the
  ;       specified method.
  ;
  ;       If the input vector is double or complex, the result is
  ;       double or complex.
  ;
  ; COMMON BLOCKS:
  ;       None.
  ;
  ; SIDE EFFECTS:
  ;       None.
  ;
  ; RESTRICTIONS:
  ;       None.
  ;
  ; PROCEDURE:
  ;       For linear interpolation,
  ;       Result(i) = V(x) + (x - FIX(x)) * (V(x+1) - V(x))
  ;
  ;       where   x = i*(m-1)/(N-1) for regular grids.
  ;               m = # of elements in V, i=0 to N-1.
  ;
  ;       For irregular grids, x = U(i).
  ;               m = number of points of input vector.
  ;
  ;         For QUADRATIC interpolation, the equation y=a+bx+cx^2 is
  ;       solved explicitly for each three point interval, and is
  ;       then evaluated at the interpolate.
  ;         For LSQUADRATIC interpolation, the coefficients a, b,
  ;       and c, from the above equation are found, for the four
  ;       point interval surrounding the interpolate using a least
  ;       square fit.  Then the equation is evaluated at the
  ;       interpolate.
  ;         For SPLINE interpolation, a cubic spline is fit over the
  ;       4 point interval surrounding each interpolate, using the
  ;       routine SPL_INTERP().
  ;
  ; MODIFICATION HISTORY:
  ;       Written, DMS, October, 1982.
  ;       Modified, Rob at NCAR, February, 1991.  Made larger arrays possible
  ;               and correct by using long indexes into the array instead of
  ;               integers.
  ;       Modified, DMS, August, 1998.  Now use binary intervals which
  ;               speed things up considerably when U is random.
  ;       DMS, May, 1999.  Use new VALUE_LOCATE function to find intervals,
  ;               which speeds things up by a factor of around 100, when
  ;               interpolating from large arrays.  Also added SPLINE,
  ;               QUADRATIC, and LSQUADRATIC keywords.
  ;-
  ;**/
  /*
  COMPILE_OPT strictarr
  on_error,2                      ;Return to caller if an error occurs
  */

  //m = N_elements(v)
  /// # of input pnts

//  int NArgs = CS_A1_In.size();

  #ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::InterPol(D_A1_V = " << VVecArr << ", D_A1_X = " << XVecArr << ", D_A1_U = " << UVecArr << ", CS_A1_In) Started" << endl;
  #endif

  int M = VVecArr.size();
  #ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::InterPol(D_A1_V, D_A1_X, D_A1_U, CS_A1_In): M set to " << M << endl;
  #endif
  firstIndex i;

  /*
  if n_elements(x) ne m then $
    message, 'V and X arrays must have same # of elements'
  s = VALUE_LOCATE(x, u) > 0L < (m-2) ;Subscript intervals.
  */
  if (XVecArr.size() != M)
  {
    cout << "CFits::InterPol: ERROR: XVecArr and VVecArr must have same # of elements!" << endl;
    return false;
  }
  Array<int, 1> *p_SVecArr = this->ValueLocate(XVecArr, UVecArr);
  #ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::InterPol(D_A1_V, D_A1_X, D_A1_U, CS_A1_In): SVecArr set to " << *p_SVecArr << endl;
  #endif
  Array<int, 1> SVecArr(p_SVecArr->size());
  SVecArr = (*p_SVecArr);
  delete p_SVecArr;
  SVecArr = where(SVecArr < 0, 0, SVecArr);
#ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::InterPol(D_A1_V, D_A1_X, D_A1_U, CS_A1_In): SVecArr set to " << SVecArr << endl;
#endif

  SVecArr = where(SVecArr > M-2, M-2, SVecArr);
#ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::InterPol(D_A1_V, D_A1_X, D_A1_U, CS_A1_In): SVecArr set to " << SVecArr << endl;
#endif

#ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::InterPol(D_A1_V, D_A1_X, D_A1_U, CS_A1_In): Starting HInterPol " << endl;
#endif
//  Array<double, 1> *P_ResultVecArr;
  if (!this->HInterPol(VVecArr, XVecArr, SVecArr, UVecArr, CS_A1_In, D_A1_Out)){
    cout << "CFits::InterPol: ERROR: HInterPol returned FALSE" << endl;
    return false;
  }

  SVecArr.resize(0);
#ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::InterPol(D_A1_V, D_A1_X, D_A1_U, CS_A1_In): Ready " << endl;
#endif

  return true;
}

/**
  InterPol
 **/
bool CFits::InterPol(Array<double, 1> &VVecArr,
                     long N,
                     const Array<CString, 1> &CS_A1_In,
                     Array<double,1> &D_A1_Out) const
{
  /*
  FUNCTION INTERPOL, V, N, SPLINE=spline, LSQUADRATIC=ls2, QUADRATIC=quad
  ;+
  ; NAME:
  ;       InterPol
  ;
  ; PURPOSE:
  ;       Linearly interpolate vectors with a regular grid.
  ;       Quadratic or a 4 point least-square fit to a quadratic
  ;       interpolation may be used as an option.
  ;
  ; CATEGORY:
  ;       E1 - Interpolation
  ;
  ; CALLING SEQUENCE:
  ;       Result = INTERPOL(V, N)         ;For regular grids.
  ;
  ; INPUTS:
  ;       V:      The input vector can be any type except string.
  ;
  ;       N:      The number of points in the result when both
  ;               input and output grids are regular.
  ;
  ; Keyword Input Parameters:
  ;       LSQUADRATIC = if set, interpolate using a least squares
  ;         quadratic fit to the equation y = a + bx + cx^2, for
  ;         each 4 point neighborhood (x[i-1], x[i], x[i+1], x[i+2])
  ;         surrounding the interval, x[i] <= u < x[i+1].
  ;
  ;       QUADRATIC = if set, interpolate by fitting a quadratic
  ;         y = a + bx + cx^2, to the three point neighborhood
  ;         (x[i-1], x[i], x[i+1]) surrounding the interval
  ;         x[i] <= u < x[i+1].
  ;
  ;       SPLINE = if set, interpolate by fitting a cubic spline to
  ;         the 4 point neighborhood (x[i-1], x[i], x[i+1], x[i+2])
  ;         surrounding the interval, x[i] <= u < x[i+1].
  ;
  ;       Note: if LSQUADRATIC or QUADRATIC or SPLINE is not set,
  ;       the default linear interpolation is used.
  ;
  ; OUTPUTS:
  ;       INTERPOL returns a floating-point vector of N points
  ;       determined by interpolating the input vector by the
  ;       specified method.
  ;
  ;       If the input vector is double or complex, the result is
  ;       double or complex.
  ;
  ; PROCEDURE:
  ;       Result(i) = V(x) + (x - FIX(x)) * (V(x+1) - V(x))
  ;
  ;       where   x = i*(m-1)/(N-1) for regular grids.
  ;               m = # of elements in V, i=0 to N-1.
  ;
  ;         For QUADRATIC interpolation, the equation y=a+bx+cx^2 is
  ;       solved explicitly for each three point interval, and is
  ;       then evaluated at the interpolate.
  ;         For LSQUADRATIC interpolation, the coefficients a, b,
  ;       and c, from the above equation are found, for the four
  ;       point interval surrounding the interpolate using a least
  ;       square fit.  Then the equation is evaluated at the
  ;       interpolate.
  ;         For SPLINE interpolation, a cubic spline is fit over the
  ;       4 point interval surrounding each interpolate, using the
  ;       routine SPL_INTERP().
  */
  //m = N_elements(v)
  /// # of input pnts
  int M = VVecArr.size();
//  int NArgs = CS_A1_In.size();
# ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::InterPol: M set to " << M << endl;
//  cout << "CFits::InterPol: NArgs set to " << NArgs << endl;
#endif
  /*
    if ((keyword_set(ls2) or keyword_set(quad) or keyword_set(spline)) eq 0) then begin
      r = findgen(x)*((m-1.0)/((x-1.0) > 1.0)) ;Grid points in V
      rl = long(r)                ;Cvt to integer
      s = size(v)
      if s[s[0]+1] eq 1 then dif = v[1:*]-fix(v)  $ ;V[i+1]-v[i], signed for bytes
      else dif = v[1:*]-v         ;Other types are already signed
      return, V[rl] + (r-rl)*dif[rl] ;interpolate
    endif
    */
  firstIndex i;
  Array<double, 1> UVecArr(N);       /// Grid points
  UVecArr = i;
  double divisor = N - 1.0;
# ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::InterPol: divisor set to " << divisor << endl;
#endif
  Array<double, 1> RVecArr(N);
  RVecArr = i;
  Array<int, 1> SVecArr(UVecArr.size());
  UVecArr = 0;
  Array<double, 1> DifVecArr(VVecArr.size() - 1);
  VVecArr = 0.;
  Array<double, 1> DA1_VTemp(RVecArr.size());
  DA1_VTemp = 0.;
  Array<double, 1> DA1_DifTemp(RVecArr.size());
  DA1_DifTemp = 0.;
  double n = (double)N;
  Array<double,1> *P_D_A1_TempB;

  if (this->KeyWord_Set(CS_A1_In, CString("LSQUADRATIC")) < 0
      && this->KeyWord_Set(CS_A1_In, CString("QUADRATIC")) < 0
      && this->KeyWord_Set(CS_A1_In, CString("SPLINE")) < 0)
  {
    if (n < 2.0)
      n = 1.0;
    RVecArr *= (M - 1.0) / ((n - 1.0));  /// Grid points in VVecArr
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::InterPol: RVecArr set to " << RVecArr << endl;
#endif

    Array<int, 1> *p_RLVecArr = Fix(RVecArr);   // Conversion to Integer
    SVecArr = VVecArr.size();
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::InterPol: SVecArr set to " << SVecArr << endl;
#endif
    /*
    if s[s[0]+1] eq 1 then dif = v[1:*]-fix(v)  $ ;V[i+1]-v[i], signed for bytes
    else dif = v[1:*]-v         ;Other types are already signed
    return, V[rl] + (r-rl)*dif[rl] ;interpolate
    */
    if (SVecArr(SVecArr(0) + 1) == 1)
    {
      Array<int, 1> *p_tempFix = Fix(VVecArr);
      DifVecArr(Range::all()) = VVecArr(Range(1, VVecArr.size() - 1)) - (*p_tempFix)(Range(1, VVecArr.size() - 1));
      delete p_tempFix;
    }
    else
      DifVecArr(Range::all()) = VVecArr(Range(1, VVecArr.size() - 1)) - VVecArr(Range(1, VVecArr.size() - 1));
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::InterPol: DifVecArr set to " << DifVecArr << endl;
#endif

    /// Interpolate
    this->GetSubArrCopy(VVecArr,
                        *p_RLVecArr,
                        DA1_VTemp);
    this->GetSubArrCopy(DifVecArr,
                        *p_RLVecArr,
                        DA1_DifTemp);

    P_D_A1_TempB = new Array<double, 1>(DA1_VTemp + (RVecArr - (*p_RLVecArr)) * DA1_DifTemp);
    D_A1_Out.resize(P_D_A1_TempB->size());
    D_A1_Out = (*P_D_A1_TempB);
    delete(P_D_A1_TempB);
# ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::InterPol: *P_D_A1_TempB set to " << *P_D_A1_TempB << endl;
#endif

    UVecArr.resize(0);       /// Grid points
    RVecArr.resize(0);
    delete p_RLVecArr;
    SVecArr.resize(0);
    DifVecArr.resize(0);
    DA1_VTemp.resize(0);
    DA1_DifTemp.resize(0);

    return true;
  }
  /*
  ;
  n = long(x)                 ;# of output points
  u = findgen(n) * ((m-1.0) / ((n-1.0) > 1.0)) ;Grid points
  s = long(u)                 ;Subscripts
  */
  if (divisor < 1.0)
    divisor = 1.0;
  UVecArr *= ((M - 1.0) / divisor);
# ifdef __DEBUG_FITS_INTERPOL__
  cout << "CFits::InterPol: UVecArr set to " << UVecArr << endl;
#endif
  Array<int, 1> *p_tempFixA = Fix(UVecArr);
  SVecArr = (*p_tempFixA);   /// Subscripts
  delete p_tempFixA;
  Array<double, 1> XVecArr(1);
  XVecArr = N;

//  Array<double, 1> *P_PResultArr;
  if (!this->HInterPol(VVecArr, XVecArr, SVecArr, UVecArr, CS_A1_In, D_A1_Out)){
    cout << "CFits::InterPol: ERROR: HInterPol returned FALSE" << endl;
    return false;
  }
  UVecArr.resize(0);       /// Grid points
  RVecArr.resize(0);
  SVecArr.resize(0);
  DifVecArr.resize(0);
  DA1_VTemp.resize(0);
  DA1_DifTemp.resize(0);
  XVecArr.resize(0);

  return true;
}

/**
 InterPolate
 This Method returns an Array of linear interpolates.
 The returned Array has the same type of D_A1_P and its dimension depends on those of the location parameter D_A1_X.

 INPUTS: Array<double, 1> D_A1_P(N)
           The array of data values.
         Array<double, 1> D_A1_X(M)
           The array of interpolation locations.

  OUTPUTS: Array<double, 1> (M)
             The array of interpolates.
 **/
Array<double, 1>* CFits::InterPolate(const Array<double, 1> &D_A1_V, const Array<double, 1> &D_A1_X) const
{
#ifdef __DEBUG_FITS_INTERPOL__
  (*P_OFS_Log) << "CFits::InterPolate(D_A1_V(=" << D_A1_V << "), D_A1_X(=" << D_A1_X << ")) Started" << endl;
#endif

  Array<double,1>* P_D_A1_Out = new Array<double, 1>(D_A1_X.size());

  Array<double, 1> XArr(D_A1_X.size());
  XArr = D_A1_X;

//  double D_V0, D_V1;
//  double D_VStart = D_A1_V(0);
//  double D_VEnd = D_A1_V(D_A1_V.size()-1);
  int I_Pos;

  for (int m = 0; m < XArr.size(); m++)
  {
    /// Values outside Range(D_VStart, D_VEnd)
    if (XArr(m) < 0)
    {
      XArr(m) = 0;
#ifdef __DEBUG_FITS_INTERPOL__
      (*P_OFS_Log) << "CFits::InterPolate: XArr(m=" << m << ") set to 0" << endl;
#endif

    }
    if (XArr(m) >= D_A1_V.size())
    {
      XArr(m) = D_A1_V.size()-1;
#ifdef __DEBUG_FITS_INTERPOL__
      (*P_OFS_Log) << "CFits::InterPolate: XArr(m=" << m << ") set to D_A1_V.size() = " << D_A1_V.size() << " - 1" << endl;
#endif

    }

    I_Pos = (int)(XArr(m));

    if (I_Pos == D_A1_V.size()-1)
      (*P_D_A1_Out)(m) = D_A1_V(I_Pos);
    else
    {
      if (m >= P_D_A1_Out->size())
      {
        cout << "CFits::InterPolate: ERROR: m(=" << m << ") >= P_D_A1_Out->size(" << P_D_A1_Out->size() << ")" << endl;
        (*P_OFS_Log) << "CFits::InterPolate: ERROR: m(=" << m << ") >= P_D_A1_Out->size(" << P_D_A1_Out->size() << ")" << endl;
        exit(EXIT_FAILURE);
      }
      if (I_Pos + 1 >= D_A1_V.size())
      {
        cout << "CFits::InterPolate: ERROR: I_Pos(=" << I_Pos << ") >= D_A1_V.size(=" << D_A1_V.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::InterPolate: ERROR: I_Pos(=" << I_Pos << ") >= D_A1_V.size(=" << D_A1_V.size() << ")" << endl;
        exit(EXIT_FAILURE);
      }
      if (m >= XArr.size())
      {
        cout << "CFits::InterPolate: ERROR: m(=" << m << ") >= XArr.size(=" << XArr.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::InterPolate: ERROR: m(=" << m << ") >= XArr.size(=" << XArr.size() << ")" << endl;
        exit(EXIT_FAILURE);
      }
      if (I_Pos < 0)
      {
        cout << "CFits::InterPolate: ERROR: I_Pos(=" << I_Pos << ") < 0" << endl;
        (*P_OFS_Log) << "CFits::InterPolate: ERROR: I_Pos(=" << I_Pos << ") < 0" << endl;
        exit(EXIT_FAILURE);
      }
      (*P_D_A1_Out)(m) = D_A1_V(I_Pos) + (XArr(m) - (double)I_Pos) * (D_A1_V(I_Pos + 1) - D_A1_V(I_Pos));
    }
#ifdef __DEBUG_FITS_INTERPOL__
    (*P_OFS_Log) << "CFits::InterPolate: P_D_A1_Out(m=" << m << ") set to " << (*P_D_A1_Out)(m) << endl;
#endif

  }
#ifdef __DEBUG_FITS_INTERPOL__
  (*P_OFS_Log) << "CFits::InterPolate: P_D_A1_Out set to " << *P_D_A1_Out << endl;
#endif

  XArr.resize(0);

  return (P_D_A1_Out);
}

/**FUNCTION POLY,X,C

    compile_opt idl2

    on_error,2          ;Return to caller if an error occurs

    N = N_ELEMENTS(C)-1 ;Find degree of polynomial

    ; Special case for N=0. Be sure to return a result of the
    ; same type and array dimensions as X.
    if (n eq 0) then $
        return, x*0 + c[0]

    Y = c[n]
    for i=n-1,0,-1 do y = TEMPORARY(y) * x + c[i]

    return,y

end
**/
Array<double, 1>* CFits::Poly(const Array<double, 1> &VecArr,
                              const Array<double, 1> &VecCoeffs) const{
  int ii = 0;
  Array<double, 1>* P_D_A1_Out = new Array<double, 1>(VecArr.size());
  #ifdef __DEBUG_FITS_POLY__
    cout << "CFits::Poly: VecArr = " << VecArr << endl;
    cout << "CFits::Poly: VecCoeffs = " << VecCoeffs << endl;
    cout << "CFits::Poly: *P_D_A1_Out set to " << *P_D_A1_Out << endl;
  #endif
  int I_PolynomialOrder = VecCoeffs.size() - 1;
  #ifdef __DEBUG_FITS_POLY__
    cout << "CFits::Poly: I_PolynomialOrder set to " << I_PolynomialOrder << endl;
  #endif
  if (I_PolynomialOrder == 0){
    *P_D_A1_Out = 0.*VecArr + VecCoeffs(0);
    #ifdef __DEBUG_FITS_POLY__
      cout << "CFits::Poly: I_PolynomialOrder == 0: *P_D_A1_Out set to " << *P_D_A1_Out << endl;
    #endif
    return P_D_A1_Out;
  }
  *P_D_A1_Out = VecCoeffs(I_PolynomialOrder);
  #ifdef __DEBUG_FITS_POLY__
    cout << "CFits::Poly: I_PolynomialOrder != 0: *P_D_A1_Out set to " << *P_D_A1_Out << endl;
  #endif
  for (ii = I_PolynomialOrder-1; ii >= 0; ii--){
    *P_D_A1_Out = (*P_D_A1_Out) * VecArr + VecCoeffs(ii);
    #ifdef __DEBUG_FITS_POLY__
      cout << "CFits::Poly: I_PolynomialOrder != 0: for (ii = " << ii << "; ii >= 0; ii--) *P_D_A1_Out set to " << *P_D_A1_Out << endl;
    #endif
  }
  return P_D_A1_Out;
}

double CFits::Poly(const double D_X_In,
                   const Array<double, 1> &D_A1_Coeffs) const{
  Array<double, 1> D_A1_X(1);
  D_A1_X = D_X_In;
  Array<double, 1> *P_D_A1_Y = this->Poly(D_A1_X, D_A1_Coeffs);
  double D_Y = (*P_D_A1_Y)(0);
  delete(P_D_A1_Y);
  return D_Y;
}
            

/** 
    CHISQ=double(chisq): out
    COVAR=covar: out
    MEASURE_ERRORS=measure_errors: in
    SIGMA=sigma: out
    STATUS=status: out
    YBAND=yband
    YERROR=yerror
    YFIT=yfit: out
    LSIGMA=lsigma: lower sigma rejection threshold
    USIGMA=usigma:
    ;**/
bool CFits::PolyFit(const Array<double, 1> &D_A1_X_In,
                    const Array<double, 1> &D_A1_Y_In,
                    int I_Degree_In,
                    const Array<CString, 1> &CS_A1_Args_In,
                    void *ArgV[],
                    Array<double, 1>* P_D_A1_Out) const{

  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: Starting " << endl;
  #endif
///    m = ndegree + 1 ; # of elements in coeff vec
  int I_M = I_Degree_In + 1;
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: I_M set to " << I_M << endl;
  #endif
  if (P_D_A1_Out == NULL)
    P_D_A1_Out = new Array<double, 1>(1);
  P_D_A1_Out->resize(I_M);
  (*P_D_A1_Out) = 0.;
  int i,j,I_Pos;

///    n = N_ELEMENTS(x)
  int I_N = D_A1_X_In.size();
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: I_N set to " << I_N << endl;
  #endif

///    IF (n NE N_ELEMENTS(y)) THEN MESSAGE, $
///        'X and Y must have same number of elements.'
  if (I_N != D_A1_Y_In.size()){
    cout << "CFits::PolyFit: ERROR: X and Y must have same number of elements!" << endl;
    return false;
  }

///    sdev = 1d
  Array<double, 1> D_A1_SDev(D_A1_X_In.size());
  D_A1_SDev= 1.;
  Array<double, 1> D_A1_SDevSquare(D_A1_X_In.size());
  

  CString CS_Temp(" ");
///    double = (N_ELEMENTS(double) GT 0) ? KEYWORD_SET(double) : $
///        (SIZE(x,/TNAME) EQ 'DOUBLE') OR (SIZE(y,/TNAME) EQ 'DOUBLE')

///    haveMeasureError = (N_ELEMENTS(measure_errors) gt 0)
  bool B_HaveMeasureError = false;
  Array<double, 1> *P_D_A1_MeasureErrors = new Array<double, 1>(D_A1_X_In.size());
  *P_D_A1_MeasureErrors = 1.;
  CS_Temp.Set("MEASURE_ERRORS");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    B_HaveMeasureError = true;
    delete(P_D_A1_MeasureErrors);
    P_D_A1_MeasureErrors = (Array<double, 1>*)ArgV[I_Pos];
///    if (haveMeasureError) then $
///        sdev *= measure_errors
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: B_HaveMeasureError set to TRUE" << endl;
      cout << "CFits::PolyFit: *P_D_A1_MeasureErrors set to " << *P_D_A1_MeasureErrors << endl;
    #endif
  }
  D_A1_SDev = (*P_D_A1_MeasureErrors);
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: D_A1_SDev set to " << D_A1_SDev << endl;
  #endif
  
  double D_Reject = 0.;
  bool B_Reject = false;
  CS_Temp.Set("REJECT");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    B_Reject = true;
    D_Reject = *(double*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: B_Reject set to TRUE" << endl;
      cout << "CFits::PolyFit: D_Reject set to " << D_Reject << endl;
    #endif
  }

///    sdev2 = sdev^2
  D_A1_SDevSquare = pow(D_A1_SDev,2);
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: D_A1_SDevSquare set to " << D_A1_SDevSquare << endl;
  #endif
///    haveYband = ARG_PRESENT(yband) || ARG_PRESENT(yband_old)
  bool B_HaveYBand = false;
  double D_YBand;
  double D_YBandOld;
  Array<double,1> *P_D_A1_YFit;
  CS_Temp.Set("YBAND");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    B_HaveYBand = true;
    D_YBand = *(double*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: B_HaveYBand set to TRUE" << endl;
      cout << "CFits::PolyFit: D_YBand set to " << D_YBand << endl;
    #endif
  }
  CS_Temp.Set("YBAND_OLD");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    B_HaveYBand = true;
    D_YBandOld = *(double*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: B_HaveYBand set to TRUE" << endl;
      cout << "CFits::PolyFit: D_YBandOld set to " << D_YBandOld << endl;
    #endif
  }
  CS_Temp.Set("YFIT");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    P_D_A1_YFit = (Array<double,1>*)ArgV[I_Pos];
    P_D_A1_YFit->resize(D_A1_X_In.size());
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: KeyWord_Set(YFIT)" << endl;
    #endif
  }
  else{
    P_D_A1_YFit = new Array<double,1>(D_A1_X_In.size());
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: !KeyWord_Set(YFIT)" << endl;
    #endif
  }
  (*P_D_A1_YFit) = 0.;

  Array<double,1>* P_D_A1_Sigma = new Array<double,1>(1);
  CS_Temp.Set("SIGMA");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
    delete(P_D_A1_Sigma);
    P_D_A1_Sigma = (Array<double,1>*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: KeyWord_Set(SIGMA): *P_D_A1_Sigma set to " << (*P_D_A1_Sigma) << endl;
    #endif
  }

///    ; construct work arrays
///    covar = DBLARR(m,m) ; least square matrix, weighted matrix
  Array<double, 2> *P_D_A2_Covar = new Array<double,2>(I_M,I_M);
  CS_Temp.Set("COVAR");
//  bool B_WithCoVar = false;
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) >= 0)
  {
//    B_WithCoVar = true;
    delete(P_D_A2_Covar);
    P_D_A2_Covar = (Array<double,2>*)ArgV[I_Pos];
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: KeyWord_Set(COVAR): *P_D_A2_Covar set to " << (*P_D_A2_Covar) << endl;
    #endif
  }

///    b = DBLARR(m)   ; will contain sum weights*y*x^j
  Array<double, 1> D_A1_B(I_M);

///    z = 1d          ; polynomial term (guarantees double precision calc)
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: D_A1_X_In.size() = " << D_A1_X_In.size() << endl;
  #endif
  Array<double, 1> D_A1_Z(D_A1_X_In.size());
  D_A1_Z = 1.;
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: D_A1_Z set to " << D_A1_Z << endl;
  #endif

///    wy = DOUBLE(y)
  Array<double, 1> D_A1_WY(D_A1_Y_In.size());
  D_A1_WY = D_A1_Y_In;
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: D_A1_WY set to " << D_A1_WY << endl;
  #endif

///    if (haveMeasureError) then $
///        wy /= sdev2
  if (B_HaveMeasureError){
    D_A1_WY = D_A1_WY / D_A1_SDevSquare;
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: B_HaveMeasureError: D_A1_WY set to " << D_A1_WY << endl;
    #endif
  }

///    ; Just fill in some values in case we fail.
///    yfit = !VALUES.D_NAN
///    yband = !VALUES.D_NAN
///    yerror = !VALUES.D_NAN

///    covar[0,0] = haveMeasureError ?  TOTAL(1d/sdev2) : n
//  if (B_WithCoVar){
    if (B_HaveMeasureError){
      (*P_D_A2_Covar)(0,0) = sum(1./D_A1_SDevSquare);
      #ifdef __DEBUG_FITS_POLYFIT__
        cout << "CFits::PolyFit: B_HaveMeasureError: (*P_D_A2_Covar)(0,0) set to " << (*P_D_A2_Covar)(0,0) << endl;
      #endif
    }
    else{
      (*P_D_A2_Covar)(0,0) = I_N;
      #ifdef __DEBUG_FITS_POLYFIT__
        cout << "CFits::PolyFit: !B_HaveMeasureError: (*P_D_A2_Covar)(0,0) set to " << (*P_D_A2_Covar)(0,0) << endl;
      #endif
    }
//  }

///    b[0] = TOTAL(wy)
  D_A1_B(0) = sum(D_A1_WY);
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: D_A1_B(0) set to " << D_A1_B(0) << endl;
  #endif

  double D_Sum;
///    FOR p = 1L,2*ndegree DO BEGIN   ; power loop
  for (int p = 1; p <= 2 * I_Degree_In; p++){
///        z *= x  ; z is now x^p
    D_A1_Z *= D_A1_X_In;
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: for(p(=" << p << ")...): D_A1_Z set to " << D_A1_Z << endl;
    #endif
///        IF p LT m THEN b[p] = TOTAL(wy*z)   ; b is sum weights*y*x^j
    if (p < I_M){
      D_A1_B(p) = sum(D_A1_WY * D_A1_Z);
      #ifdef __DEBUG_FITS_POLYFIT__
        cout << "CFits::PolyFit: for(p(=" << p << ")...): p < I_M(=" << I_M << "): D_A1_B(p) set to " << D_A1_B(p) << endl;
      #endif
    }
///        sum =  haveMeasureError ? TOTAL(z/sdev2) : TOTAL(z)
    if (B_HaveMeasureError){
      D_Sum = sum(D_A1_Z / D_A1_SDevSquare);
      #ifdef __DEBUG_FITS_POLYFIT__
        cout << "CFits::PolyFit: for(p(=" << p << ")...): B_HaveMeasureError: D_Sum set to " << D_Sum << endl;
      #endif
    }
    else{
      D_Sum = sum(D_A1_Z);
      #ifdef __DEBUG_FITS_POLYFIT__
        cout << "CFits::PolyFit: for(p(=" << p << ")...): !B_HaveMeasureError: D_Sum set to " << D_Sum << endl;
      #endif
    }
///        for j = 0 > (p-ndegree), ndegree < p do $
///            covar[j,p-j] = sum
    if (p-I_Degree_In > 0){
      i = p-I_Degree_In;
    }
    else{
      i = 0;
    }
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: for(p(=" << p << ")...): i set to " << i << endl;
    #endif
//    if (B_WithCoVar){
      for (j = i; j <= I_Degree_In; j++){
        (*P_D_A2_Covar)(j,p-j) = D_Sum;
        #ifdef __DEBUG_FITS_POLYFIT__
          cout << "CFits::PolyFit: for(p(=" << p << ")...): for(j(=" << j << ")...): (*P_D_A2_Covar)(j,p-j=" << p-j << ") set to " << (*P_D_A2_Covar)(j,p-j) << endl;
        #endif
      }
//    }
///    ENDFOR ; end of p loop, construction of covar and b
  }

///    covar = INVERT(TEMPORARY(covar), status)
//  if (B_WithCoVar){
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: before InvertGaussJ: (*P_D_A2_Covar) = " << (*P_D_A2_Covar) << endl;
    #endif
    if (!this->InvertGaussJ(*P_D_A2_Covar)){
      cout << "CFits::PolyFit: ERROR! InvertGaussJ(*P_D_A2_Covar=" << *P_D_A2_Covar << ") returned false!" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: InvertGaussJ: (*P_D_A2_Covar) set to " << (*P_D_A2_Covar) << endl;
    #endif
//  }
///    IF NOT ARG_PRESENT(status) THEN BEGIN
///        CASE status OF
///        1: MESSAGE, "Singular matrix detected."
///        2: MESSAGE,/INFO, "Warning: Invert detected a small pivot element."
///        ELSE:
///        ENDCASE
///    ENDIF
///    if (status eq 1) then begin
///        result = !VALUES.D_NAN
///        goto, done
///    endif


///    result = (TEMPORARY(b) # covar)  ; construct coefficients
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: MatrixTimesVecArr: P_D_A2_Covar->rows() = " << P_D_A2_Covar->rows() << endl;
    cout << "CFits::PolyFit: MatrixTimesVecArr: P_D_A2_Covar->cols() = " << P_D_A2_Covar->cols() << endl;
    cout << "CFits::PolyFit: MatrixTimesVecArr: (*P_D_A2_Covar) = " << (*P_D_A2_Covar) << endl;
    cout << "CFits::PolyFit: MatrixTimesVecArr: D_A1_B = " << D_A1_B.size() << ": " << D_A1_B << endl;
  #endif
  Array<double,1> *P_D_A1_TempA = MatrixTimesVecArr(*P_D_A2_Covar, D_A1_B);
  P_D_A1_Out->resize(P_D_A1_TempA->size());
  (*P_D_A1_Out) = (*P_D_A1_TempA);
  delete(P_D_A1_TempA);
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: MatrixTimesVecArr: P_D_A1_YFit->size() = " << P_D_A1_YFit->size() << ": (*P_D_A1_Out) set to " << (*P_D_A1_Out) << endl;
  #endif

///    ; compute optional output parameters.

///    ; one-standard deviation error estimates, init
///    yfit = result[ndegree]
///  Array<double,1> P_D_A1_YFit = (*P_D_A1_Out)(I_Degree_In);
  (*P_D_A1_YFit) = (*P_D_A1_Out)(I_Degree_In);
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: InvertGaussJ: (*P_D_A1_YFit) set to " << (*P_D_A1_YFit) << endl;
  #endif

///    for k = ndegree-1L, 0, -1 do $
///        yfit = result[k] + TEMPORARY(yfit)*x  ; sum basis vectors
  for (int k=I_Degree_In-1; k >= 0; k--){
    (*P_D_A1_YFit) = (*P_D_A1_Out)(k) + (*P_D_A1_YFit) * D_A1_X_In;
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: for(k(=" << k << ")...): (*P_D_A1_YFit) set to " << (*P_D_A1_YFit) << endl;
    #endif
  }

///    ; Vector of parameter errors.
///    sigma = SQRT(ABS(covar[lindgen(M)*(M+1)]))
  P_D_A1_Sigma->resize(I_M);
  for (int k=0;k < I_M; k++){
    (*P_D_A1_Sigma)(k) = (*P_D_A2_Covar)(k,k);
  }
  (*P_D_A1_Sigma) = sqrt(abs(*P_D_A1_Sigma));
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: (*P_D_A1_Sigma) set to " << (*P_D_A1_Sigma) << endl;
  #endif

  double D_ChiSq = 0.;
  double D_Var = 0.;
///    if (haveMeasureError) then begin
  if (B_HaveMeasureError){
///        ; Only do this computation once.
///        diff = (yfit - y)^2
    Array<double,1> D_A1_Diff(D_A1_Y_In.size());
    D_A1_Diff = pow(D_A1_Y_In - (*P_D_A1_YFit),2);
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: B_HaveMeasureError: D_A1_Diff set to " << D_A1_Diff << endl;
    #endif

///        chisq = TOTAL(diff/sdev2)
    D_ChiSq = sum(D_A1_Diff / D_A1_SDevSquare);
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: B_HaveMeasureError: D_ChiSq set to " << D_ChiSq << endl;
    #endif

///        ; Experimental variance estimate, unbiased.
///        var = (n gt m) ? TOTAL(diff)/(n-m) : 0d
    D_Var = 0.;
    if (I_N > I_M){
      D_Var = sum(D_A1_Diff) / (I_N - I_M);
#ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: B_HaveMeasureError: I_N > I_M: D_Var set to " << D_Var << endl;
#endif
    }
///    endif else begin
  }
  else{
///        ; No weighting, don't need to divide by sdev2.
///        chisq = TOTAL((yfit - y)^2)
    D_ChiSq = sum(pow(D_A1_Y_In - (*P_D_A1_YFit),2));
#ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: !B_HaveMeasureError: D_ChiSq set to " << D_ChiSq << endl;
#endif

///        ; Experimental variance estimate, unbiased.
///        var = (n gt m) ? chisq/(n-m) : 0d
    D_Var = 0.;
    if (I_N > I_M){
      D_Var = D_ChiSq / (I_N - I_M);
#ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: !B_HaveMeasureError: I_N > I_M: D_Var set to " << D_Var << endl;
#endif
    }

///        ; If MEASURE_ERRORS is omitted, then you are assuming that your model
///        ; is correct. In this case, SIGMA is multiplied by SQRT(chisq/(n-m)).
///        ; See section 15.2 of Numerical Recipes in C (Second Edition) for details.
///        sigma *= SQRT(chisq/(n-m))
    (*P_D_A1_Sigma) *= sqrt(D_ChiSq / (I_N - I_M));
#ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: !B_HaveMeasureError: (*P_D_A1_Sigma) set to " << (*P_D_A1_Sigma) << endl;
#endif
///    endelse
  }
///    ; Overall fit error.
///    yerror = SQRT(var)
//  double D_YError = sqrt(D_Var);
///    ; Only do this computation if user wants YBAND.
///    if (haveYband) then begin
///        z = REPLICATE(1d, n)
///        yband = REPLICATE(covar[0,0], n)
///        FOR p=1L,2*ndegree DO BEGIN ; compute correlated error estimates on y
///            z *= x      ; z is now x^p
///            sum = 0
///            for j=0 > (p - ndegree), ndegree<p do $
///                sum += covar[j,p-j]
///            yband += sum * z  ; add in all the error sources
///        ENDFOR  ; end of p loop

///        yband *= var
///        IF (MIN(yband) LT 0) OR (MIN(FINITE(yband)) EQ 0) THEN BEGIN
///            status = 3
///            IF NOT ARG_PRESENT(status) THEN MESSAGE, $
///                'Undefined (NaN) error estimate encountered.'
///        ENDIF ELSE yband = SQRT( TEMPORARY(yband) )
///    endif

///done:

///    ; If necessary, convert all results to single precision.
///    if (not double) then begin
///        chisq = FLOAT(chisq)
///        covar = FLOAT(covar)
///        result = FLOAT(result)
///        sigma = FLOAT(sigma)
///        var = FLOAT(var)   ; needed for corrm_old below
///        yfit = FLOAT(yfit)
///        if (haveYband) then $
///            yband = FLOAT(yband)
///        yerror = FLOAT(yerror)
///    endif

///; fill in obsolete arguments, if necessary
///    IF (N_PARAMS() GT 3) THEN BEGIN
///        corrm_old = covar*var   ; convert to correlation matrix
///        yerror_old = yerror
///        yfit_old = yfit
///        if (haveYband) then $
///            yband_old = yband
///    ENDIF

///    RETURN, result**/
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: returning *P_D_A1_Out = " << (*P_D_A1_Out) << endl;
  #endif

  CS_Temp.Set("YFIT");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) < 0)
  {
    delete(P_D_A1_YFit);
  }
  CS_Temp.Set("SIGMA");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) < 0)
  {
    delete(P_D_A1_Sigma);
  }
  CS_Temp.Set("COVAR");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args_In)), CS_Temp)) < 0)
  {
    delete(P_D_A2_Covar);
  }
  if (!B_HaveMeasureError)
    delete(P_D_A1_MeasureErrors);
  return true;
}

/** **********************************************************************/

bool CFits::PolyFit(const Array<double, 1> &D_A1_X_In,
                    const Array<double, 1> &D_A1_Y_In,
                    int I_Degree_In,
                    Array<double, 1>* P_D_A1_Out) const{
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: Starting " << endl;
  #endif
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args = CString(" ");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  if (!PolyFit(D_A1_X_In, D_A1_Y_In, I_Degree_In, CS_A1_Args, PP_Args, P_D_A1_Out)){
    cout << "CFits::PolyFit: ERROR: PolyFit(" << D_A1_X_In << ", " << D_A1_Y_In << ", " << I_Degree_In << "...) returned FALSE" << endl;
    cout << "CFits::PolyFit: ERROR: PolyFit returned *P_D_A1_Out = " << *P_D_A1_Out << endl;
    free(PP_Args);
    return false;
  }
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: PolyFit returned *P_D_A1_Out = " << *P_D_A1_Out << endl;
  #endif
//  free(*PP_Args);
  free(PP_Args);
  return true;
}

/**    FUNCTION POLY_FIT, x, y, ndegree, $
    yfit_old, yband_old, yerror_old, corrm_old, $     ; obsolete arguments
    CHISQ=chisq, $
    COVAR=covar, $
    DOUBLE=double, $
    MEASURE_ERRORS=measure_errors, $
    SIGMA=sigma, $
    STATUS=status, $
    YBAND=yband, $
    YERROR=yerror, $
    YFIT=yfit
    REJECTED=Array<int, 1>
    NOT_REJECTED=Array<int, 1>
    N_REJECTED=int
    ;**/
bool CFits::PolyFit(const Array<double, 1> &D_A1_X_In,
                    const Array<double, 1> &D_A1_Y_In,
                    const int I_Degree_In,
                    const double D_Reject_In,
                    const Array<CString, 1> &CS_A1_Args_In,
                    void *ArgV[],
                    Array<double, 1>* P_D_A1_Out) const{
  return this->PolyFit(D_A1_X_In,
                       D_A1_Y_In,
                       I_Degree_In,
                       D_Reject_In,
                       D_Reject_In,
                       -1,
                       CS_A1_Args_In,
                       ArgV,
                       P_D_A1_Out);
}
bool CFits::PolyFit(const Array<double, 1> &D_A1_X_In,
                    const Array<double, 1> &D_A1_Y_In,
                    const int I_Degree_In,
                    const double D_LReject_In,
                    const double D_UReject_In,
                    const int I_NIter,
                    const Array<CString, 1> &CS_A1_Args_In,
                    void *ArgV[],
                    Array<double, 1>* P_D_A1_Out) const{

  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: Starting " << endl;
  #endif

  int I_NReject = 0;
  Array<double, 1> D_A1_X(D_A1_X_In.size());
  D_A1_X = D_A1_X_In;
  Array<double, 1> D_A1_Y(D_A1_Y_In.size());
  D_A1_Y = D_A1_Y_In;
  Array<double, 1> D_A1_X_New(D_A1_X.size());
  Array<double, 1> D_A1_Y_New(D_A1_Y.size());
  Array<double, 1> D_A1_MeasureErrors(D_A1_X.size());
  Array<double, 1> D_A1_MeasureErrors_New(D_A1_X.size());
  Array<double, 1> *P_D_A1_MeasureErrors = new Array<double, 1>(D_A1_X_In.size());
  int I_DataValues_New = 0;
  int I_NRejected = 0;
  D_A1_MeasureErrors = sqrt(D_A1_Y_In);
  (*P_D_A1_MeasureErrors) = D_A1_MeasureErrors;
  bool B_HaveMeasureErrors = false;
  
  int I_Pos = -1;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS"));
  if (I_Pos >= 0){
    delete(P_D_A1_MeasureErrors);
    P_D_A1_MeasureErrors = (Array<double,1>*)ArgV[I_Pos];
    D_A1_MeasureErrors = *P_D_A1_MeasureErrors;
    B_HaveMeasureErrors = true;
    if (P_D_A1_MeasureErrors->size() != D_A1_X_In.size()){
      cout << "CFits::PolyFit: ERROR: P_D_A1_MeasureErrors->size(=" << P_D_A1_MeasureErrors->size() << ") != D_A1_X_In.size(=" << D_A1_X_In.size() << ")" << endl;
      return false;
    }
  }

  Array<int, 1> *P_I_A1_NotRejected;
  bool B_KeyWordSet_NotRejected = false;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("NOT_REJECTED"));
  if (I_Pos >= 0){
    cout << "CFits::PolyFit: Reading KeyWord NOT_REJECTED" << endl;
    cout << "CFits::PolyFit: I_Pos = " << I_Pos << endl;
    P_I_A1_NotRejected = (Array<int,1>*)(ArgV[I_Pos]);
    cout << "CFits::PolyFit: *P_I_A1_NotRejected = " << *P_I_A1_NotRejected << endl;
//    P_I_A1_NotRejected->resize(D_A1_X_In.size());
//    *P_I_A1_NotRejected = -1;
    B_KeyWordSet_NotRejected = true;
    cout << "CFits::PolyFit: KeyWord NOT_REJECTED read" << endl;
  }

  Array<int, 1> *P_I_A1_Rejected;
  Array<int, 1> I_A1_Rejected(D_A1_X_In.size());
  I_A1_Rejected = 0;
  bool B_KeyWordSet_Rejected = false;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("REJECTED"));
  if (I_Pos >= 0){
    cout << "CFits::PolyFit: Reading KeyWord REJECTED" << endl;
    cout << "CFits::PolyFit: I_Pos = " << I_Pos << endl;
    P_I_A1_Rejected = (Array<int,1>*)(ArgV[I_Pos]);
    cout << "CFits::PolyFit: *P_I_A1_Rejected = " << *P_I_A1_Rejected << endl;
//    P_I_A1_Rejected->resize(D_A1_X_In.size());
//    *P_I_A1_Rejected = -1;
    B_KeyWordSet_Rejected = true;
    cout << "CFits::PolyFit: KeyWord REJECTED read" << endl;
  }

  int *P_I_NRejected;
  bool B_KeyWordSet_NRejected = false;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("N_REJECTED"));
  if (I_Pos >= 0){
    cout << "CFits::PolyFit: Reading KeyWord N_REJECTED" << endl;
    cout << "CFits::PolyFit: I_Pos = " << I_Pos << endl;
    P_I_NRejected = (int*)(ArgV[I_Pos]);
    cout << "CFits::PolyFit: P_I_NRejected = " << *P_I_NRejected << endl;
    B_KeyWordSet_NRejected = true;
    cout << "CFits::PolyFit: KeyWord N_REJECTED read" << endl;
  }

  Array<int, 1> *P_I_A1_OrigPos = this->IndGenArr(D_A1_X_In.size());
  Array<double, 1> *P_D_A1_PolyRes;
  int I_NRejected_Old=0;
  Array<int, 1> I_A1_Rejected_Old(D_A1_X_In.size());
  bool B_Run = true;
  int i_iter = 0;
//  if (I_NIter > 0)
//    B_Run = false;
  while (B_Run){
    I_A1_Rejected_Old.resize(I_A1_Rejected.size());
    I_A1_Rejected_Old = I_A1_Rejected;
    I_A1_Rejected.resize(D_A1_X_In.size());
    I_NRejected_Old = I_NRejected;
    I_NReject = 0;
    I_NRejected = 0;
    I_DataValues_New = 0;
    if (!this->PolyFit(D_A1_X,
                       D_A1_Y,
                       I_Degree_In,
                       CS_A1_Args_In,
                       ArgV,
                       P_D_A1_Out)){
      cout << "CFits::PolyFit: ERROR: PolyFit returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_POLYFIT__
      cout << "CFits::PolyFit: PolyFit(D_A1_X, D_A1_Y, I_Degree_In, CS_A1_Args_In, ArgV, P_D_A1_Out) returned *P_D_A1_Out = " << *P_D_A1_Out << endl;
//      return false;
    #endif
    Array<double, 1> *P_D_A1_YFit = this->Poly(D_A1_X, *P_D_A1_Out);
    double D_SDev = sqrt(sum(pow2(D_A1_Y - (*P_D_A1_YFit)) / D_A1_Y.size()));

    P_D_A1_PolyRes = this->Poly(D_A1_X_In, *P_D_A1_Out);
    for (int i_pos=0; i_pos < D_A1_Y_In.size(); i_pos++){
      double D_Dev = D_A1_Y_In(i_pos) - (*P_D_A1_PolyRes)(i_pos);
      if (((D_Dev < 0) && (D_Dev > (D_LReject_In * D_SDev))) || ((D_Dev >= 0) && (D_Dev < (D_UReject_In * D_SDev)))){
        D_A1_X_New(I_DataValues_New) = D_A1_X_In(i_pos);
        D_A1_Y_New(I_DataValues_New) = D_A1_Y_In(i_pos);
        if (B_HaveMeasureErrors)
          D_A1_MeasureErrors_New(I_DataValues_New) = (*P_D_A1_MeasureErrors)(i_pos);
        (*P_I_A1_OrigPos)(I_DataValues_New) = D_A1_Y_In(i_pos);

        I_DataValues_New++;
      }
      else{
        I_A1_Rejected(I_NRejected) = i_pos;
        cout << "CFits::PolyFit: D_A1_Y_In(i_pos)=" << D_A1_Y_In(i_pos) << ", (*P_D_A1_PolyRes)(i_pos)=" << (*P_D_A1_PolyRes)(i_pos) << ", D_Dev=" << D_Dev << ", D_SDev=" << D_SDev << ": Rejecting D_A1_X_In(i_pos=" << i_pos << ") = " << D_A1_X_In(i_pos) << endl;
        I_NReject++;
        I_NRejected++;
      }
    }
    delete(P_D_A1_PolyRes);
    D_A1_X.resize(I_DataValues_New);
    D_A1_Y.resize(I_DataValues_New);
    D_A1_X = D_A1_X_New(Range(0,I_DataValues_New-1));
    D_A1_Y = D_A1_Y_New(Range(0,I_DataValues_New-1));
    if (B_HaveMeasureErrors){
      D_A1_MeasureErrors.resize(I_DataValues_New);
      D_A1_MeasureErrors = D_A1_MeasureErrors_New(Range(0,I_DataValues_New-1));
    }

    delete(P_D_A1_YFit);

    B_Run = false;
    if (I_NRejected != I_NRejected_Old)
      B_Run = true;
    else{
      for (int i_pos=0; i_pos < I_NRejected; i_pos++){
        if (fabs(I_A1_Rejected(i_pos) - I_A1_Rejected_Old(i_pos)) > 0.0001)
          B_Run = true;
      }
    }
    i_iter++;
    if ((I_NIter >= 0) && (i_iter >= I_NIter))
      B_Run = false;
  }
  cout << "CFits::PolyFit: I_NRejected = " << I_NRejected << endl;

//  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS"));
//  if (I_Pos >= 0){
//    ArgV[I_Pos] = P_D_A1_MeasureErrors;
//  }

  cout << "CFits::PolyFit: I_DataValues_New = " << I_DataValues_New << endl;
  Array<int, 1> I_A1_NotRejected(I_DataValues_New);
  I_A1_NotRejected = (*P_I_A1_OrigPos)(Range(0, I_DataValues_New-1));
  if (B_KeyWordSet_NotRejected){
    P_I_A1_NotRejected->resize(I_DataValues_New);
    (*P_I_A1_NotRejected) = I_A1_NotRejected;
    cout << "CFits::PolyFit: *P_I_A1_NotRejected = " << *P_I_A1_NotRejected << endl;
  }
  delete(P_I_A1_OrigPos);
  P_I_A1_OrigPos = this->IndGenArr(D_A1_X_In.size());
  if (!this->Remove_SubArrayFromArray(*P_I_A1_OrigPos, I_A1_NotRejected)){
    cout << "CFits::PolyFit: ERROR: Remove_SubArrayFromArray(" << *P_I_A1_OrigPos << ", " << I_A1_NotRejected << ") returned FALSE" << endl;
    return false;
  }
  if (B_KeyWordSet_Rejected){
    P_I_A1_Rejected->resize(I_NRejected);
    (*P_I_A1_Rejected) = I_A1_Rejected(Range(0, I_NRejected-1));
    cout << "CFits::PolyFit: *P_I_A1_Rejected = " << *P_I_A1_Rejected << endl;
  }
  if (B_KeyWordSet_NRejected){
    *P_I_NRejected = I_NRejected;
  }
  delete(P_I_A1_OrigPos);

  return true;
}

/** **********************************************************************/

bool CFits::PolyFit(const Array<double, 1> &D_A1_X_In,
                    const Array<double, 1> &D_A1_Y_In,
                    const int I_Degree_In,
                    const double D_Reject_In,
                    Array<double, 1>* P_D_A1_Out) const{
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: Starting " << endl;
  #endif
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args = CString(" ");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  if (!PolyFit(D_A1_X_In, D_A1_Y_In, I_Degree_In, D_Reject_In, CS_A1_Args, PP_Args, P_D_A1_Out)){
    cout << "CFits::PolyFit: ERROR: PolyFit(" << D_A1_X_In << ", " << D_A1_Y_In << ", " << I_Degree_In << "...) returned FALSE" << endl;
    cout << "CFits::PolyFit: ERROR: PolyFit returned *P_D_A1_Out = " << *P_D_A1_Out << endl;
    free(PP_Args);
    return false;
  }
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: PolyFit returned *P_D_A1_Out = " << *P_D_A1_Out << endl;
  #endif
//  free(*PP_Args);
  free(PP_Args);
  return true;
}

/** **********************************************************************/

bool CFits::PolyFit(const Array<double, 1> &D_A1_X_In,
                    const Array<double, 1> &D_A1_Y_In,
                    const int I_Degree_In,
                    const double D_LReject_In,
                    const double D_HReject_In,
                    const int I_NIter,
                    Array<double, 1>* P_D_A1_Out) const{
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: Starting " << endl;
  #endif
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args = CString(" ");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  if (!PolyFit(D_A1_X_In, 
               D_A1_Y_In, 
               I_Degree_In, 
               D_LReject_In, 
               D_HReject_In, 
               I_NIter,
               CS_A1_Args, 
               PP_Args, 
               P_D_A1_Out)){
    cout << "CFits::PolyFit: ERROR: PolyFit(" << D_A1_X_In << ", " << D_A1_Y_In << ", " << I_Degree_In << "...) returned FALSE" << endl;
    cout << "CFits::PolyFit: ERROR: PolyFit returned *P_D_A1_Out = " << *P_D_A1_Out << endl;
    free(PP_Args);
    return false;
  }
  #ifdef __DEBUG_FITS_POLYFIT__
    cout << "CFits::PolyFit: PolyFit returned *P_D_A1_Out = " << *P_D_A1_Out << endl;
  #endif
//  free(*PP_Args);
  free(PP_Args);
  return true;
}

/** GaussFit
**/
bool CFits::GaussFit(const Array<double, 1> &D_A1_X,
                     const Array<double, 1> &D_A1_Y,
                     Array<double,1> &D_A1_A,
                     const Array<CString, 1> &CS_A1_Args_In,
                     void *ArgV[]) const{
///                  CHISQ=variable,
///                  ESTIMATES=array,
///                  MEASURE_ERRORS=vector,
///                  NTERMS=integer{3 to 6},
///                  SIGMA=double,
///                  YERROR=double,
///                  YFIT=Array<double, 1>*)
  int I_NT = 0;
  int i,I_Pos, I_I0;
  double c, xmin, xmax, ymin, ymax;
  double D_DY, D_Del;
  Array<double, 1> *P_D_A1_MeasureErrors;
  Array<double, 1> *P_D_A1_Estimates;
  Array<double, 1> *P_D_A1_YFit;
  Array<double, 1> *P_D_A1_Sigma;
  bool B_NeedToDelete_P_D_A1_YFit = false;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("YFIT"));
  if (I_Pos >= 0){
    P_D_A1_YFit = (Array<double, 1>*)ArgV[I_Pos];
  }
  else{
    P_D_A1_YFit = new Array<double, 1>(1);
    *P_D_A1_YFit = 0.;
    B_NeedToDelete_P_D_A1_YFit = true;
  }

  bool B_NeedToDelete_P_D_A1_Sigma = false;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("SIGMA"));
  if (I_Pos >= 0){
    P_D_A1_Sigma = (Array<double, 1>*)ArgV[I_Pos];
  }
  else{
    P_D_A1_Sigma = new Array<double, 1>(1);
    *P_D_A1_Sigma = 0.;
    B_NeedToDelete_P_D_A1_Sigma = true;
  }
  Array<double, 1> *P_D_A1_PolyFitOut = new Array<double, 1>(1);
  Array<double, 1> D_A1_YD(D_A1_Y.size());
  TinyVector<int, 1> TV_Index;
  Array<int, 1> *P_I_A1_MinIndex;
  Array<int, 1> *P_I_A1_MaxIndex;
  Array<CString, 1> CS_A1_ArgsPolyFit(1);
  CS_A1_ArgsPolyFit(0) = CString("YFIT");
  void **PP_ArgsPolyFit = (void**)malloc(sizeof(void*));
  PP_ArgsPolyFit[0] = P_D_A1_YFit;

  double D_YError;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("YERROR"));
  if (I_Pos >= 0){
    D_YError = *(double*)ArgV[I_Pos];
  }
  else{
    D_YError = 0.;
  }

  bool B_NeedToDelete_P_D_ChiSq = false;
  double *P_D_ChiSq;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("CHISQ"));
  if (I_Pos >= 0){
    P_D_ChiSq = (double*)ArgV[I_Pos];
  }
  else{
    P_D_ChiSq = new double();
    *P_D_ChiSq = 0.;
    B_NeedToDelete_P_D_ChiSq = true;
  }

  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("NTERMS"));
  if (I_Pos >= 0)
    I_NT = *(int*)ArgV[I_Pos];
  else
    I_NT = 6;
  if (I_NT < 3 || I_NT > 6){
    cout << "CFits::GaussFit: ERROR: NTERMS must have values from 3 to 6." << endl;
    if (B_NeedToDelete_P_D_A1_Sigma)
      delete(P_D_A1_Sigma);
    if (B_NeedToDelete_P_D_A1_YFit)
      delete(P_D_A1_YFit);
    if (B_NeedToDelete_P_D_ChiSq)
      delete(P_D_ChiSq);
    delete(P_D_A1_PolyFitOut);
    free(PP_ArgsPolyFit);
    return false;
  }
  #ifdef __DEBUG_FITS_GAUSSFIT__
    cout << "CFits::GaussFit: I_NT set to " << I_NT << endl;
  #endif
  int n = D_A1_Y.size();
  #ifdef __DEBUG_FITS_GAUSSFIT__
    cout << "CFits::GaussFit: n set to " << n << endl;
  #endif
  if (n < 2){
    cout << "CFits::GaussFit: ERROR: D_A1_Y must have at least 2 elements" << endl;
    if (B_NeedToDelete_P_D_A1_Sigma)
      delete(P_D_A1_Sigma);
    if (B_NeedToDelete_P_D_A1_YFit)
      delete(P_D_A1_YFit);
    if (B_NeedToDelete_P_D_ChiSq)
      delete(P_D_ChiSq);
    delete(P_D_A1_PolyFitOut);
    free(PP_ArgsPolyFit);
    return false;
  }

  bool B_NeedToDelete_P_D_A1_MeasureErrors = false;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS"));
  if (I_Pos >= 0)
    P_D_A1_MeasureErrors = (Array<double, 1>*)ArgV[I_Pos];
  else{
    P_D_A1_MeasureErrors = new Array<double, 1>(1);
    B_NeedToDelete_P_D_A1_MeasureErrors = true;
  }
  int I_NMeas = P_D_A1_MeasureErrors->size();
  #ifdef __DEBUG_FITS_GAUSSFIT__
    cout << "CFits::GaussFit: I_NMeas set to " << I_NMeas << endl;
  #endif
  if (I_NMeas > 1 && I_NMeas != n){
    cout << "CFits::GaussFit: ERROR: MEASURE_ERRORS must have same size as D_A1_Y" << endl;
    if (B_NeedToDelete_P_D_A1_Sigma)
      delete(P_D_A1_Sigma);
    if (B_NeedToDelete_P_D_A1_YFit)
      delete(P_D_A1_YFit);
    if (B_NeedToDelete_P_D_A1_MeasureErrors)
      delete(P_D_A1_MeasureErrors);
    if (B_NeedToDelete_P_D_ChiSq)
      delete(P_D_ChiSq);
    delete(P_D_A1_PolyFitOut);
    free(PP_ArgsPolyFit);
    return false;
  }

  bool B_NeedToDelete_P_D_A1_Estimates = false;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("ESTIMATES"));
  if (I_Pos >= 0)
    P_D_A1_Estimates = (Array<double, 1>*)ArgV[I_Pos];
  else{
    P_D_A1_Estimates = new Array<double, 1>(1);
    B_NeedToDelete_P_D_A1_Estimates = true;
  }
  int I_NEst = P_D_A1_Estimates->size();
  #ifdef __DEBUG_FITS_GAUSSFIT__
    cout << "CFits::GaussFit: I_NEst set to " << I_NEst << endl;
  #endif
  if (I_NEst > 1 && I_NEst != I_NT){
    cout << "CFits::GaussFit: ERROR: ESTIMATES must have same size as NTERMS" << endl;
    if (B_NeedToDelete_P_D_A1_Sigma)
      delete(P_D_A1_Sigma);
    if (B_NeedToDelete_P_D_A1_YFit)
      delete(P_D_A1_YFit);
    if (B_NeedToDelete_P_D_A1_MeasureErrors)
      delete(P_D_A1_MeasureErrors);
    if (B_NeedToDelete_P_D_A1_Estimates)
      delete(P_D_A1_Estimates);
    if (B_NeedToDelete_P_D_ChiSq)
      delete(P_D_ChiSq);
    delete(P_D_A1_PolyFitOut);
    free(PP_ArgsPolyFit);
    return false;
  }

  if (I_NEst == 1 || (P_D_A1_Estimates->size() > 1 && (*P_D_A1_Estimates)(2) == 0)){///Compute Estimates
    if (I_NT > 3){
///            ; For a Gaussian + polynomial, we need to subtract off either
///            ; a constant or a straight line to get good estimates.
///            ; NOTE: Because a Gaussian and a quadratic can be highly correlated,
///            ; we do not want to subtract off the quadratic term.
///            c = POLY_FIT(x, y, (nt eq 4) ? 0 : 1, yf)
///            yd = y - yf
      if (!this->PolyFit(D_A1_X, D_A1_Y, (I_NT == 4) ? 0 : 1, CS_A1_ArgsPolyFit, PP_ArgsPolyFit, P_D_A1_PolyFitOut)){
        cout << "CFits::GaussFit: ERROR: PolyFit returned FALSE" << endl;
        if (B_NeedToDelete_P_D_A1_Sigma)
          delete(P_D_A1_Sigma);
        if (B_NeedToDelete_P_D_A1_YFit)
          delete(P_D_A1_YFit);
        if (B_NeedToDelete_P_D_A1_MeasureErrors)
          delete(P_D_A1_MeasureErrors);
        if (B_NeedToDelete_P_D_A1_Estimates)
          delete(P_D_A1_Estimates);
        if (B_NeedToDelete_P_D_ChiSq)
          delete(P_D_ChiSq);
        delete(P_D_A1_PolyFitOut);
        free(PP_ArgsPolyFit);
        return false;
      }
      #ifdef __DEBUG_FITS_GAUSSFIT__
        cout << "CFits::GaussFit: after PolyFit: P_D_A1_YFit = " << *P_D_A1_YFit << endl;
        cout << "CFits::GaussFit: after PolyFit: P_D_A1_PolyFitOut = " << *P_D_A1_PolyFitOut << endl;
      #endif
      D_A1_YD = D_A1_Y - (*P_D_A1_YFit);
      #ifdef __DEBUG_FITS_GAUSSFIT__
        cout << "CFits::GaussFit: after PolyFit: D_A1_YD set to " << D_A1_YD << endl;
      #endif
    }
    else{
///            ; Just fitting a Gaussian. Don't need to subtract off anything.
///            yd = y
///            c = 0d
      D_A1_YD = D_A1_Y;
      #ifdef __DEBUG_FITS_GAUSSFIT__
        cout << "CFits::GaussFit: D_A1_YD set to " << D_A1_YD << endl;
      #endif
      P_D_A1_YFit->resize(1);
      *P_D_A1_YFit = 0.0;
    }

///        ;x,y and subscript of extrema
///        ymax=max(yd, imax)
///        xmax=x[imax]
    ymax = max(D_A1_YD);
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: ymax set to " << ymax << endl;
    #endif
    TV_Index = maxIndex(D_A1_YD);
    P_I_A1_MaxIndex = this->MaxIndex(TV_Index);
    xmax = D_A1_X((*P_I_A1_MaxIndex)(0));
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: xmax set to " << xmax << endl;
    #endif

///        ymin=min(yd, imin)
///        xmin=x[imin]
    ymin = min(D_A1_YD);
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: ymin set to " << ymin << endl;
    #endif
    TV_Index = minIndex(D_A1_YD);
    P_I_A1_MinIndex = this->MaxIndex(TV_Index);
    xmin = D_A1_X((*P_I_A1_MinIndex)(0));
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: xmin set to " << xmin << endl;
    #endif

///        if abs(ymax) gt abs(ymin) then i0=imax else i0=imin ;emiss or absorp?
///        i0 = i0 > 1 < (n-2)     ;never take edges
    if (fabs(ymax) > fabs(ymin))
      I_I0 = (*P_I_A1_MaxIndex)(0);
    else
      I_I0 = (*P_I_A1_MinIndex)(0);
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: I_I0 set to " << I_I0 << endl;
    #endif
    delete(P_I_A1_MinIndex);
    delete(P_I_A1_MaxIndex);
    if (I_I0 < 1)
      I_I0 = 1;
    if (I_I0 > n-2)
      I_I0 = n-2;
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: I_I0 set to " << I_I0 << endl;
    #endif

///        dy=yd[i0]           ;diff between extreme and mean
    D_DY = D_A1_YD(I_I0);
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: D_DY set to " << D_DY << endl;
    #endif

///        del = dy/exp(1.)        ;1/e value
    D_Del = D_DY / exp(1.);
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: D_Del set to " << D_Del << endl;
    #endif

    i=0;
///        while ((i0+i+1) lt n) and $ ;guess at 1/2 width.
///        ((i0-i) gt 0) and $
///        (abs(yd[i0+i]) gt abs(del)) and $
///        (abs(yd[i0-i]) gt abs(del)) do i=i+1
    while(((I_I0 + i + 1) < n) && ((I_I0 - i) > 0) && (fabs(D_A1_YD(I_I0 + i)) > fabs(D_Del)) && (fabs(D_A1_YD(I_I0 - i)) > fabs(D_Del)))
      i++;
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: i set to " << i << endl;
    #endif

///        a = [yd[i0], x[i0], abs(x[i0]-x[i0+i])]
    D_A1_A.resize(I_NT);
    D_A1_A = 0.;
    D_A1_A(0) = D_A1_YD(I_I0);
    D_A1_A(1) = D_A1_X(I_I0);
    D_A1_A(2) = fabs(D_A1_X(I_I0) - D_A1_X(I_I0 + i));
    if (I_NT > 3)
      D_A1_A(3) = (*P_D_A1_PolyFitOut)(0);
    if (I_NT > 4)
      D_A1_A(4) = (*P_D_A1_PolyFitOut)(1);
    if (I_NT > 5)
      D_A1_A(5) = 0.;
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: D_A1_A set to " << D_A1_A << endl;
    #endif

///        if nt gt 3 then a = [a, c[0]] ; estimate for constant term
///        if nt gt 4 then a = [a, c[1]] ; estimate for linear term
///        if nt gt 5 then a = [a, 0.]   ; assume zero for quadratic estimate
///    endif
  }

///    ; Were estimates provided?
///    if (nEst gt 0) then begin
///        tmp = est
///        ; Did we need to compute the A2 term above?
///        if (est[2] eq 0) then $
///            tmp[2] = a[2]
///        a = tmp
///    endif
  Array<double, 1> D_A1_Temp(P_D_A1_Estimates->size());
  if (I_NEst > 1){
    D_A1_Temp = (*P_D_A1_Estimates);
    if ((*P_D_A1_Estimates)(2) == 0.)
      D_A1_Temp(2) = D_A1_A(2);
    D_A1_A = D_A1_Temp;
  }

///    ; Convert from MEASURE_ERRORS to CURVEFIT weights argument.
///    ; If we don't have MEASURE_ERRORS we will pass in an undefined variable
///    ; to CURVEFIT, which will then assume no weighting.
///    if (nMeas gt 0) then $
///        weights = 1/measureErrors^2
  #ifdef __DEBUG_FITS_GAUSSFIT__
    cout << "CFits::GaussFit: I_NMeas = " << I_NMeas << endl;
  #endif
  Array<double, 1> D_A1_Weights(I_NMeas);
  if (I_NMeas > 1){
    D_A1_Weights = 1. / pow2(*P_D_A1_MeasureErrors);
  }
  else{
    D_A1_Weights = 0.;
  }
  #ifdef __DEBUG_FITS_GAUSSFIT__
    cout << "CFits::GaussFit: D_A1_Weights = " << D_A1_Weights << endl;
  #endif

///    yfit = CURVEFIT(x,y,weights,a,sigma, $
///        CHISQ=chisq, YERROR=yerror, $
///        FUNCTION_NAME = "GAUSS_FUNCT") ;call curvefit
  Array<CString, 1> CS_A1_ArgsCurveFit(4);
  void **PP_ArgsCurveFit = (void**)malloc(sizeof(void*) * 4);
  CS_A1_ArgsCurveFit(0).Set("YFIT");
  PP_ArgsCurveFit[0] = P_D_A1_YFit;
  CS_A1_ArgsCurveFit(1).Set("CHISQ");
  PP_ArgsCurveFit[1] = P_D_ChiSq;
  CS_A1_ArgsCurveFit(2).Set("YERROR");
  PP_ArgsCurveFit[2] = &D_YError;
  CS_A1_ArgsCurveFit(3).Set("FUNCTION_NAME");
  CString CS_FunctionName("GaussFunct");
  PP_ArgsCurveFit[3] = &CS_FunctionName;
  if (!this->CurveFit(D_A1_X, D_A1_Y, D_A1_Weights, D_A1_A, *P_D_A1_Sigma, CS_A1_ArgsCurveFit, PP_ArgsCurveFit)){///22,734
    #ifdef __DEBUG_FITS_GAUSSFIT__
      cout << "CFits::GaussFit: ERROR: CurveFit returned FALSE" << endl;
    #endif

    if (B_NeedToDelete_P_D_A1_Sigma)
      delete(P_D_A1_Sigma);
    if (B_NeedToDelete_P_D_A1_YFit)
      delete(P_D_A1_YFit);
    if (B_NeedToDelete_P_D_A1_Estimates)
      delete(P_D_A1_Estimates);
    if (B_NeedToDelete_P_D_ChiSq)
      delete(P_D_ChiSq);
    if (B_NeedToDelete_P_D_A1_MeasureErrors)
      delete(P_D_A1_MeasureErrors);
    delete(P_D_A1_PolyFitOut);
    free(PP_ArgsPolyFit);
    free(PP_ArgsCurveFit);

    return false;
  }
  #ifdef __DEBUG_FITS_GAUSSFIT__
    cout << "CFits::GaussFit: After CurveFit: P_D_A1_YFit = " << *P_D_A1_YFit << endl;
    cout << "CFits::GaussFit: After CurveFit: P_D_ChiSq = " << *P_D_ChiSq << endl;
    cout << "CFits::GaussFit: After CurveFit: P_D_YError = " << D_YError << endl;
    cout << "CFits::GaussFit: After CurveFit: D_A1_A = " << D_A1_A << endl;
    cout << "CFits::GaussFit: After CurveFit: P_D_A1_Sigma = " << *P_D_A1_Sigma << endl;
  #endif
///    return, yfit

  if (B_NeedToDelete_P_D_A1_Sigma)
    delete(P_D_A1_Sigma);
  if (B_NeedToDelete_P_D_A1_YFit)
    delete(P_D_A1_YFit);
  if (B_NeedToDelete_P_D_A1_Estimates)
    delete(P_D_A1_Estimates);
  if (B_NeedToDelete_P_D_ChiSq)
    delete(P_D_ChiSq);
  if (B_NeedToDelete_P_D_A1_MeasureErrors)
    delete(P_D_A1_MeasureErrors);
  delete(P_D_A1_PolyFitOut);
  free(PP_ArgsPolyFit);
  free(PP_ArgsCurveFit);

  return true;
}

/** **************************************************/

bool CFits::GaussFit(const Array<double, 1> &D_A1_X,
                     const Array<double, 1> &D_A1_Y,
                     Array<double,1> &D_A1_A) const{
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args = CString(" ");
  CS_A1_Args(0).Set("FUNCTION_NAME");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  return this->GaussFit(D_A1_X, D_A1_Y, D_A1_A, CS_A1_Args, PP_Args);
}

/** **************************************************/

bool CFits::CurveFit(const Array<double, 1> &D_A1_X,
                     const Array<double, 1> &D_A1_Y,
                     const Array<double, 1> &D_A1_WeightsIn,
                     Array<double, 1> &D_A1_A,
                     Array<double, 1> &D_A1_Sigma,
                     const Array<CString, 1> &CS_A1_ArgsIn,
                     void* PP_ArgsIn[]) const{
  /**
  FUNCTION CURVEFIT, x, y, weightsIn, a, sigma, FUNCTION_NAME = Function_Name, $
  FITA=fita, $
  ITMAX=itmax, ITER=iter, TOL=tol, CHI2=chi2, $
  NODERIVATIVE=noderivative:in, CHISQ=chisq:out, $
  YERROR=yerror, $
  STATUS=status
  **/

  int I_Pos;
  int I_Status;
  CString CS_Comp("FUNCTION_NAME");
  CString CS_Function_In(" ");
  Array<double, 1> D_A1_B(D_A1_A.size());

///  ;Name of function to fit
///  IF n_elements(function_name) LE 0 THEN function_name = "FUNCT"
  //CS_Comp = CString("FUNCTION_NAME");
  I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
  if (I_Pos >= 0){
    CS_Function_In = *(CString*)(PP_ArgsIn[I_Pos]);
#ifdef __DEBUG_FITS_CURVEFIT__
    cout << "CFits::CurveFit: KeyWord_Set(FUNCTION_NAME): CS_Function_In = " << CS_Function_In << endl;
#endif
  }
  else{
    CS_Function_In = CString("Funct");
#ifdef __DEBUG_FITS_CURVEFIT__
    cout << "CFits::CurveFit: !KeyWord_Set(FUNCTION_NAME): CS_Function_In = " << CS_Function_In << endl;
#endif
  }

///  if ARG_PRESENT(status) then $
///  status = 0   ; Assume success
//  bool B_NeedToDelete_P_I_Status = false;
  CS_Comp = CString("STATUS");
  I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
  if (I_Pos >= 0)
    I_Status = *(int*)(PP_ArgsIn[I_Pos]);
  I_Status = 0;
///  IF n_elements(tol) EQ 0 THEN tol = double ? 1d-3 : 1e-3  ;Convergence tol

  double D_Tol;
  CS_Comp = CString("TOL");
  I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
  if (I_Pos >= 0)
    D_Tol = *(double*)(PP_ArgsIn[I_Pos]);
  else{
    D_Tol = 0.001;
  }

  double D_YError;
  CS_Comp = CString("YERROR");
  I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
  if (I_Pos >= 0)
    D_YError = *(double*)(PP_ArgsIn[I_Pos]);
  else{
    D_YError = 0.0;
  }

///  IF n_elements(itmax) EQ 0 THEN itmax = 20     ;Maximum # iterations
  int I_ItMax;
  CS_Comp = CString("ITMAX");
  I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
  if (I_Pos >= 0)
    I_ItMax = *(int*)(PP_ArgsIn[I_Pos]);
  else{
    I_ItMax = 30;
  }

  double D_ChiSqr;
  CS_Comp = CString("CHISQ");
  I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
  if (I_Pos >= 0)
    D_ChiSqr = *(double*)(PP_ArgsIn[I_Pos]);
  else{
    D_ChiSqr = 0.;
  }

///  ; IF we will be estimating partial derivatives THEN compute machine
///  ; precision

///  IF keyword_set(NODERIVATIVE) THEN BEGIN
///  res = machar(DOUBLE=double)
///  eps = sqrt(res.eps)
///  ENDIF
  double D_Eps = 2.2204460*pow(10.,-16);

///  ;  Handle fixed parameters
///  nterms = N_ELEMENTS(a)         ; # of parameters
///  if (N_ELEMENTS(fita) ne nterms) then $
///  fita = REPLICATE(1, nterms)
///  iparam = WHERE(fita, nparam)
///  if (nparam eq 0) then $
///  MESSAGE, 'FITA must contain at least one parameter to fit.'
  int I_NTerms = D_A1_A.size();
  Array<int, 1> *P_I_A1_FitA;
  bool B_NeedToDelete_P_I_A1_FitA = false;
  CS_Comp = CString("FITA");
  I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
  if (I_Pos >= 0){
    P_I_A1_FitA = (Array<int, 1>*)(PP_ArgsIn[I_Pos]);
    if (P_I_A1_FitA->size() != I_NTerms){
      delete(P_I_A1_FitA);
      P_I_A1_FitA = this->Replicate(1, I_NTerms);
      B_NeedToDelete_P_I_A1_FitA = true;
    }
  }
  else{
    P_I_A1_FitA = this->Replicate(1, I_NTerms);
    B_NeedToDelete_P_I_A1_FitA = true;
  }

  Array<int, 1> I_A1_TempC(P_I_A1_FitA->size());
  I_A1_TempC = where(*P_I_A1_FitA != 0, 1, 0);
  int I_NParam;
  Array<int, 1> *P_I_A1_IParam = this->GetIndex(I_A1_TempC, I_NParam);
  if (I_NParam == 0){
    cout << "CFits::CurveFit: ERROR: FITA must contain at least one parameter to fit" << endl;

    if (B_NeedToDelete_P_I_A1_FitA)
      delete(P_I_A1_FitA);
    delete(P_I_A1_IParam);

    return false;
  }
#ifdef __DEBUG_FITS_CURVEFIT__
  cout << "CFits::CurveFit: P_I_A1_IParam = " << *P_I_A1_IParam << endl;
#endif

///  nY = n_elements(y)
///  nfree = nY - nparam ; Degrees of freedom
  int I_NY = D_A1_Y.size();
  int I_NFree = I_NY - I_NParam;
#ifdef __DEBUG_FITS_CURVEFIT__
  cout << "CFits::CurveFit: I_NY = " << I_NY << endl;
  cout << "CFits::CurveFit: I_NFree = " << I_NFree << endl;
  cout << "CFits::CurveFit: I_NTerms = " << I_NTerms << endl;
#endif

///  IF nfree LE 0 THEN MESSAGE, $
///  'Number of parameters in A must be less than number of dependent values in Y.'
  if (I_NFree <= 0){
    cout << "CFits::CurveFit: ERROR: Number of parameters in A must be less than number of dependent values in Y." << endl;
    cout << "CFits::CurveFit: D_A1_X = " << D_A1_X << endl;
    cout << "CFits::CurveFit: D_A1_Y = " << D_A1_Y << endl;
    cout << "CFits::CurveFit: D_A1_A = " << D_A1_A << endl;

    if (B_NeedToDelete_P_I_A1_FitA)
      delete(P_I_A1_FitA);
    delete(P_I_A1_IParam);

    return false;
  }

///  IF (nterms EQ 1) THEN a = a[0]   ; Ensure a is a scalar
  if (I_NTerms == 1)
    D_A1_A.resizeAndPreserve(1);

///  flambda = double ? 0.001d : 0.001                   ;Initial lambda
  double D_FLambda = 0.001;

///  diag = LINDGEN(nparam)*(nparam + 1) ; Subscripts of diagonal elements
  Vector<int> *P_I_V_Diag = this->IndGen(I_NParam);
  *P_I_V_Diag *= I_NParam + 1;
  Array<int, 1> I_A1_Diag(P_I_V_Diag->length());
  for (int m = 0; m < I_A1_Diag.size(); m++)
    I_A1_Diag(m) = (*P_I_V_Diag)(m);
#ifdef __DEBUG_FITS_CURVEFIT__
  cout << "CFits::CurveFit: I_A1_Diag = " << I_A1_Diag << endl;
#endif
  delete(P_I_V_Diag);

///  sigma = double ? DBLARR(nterms) : FLTARR(nterms)
  D_A1_Sigma.resize(I_NTerms);
  D_A1_Sigma = 0.;

///  ;      Define the partial derivative array
///  pder = double ? dblarr(nY, nterms) : fltarr(nY, nterms)
  Array<double, 2> D_A2_PDer(I_NY, I_NTerms);
  D_A2_PDer = 0.;

///  noWeighting = N_ELEMENTS(weightsIn) eq 0
///  weights = noWeighting ? REPLICATE(1.0, nY) : weightsIn
  bool B_NoWeighting = false;
  if (D_A1_WeightsIn.size() == 1 && D_A1_WeightsIn(0) == 0.)
    B_NoWeighting = true;
  Array<double, 1> D_A1_Weights(I_NY);
  Array<double, 1> *P_D_A1_Rep = this->Replicate(1., I_NY);
  if (B_NoWeighting)
    D_A1_Weights = *P_D_A1_Rep;
  else
    D_A1_Weights = D_A1_WeightsIn;
  delete(P_D_A1_Rep);
#ifdef __DEBUG_FITS_CURVEFIT__
  cout << "CFits::CurveFit: D_A1_Weights = " << D_A1_Weights << endl;
#endif

  bool B_Done = false;
  bool B_DoneEarly = false;

  Array<double, 1> D_A1_ArrayDiag(1);
  Array<double, 1>* P_D_A1_YFit;
  Array<double, 1> D_A1_YFit1(D_A1_X.size());
  Array<double, 1> D_A1_P(D_A1_A.size());
  Array<double, 1> *P_D_A1_TempE;
  Array<double, 1> D_A1_TempA(D_A2_PDer.cols());
  Array<double, 1> D_A1_Beta(1);
  Array<double, 1> D_A1_TempB(D_A1_Y.size());
  Array<double, 1> *P_D_A1_TempF;
  Array<double, 1> D_A1_Temp(D_A1_Y.size());
  Array<double, 1> *P_D_A1_TempC;
  Array<double, 1> *P_D_A1_TempD;
  Array<double, 2> *P_D_A2_TempA;
  Array<double, 2> D_A2_TempB(1,1);
  Array<double, 2> *P_D_A2_TempC;
  Array<double, 2> D_A2_Alpha(1,1);
  Array<double, 1> D_A1_Sigma1(1);
  Array<double, 1> D_A1_AlphaDiag(1);
  Array<double, 1> D_A1_SigmaIParam(1);
  Array<double, 1> D_A1_C(1);
  Array<double, 2> *P_D_A2_C;
  Array<double, 2> D_A2_Array(1,1);
  Array<int, 2> I_A2_Diag(1,1);
  Array<int, 2> I_A2_IndDiag(1,1);
  Array<double, 2> D_A2_ArrayTemp(1,1);
  Array<double, 2>* P_D_A2_ArrayTemp;
  Array<double, 1> D_A1_AIParam(2);
  Array<double, 1> D_A1_BIParam(1);
  Array<double, 2> D_A2_Temp(1,1);
  Array<double, 1> *P_D_A1_MTV;
  Array<double, 1> D_A1_TempPDer;
  Array<double, 2> D_A2_TempPDer(1,1);
  double D_Inc;
  double D_Chisq1;
  double d_temp;

  bool B_NeedToDelete_P_D_A1_YFit = false;
  CS_Comp = CString("YFIT");
  I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
  if (I_Pos >= 0)
    P_D_A1_YFit = (Array<double, 1>*)(PP_ArgsIn[I_Pos]);
  else{
    P_D_A1_YFit = new Array<double, 1>(D_A1_X.size());
    bool B_NeedToDelete_P_D_A1_YFit = true;
  }
///  FOR iter = 1, itmax DO BEGIN      ; Iteration loop
  int iter = 0;
  for (iter=1; iter <= I_ItMax; iter++){
    if (!B_Done && !B_DoneEarly){
///  ;         Evaluate alpha and beta matricies.

///  IF keyword_set(NODERIVATIVE) THEN BEGIN
      CS_Comp = CString("NODERIVATIVE");
      I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
      if (I_Pos >= 0){
///  ;            Evaluate function and estimate partial derivatives
///  CALL_PROCEDURE, Function_name, x, a, yfit
        if (CS_Function_In.EqualValue(CString("Funct"))){
          if (!this->Funct(D_A1_X, D_A1_A, *P_D_A1_YFit)){
            cout << "CFits::CurveFit: ERROR: Funct returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
        }
        else if (CS_Function_In.EqualValue(CString("GaussFunct"))){
          #ifdef __DEBUG_FITS_CURVEFIT__
            cout << "CFits::CurveFit: 1. Calling GaussFunct: D_A1_X = " << D_A1_X << ", D_A1_A = " << D_A1_A << endl;
          #endif
          if (!this->GaussFunct(D_A1_X, D_A1_A, *P_D_A1_YFit)){
            cout << "CFits::CurveFit: ERROR: GaussFunct returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
          #ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: GaussFunct returned TRUE" << endl;
          #endif
        }
///  IF (N_ELEMENTS(yfit) NE nY) THEN MESSAGE, error_msg1
        if (P_D_A1_YFit->size() != I_NY){
          cout << "CFits::CurveFit: ERROR: Result F from " << CS_Function_In << " must have same number of elements as Y." << endl;

          if (B_NeedToDelete_P_I_A1_FitA)
            delete(P_I_A1_FitA);
          if (B_NeedToDelete_P_D_A1_YFit)
            delete(P_D_A1_YFit);
          delete(P_I_A1_IParam);

          return false;
        }

///  FOR term=0, nterms-1 DO BEGIN
        for (int term=0; term < I_NTerms; term++){
///  p = a       ; Copy current parameters
          D_A1_P = D_A1_A;

///  ; Increment size for forward difference derivative
///  inc = eps * abs(p[term])
          D_Inc = D_Eps * fabs(D_A1_P(term));

///  IF (inc EQ 0.) THEN inc = eps
          if (D_Inc == 0.)
            D_Inc = D_Eps;

///  p[term] = p[term] + inc
          D_A1_P(term) = D_A1_P(term) + D_Inc;

///  CALL_PROCEDURE, function_name, x, p, yfit1
          if (CS_Function_In.EqualValue(CString("Funct"))){
            if (!this->Funct(D_A1_X, D_A1_P, D_A1_YFit1)){
              cout << "CFits::CurveFit: ERROR: Funct returned FALSE" << endl;

              if (B_NeedToDelete_P_I_A1_FitA)
                delete(P_I_A1_FitA);
              if (B_NeedToDelete_P_D_A1_YFit)
                delete(P_D_A1_YFit);
              delete(P_I_A1_IParam);

              return false;
            }
          }
          else if (CS_Function_In.EqualValue(CString("GaussFunct"))){
            #ifdef __DEBUG_FITS_CURVEFIT__
              cout << "CFits::CurveFit: 2. Calling GaussFunct: D_A1_X = " << D_A1_X << ", D_A1_P = " << D_A1_P << endl;
            #endif
            if (!this->GaussFunct(D_A1_X, D_A1_P, D_A1_YFit1)){
              cout << "CFits::CurveFit: ERROR: GaussFunct returned FALSE" << endl;

              if (B_NeedToDelete_P_I_A1_FitA)
                delete(P_I_A1_FitA);
              if (B_NeedToDelete_P_D_A1_YFit)
                delete(P_D_A1_YFit);
              delete(P_I_A1_IParam);

              return false;
            }
          }

///  pder[0,term] = (yfit1-yfit)/inc
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: P_D_A1_YFit->size() = " << P_D_A1_YFit->size() << endl;
          cout << "CFits::CurveFit: D_A1_YFit1.size() = " << D_A1_YFit1.size() << endl;
#endif
//        if (P_D_A1_YFit->size() > 1)
//          return false;/// REMOVE when tested
        /// if D_A1_YFit.size() > 1, IDL is setting all D_A1_YFit.size() elements starting at (0,term)
          D_A2_PDer(0,Range(term, term + P_D_A1_YFit->size()-1)) = (D_A1_YFit1 - (*P_D_A1_YFit)) / D_Inc;
///  ENDFOR
        }
///  ENDIF ELSE BEGIN
      }
      else{
/**  ; The user's procedure will return partial derivatives
  call_procedure, function_name, x, a, yfit, pder
  IF (N_ELEMENTS(yfit) NE nY) THEN MESSAGE, error_msg1

  ENDELSE**/
        CS_Comp = CString("Funct");
        if (CS_Function_In.EqualValue(CS_Comp)){
          if (!this->Funct(D_A1_X, D_A1_A, *P_D_A1_YFit, D_A2_PDer)){
            cout << "CFits::CurveFit: ERROR: Funct returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: After Funct: D_A2_PDer = " << D_A2_PDer << endl;
#endif
        }
        CS_Comp = CString("GaussFunct");
        if (CS_Function_In.EqualValue(CS_Comp)){
          #ifdef __DEBUG_FITS_CURVEFIT__
            cout << "CFits::CurveFit: 3. Calling GaussFunct: D_A1_X = " << D_A1_X << ", D_A1_A = " << D_A1_A << endl;
          #endif
          if (!this->GaussFunct(D_A1_X, D_A1_A, *P_D_A1_YFit, D_A2_PDer)){
            cout << "CFits::CurveFit: ERROR: GaussFunct returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: After GaussFunct: D_A2_PDer = " << D_A2_PDer << endl;
#endif
        }
        if (P_D_A1_YFit->size() != I_NY){
          cout << "CFits::CurveFit: ERROR: P_D_A1_YFit->size(=" << P_D_A1_YFit->size() << ") != I_NY(=" << I_NY << ")" << endl;

          if (B_NeedToDelete_P_I_A1_FitA)
            delete(P_I_A1_FitA);
          if (B_NeedToDelete_P_D_A1_YFit)
            delete(P_D_A1_YFit);
          delete(P_I_A1_IParam);

          return false;
        }
      }

///  IF nterms EQ 1 THEN pder = reform(pder, n_elements(y), 1)
      if (I_NTerms == 1){
        P_D_A1_TempE = this->Reform(D_A2_PDer);
        D_A2_PDer.resize(P_D_A1_TempE->size(), 1);
        D_A2_PDer(Range::all(), 0) = (*P_D_A1_TempE);
        delete(P_D_A1_TempE);
      }
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A2_PDer = " << D_A2_PDer << endl;
#endif

///  IF (NOT ARRAY_EQUAL(SIZE(pder,/DIM),[nY,nterms])) THEN $
///  MESSAGE, error_msg2
      if (D_A2_PDer.rows() != I_NY || D_A2_PDer.cols() != I_NTerms){
        cout << "PDER from " << CS_Function_In << " must be of size N_ELEMENTS(Y) by N_ELEMENTS(A)." << endl;

        if (B_NeedToDelete_P_I_A1_FitA)
          delete(P_I_A1_FitA);
        if (B_NeedToDelete_P_D_A1_YFit)
          delete(P_D_A1_YFit);
        delete(P_I_A1_IParam);

        return false;
      }

///  beta = (nparam eq 1) ? [TOTAL((y-yfit)*Weights*pder[*,iparam])] : $
///  (y-yfit)*Weights # pder[*,iparam]
      D_A2_TempPDer.resize(D_A2_PDer.rows(), P_I_A1_IParam->size());
      for (int m = 0; m < D_A2_PDer.rows(); m++){
        D_A1_TempA.resize(D_A2_PDer.cols());
        D_A1_TempA = D_A2_PDer(m, Range::all());
        if (!this->GetSubArrCopy(D_A1_TempA,
                                 *P_I_A1_IParam,
                                 D_A1_TempPDer)){
          cout << "CFits::CurveFit: ERROR: this->GetSubArrCopy(D_A2_PDer(Range::all, m), P_I_A1_IParam, D_A1_TempPDer) returned FALSE." << endl;

          if (B_NeedToDelete_P_I_A1_FitA)
            delete(P_I_A1_FitA);
          if (B_NeedToDelete_P_D_A1_YFit)
            delete(P_D_A1_YFit);
          delete(P_I_A1_IParam);

          return false;
        }
        D_A2_TempPDer(m, Range::all()) = D_A1_TempPDer;
      }
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A2_TempPDer = " << D_A2_TempPDer << endl;
#endif
      if (I_NParam == 1){
        D_A1_TempB = D_A1_Y - (*P_D_A1_YFit);
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: D_A1_TempB = " << D_A1_TempB << endl;
#endif
        D_A1_TempB *= D_A1_Weights;
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: D_A1_TempB = " << D_A1_TempB << endl;
#endif
        P_D_A1_TempF = this->VecArrTimesMatrix(D_A1_TempB, D_A2_TempPDer);
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: P_D_A1_TempF = " << *P_D_A1_TempF << endl;
#endif
        D_A1_Beta = sum(*P_D_A1_TempF);
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: D_A1_Beta = " << D_A1_Beta << endl;
#endif
        delete(P_D_A1_TempF);
      }
      else{
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: D_A1_Y = " << D_A1_Y << endl;
        cout << "CFits::CurveFit: P_D_A1_YFit = " << *P_D_A1_YFit << endl;
        cout << "CFits::CurveFit: D_A1_Weights = " << D_A1_Weights << endl;
#endif
        D_A1_Temp = (D_A1_Y - (*P_D_A1_YFit)) * D_A1_Weights;
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: D_A1_Temp = " << D_A1_Temp << endl;
#endif
        P_D_A1_TempC = VecArrTimesMatrix(D_A1_Temp, D_A2_TempPDer);
//      Array<double, 1> *P_D_A1_TempC = MatrixTimesVecArr(D_A2_TempPDer, D_A1_Temp);
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: P_D_A1_TempC = " << *P_D_A1_TempC << endl;
#endif
        D_A1_Beta.resize(P_D_A1_TempC->size());
        D_A1_Beta = (*P_D_A1_TempC);
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: D_A1_Beta = " << D_A1_Beta << endl;
#endif
        delete(P_D_A1_TempC);
      }

///  alpha = TRANSPOSE(pder[*,iparam]) # $
///  ((Weights # (FLTARR(nparam)+1))*pder)
      P_D_A1_TempD = this->Replicate(1., I_NParam);
      P_D_A2_TempA = this->VecArrACrossB(*P_D_A1_TempD, D_A1_Weights);
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: *P_D_A2_TempA = " << *P_D_A2_TempA << endl;
      cout << "CFits::CurveFit: D_A2_PDer = " << D_A2_PDer << endl;
#endif
      D_A2_TempB.resize(D_A2_PDer.cols(), D_A2_PDer.rows());
      D_A2_TempB = D_A2_PDer.transpose(secondDim, firstDim);
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A2_TempB = " << D_A2_TempB << endl;
#endif
      *P_D_A2_TempA *= D_A2_TempB;
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: *P_D_A2_TempA = " << *P_D_A2_TempA << endl;
#endif
//      P_D_A2_TempC->resize(P_D_A2_TempA->rows(), D_A2_PDer.cols());
      P_D_A2_TempC = this->MatrixBTimesA(D_A2_PDer, *P_D_A2_TempA);
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: *P_D_A2_TempC = " << *P_D_A2_TempC << endl;
#endif
      D_A2_Alpha.resize(P_D_A2_TempC->rows(), P_D_A2_TempC->cols());
      D_A2_Alpha = (*P_D_A2_TempC);
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A2_Alpha = " << D_A2_Alpha << endl;
#endif
      delete(P_D_A1_TempD);
      delete(P_D_A2_TempA);
      D_A2_TempB.resize(0);
      delete(P_D_A2_TempC);

///  ; save current values of return parameters
///  sigma1 = sqrt( 1.0 / alpha[diag] )           ; Current sigma.
      D_A1_Sigma1.resize(I_A1_Diag.size());
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A2_Alpha = " << D_A2_Alpha << endl;
      cout << "CFits::CurveFit: I_A1_Diag = " << I_A1_Diag << endl;
#endif
      if (!this->GetSubArrCopy(D_A2_Alpha,
                               I_A1_Diag,
                               0,
                               D_A1_AlphaDiag)){
        cout << "CFits::CurveFit: ERROR: GetSubArrCopy returned FALSE." << endl;

        if (B_NeedToDelete_P_I_A1_FitA)
          delete(P_I_A1_FitA);
        if (B_NeedToDelete_P_D_A1_YFit)
          delete(P_D_A1_YFit);
        delete(P_I_A1_IParam);

        return false;
      }
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A1_AlphaDiag = " << D_A1_AlphaDiag << endl;
#endif
      D_A1_Sigma1 = sqrt(1.0 / D_A1_AlphaDiag);
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A1_Sigma1 = " << D_A1_Sigma1 << endl;
#endif

///  sigma[iparam]  = sigma1
      if (!this->GetSubArrCopy(D_A1_Sigma,
                               *P_I_A1_IParam,
                               D_A1_SigmaIParam)){
        cout << "CFits::CurveFit: ERROR: GetSubArrCopy(D_A1_Sigma, *P_I_A1_IParam, D_A1_SigmaIParam) returned FALSE" << endl;

        if (B_NeedToDelete_P_I_A1_FitA)
          delete(P_I_A1_FitA);
        if (B_NeedToDelete_P_D_A1_YFit)
          delete(P_D_A1_YFit);
        delete(P_I_A1_IParam);

        return false;
      }
      D_A1_SigmaIParam = D_A1_Sigma1;
      if (!this->Set_SubArray(D_A1_Sigma, *P_I_A1_IParam, D_A1_SigmaIParam)){
        cout << "CFits::CurveFit: ERROR: Set_SubArray(D_A1_Sigma, *P_I_A1_IParam, D_A1_SigmaIParam) returned FALSE" << endl;

        if (B_NeedToDelete_P_I_A1_FitA)
          delete(P_I_A1_FitA);
        if (B_NeedToDelete_P_D_A1_YFit)
          delete(P_D_A1_YFit);
        delete(P_I_A1_IParam);

        return false;
      }
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A1_SigmaIParam = " << D_A1_SigmaIParam << endl;
#endif

///  chisq1 = total(Weights*(y-yfit)^2)/nfree     ; Current chi squared.
      D_Chisq1 = sum(D_A1_Weights * pow2(D_A1_Y - (*P_D_A1_YFit))) / I_NFree;
///  chisq = chisq1
      D_ChiSqr = D_Chisq1;
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_ChiSqr = " << D_ChiSqr << endl;
#endif

///  yfit1 = yfit
      D_A1_YFit1.resize(P_D_A1_YFit->size());
      D_A1_YFit1 = (*P_D_A1_YFit);
#ifdef __DEBUG_FITS_CURVEFIT__
      cout << "CFits::CurveFit: D_A1_YFit1 = " << D_A1_YFit1 << endl;
#endif

///  done_early = chisq1 LT total(abs(y))/1d7/nfree
      B_DoneEarly = D_Chisq1 < (sum(fabs(D_A1_Y)) / 10000000. / I_NFree);
#ifdef __DEBUG_FITS_CURVEFIT__
      if (B_DoneEarly){
        cout << "CFits::CurveFit: B_DoneEarly = TRUE" << endl;

        if (B_NeedToDelete_P_I_A1_FitA)
          delete(P_I_A1_FitA);
        if (B_NeedToDelete_P_D_A1_YFit)
          delete(P_D_A1_YFit);
        delete(P_I_A1_IParam);

        return false;
      }
      else
        cout << "CFits::CurveFit: B_DoneEarly = FALSE" << endl;
#endif

///  IF done_early THEN GOTO, done
      if (!B_DoneEarly){
///  c = sqrt(alpha[diag])
///  c = c # c
        D_A1_C.resize(D_A1_AlphaDiag.size());
        D_A1_C = sqrt(D_A1_AlphaDiag);
        P_D_A2_C = this->VecArrACrossB(D_A1_C, D_A1_C);
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: P_D_A2_C = " << *P_D_A2_C << endl;
#endif

///  lambdaCount = 0
        int I_LambdaCount = 0;

///  REPEAT BEGIN
        D_A2_Array.resize(D_A2_Alpha.rows(), D_A2_Alpha.cols());
        do{
///  lambdaCount = lambdaCount + 1
          I_LambdaCount++;

///  ; Normalize alpha to have unit diagonal.
///  array = alpha / c
          D_A2_Array = D_A2_Alpha / (*P_D_A2_C);
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: 1. D_A2_Array = " << D_A2_Array << endl;
#endif

///  ; Augment the diagonal.
///  array[diag] = array[diag]*(1.+flambda)
          if (!this->GetSubArrCopy(D_A2_Array,
                                   I_A1_Diag,
                                   0,
                                   D_A1_ArrayDiag)){
            cout << "CFits::CurveFit: ERROR: GetSubArrCopy(D_A2_Array, I_A1_Diag, 0, D_A1_ArrayDiag) returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
          D_A1_ArrayDiag = D_A1_ArrayDiag * (1. + D_FLambda);
          if (!this->A1ToA2(I_A1_Diag, D_A2_Array.rows(), D_A2_Array.cols(), I_A2_Diag, 0)){
            cout << "CFits::CurveFit: ERROR: A1ToA2 returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
          I_A2_IndDiag.resize(I_A1_Diag.size(),4);
          I_A2_IndDiag(Range::all(), 0) = I_A2_Diag(Range::all(),0);
          I_A2_IndDiag(Range::all(), 1) = I_A2_Diag(Range::all(),1);
//      for (int lll=0; lll < I_A1_Diag.size(); lll++){
//        I_A2_IndDiag(lll,2) = lll;
//        I_A2_IndDiag(lll,3) = 0;
//      }

          if (!this->Set_SubArray(D_A2_Array, I_A2_IndDiag, D_A1_ArrayDiag)){
            cout << "CFits::CurveFit: ERROR: Set_SubArray(D_A2_Array, I_A3_Diag, D_A1_ArrayDiag) returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: D_A1_ArrayDiag = " << D_A1_ArrayDiag << endl;
          cout << "CFits::CurveFit: 2. D_A2_Array = " << D_A2_Array << endl;
//      return false;
#endif

///  ; Invert modified curvature matrix to find new parameters.
///  IF n_elements(array) EQ 1 THEN array = (1.0 / array) $
///  ELSE array = invert(array)
          if (D_A2_Array.size() == 1)
            D_A2_Array = 1. / D_A2_Array;
          else{
            D_A2_ArrayTemp.resize(D_A2_Array.rows(), D_A2_Array.cols());
            D_A2_ArrayTemp = D_A2_Array;
            if (!this->InvertGaussJ(D_A2_Array)){
              cout << "CFits::CurveFit: ERROR: this->InvertGaussJ(D_A2_Array) returned false." << endl;

              if (B_NeedToDelete_P_I_A1_FitA)
                delete(P_I_A1_FitA);
              if (B_NeedToDelete_P_D_A1_YFit)
                delete(P_D_A1_YFit);
              delete(P_I_A1_IParam);

              return false;
            }
            P_D_A2_ArrayTemp = this->MatrixATimesB(D_A2_ArrayTemp, D_A2_Array);
#ifdef __DEBUG_FITS_CURVEFIT__
            cout << "CFits::CurveFit: P_D_A2_ArrayTemp = " << *P_D_A2_ArrayTemp << endl;
#endif
            delete(P_D_A2_ArrayTemp);
            P_D_A2_ArrayTemp = this->MatrixBTimesA(D_A2_ArrayTemp, D_A2_Array);
#ifdef __DEBUG_FITS_CURVEFIT__
            cout << "CFits::CurveFit: P_D_A2_ArrayTemp = " << *P_D_A2_ArrayTemp << endl;
#endif
            delete(P_D_A2_ArrayTemp);
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: 3. D_A2_Array = " << D_A2_Array << endl;
#endif
///  b = a
          D_A1_B = D_A1_A;
///  b[iparam] = a[iparam] + (array/c) # transpose(beta) ; New params
          if (!this->GetSubArrCopy(D_A1_A,
                                   *P_I_A1_IParam,
                                   D_A1_AIParam)){
            cout << "CFits::CurveFit: ERROR: GetSubArrCopy(D_A1_A, *P_I_A1_IParam, D_A1_AIParam) returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: D_A1_AIParam = " << D_A1_AIParam << endl;
//      double d_temp2 = D_A1_AIParam(0);
//      D_A1_AIParam(0) = 2. * d_temp2 + 2.;
//        cout << "CFits::CurveFit: D_A1_AIParam(0) = " << D_A1_AIParam(0) << endl;
//        cout << "CFits::CurveFit: D_A1_A((*P_I_A1_IParam)(0)) = " << D_A1_A((*P_I_A1_IParam)(0)) << endl;
//      D_A1_AIParam(0) = d_temp2;
//      return false;
#endif
          if (!this->GetSubArrCopy(D_A1_B,
                                   *P_I_A1_IParam,
                                   D_A1_BIParam)){
            cout << "CFits::CurveFit: ERROR: GetSubArrCopy(D_A1_B, *P_I_A1_IParam, D_A1_BIParam) returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          d_temp = D_A1_BIParam(0);
          D_A1_BIParam(0) = -100.;
          cout << "D_A1_BIParam(0) = " << D_A1_BIParam(0) << endl;
          cout << "D_A1_B((*P_I_A1_IParam)(0)) = " << D_A1_B((*P_I_A1_IParam)(0)) << endl;
          D_A1_BIParam(0) = d_temp;
#endif
          D_A2_Temp.resize(D_A2_Array.rows(), D_A2_Array.cols());
          D_A2_Temp = (D_A2_Array / (*P_D_A2_C));
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: D_A2_Temp = " << D_A2_Temp << endl;
#endif
          P_D_A1_MTV = this->MatrixTimesVecArr(D_A2_Temp, D_A1_Beta);
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: P_D_A1_MTV = " << *P_D_A1_MTV << endl;
#endif
          if (D_A1_AIParam.size() != P_D_A1_MTV->size()){
            cout << "CFits::CurveFit: ERROR: D_A1_AIParam.size() = " << D_A1_AIParam.size() << " != P_D_A1_MTV->size() = " << P_D_A1_MTV->size() << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
          D_A1_BIParam = D_A1_AIParam + (*P_D_A1_MTV);
          delete(P_D_A1_MTV);
          if (!this->Set_SubArray(D_A1_B, *P_I_A1_IParam, D_A1_BIParam)){
            cout << "CFits::CurveFit: ERROR: Set_SubArray(D_A1_B, *P_I_A1_IParam, D_A1_B) returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: D_A1_BIParam = " << D_A1_BIParam << endl;
          cout << "CFits::CurveFit: D_A1_B = " << D_A1_B << endl;
#endif

///  IF (nterms EQ 1) THEN b = b[0]             ; Ensure b is a scalar

///  call_procedure, function_name, x, b, yfit  ; Evaluate function
          if (CS_Function_In.EqualValue(CString("Funct"))){
            if (!this->Funct(D_A1_X, D_A1_B, *P_D_A1_YFit)){
              cout << "CFits::CurveFit: ERROR: Funct returned FALSE" << endl;

              if (B_NeedToDelete_P_I_A1_FitA)
                delete(P_I_A1_FitA);
              if (B_NeedToDelete_P_D_A1_YFit)
                delete(P_D_A1_YFit);
              delete(P_I_A1_IParam);

              return false;
            }
          }
          else if (CS_Function_In.EqualValue(CString("GaussFunct"))){
            #ifdef __DEBUG_FITS_CURVEFIT__
              cout << "CFits::CurveFit: 4. Calling GaussFunct: D_A1_X = " << D_A1_X << ", D_A1_B = " << D_A1_B << endl;
            #endif
            if (!this->GaussFunct(D_A1_X, D_A1_B, *P_D_A1_YFit)){
              cout << "CFits::CurveFit: ERROR: GaussFunct returned FALSE" << endl;

              if (B_NeedToDelete_P_I_A1_FitA)
                delete(P_I_A1_FitA);
              if (B_NeedToDelete_P_D_A1_YFit)
                delete(P_D_A1_YFit);
              delete(P_I_A1_IParam);

              return false;
            }
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: After GaussFunct: P_D_A1_YFit = " << *P_D_A1_YFit << endl;
#endif

///  chisq = total(Weights*(y-yfit)^2)/nfree    ; New chisq
          D_ChiSqr = sum(D_A1_Weights * pow2(D_A1_Y - (*P_D_A1_YFit))) / I_NFree;
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: D_ChiSqr = " << D_ChiSqr << endl;
#endif

///  sigma[iparam] = SQRT(array[diag]/alpha[diag])      ; New sigma
        //D_A1_SigmaIParam = this->GetSubArr(D_A1_Sigma, *P_I_A1_IParam);
//        Array<double, 2> D_A2_AlphaDiag = this->GetSubArr(D_A2_Alpha, I_A1_Diag, 2);
          if (!this->GetSubArrCopy(D_A2_Array,
                                   I_A1_Diag,
                                   0,
                                   D_A1_ArrayDiag)){
            cout << "CFits::CurveFit: ERROR: GetSubArrCopy(D_A2_Array, I_A1_Diag, 0, D_A1_ArrayDiag) returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: 4. D_A2_Array = " << D_A2_Array << endl;
          cout << "CFits::CurveFit: D_A1_ArrayDiag = " << D_A1_ArrayDiag << endl;
          cout << "CFits::CurveFit: D_A2_Alpha = " << D_A2_Alpha << endl;
          cout << "CFits::CurveFit: D_A1_AlphaDiag = " << D_A1_AlphaDiag << endl;
#endif
          D_A1_SigmaIParam = sqrt(D_A1_ArrayDiag / D_A1_AlphaDiag);
          if (!this->Set_SubArray(D_A1_Sigma, *P_I_A1_IParam, D_A1_SigmaIParam)){
            cout << "CFits::CurveFit: ERROR: Set_SubArray(D_A1_Sigma, *P_I_A1_IParam, D_A1_SigmaIParam) returned FALSE" << endl;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return false;
          }
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: D_A1_SigmaIParam = " << D_A1_SigmaIParam << endl;
          cout << "CFits::CurveFit: D_A1_Sigma = " << D_A1_Sigma << endl;
#endif
        /// TODO:??? D_A1 = D_A2???
///     return false;

///  IF (finite(chisq) EQ 0) OR $
///  (lambdaCount GT 30 AND chisq GE chisq1) THEN BEGIN
          if (I_LambdaCount > 30 && D_ChiSqr >= D_Chisq1){
///  ; Reject changes made this iteration, use old values.

///  yfit  = yfit1
            (*P_D_A1_YFit) = D_A1_YFit1;
#ifdef __DEBUG_FITS_CURVEFIT__
            cout << "CFits::CurveFit: P_D_A1_YFit = " << *P_D_A1_YFit << endl;
#endif
///  sigma[iparam] = sigma1
            D_A1_SigmaIParam = D_A1_Sigma1;
            if (!this->Set_SubArray(D_A1_Sigma, *P_I_A1_IParam, D_A1_SigmaIParam)){
              cout << "CFits::CurveFit: ERROR: Set_SubArray(D_A1_Sigma, *P_I_A1_IParam, D_A1_SigmaIParam) returned FALSE" << endl;

              if (B_NeedToDelete_P_I_A1_FitA)
                delete(P_I_A1_FitA);
              if (B_NeedToDelete_P_D_A1_YFit)
                delete(P_D_A1_YFit);
              delete(P_I_A1_IParam);

              return false;
            }
#ifdef __DEBUG_FITS_CURVEFIT__
            cout << "CFits::CurveFit: D_A1_SigmaIParam = " << D_A1_SigmaIParam << endl;
            cout << "CFits::CurveFit: D_A1_Sigma = " << D_A1_Sigma << endl;
#endif
///  chisq = chisq1
            D_ChiSqr = D_Chisq1;
#ifdef __DEBUG_FITS_CURVEFIT__
            cout << "CFits::CurveFit: D_ChiSqr = " << D_ChiSqr << endl;
#endif

///  if ARG_PRESENT(status) then begin
            CS_Comp.Set("STATUS");
            if (this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp) >= 0){
///  status = 1
              I_Status = 1;
///  endif else begin
            }
            else {
              cout << "CFits::CurveFit: Failed to converge- CHISQ increasing without bound." << endl;
///                       /INFORMATIONAL
///  endelse
            }
///  GOTO, done
            B_Done = true;
            cout << "CFits::CurveFit: B_Done set to true" << endl;
            D_A1_A = 0.;
            D_A1_Sigma = 0.;
            CS_Comp = CString("YFIT");
            I_Pos = this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp);
            if (I_Pos >= 0)
              (*P_D_A1_YFit) = 0.;

            if (B_NeedToDelete_P_I_A1_FitA)
              delete(P_I_A1_FitA);
            if (B_NeedToDelete_P_D_A1_YFit)
              delete(P_D_A1_YFit);
            delete(P_I_A1_IParam);

            return true;
///  ENDIF
          }
///  flambda = flambda*10.               ; Assume fit got worse
          if (!B_Done)
            D_FLambda = D_FLambda * 10.;

///  ENDREP UNTIL chisq LE chisq1
#ifdef __DEBUG_FITS_CURVEFIT__
          cout << "CFits::CurveFit: D_ChiSqr = " << D_ChiSqr << endl;
          cout << "CFits::CurveFit: D_Chisq1 = " << D_Chisq1 << endl;
#endif
        } while(D_ChiSqr > D_Chisq1 && !B_Done);
#ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: while loop left" << endl;
#endif
//        return false;

        delete(P_D_A2_C);

        if (!B_Done){
///  flambda = flambda/100.
          D_FLambda = D_FLambda / 100.;
///  a=b                                    ; Save new parameter estimate.
          D_A1_A = D_A1_B;

///  IF ((chisq1-chisq)/chisq1) LE tol THEN GOTO,done   ;Finished?
          if (((D_Chisq1 - D_ChiSqr) / D_Chisq1) <= D_Tol)
            B_Done = 1;
        }///end if (!B_Done)
///  ENDFOR                        ;iteration loop**/
      }
    }
  }
  if (!B_DoneEarly && !B_Done){
///  if ARG_PRESENT(status) then begin
///  status = 2
///  endif else begin
    CS_Comp.Set("STATUS");
    if (this->KeyWord_Set(CS_A1_ArgsIn, CS_Comp) >= 0){
///  status = 1
      I_Status = 1;
///  endif else begin
    }
    else {
///  iterationStr = STRTRIM(itmax,2)+' iteration' + (['','s'])[itmax NE 1]
      #ifdef __DEBUG_FITS_CURVEFIT__
        cout << "CFits::CurveFit: Failed to converge after " << I_ItMax << " iterations" << endl;
      #endif
      if (B_NeedToDelete_P_I_A1_FitA)
        delete(P_I_A1_FitA);
      if (B_NeedToDelete_P_D_A1_YFit)
        delete(P_D_A1_YFit);
      delete(P_I_A1_IParam);

      return false;
///                /INFORMATIONAL
///  endelse
    }
  }
///done:

///  ; If no weighting, then we need to boost error estimates by sqrt(chisq).
///  ; See Numerical Recipes section 15.2 for details.
///  if noWeighting then begin
///  sigma *= SQRT(chisq)
///  endif
  if (B_NoWeighting)
    D_A1_Sigma *= sqrt(D_ChiSqr);
#ifdef __DEBUG_FITS_CURVEFIT__
  cout << "CFits::CurveFit: D_A1_Sigma set to " << D_A1_Sigma << endl;
#endif

///  ; Experimental variance estimate, unbiased
///  var = (nY GT nterms) ? TOTAL((yfit-y)^2 )/nfree : (double ? 0d : 0.0)
///  yerror = SQRT(var)
  double D_Var = 0.;
  if (I_NY > I_NTerms)
    D_Var = sum(pow2((*P_D_A1_YFit) - D_A1_Y)) / I_NFree;
#ifdef __DEBUG_FITS_CURVEFIT__
  cout << "CFits::CurveFit: D_Var set to " << D_Var << endl;
#endif

  D_YError = sqrt(D_Var);
#ifdef __DEBUG_FITS_CURVEFIT__
  cout << "CFits::CurveFit: *P_D_YError set to " << D_YError << endl;
#endif

///  chi2 = chisq         ; Return chi-squared (chi2 obsolete-still works)

///  if done_early then $
///  iter--
  if (B_DoneEarly)
    iter--;

///  return,yfit          ; return result
///  END

  if (B_NeedToDelete_P_I_A1_FitA)
    delete(P_I_A1_FitA);
  if (B_NeedToDelete_P_D_A1_YFit)
    delete(P_D_A1_YFit);
  delete(P_I_A1_IParam);

  return true;
}

bool CFits::Funct(const Array<double, 1> &D_A1_X,
                  const Array<double, 1> &D_A1_A,
                  Array<double, 1> &D_A1_YFit) const{
  Array<double, 1> D_A1_EZ(1);
  Array<double, 1> D_A1_Z(1);
  return this->Funct(D_A1_X, D_A1_A, D_A1_YFit, D_A1_EZ, D_A1_Z);
}

bool CFits::Funct(const Array<double, 1> &D_A1_X,
                  const Array<double, 1> &D_A1_A,
                  Array<double, 1> &D_A1_YFit,
                  Array<double, 1> &D_A1_EZ,
                  Array<double, 1> &D_A1_Z) const{
///PRO  FUNCT,X,A,F,PDER
///     if a[2] ne 0.0 then Z = (X-A[1])/A[2] $ ;GET Z
///     else z= 10.
  if (D_A1_A.size() < 6){
    cout << "CFits::Funct: ERROR: D_A1_A must have at least 6 elements" << endl;
    return false;
  }
  if (D_A1_A(2) != 0.0){
    D_A1_Z.resize(D_A1_X.size());
    D_A1_Z = (D_A1_X - D_A1_A(1)) / D_A1_A(2);
  }
  else{
    D_A1_Z.resize(1);
    D_A1_Z = 10.;
  }
///     EZ = EXP(-Z^2/2.)*(ABS(Z) LE 7.) ;GAUSSIAN PART IGNORE SMALL TERMS
  D_A1_EZ.resize(D_A1_Z.size());
  D_A1_EZ = exp((0.0-pow2(D_A1_Z)) / 2.) * fabs(D_A1_Z);
  D_A1_EZ = where(D_A1_EZ > 7., 7., D_A1_EZ);

///     F = A[0]*EZ + A[3] + A[4]*X + A[5]*X^2 ;FUNCTIONS.
  D_A1_YFit.resize(D_A1_X.size());
  D_A1_YFit = D_A1_A(0) * D_A1_EZ + D_A1_A(3) + D_A1_A(4) * D_A1_X + D_A1_A(5) * pow2(D_A1_X);

  return true;
}


bool CFits::Funct(const Array<double, 1> &D_A1_X,
                  const Array<double, 1> &D_A1_A,
                  Array<double, 1> &D_A1_YFit,
                  Array<double, 2> &D_A2_PDer) const{
  Array<double, 1> D_A1_EZ(1);
  Array<double, 1> D_A1_Z(1);
  if (!this->Funct(D_A1_X, D_A1_A, D_A1_YFit, D_A1_EZ, D_A1_Z)){
    cout << "CFits::Funct: ERROR: this->Funct returned FALSE" << endl;
    return false;
  }
///     PDER = FLTARR(N_ELEMENTS(X),6) ;YES, MAKE ARRAY.
  D_A2_PDer.resize(D_A1_X.size(), 6);
///     PDER[0,0] = EZ          ;COMPUTE PARTIALS
  D_A2_PDer(0, Range::all()) = D_A1_EZ;

///     if a[2] ne 0. then PDER[0,1] = A[0] * EZ * Z/A[2]
  if (D_A1_A(2) != 0.)
    D_A2_PDer(1,Range::all()) = D_A1_A(0) * D_A1_EZ * D_A1_Z / D_A1_A(2);

///     PDER[0,2] = PDER[*,1] * Z
  D_A2_PDer(2,Range::all()) = D_A2_PDer(1,Range::all()) * D_A1_Z;

///     PDER[*,3] = 1.
  D_A2_PDer(3,Range::all()) = 1.;

///     PDER[0,4] = X
  D_A2_PDer(4,Range::all()) = D_A1_X;

///     PDER[0,5] = X^2
  D_A2_PDer(5,Range::all()) = pow2(D_A1_X);

///     RETURN
  return true;
}

bool CFits::GaussFunct(const Array<double, 1> &D_A1_X,
                       const Array<double, 1> &D_A1_A,
                       Array<double, 1> &D_A1_F,
                       Array<double, 2> &D_A2_PDer) const{
  Array<double, 1> D_A1_Z(1);
  Array<double, 1> D_A1_EZ(1);
  if (!this->GaussFunct(D_A1_X, D_A1_A, D_A1_F, D_A1_Z, D_A1_EZ)){
    cout << "CFits::GaussFunct: ERROR: GaussFunct return FALSE" << endl;
    return false;
  }
#ifdef __DEBUG_FITS_GAUSSFIT__
  cout << "CFits::GaussFunct: After GaussFunct(x,a,f,z,ez): D_A1_X = " << D_A1_X << endl;
  cout << "CFits::GaussFunct: After GaussFunct(x,a,f,z,ez): D_A1_A = " << D_A1_A << endl;
  cout << "CFits::GaussFunct: After GaussFunct(x,a,f,z,ez): D_A1_F = " << D_A1_F << endl;
  cout << "CFits::GaussFunct: After GaussFunct(x,a,f,z,ez): D_A1_Z = " << D_A1_Z << endl;
  cout << "CFits::GaussFunct: After GaussFunct(x,a,f,z,ez): D_A1_EZ = " << D_A1_EZ << endl;
#endif

  int n = D_A1_A.size();
  int nx = D_A1_X.size();
#ifdef __DEBUG_FITS_GAUSSFIT__
  cout << "CFits::GaussFunct: n = " << n << endl;
  cout << "CFits::GaussFunct: nx = " << nx << endl;
#endif

  ///YES, MAKE ARRAY.
  D_A2_PDer.resize(nx, n);

  ///COMPUTE PARTIALS
  D_A2_PDer(Range::all(), 0) = D_A1_EZ;

  ///    if a[2] ne 0. then PDER[*,1] = A[0] * EZ * Z/A[2]
  if (D_A1_A(2) != 0.)
    D_A2_PDer(Range::all(), 1) = D_A1_A(0) * D_A1_EZ * D_A1_Z / D_A1_A(2);
///    PDER[*,2] = PDER[*,1] * Z
  D_A2_PDer(Range::all(), 2)  = D_A2_PDer(Range::all(), 1) * D_A1_Z;
///    if n gt 3 then PDER[*,3] = 1.
  if (n > 3)
    D_A2_PDer(Range::all(), 3) = 1.;
///    if n gt 4 then PDER[*,4] = X
  if (n > 4)
    D_A2_PDer(Range::all(), 4) = D_A1_X;
///    if n gt 5 then PDER[*,5] = X^2
  if (n > 5)
    D_A2_PDer(Range::all(), 5) = pow2(D_A1_X);
  #ifdef __DEBUG_FITS_GAUSSFIT__
  cout << "CFits::GaussFunct: D_A2_PDer set to " << D_A2_PDer << endl;
  #endif
  return true;
}

bool CFits::GaussFunct(const Array<double, 1> &D_A1_X,
                       const Array<double, 1> &D_A1_A,
                       Array<double, 1> &D_A1_F) const{
  Array<double, 1> D_A1_Z(1);
  Array<double, 1> D_A1_EZ(1);
  return this->GaussFunct(D_A1_X, D_A1_A, D_A1_F, D_A1_Z, D_A1_EZ);
}

bool CFits::GaussFunct(const Array<double, 1> &D_A1_X,
                       const Array<double, 1> &D_A1_A,
                       Array<double, 1> &D_A1_F,
                       Array<double, 1> &D_A1_Z,
                       Array<double, 1> &D_A1_EZ) const{
///    n = n_elements(a)
///    nx = N_ELEMENTS(x)
  #ifdef __DEBUG_FITS_GAUSSFIT__
  cout << "CFits::GaussFunct: D_A1_X = " << D_A1_X << endl;
  cout << "CFits::GaussFunct: D_A1_A = " << D_A1_A << endl;
  #endif
  int n = D_A1_A.size();
  int nx = D_A1_X.size();

  D_A1_Z.resize(nx);
  D_A1_EZ.resize(nx);
  D_A1_F.resize(nx);
///    if a[2] ne 0.0 then begin
  if (D_A1_A(2) != 0.){
///        Z = (X-A[1])/A[2]   ;GET Z
    D_A1_Z = (D_A1_X - D_A1_A(1)) / D_A1_A(2);
///        EZ = EXP(-Z^2/2.)   ;GAUSSIAN PART
    D_A1_EZ = exp(0. - pow2(D_A1_Z) / 2.);
///    endif else begin
  }
  else{
///        z = REPLICATE(FIX(100, TYPE=SIZE(x,/TYPE)), nx)
    Array<double, 1> *P_D_A1_Z = this->Replicate(100., nx);
    D_A1_Z = (*P_D_A1_Z);
    delete(P_D_A1_Z);
///        ez = z*0
    D_A1_EZ = 0.;
///    endelse
  }
  #ifdef __DEBUG_FITS_GAUSSFIT__
  cout << "CFits::GaussFunct: D_A1_Z set to " << D_A1_Z << endl;
  cout << "CFits::GaussFunct: D_A1_EZ set to " << D_A1_EZ << endl;
  #endif
///    case n of
///        3:  F = A[0]*EZ
  if (n == 3)
    D_A1_F = D_A1_A(0) * D_A1_EZ;
///        4:  F = A[0]*EZ + A[3]
  else if (n == 4)
    D_A1_F = D_A1_A(0) * D_A1_EZ + D_A1_A(3);
///        5:  F = A[0]*EZ + A[3] + A[4]*X
  else if (n == 5)
    D_A1_F = D_A1_A(0) * D_A1_EZ + D_A1_A(3) + D_A1_A(4) * (D_A1_X - D_A1_A(1));
///        6:  F = A[0]*EZ + A[3] + A[4]*X + A[5]*X^2 ;FUNCTIONS.
  else if (n == 6)
    D_A1_F = D_A1_A(0) * D_A1_EZ + D_A1_A(3) + D_A1_A(4) * (D_A1_X - D_A1_A(1)) + D_A1_A(5) * pow2((D_A1_X - D_A1_A(1)));
///    ENDCASE
  #ifdef __DEBUG_FITS_GAUSSFIT__
  cout << "CFits::GaussFunct: D_A1_F set to " << D_A1_F << endl;
  #endif

  return true;
}


void CFits::GaussFunct(double D_X,
                       const Array<double, 1> &D_A1_A,
                       double D_Y) const{
  int n = D_A1_A.size();
  int nx = 1;

  double D_Z;
  double D_EZ;

  if (D_A1_A(2) != 0.){
    D_Z = (D_X - D_A1_A(1)) / D_A1_A(2);
    D_EZ = exp(0. - pow2(D_Z) / 2.);
  }
  else{
    D_Z = 100.;
    D_EZ = 0.;
  }
  #ifdef __DEBUG_FITS_GAUSSFIT__
  cout << "CFits::GaussFunct: D_Z set to " << D_Z << endl;
  cout << "CFits::GaussFunct: D_EZ set to " << D_EZ << endl;
  #endif
  if (n == 3)
    D_Y = D_A1_A(0) * D_EZ;
  else if (n == 4)
    D_Y = D_A1_A(0) * D_EZ + D_A1_A(3);
  else if (n == 5)
    D_Y = D_A1_A(0) * D_EZ + D_A1_A(3) + D_A1_A(4) * (D_X - D_A1_A(1));
  else if (n == 6)
    D_Y = D_A1_A(0) * D_EZ + D_A1_A(3) + D_A1_A(4) * (D_X - D_A1_A(1)) + D_A1_A(5) * pow2((D_X - D_A1_A(1)));
  #ifdef __DEBUG_FITS_GAUSSFIT__
  cout << "CFits::GaussFunct: D_Y set to " << D_Y << endl;
  #endif

  return;
}

/**
 * Calculate D_A1_YFit_Out
 * D_A1_Coeffs_In.size() == 3: one Gauss, no background
 * D_A1_Coeffs_In.size() == 4: one Gauss, constant background
 * D_A1_Coeffs_In.size() == 6: two Gauss, no background (NOTE: Not yet implemented)
 * D_A1_Coeffs_In.size() == 7: two Gauss, constant background (NOTE: Not yet implemented)
 * D_A1_Coeffs_In.size() == 9: three Gauss, no background (NOTE: Not yet implemented)
 * D_A1_Coeffs_In.size() == 10: three Gauss, constant background (NOTE: Not yet implemented)
 **/
bool CFits::GaussArea(const Array<double, 1> &D_A1_X_In,
                      const Array<double, 1> &D_A1_Coeffs_In,
                      Array<double, 1> &D_A1_YFit_Out) const{
  D_A1_YFit_Out.resize(D_A1_X_In.size());
  D_A1_YFit_Out = 0.;
  if ((D_A1_Coeffs_In.size() < 3) || (D_A1_Coeffs_In.size() > 4)){
    cout << "CFits::GaussArea: ERROR: D_A1_Coeffs_In.size() != [3,4]" << endl;
    return false;
  }
  D_A1_YFit_Out = D_A1_Coeffs_In(D_A1_Coeffs_In.size()-3) * exp(0. - pow2(D_A1_X_In - D_A1_Coeffs_In(D_A1_Coeffs_In.size()-2)) / (2. * pow2(D_A1_Coeffs_In(D_A1_Coeffs_In.size()-1)))) / (D_A1_Coeffs_In(D_A1_Coeffs_In.size()-1) * sqrt(2. * D_PI));
  if (D_A1_Coeffs_In.size() == 4){
    D_A1_YFit_Out = D_A1_YFit_Out + D_A1_Coeffs_In(0);
  }
  return true;
}


/**
  Spline
  Given Arrays XVecArr(0:N-1) and YVecArr(0:N-1) containing a tabulated function, i.e., y_i = f(x_i), with x_1 < x_2 < ... < x_N, and given values YP1 and YPN for the first derivative of the interpolating function at points 1 and N, respectively, this routine returns an Array y2(0:N-1) that contains the second derivatives of the interpolating function at the tabulated points x_i. If YP1 and/or YPN are equal to 1x10^30 or larger, the routine is signaled to set the corresponding boundary condition for a natural spline, with zero second derivative on that boundary.
 **/
bool CFits::Spline(Array<double, 1> &XVecArr, Array<double, 1> &YVecArr, double YP1, double YPN, Array<double, 1> &Y2VecArr) const
{
  int m, o, N = XVecArr.size();
  double p, qn, sig, un;
  Array<double, 1> UVecArr(N-1);
  Y2VecArr.resize(N);

  if (YP1 > 0.99e30)  /// The lower boundary condition is set either to be "natural"
  {
    Y2VecArr(0) = UVecArr(0) = 0.0;
  }
  else                /// or else to have a specified first derivative
  {
    Y2VecArr(0) = -0.5;
    UVecArr(0)  = (3.0 / (XVecArr(1) - XVecArr(0))) * ((YVecArr(1) - YVecArr(0)) / (XVecArr(1) - XVecArr(0)) - YP1);
  }

  /**
  This is the decomposition loop of the tridiagonal algorithm. Y2VecArr and UVecArr are used for temporary storage of the decomposed factors.
  **/
  for (m = 1; m < N-1; m++)
  {
    sig = (XVecArr(m) - XVecArr(m-1)) / (XVecArr(m + 1) - XVecArr(m-1));
    p = sig * Y2VecArr(m - 1) + 2.0;
    Y2VecArr(m) = (sig - 1.0) / p;
    UVecArr(m)  = (YVecArr(m+1) - YVecArr(m)) / (XVecArr(m+1) - XVecArr(m)) - (YVecArr(m) - YVecArr(m-1)) / (XVecArr(m) - XVecArr(m-1));
    UVecArr(m)  = (6.0 * UVecArr(m) / (XVecArr(m+1) - XVecArr(m-1)) - sig * UVecArr(m-1)) / p;
  }
  if (YPN > 0.99e30)  /// The upper boundary condition is set either to be "natural"
    qn = un = 0.0;
  else                /// or else to have a specified first derivative
  {
    qn = 0.5;
    un = (3.0 / (XVecArr(N-1) - XVecArr(N-2))) * (YPN - (YVecArr(N-1) - YVecArr(N-2)) / (XVecArr(N-1) - XVecArr(N-2)));
  }
  Y2VecArr(N-1) = (un - qn * UVecArr(N-2)) / (qn * Y2VecArr(N-2) + 1.0);

  /// This is the backsubstitution loop of the tridiagonal algorithm
  for (o = N - 2; o >= 0; o--)
  {
    Y2VecArr(o) = Y2VecArr(o) * Y2VecArr(o+1) + UVecArr(o);
  }
  UVecArr.resize(0);
  return true;
}

/**
  Spline
  Given Arrays XVecArr(0:N-1) and YVecArr(0:N-1) containing a tabulated function, i.e., y_i = f(x_i), with x_1 < x_2 < ... < x_N, this routine returns an Array y2(0:N-1) that contains the second derivatives of the interpolating function at the tabulated points x_i. The routine is signaled to set the corresponding boundary condition for a natural spline, with zero second derivative on that boundary.
 **/
bool CFits::Spline(Array<double, 1> &XVecArr, Array<double, 1> &YVecArr, Array<double, 1> &Y2VecArr) const
{
  return this->Spline(XVecArr, YVecArr, 1.0e30, 1.0e30, Y2VecArr);
}

/**
  SplInt
  Given the Arrays XAVecArr(0:N-1) and YAVecArr(0:N-1), which tabulate a function (whith the XAVecArr(i)'s in order), and given the array Y2AVecArr(0:N-1), which is the output from Spline above, and given a value of X, this routine returns a cubic-spline interpolated value Y;
 **/
bool CFits::SplInt(Array<double, 1> &XAVecArr, Array<double, 1> &YAVecArr, Array<double, 1> &Y2AVecArr, double X, double *Y) const
{
  int klo, khi, o, N;
  double h, b, a;

  N = XAVecArr.size();
  /**
  We will find the right place in the table by means of bisection. This is optimal if sequential calls to this routine are at random values of X. If sequential calls are in order, and closely spaced, one would do better to store previous values of klo and khi and test if they remain appropriate on the next call.
  **/
  klo = 1;
  khi = N;
  while (khi - klo > 1)
  {
    o = (khi + klo) >> 1;
    if (XAVecArr(o) > X)
      khi = o;
    else
      klo = o;
  } /// klo and khi now bracket the input value of X
  h = XAVecArr(khi) - XAVecArr(klo);
  if (h == 0.0)  /// The XAVecArr(i)'s must be distinct
  {
    cout << "CFits::SplInt: ERROR: Bad XAVecArr input to routine SplInt" << endl;
    (*P_OFS_Log) << "CFits::SplInt: ERROR: Bad XAVecArr input to routine SplInt" << endl;
    return false;
  }
  a = (XAVecArr(khi) - X) / h;
  b = (X - XAVecArr(klo)) / h; /// Cubic Spline polynomial is now evaluated.
  *Y = a * YAVecArr(klo) + b * YAVecArr(khi) + ((a * a * a - a) * Y2AVecArr(khi)) * (h * h) / 6.0;
  return true;
}

/**
  InvertGaussJ(AArray, BArray)
  Linear equation solution by Gauss-Jordan elimination
  AArray(0:N-1, 0:N-1) is the input matrix. BArray(0:N-1, 0:M-1) is input containing the m right-hand side vectors.
  On output, AArray is replaced by its matrix inverse, and BArray is replaced by the corresponding set of solution vectors.
 **/
bool CFits::InvertGaussJ(Array<double, 2> &AArray, Array<double, 2> &BArray) const
{
  /// The integer arrays IPivVecArr, IndXCVecArr, and IndXRVecArr are used for bookkeeping on the pivoting
  Array<int, 1> IndXCVecArr(AArray.extent(firstDim));
  Array<int, 1> IndXRVecArr(AArray.extent(firstDim));
  Array<int, 1> IPivVecArr(AArray.extent(firstDim));

  #ifdef __DEBUG_FITS_INVERT__
    cout << "CFits::InvertGaussJ: AArray = " << AArray << endl;
    cout << "CFits::InvertGaussJ: BArray = " << BArray << endl;
    cout << "CFits::InvertGaussJ: IndXCVecArr = " << IndXCVecArr << endl;
    cout << "CFits::InvertGaussJ: IndXRVecArr = " << IndXRVecArr << endl;
    cout << "CFits::InvertGaussJ: IPivVecArr = " << IPivVecArr << endl;
  #endif

  int m = 0, icol = 0, irow = 0, n = 0, o = 0, p = 0, pp = 0, N = 0, M = 0;
  double Big = 0., dum = 0., PivInv = 0.;

  N = AArray.rows();
  M = BArray.cols();

  IPivVecArr = 0;
#ifdef __DEBUG_FITS_INVERT__
  cout << "CFits::InvertGaussJ: N = " << N << ", M = " << M << endl;
  cout << "CFits::InvertGaussJ: IPivVecArr = " << IPivVecArr << endl;
#endif

  /// This is the main loop over the columns to be reduced
  for (m = 0; m < N; m++) /// m == i
  {
    Big = 0.;

    /// This is the outer loop of the search for a pivot element
    for (n = 0; n < N; n++) /// n == j
    {
      if (IPivVecArr(n) != 1)
      {
        for (o = 0; o < N; o++) /// o == k
        {
          if (IPivVecArr(o) == 0)
          {
            if (fabs(AArray(n, o)) >= Big)
            {
              Big = fabs(AArray(n, o));
              irow = n;
              icol = o;
            }
          }
        }
      } /// end if (IPivVecArr(n) != 1)
    } /// end for (n = 0; n < N; n++)     Outer Loop
    ++(IPivVecArr(icol));

    /** We now have the pivot element, so we interchange rows, if needed, to put the pivot element on the diagonal. The columns are not physically interchanged, only relabled: IndXCVecArr(m), the column of the mth pivot element, is the mth column that is reduced, while IndXRVecArr(m) is the row in which that pivot element was originally located. If IndXCVecArr(i) != IndXRVecArr there is an implied column interchange. With this form of bookkeeping, the solution BVecArr's will end up in the correct order, and the inverse matrix will be scrambled by columns.
     **/
    if (irow != icol)
    {
      for (p = 0; p < N; p++)
      {
        Swap(AArray(irow, p), AArray(icol, p));
      }
      for (p = 0; p < M; p++)
      {
        Swap(BArray(irow, p), BArray(icol, p));
      }
    }
    IndXRVecArr(m) = irow;
    IndXCVecArr(m) = icol;

    /** We are now ready to divide the pivot row by the pivot element, located at irow and icol
     **/
    if (AArray(icol, icol) == 0.0)
    {
      cout << "CFits::InvertGaussJ: Error 1: Singular Matrix!" << endl;
      cout << "CFits::InvertGaussJ: AArray = " << AArray << endl;
      cout << "CFits::InvertGaussJ: AArray(" << icol << ", " << icol << ") == 0." << endl;
      (*P_OFS_Log) << "CFits::InvertGaussJ: Error 1: Singular Matrix!" << endl;
      (*P_OFS_Log) << "CFits::InvertGaussJ: AArray(" << icol << ", " << icol << ") == 0." << endl;
      return false;
    }
    PivInv = 1.0 / AArray(icol, icol);
    AArray(icol, icol) = 1.0;
    for (p = 0; p < N; p++)
    {
      AArray(icol, p) *= PivInv;
    }
    for (p = 0; p < M; p++)
    {
      BArray(icol, p) *= PivInv;
    }

    /**
      Next, we reduce the rows...
          ... except for the pivot one, of course
     **/
    for (pp = 0; pp < N; pp++)
    {
      if (pp != icol)
      {
        dum = AArray(pp, icol);
        AArray(pp, icol) = 0.0;
        for (p = 0; p < N; p++)
        {
          AArray(pp, p) -= AArray(icol, p) * dum;
        }
        for (p = 0; p < M; p++)
        {
          BArray(pp, p) -= BArray(icol, p) * dum;
        }
      } /// end if (pp != icol)
    } /// end for (pp = 0; pp < N; pp++)
  } /// end for (m = 0; m < N; m++)       Main Loop
  /** This is the end of the main loop over columns of the reduction. It only remains to unscramble the solution in view of the column interchanges. We do this by interchanging pairs of columns int the reverse order that the permutation was built up.
  **/
  for (p = N-1; p >= 0; p--)
  {
    if (IndXRVecArr(p) != IndXCVecArr(p))
    {
      for (o = 0; o < N; o++)
      {
        Swap(AArray(o, IndXRVecArr(p)), AArray(o, IndXCVecArr(p)));
        /// And we are done.
      }
    }
  }
  IndXCVecArr.resize(0);
  IndXRVecArr.resize(0);
  IPivVecArr.resize(0);
  return true;
}

/**
  InvertGaussJ(AArray)
  From: Numerical Recipies
  Linear equation solution by Gauss-Jordan elimination with B == Unity
  AArray(0:N-1, 0:N-1) is the input matrix.
  On output, AArray is replaced by its matrix inverse.
 **/
bool CFits::InvertGaussJ(Array<double, 2> &AArray) const
{
  int N = AArray.cols();
  if (N != AArray.rows())
  {
    cout << "CFits::InvertGaussJ(AArray=" << AArray << "): ERROR: AArray is not quadratic!" << endl;
    (*P_OFS_Log) << "CFits::InvertGaussJ(AArray=" << AArray << "): ERROR: AArray is not quadratic!" << endl;
    return false;
  }
  Array<double, 2> Unity(N, N);
  Unity = 0.;
  for (int m = 0; m < N; m ++)
  {
    Unity(m, m) = 1.;
  }
  if (!this->InvertGaussJ(AArray, Unity))
  {
    cout << "CFits::InvertGaussJ: ERROR: InvertGaussJ(AArray=" << AArray << ", Unity=" << Unity << ") retuned FALSE" << endl;
    (*P_OFS_Log) << "CFits::InvertGaussJ: ERROR: InvertGaussJ(AArray, Unity) retuned FALSE" << endl;
    return false;
  }
  Unity.resize(0);
  return true;
}

/**
 ValueLocate
 Returns the Start Index of the Range of the two indixes of the monotonically increasing or decreasing Vector VecArr, in which Val falls.
 If Vector is monotonically increasing, the result is
   if j = -1       Value(i) < VecArr(0)
   if 0 <= j < N-1 VecArr(j) <= Value(i) < VecArr(j+1)
   if j = N-1      VecArr(N-1) <= Value(i)

 If Vector is monotonically decreasing, the result is
   if j = -1       VecArr(0) <= ValVecArr(i)
   if 0 <= j < N-1 VecArr(j+1) <= ValVecArr(i) < VecArr(j)
   if j = N-1      ValVecArr(i) < VecArr(N-1)
**/
Array<int, 1>* CFits::ValueLocate(const Array<double, 1> &VecArr, const Array<double, 1> &ValVecArr) const
{
  #ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::ValueLocate: VecArr = " << VecArr << endl;
    cout << "CFits::ValueLocate: ValVecArr = " << ValVecArr << endl;
  #endif
  if (VecArr.size() < 1){
    cout << "CFits::ValueLocate: ERROR: VecArr.size() < 1 => Returning FALSE" << endl;
    exit(EXIT_FAILURE);
  }
  if (ValVecArr.size() < 1){
    cout << "CFits::ValueLocate: ERROR: ValVecArr.size() < 1 => Returning FALSE" << endl;
    exit(EXIT_FAILURE);
  }
  Array<int, 1> IntVecArr(ValVecArr.size());

  int n;
  int N = VecArr.size();
  int M = ValVecArr.size();

  bool Increasing = false;
  int ii=0;
  while(ValVecArr(ii) == ValVecArr(ii+1)){
    ii++;
  }
  if (ValVecArr(ii+1) > ValVecArr(ii))
    Increasing = true;

  #ifdef __DEBUG_FITS_INTERPOL__
    if (Increasing)
      cout << "CFits::ValueLocate: Increasing = TRUE" << endl;
    else
      cout << "CFits::ValueLocate: Increasing = FALSE" << endl;
  #endif

  /// For every element in ValVecArr
  for (int m = 0; m < M; m++)
  {
    #ifdef __DEBUG_FITS_INTERPOL__
      cout << "CFits::ValueLocate: ValVecArr(m) = " << ValVecArr(m) << endl;
    #endif
    if (Increasing)
    {
      if (ValVecArr(m) < VecArr(0)){
        IntVecArr(m) = 0 - 1;
      }
      else if (VecArr(N-1) <= ValVecArr(m)){
        IntVecArr(m) = N - 1;
      }
      else{
        n = -1;
        while (n < N-1)
        {
          n++;
          if (VecArr(n) <= ValVecArr(m) && ValVecArr(m) < VecArr(n+1))
          {
            IntVecArr(m) = n;
            break;
          }
        }
      }
      #ifdef __DEBUG_FITS_INTERPOL__
        cout << "CFits::ValueLocate: Increasing = TRUE: IntVecArr(m) = " << IntVecArr(m) << endl;
      #endif
    }
    else/// if (Decreasing)
    {
      if (VecArr(0) <= ValVecArr(m))
        IntVecArr(m) = 0 - 1;
      else if (ValVecArr(m) < VecArr(N-1))
        IntVecArr(m) = N - 1;
      else
      {
        n = -1;
        while (n < N-1)
        {
          n++;
          if (VecArr(n+1) <= ValVecArr(m) && ValVecArr(m) < VecArr(n))
          {
            IntVecArr(m) = n;
            break;
          }
        }
      }
      #ifdef __DEBUG_FITS_INTERPOL__
        cout << "CFits::ValueLocate: Increasing = FALSE: IntVecArr(m) = " << IntVecArr(m) << endl;
      #endif
    }
  }
  #ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::ValueLocate: IntVecArr = " << IntVecArr << endl;
  #endif
  Array<int, 1> *P_I_Result = new Array<int, 1>(IntVecArr.size());
  (*P_I_Result) = IntVecArr;
  #ifdef __DEBUG_FITS_INTERPOL__
    cout << "CFits::ValueLocate: *P_I_Result = " << (*P_I_Result) << endl;
  #endif
  IntVecArr.resize(0);
  return P_I_Result;
}

/**
 FixDF(Array<double, 1> &VecArr, CString Mode)
 Returns an Array of the same size containing the float values of VecArr.
 **/
Array<float, 1>* CFits::FixDF(const Array<double, 1> &VecArr) const
{
  Array<float, 1> *P_TempFloatVecArr = new Array<float, 1>(VecArr.size());
  for (int m = 0; m < VecArr.size(); m++)
  {
    (*P_TempFloatVecArr)(m) = (float)VecArr(m);
  }
  return (P_TempFloatVecArr);
}

/**
 * Fix(double)
 * Returns integer value cut at decimal point
 **/
int CFits::Fix(double D_In) const{
  return (int)(D_In);
}

/**
 Fix(Array<double, 1> &VecArr, CString Mode)
 Returns an Array of the same size containing the integer values of VecArr. If <Mode> is set to "ROUND" the double values are rounded, else cut.
 **/
Array<int, 1>* CFits::Fix(const Array<double, 1> &VecArr, const CString &Mode) const
{
  Array<int, 1> *P_TempIntVecArr = new Array<int, 1>(VecArr.size());
  for (int m = 0; m < VecArr.size(); m++)
  {
//    if (Mode.EqualValue(*(new CString("ROUND"))))
    if (Mode.EqualValue(CString("ROUND")))
    {
      (*P_TempIntVecArr)(m) = Round(VecArr(m));
    }
    else
      (*P_TempIntVecArr)(m) = (int)VecArr(m);
  }
  return (P_TempIntVecArr);
}

/**
  Fix(Array<double, 1> &VecArr)
  Returns an Array of the same size containing the not rounded integer values of VecArr.
 **/
Array<int, 1>* CFits::Fix(const Array<double, 1> &VecArr) const
{
  return (this->Fix(VecArr, CString("NORMAL")));
}

/**
 Fix(Array<double, 2> &Arr, CString Mode)
 Returns an Array of the same size containing the integer values of Arr. If <Mode> is set to "ROUND" the double values are rounded, else cut.
 **/
Array<int, 2>* CFits::Fix(const Array<double, 2> &Arr, const CString &Mode) const
{
  Array<int, 2> *P_TempIntArr = new Array<int, 2>(Arr.rows(), Arr.cols());

  firstIndex i;
  secondIndex j;

  for (int m = 0; m < Arr.rows(); m++)
  {
    for (int n = 0; n < Arr.cols(); m++)
    {
      if (Mode.EqualValue(CString("ROUND")))
      {
        (*P_TempIntArr)(m, n) = Round(Arr(m, n));
      }
      else
        (*P_TempIntArr)(m, n) = (int)Arr(m, n);
    }
  }
  return (P_TempIntArr);
}

/**
  Fix(Array<double, 2> &Arr)
  Returns an Array of the same size containing the not rounded integer values of VecArr.
 **/
Array<int, 2>* CFits::Fix(const Array<double, 2> &Arr) const
{
  return (this->Fix(Arr, CString("NORMAL")));
}

/**
 FixL(Array<double, 1> &VecArr, CString Mode)
 Returns an Array of the same size containing the long integer values of VecArr. If <Mode> is set to "ROUND" the double values are rounded, else cut.
 **/
Array<long, 1>* CFits::FixL(const Array<double, 1> &VecArr, const CString &Mode) const
{
  Array<long, 1> *P_TempLongVecArr = new Array<long, 1>(VecArr.size());
  for (int m = 0; m < VecArr.size(); m++)
  {
    if (Mode.EqualValue(CString("ROUND")))
    {
      (*P_TempLongVecArr)(m) = Round(VecArr(m));
    }
    else
      (*P_TempLongVecArr)(m) = (long)VecArr(m);
  }
  return (P_TempLongVecArr);
}

/**
 FixL(Array<double, 1> &VecArr)
 Returns an Array of the same size containing the not rounded long integer values of VecArr.
 **/
Array<long, 1>* CFits::FixL(const Array<double, 1> &VecArr) const
{
  return (this->FixL(VecArr, CString("NORMAL")));
}

/**
 FixL(Array<double, 2> &Arr, CString Mode)
 Returns an Array of the same size containing the long integer values of Arr. If <Mode> is set to "ROUND" the double values are rounded, else cut.
 **/
Array<long, 2>* CFits::FixL(const Array<double, 2> &Arr, const CString &Mode) const
{
  Array<long, 2> *P_TempIntArr = new Array<long, 2>(Arr.rows(), Arr.cols());

  firstIndex i;
  secondIndex j;

  for (int m = 0; m < Arr.rows(); m++)
  {
    for (int n = 0; n < Arr.cols(); m++)
    {
      if (Mode.EqualValue(CString("ROUND")))
      {
        (*P_TempIntArr)(m, n) = RoundToLong(Arr(m, n));
      }
      else
        (*P_TempIntArr)(m, n) = (int)Arr(m, n);
    }
  }
  return (P_TempIntArr);
}

/**
 FixL(Array<double, 2> &Arr)
 Returns an Array of the same size containing the not rounded long integer values of Arr.
 **/
Array<long, 2>* CFits::FixL(const Array<double, 2> &Arr) const
{
  return (this->FixL(Arr, CString("NORMAL")));
}

/**
 FixD(Array<long, 1> &VecArr)
 Returns an Array of the same size containing the double values of Array<long, 1> Arr.
 **/
Array<double, 1>* CFits::FixD(const Array<long, 1> &VecArr) const
{
  Array<double, 1> *P_TempDoubleVecArr = new Array<double, 1>(VecArr.size());
  for (int m = 0; m < VecArr.size(); m++)
  {
    (*P_TempDoubleVecArr)(m) = (double)VecArr(m);
  }
  return (P_TempDoubleVecArr);
}

/**
 FixD(Array<int, 1> &VecArr)
 Returns an Array of the same size containing the double values of Array<int, 1> Arr.
 **/
Array<double, 1>* CFits::FixD(const Array<int, 1> &VecArr) const
{
  Array<double, 1> *P_TempDoubleVecArr = new Array<double, 1>(VecArr.size());
  for (int m = 0; m < VecArr.size(); m++)
  {
    (*P_TempDoubleVecArr)(m) = (double)VecArr(m);
  }
  return (P_TempDoubleVecArr);
}

/**
 FixIL(Array<int, 1> &VecArr)
 Returns an Array of the same size containing the long integer values of Array<int, 1> Arr.
 **/
Array<long, 1>* CFits::FixIL(const Array<int, 1> &VecArr) const
{
  Array<long, 1> *P_TempLongVecArr = new Array<long, 1>(VecArr.size());
  for (int m = 0; m < VecArr.size(); m++)
  {
    (*P_TempLongVecArr)(m) = (long)VecArr(m);
  }
  return (P_TempLongVecArr);
}

/**
 FixLI(Array<long, 1> &VecArr)
 Returns an Array of the same size containing the integer values of Array<long, 1> Arr.
 **/
Array<int, 1>* CFits::FixLI(const Array<long, 1> &VecArr) const
{
  Array<int, 1> *P_TempIntVecArr = new Array<int, 1>(VecArr.size());
  for (int m = 0; m < VecArr.size(); m++)
  {
    (*P_TempIntVecArr)(m) = (int)VecArr(m);
  }
  return (P_TempIntVecArr);
}

double CFits::Round(const double ToRound, int DigitsBehindDot) const
{
  long TempLong;
  int TempInt;
  double TempDbl;

  bool B_IsNegative = ToRound < 0.;
//  if (B_IsNegative)
//    cout << "CFits::Round(dbl,int): B_IsNegative set to TRUE" << endl;
//  else
//    cout << "CFits::Round(dbl,int): B_IsNegative set to FALSE" << endl;
  TempLong = long(ToRound * pow(10., (int)DigitsBehindDot));
  TempDbl = (ToRound - double(TempLong)) * pow(10., DigitsBehindDot);
  TempInt = int(abs(TempDbl * 10.));
//  cout << "CFits::Round(dbl,int): ToRound = " << ToRound << ", TempInt set to " << TempInt << endl;
  if (TempInt > 4){
    if (B_IsNegative)
      TempLong--;
    else
      TempLong++;
  }
  return (double(TempLong) / pow(10., DigitsBehindDot));
}
/*
Array<int, 1>* CFits::Round(const Array<double, 1> D_A1_ToRound) const{
  Array<int, 1> *P_I_A1_Out = new Array<int, 1>(D_A1_ToRound.size());
  for (int i_pos=0; i_pos<D_A1_ToRound.size(); i_pos++){
    (*P_I_A1_Out)(i_pos) = this->Round(D_A1_ToRound(i_pos));
  }
  return P_I_A1_Out;
}

/************************************************************/

long CFits::RoundToLong(const double ToRound) const
{
  return long(Round(ToRound, 0));
}

/************************************************************/

int CFits::Round(const double ToRound) const
{
  return (int)Round(ToRound, 0);
}

/************************************************************/

Array<int, 1>* CFits::Round(const Array<double, 1> &D_A1_ToRound_In) const
{
  return this->Fix(D_A1_ToRound_In, CString("ROUND"));
}

/**
 Uniq
 **/
template<typename T>
bool CFits::Uniq(const blitz::Array<T, 1> &IA1_In, blitz::Array<int, 1> &IA1_Result)
{
  blitz::Array<T, 1> VecArr_In(IA1_In.size());
  VecArr_In = IA1_In;
  std::vector<T> vec_In(VecArr_In.data(),VecArr_In.data() + VecArr_In.size());
  std::sort(vec_In.begin(), vec_In.end());
  auto last = std::unique(vec_In.begin(), vec_In.end());
  vec_In.erase(last, vec_In.end());
  #ifdef __DEBUG_UNIQ__
    std::cout << "Uniq: IA1_In = " << IA1_In << endl;
    cout << "Uniq: vec_In.size() = " << vec_In.size() << endl;
    for (const auto& i : vec_In)
      std::cout << i << " ";
    std::cout << "\n";
    int a=2;
    int b=2;
    double c=fabs(a-b);
    cout << "c = " << c << endl;
  #endif
  IA1_Result.resize(vec_In.size());
  blitz::Array<int, 1> I_A1_Ind(IA1_In.size());
  blitz::Array<int, 1> *P_I_A1_Ind;
  int count = 0;
  for (int i=0; i<static_cast<int>(vec_In.size()); i++){
    I_A1_Ind = blitz::where(fabs(IA1_In - vec_In[i]) < 0.5, 1, 0);
    P_I_A1_Ind = this->GetIndex(I_A1_Ind, count);
    if (count == 0){
      #ifdef __DEBUG_UNIQ__
        for (int j=0; j<IA1_In.size(); j++)
          cout << "Uniq: fabs(IA1_In(j=" << j << ")=" << IA1_In(j) << " - vec_In[i=" << i << "]=" << vec_In[i] << ") = " << fabs(IA1_In(j) - vec_In[i]) << endl;
      #endif
      cout << "Uniq: I_A1_Ind = " << I_A1_Ind << endl;
      cout << "Uniq: ERROR: vec_In[" << i << "]=" << vec_In[i] << ": count == 0 => Returning FALSE" << endl;
      return false;
    }
    IA1_Result(i) = (*P_I_A1_Ind)(0);
    delete(P_I_A1_Ind);
  }
  return true;// (*(new blitz::Array<int, 1>(IA1_Indices.copy())));
}

/**
  CrossCorrelate
 **/
bool CFits::CrossCorrelate(const Array<double, 1> &DA1_Static,
                           const Array<double, 1> &DA1_Moving,
                           int I_NPixMaxLeft,
                           int I_NPixMaxRight,
                           int &I_Out,
                           double &D_ChiSquare_Out) const{
  /// Check that both arrays have the same size
  if (DA1_Moving.size() != DA1_Static.size()){
    cout << "CFits::CrossCorrelate: ERROR: DA1_Moving.size() = " << DA1_Moving.size() << " != DA1_Static.size() = " << DA1_Static.size() << endl;
    return false;
  }

  int I_Size = DA1_Static.size();

  /// Check I_NPixMaxLeft and I_NPixMaxRight
  if (I_NPixMaxLeft >= I_Size){
    I_NPixMaxLeft = I_Size - 1;
    cout << "CFits::CrossCorrelate: Warning: I_NPixMaxLeft too large, set to " << I_NPixMaxLeft << endl;
  }
  if (I_NPixMaxRight >= I_Size){
    I_NPixMaxRight = I_Size - 1;
    cout << "CFits::CrossCorrelate: Warning: I_NPixMaxRight too large, set to " << I_NPixMaxRight << endl;
  }

  int I_Pix = 0. - I_NPixMaxLeft;
  int I_NPixMove = I_NPixMaxLeft + I_NPixMaxRight + 1;
  int run = 0;
  #ifdef __DEBUG_FITS_CROSSCORRELATE__
    cout << "CFits::CrossCorrelate: I_Pix = " << I_Pix << endl;
    cout << "CFits::CrossCorrelate: I_NPixMove = " << I_NPixMove << endl;
  #endif

  Array<double, 1> DA1_StaticTemp(1);
  Array<double, 1> DA1_MovingTemp(1);
  Array<double, 1> DA1_Diff(1);
  Array<double, 1> DA1_ChiSquare(I_NPixMove);
  Array<int, 1> IA1_NPix(I_NPixMove);

  for (int i = I_Pix; i <= I_NPixMaxRight; i++){
    if (i < 0){
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i=" << i << " < 0: new array size = " << DA1_Static.size()+i << endl;
        cout << "CFits::CrossCorrelate: i=" << i << " < 0: DA1_StaticTemp.size() = " << DA1_StaticTemp.size() << endl;
      #endif
      DA1_StaticTemp.resizeAndPreserve(DA1_Static.size()+i);
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i=" << i << " < 0: DA1_MovingTemp.size() = " << DA1_MovingTemp.size() << endl;
      #endif
      DA1_MovingTemp.resizeAndPreserve(DA1_Static.size()+i);
      DA1_Diff.resize(DA1_Static.size()+i);
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i," << i << " < 0: DA1_Static = " << DA1_Static << endl;
        cout << "CFits::CrossCorrelate: i," << i << " < 0: Setting DA1_StaticTemp to DA1_Static(Range(0," << DA1_Static.size() + i - 1 << "))" << endl;
      #endif
      DA1_StaticTemp = DA1_Static(Range(0,DA1_Static.size()+i-1));
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i," << i << " < 0: DA1_moving = " << DA1_Moving << endl;
        cout << "CFits::CrossCorrelate: i," << i << " < 0: Setting DA1_MovingTemp to DA1_Moving(Range(" << 0-i << "," << DA1_Moving.size() - 1 << "))" << endl;
      #endif
      DA1_MovingTemp = DA1_Moving(Range(0-i,DA1_Moving.size()-1));
    } 
    else{
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i=" << i << " >= 0: new array size = " << DA1_Static.size()+i << endl;
      #endif
      DA1_StaticTemp.resize(DA1_Static.size()-i);
      DA1_MovingTemp.resize(DA1_Static.size()-i);
      DA1_Diff.resize(DA1_Static.size()-i);
      DA1_StaticTemp = DA1_Static(Range(i,DA1_Static.size()-1));
      DA1_MovingTemp = DA1_Moving(Range(0,DA1_Moving.size()-i-1));
    }
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelate: DA1_StaticTemp = " << DA1_StaticTemp << endl;
      cout << "CFits::CrossCorrelate: DA1_MovingTemp = " << DA1_MovingTemp << endl;
    #endif

    /// Calculate difference of both arrays and square
    DA1_Diff = DA1_StaticTemp - DA1_MovingTemp;
    DA1_Diff = pow2(DA1_Diff);
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelate: DA1_Diff = " << DA1_Diff << endl;
    #endif

    /// Calculate sum of squares of differences
    DA1_ChiSquare(run) = sum(DA1_Diff) / DA1_Diff.size();
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelate: DA1_ChiSquare(run = " << run << ") = " << DA1_ChiSquare(run) << endl;
    #endif

    /// Save number of pixels used for calculations
    IA1_NPix(run) = DA1_StaticTemp.size();
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelate: IA1_NPix(run = " << run << ") = " << IA1_NPix(run) << endl;
    #endif

    run++;
  }
  /// Normalise DA1_ChiSquare to number of pixels
  DA1_ChiSquare = DA1_ChiSquare / IA1_NPix;
  #ifdef __DEBUG_FITS_CROSSCORRELATE__
    cout << "CFits::CrossCorrelate: DA1_ChiSquare = " << DA1_ChiSquare << endl;
  #endif

  TinyVector<int, 1> TV_MinIndex = minIndex(DA1_ChiSquare);
  D_ChiSquare_Out = DA1_ChiSquare(TV_MinIndex(0));
  I_Out = TV_MinIndex(0) - I_NPixMaxLeft;
  #ifdef __DEBUG_FITS_CROSSCORRELATE__
    cout << "CFits::CrossCorrelate: TV_MinIndex " << TV_MinIndex << endl;
    cout << "CFits::CrossCorrelate: I_Out = " << I_Out << endl;
  #endif
  return true;
}


/**
  CrossCorrelate with Gauss fit to ChiSquare to find subpixel of minimum
 **/
bool CFits::CrossCorrelate(const Array<double, 1> &DA1_Static,
                           const Array<double, 1> &DA1_Moving,
                           int I_NPixMaxLeft,
                           int I_NPixMaxRight,
                           double &D_Out,
                           double &D_ChiSquare_Out) const{
  /// Check that both arrays have the same size
  if (DA1_Moving.size() != DA1_Static.size()){
    cout << "CFits::CrossCorrelate: ERROR: DA1_Moving.size() = " << DA1_Moving.size() << " != DA1_Static.size() = " << DA1_Static.size() << endl;
    return false;
  }

  int I_Size = DA1_Static.size();

  /// Check I_NPixMaxLeft and I_NPixMaxRight
  if (I_NPixMaxLeft >= I_Size){
    I_NPixMaxLeft = I_Size - 1;
    cout << "CFits::CrossCorrelate: Warning: I_NPixMaxLeft too large, set to " << I_NPixMaxLeft << endl;
  }
  if (I_NPixMaxRight >= I_Size){
    I_NPixMaxRight = I_Size - 1;
    cout << "CFits::CrossCorrelate: Warning: I_NPixMaxRight too large, set to " << I_NPixMaxRight << endl;
  }

  int I_Pix = 0. - I_NPixMaxLeft;
  int I_NPixMove = I_NPixMaxLeft + I_NPixMaxRight + 1;
  int run = 0;
  #ifdef __DEBUG_FITS_CROSSCORRELATE__
    cout << "CFits::CrossCorrelate: I_Pix = " << I_Pix << endl;
    cout << "CFits::CrossCorrelate: I_NPixMove = " << I_NPixMove << endl;
  #endif

  Array<double, 1> DA1_StaticTemp(1);
  Array<double, 1> DA1_MovingTemp(1);
  Array<double, 1> DA1_Diff(1);
  Array<double, 1> DA1_ChiSquare(I_NPixMove);
  Array<int, 1> IA1_NPix(I_NPixMove);

  for (int i = I_Pix; i <= I_NPixMaxRight; i++){
    if (i < 0){
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i=" << i << " < 0: new array size = " << DA1_Static.size()+i << endl;
        cout << "CFits::CrossCorrelate: i=" << i << " < 0: DA1_StaticTemp.size() = " << DA1_StaticTemp.size() << endl;
      #endif
      DA1_StaticTemp.resizeAndPreserve(DA1_Static.size()+i);
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i=" << i << " < 0: DA1_MovingTemp.size() = " << DA1_MovingTemp.size() << endl;
      #endif
      DA1_MovingTemp.resizeAndPreserve(DA1_Static.size()+i);
      DA1_Diff.resize(DA1_Static.size()+i);
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i," << i << " < 0: DA1_Static = " << DA1_Static << endl;
        cout << "CFits::CrossCorrelate: i," << i << " < 0: Setting DA1_StaticTemp to DA1_Static(Range(0," << DA1_Static.size() + i - 1 << "))" << endl;
      #endif
      DA1_StaticTemp = DA1_Static(Range(0,DA1_Static.size()+i-1));
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i," << i << " < 0: DA1_moving = " << DA1_Moving << endl;
        cout << "CFits::CrossCorrelate: i," << i << " < 0: Setting DA1_MovingTemp to DA1_Moving(Range(" << 0-i << "," << DA1_Moving.size() - 1 << "))" << endl;
      #endif
      DA1_MovingTemp = DA1_Moving(Range(0-i,DA1_Moving.size()-1));
    } 
    else{
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate: i=" << i << " >= 0: new array size = " << DA1_Static.size()+i << endl;
      #endif
      DA1_StaticTemp.resize(DA1_Static.size()-i);
      DA1_MovingTemp.resize(DA1_Static.size()-i);
      DA1_Diff.resize(DA1_Static.size()-i);
      DA1_StaticTemp = DA1_Static(Range(i,DA1_Static.size()-1));
      DA1_MovingTemp = DA1_Moving(Range(0,DA1_Moving.size()-i-1));
    }
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelate: DA1_StaticTemp = " << DA1_StaticTemp << endl;
      cout << "CFits::CrossCorrelate: DA1_MovingTemp = " << DA1_MovingTemp << endl;
    #endif

    /// Calculate difference of both arrays and square
    DA1_Diff = DA1_StaticTemp - DA1_MovingTemp;
    DA1_Diff = pow2(DA1_Diff);
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelate: DA1_Diff = " << DA1_Diff << endl;
    #endif

    /// Calculate sum of squares of differences
    DA1_ChiSquare(run) = sum(DA1_Diff) / double(DA1_Diff.size());
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelate: DA1_ChiSquare(run = " << run << ") = " << DA1_ChiSquare(run) << endl;
    #endif

    /// Save number of pixels used for calculations
//    IA1_NPix(run) = DA1_StaticTemp.size();
//    #ifdef __DEBUG_FITS_CROSSCORRELATE__
//      cout << "CFits::CrossCorrelate: IA1_NPix(run = " << run << ") = " << IA1_NPix(run) << endl;
//    #endif

    run++;
  }
  /// Normalise DA1_ChiSquare to number of pixels
//  Array<double, 1> DA1_NPix(IA1_NPix.size());
//  if (!this->CastIntArrToDblArr(IA1_NPix, DA1_NPix)){
//    cout << "CFits::CrossCorrelate: ERROR: CastIntArrToDblArr(IA1_NPix) returned FALSE" << endl;
//    returm false;
//  }
//  DA1_ChiSquare = DA1_ChiSquare / DA1_NPix;
  #ifdef __DEBUG_FITS_CROSSCORRELATE__
    cout << "CFits::CrossCorrelate: DA1_ChiSquare = " << DA1_ChiSquare << endl;
  #endif

  
  TinyVector<int, 1> TV_MinIndex = minIndex(DA1_ChiSquare);
  #ifdef __DEBUG_CFITS_CROSSCORRELATE__
    cout << "CFits::CrossCorrelate: TV_MinIndex = " << TV_MinIndex << endl;
    cout << "CFits::CrossCorrelate: DA1_ChiSquare(TV_MinIndex(0)) = " << DA1_ChiSquare(TV_MinIndex(0)) << endl;
  #endif
  if ((TV_MinIndex(0) == 0) || (TV_MinIndex(0) == (DA1_ChiSquare.size()-1))){
    D_Out = double(TV_MinIndex(0) - I_NPixMaxLeft);
    D_ChiSquare_Out = DA1_ChiSquare(TV_MinIndex(0));
  }
  int I_Start = TV_MinIndex(0) - 2;
  if (I_Start < 0)
    I_Start = 0;
  int I_End = TV_MinIndex(0) + 2;
  if (I_End >= DA1_ChiSquare.size())
    I_End = DA1_ChiSquare.size()-1;
  Array<double, 1> *P_D_A1_X = this->DIndGenArr(DA1_ChiSquare.size());
  Array<double, 1> D_A1_X(I_End - I_Start + 1);
  D_A1_X = (*P_D_A1_X)(Range(I_Start, I_End));
  delete(P_D_A1_X);
  Array<double, 1> D_A1_ChiSqu(I_End - I_Start + 1);
  D_A1_ChiSqu = DA1_ChiSquare(Range(I_Start, I_End));
  Array<double, 1> *P_D_A1_MeasureErrors = this->Replicate(1., D_A1_ChiSqu.size());
  Array<double, 1> D_A1_Guess(4);
  D_A1_Guess(0) = max(DA1_ChiSquare);
  D_A1_Guess(1) = 0. - (max(DA1_ChiSquare) - DA1_ChiSquare(TV_MinIndex(0)));
  D_A1_Guess(2) = double(TV_MinIndex(0));
  D_A1_Guess(3) = 2.;
  Array<int, 2> I_A2_Limited(4,2);
  I_A2_Limited(0,0) = 1;
  I_A2_Limited(0,1) = 1;
  I_A2_Limited(1,0) = 1;
  I_A2_Limited(1,1) = 1;
  I_A2_Limited(2,0) = 1;
  I_A2_Limited(2,1) = 1;
  I_A2_Limited(3,0) = 1;
  I_A2_Limited(3,1) = 1;
  Array<double, 2> D_A2_Limits(4,2);
  D_A2_Limits(0,0) = D_A1_Guess(0) / 2.;
  D_A2_Limits(0,1) = D_A1_Guess(0) * 1.1;
  if (D_A2_Limits(0,1) < D_A2_Limits(0,0)){
    cout << "CFits::CrossCorrelate: ERROR: D_A2_Limits(0,1) < D_A2_Limits(0,0)" << endl;
    return false;
  }
  D_A2_Limits(1,0) = 1.5 * D_A1_Guess(1);
  D_A2_Limits(1,1) = 0.;
  if (D_A2_Limits(1,1) < D_A2_Limits(1,0)){
    cout << "CFits::CrossCorrelate: ERROR: D_A2_Limits(1,1) < D_A2_Limits(1,0)" << endl;
    return false;
  }
  D_A2_Limits(2,0) = double(TV_MinIndex(0) - 1);
  D_A2_Limits(2,1) = double(TV_MinIndex(0) + 1);
  if (D_A2_Limits(2,1) < D_A2_Limits(2,0)){
    cout << "CFits::CrossCorrelate: ERROR: D_A2_Limits(2,1) < D_A2_Limits(2,0)" << endl;
    return false;
  }
  D_A2_Limits(3,0) = 0.;
  D_A2_Limits(3,1) = DA1_ChiSquare.size();
  if (D_A2_Limits(3,1) < D_A2_Limits(3,0)){
    cout << "CFits::CrossCorrelate: ERROR: D_A2_Limits(3,1) < D_A2_Limits(3,0)" << endl;
    return false;
  }
  Array<double, 1> D_A1_GaussCoeffs(4);
  D_A1_GaussCoeffs = 0.;
  Array<double, 1> D_A1_EGaussCoeffs(4);
  D_A1_EGaussCoeffs = 0.;
  if (!MPFitGaussLim(D_A1_X,
                     D_A1_ChiSqu,
                     *P_D_A1_MeasureErrors,
                     D_A1_Guess,
                     I_A2_Limited,
                     D_A2_Limits,
                     true,
                     false,
                     D_A1_GaussCoeffs,
                     D_A1_EGaussCoeffs)){
    cout << "CFits::CrossCorrelate: WARNING: GaussFit returned FALSE" << endl;
    //        return false;
  }
  #ifdef __DEBUG_CFITS_CROSSCORRELATE__
    cout << "CFits::CrossCorrelate: D_A1_X = " << D_A1_X << endl;
    cout << "CFits::CrossCorrelate: D_A1_ChiSqu = " << D_A1_ChiSqu << endl;
    cout << "CFits::CrossCorrelate: D_A1_Guess = " << D_A1_Guess << endl;
    cout << "CFits::CrossCorrelate: D_A2_Limits = " << D_A2_Limits << endl;
    cout << "CFits::CrossCorrelate: D_A1_GaussCoeffs = " << D_A1_GaussCoeffs << endl;
  #endif
  D_Out = D_A1_GaussCoeffs(2) - double(I_NPixMaxLeft);
  D_ChiSquare_Out = D_A1_GaussCoeffs(1) + D_A1_GaussCoeffs(0);
  #ifdef __DEBUG_FITS_CROSSCORRELATE__
    cout << "CFits::CrossCorrelate: D_Out = " << D_Out << endl;
    cout << "CFits::CrossCorrelate: D_ChiSquare_Out = " << D_ChiSquare_Out << endl;
  #endif
  return true;
}

/**
  CrossCorrelateAllApertureColsToColNo
 **/
bool CFits::CrossCorrelateAllApertureColsToColNo(int I_Col, int I_NPixMaxUp, int I_NPixMaxDown, Array<int, 1> &IA1_Out, Array<int, 2> &IA2_Out) const{
  int I_NRowsIn = this->P_D_A2_PixArray->rows();
  int I_NColsIn = this->P_D_A2_PixArray->cols();
  int I_Result;
  IA1_Out.resize(this->P_D_A2_PixArray->cols());
  IA1_Out = 0;
  IA2_Out.resize(this->I_NApertures, 2);

  ///Check if TraceFunctionsCalculated
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::CrossCorrelateAllApertureColsToColNo: ERROR: Trace Functions not calculated" << endl;
    return false;
  }

  ///Check I_NPixMaxUp and I_NPixMaxDown
  if (I_NPixMaxUp >= I_NRowsIn){
    I_NPixMaxUp = I_NRowsIn-1;
    cout << "CFits::CrossCorrelateAllApertureColsToColNo: WARNING: I_NPixMaxUp too large - set to " << I_NPixMaxUp << endl;
  }
  if (I_NPixMaxDown >= I_NRowsIn){
    I_NPixMaxDown = I_NRowsIn-1;
    cout << "CFits::CrossCorrelateAllApertureColsToColNo: WARNING: I_NPixMaxDown too large - set to " << I_NPixMaxDown << endl;
  }

  int I_MinCol, I_MaxCol;
  double D_ChiSqTemp = 0.;

  for (int i_ap=0; i_ap < this->I_NApertures; i_ap++){
    I_MinCol = min(floor((*(this->P_D_A2_XCenters))(i_ap,Range::all()) + (*this->P_D_A1_XLow)));
    IA2_Out(i_ap,0) = I_MinCol;
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelateAllApertureColsToColNo: i_ap = " << i_ap << ": I_MinCol = " << I_MinCol << endl;
    #endif
    I_MaxCol = max(ceil((*(this->P_D_A2_XCenters))(i_ap,Range::all()) + (*this->P_D_A1_XHigh)));
    IA2_Out(i_ap,1) = I_MaxCol;
    #ifdef __DEBUG_FITS_CROSSCORRELATE__
      cout << "CFits::CrossCorrelateAllApertureColsToColNo: i_ap = " << i_ap << ": I_MaxCol = " << I_MaxCol << endl;
    #endif
    for (int i=I_MinCol; i <= I_MaxCol; i++){
      if (i == I_Col)
        i++;
      if (!this->CrossCorrelate((*this->P_D_A2_PixArray)(Range::all(), I_Col), (*this->P_D_A2_PixArray)(Range::all(), i), I_NPixMaxUp, I_NPixMaxDown, I_Result, D_ChiSqTemp)){
        cout << "CFits::CrossCorrelateAllApertureColsToColNo: Column " << i << ": ERROR: CrossCorrelate returned FALSE => returning FALSE" << endl;
        return false;
      }
      IA1_Out(i) = I_Result;
    }
  }
  return true;
}

/**
  CalcFeatureOffsets
  Cross-correlates all columns to the column I_Col and calculates the offset of the spectral features with respect to column I_Col and fits the offsets
 **/
bool CFits::CalcFeatureOffsets(int I_Col,
                               int I_NPixMaxUp,
                               int I_NPixMaxDown,
                               int I_Order,
                               Array<int, 1> &I_A1_X_Out,
                               Array<int, 2> &I_A2_ColsMinMax,
                               Array<double, 1> &D_A1_Out,
                               const CString &CS_Mode) const{
  /// Cross-correlate all Aperture columns to column I_Col
  #ifdef __DEBUG_CFITS_CALCFEATUREOFFSETS__
    cout << "CFits::CalcFeatureOffsets: I_Col = " << I_Col << endl;
    cout << "CFits::CalcFeatureOffsets: I_NPixMaxUp = " << I_NPixMaxUp << endl;
    cout << "CFits::CalcFeatureOffsets: I_NPixMaxDown = " << I_NPixMaxDown << endl;
    cout << "CFits::CalcFeatureOffsets: I_Order = " << I_Order << endl;
    cout << "CFits::CalcFeatureOffsets: CS_Mode = " << CS_Mode << endl;
  #endif
  Array<int, 1> I_A1_MeasuredOffsets(1);
  #ifdef __DEBUG_CFITS_CALCFEATUREOFFSETS__
    cout << "CFits::CalcFeatureOffsets: starting CrossCorrelateAllApertureColsToColNo()" << endl;
  #endif
  if (!this->CrossCorrelateAllApertureColsToColNo(I_Col, I_NPixMaxUp, I_NPixMaxDown, I_A1_MeasuredOffsets, I_A2_ColsMinMax)){
    cout << "CFits::CalcFeatureOffsets: ERROR: CrossCorrelateAllApertureColsToColNo() returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_CFITS_CALCFEATUREOFFSETS__
    cout << "CFits::CalcFeatureOffsets: CrossCorrelateAllApertureColsToColNo() ready" << endl;
  #endif

  /// popluate Arrays D_A1_X and D_A1_Y for fitting procedure
  Array<int, 1> I_A1_Where(I_A1_MeasuredOffsets.size());
  int I_NInd = 0;
  int I_NIndThisRun;
  Array<int, 1> I_A1_Ind(this->GetNCols());
//  Array<int, 1> I_A1_IndThisRun(1);
//  Array<int, 1> *P_I_A1_XAll = this->IndGenArr(this->GetNCols());
  #ifdef __DEBUG_CFITS_CALCFEATUREOFFSETS__
    cout << "CFits::CalcFeatureOffsets: Starting for(i_ap=0; i_ap < this->Get_NApertures(=" << this->Get_NApertures() << "); i_ap++)" << endl;
  #endif
  for (int i_col=0; i_col < this->GetNCols(); i_col++){
    for (int i_ap=0; i_ap < this->Get_NApertures(); i_ap++){
      //I_A1_Where = where(((*P_I_A1_XAll) >= I_A2_ColsMinMax(i_ap,0)) && ((*P_I_A1_XAll) <= I_A2_ColsMinMax(i_ap,1)), 1, 0);
      //cout << "CFits::CalcFeatureOffsets: i_ap = " << i_ap << ": I_A1_Where = " << I_A1_Where << endl;
      //if (!this->GetIndex(I_A1_Where, I_NIndThisRun, I_A1_IndThisRun)){
      //  cout << "CFits::CalcFeatureOffsets: ERROR: GetIndex returned FALSE" << endl;
      //  return false;
      //}
      //cout << "CFits::CalcFeatureOffsets: i_ap = " << i_ap << ": GetIndex() ready" << endl;
      //I_A1_Ind.resizeAndPreserve(I_NInd + I_NIndThisRun);
      //cout << "CFits::CalcFeatureOffsets: i_ap = " << i_ap << ": I_A1_Ind.resizeAndPreserve(I_NInd(=" << I_NInd << ") + I_NIndThisRun(= " << I_NIndThisRun << ") ready" << endl;
      //I_A1_Ind(Range(I_NInd, I_NInd + I_NIndThisRun)) = I_A1_IndThisRun;
      //cout << "CFits::CalcFeatureOffsets: i_ap = " << i_ap << ": I_A1_Ind(Range(I_NInd = " << I_NInd << ", I_NInd + I_NIndThisRun = " << I_NInd + I_NIndThisRun << ") ready" << endl;
      //I_NInd += I_NIndThisRun;
      if ((i_col >= I_A2_ColsMinMax(i_ap,0)) && (i_col <= I_A2_ColsMinMax(i_ap,1))){
        I_A1_Ind(I_NInd) = i_col;
        I_NInd++;
      }
    }
  }
  #ifdef __DEBUG_CFITS_CALCFEATUREOFFSETS__
    cout << "CFits::CalcFeatureOffsets: I_NInd set to " << I_NInd << endl;
  #endif
  I_A1_Ind.resizeAndPreserve(I_NInd);
  #ifdef __DEBUG_CFITS_CALCFEATUREOFFSETS__
    cout << "CFits::CalcFeatureOffsets: I_A1_Ind set to " << I_A1_Ind << endl;
  #endif

  I_A1_X_Out.resize(I_A1_Ind.size());
  I_A1_X_Out = I_A1_Ind;
  Array<double, 1> D_A1_X(1);
  Array<double, 1> D_A1_Y(1);
  Array<double, 1> D_A1_MeasuredOffsets(1);
  CastIntArrToDblArr(I_A1_MeasuredOffsets, D_A1_MeasuredOffsets);
  CastIntArrToDblArr(I_A1_Ind, D_A1_X);
  if (!this->GetSubArrCopy(D_A1_MeasuredOffsets,
                           I_A1_Ind,
                           D_A1_Y)){
    cout << "CFits::CalcFeatureOffsets: ERROR: GetSubArrCopy returned FALSE" << endl;
    return false;
  }

  /// write Measured Offsets
  #ifdef __DEBUG_FITS_CALCFEATUREOFFSETS__
    if (!this->WriteArrayToFile(D_A1_Y, CString("/home/azuri/spectra/WiFes/Red/MeasuredOffsets.dat"), CString("ascii"))){
      cout << "CFits::CalcFeatureOffsets: ERROR: this->WriteArrayToFile returned FALSE" << endl;
      return false;
    }
  #endif
  /// run polynomial fitting procedure to fit measured offsets



/// also include and try legendre and chebyshev polynomials!!!


  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args(0) = CString("YFIT");
  void **PP_Args = (void**)malloc(sizeof(void*));
  PP_Args[0] = &D_A1_Out;
  Array<double, 1> D_A1_Coeffs(I_Order + 1);
  if (CS_Mode.EqualValue(CString("Poly"))){
    if (!this->PolyFit(D_A1_X, D_A1_Y, I_Order, CS_A1_Args, PP_Args, &D_A1_Coeffs)){
      cout << "CFits::CalcFeatureOffsets: ERROR: PolyFit returned FALSE" << endl;
      return false;
    }
  } 
  else if (CS_Mode.EqualValue(CString("Chebyshev"))){
    cout << "CFits::CalcFeatureOffsets: ERROR: Chebyshev polynomial not yet implemented" << endl;
    return false;
    if (!this->PolyFit(D_A1_X, D_A1_Y, I_Order, CS_A1_Args, PP_Args, &D_A1_Coeffs)){
      cout << "CFits::CalcFeatureOffsets: ERROR: PolyFit returned FALSE" << endl;
      return false;
    }
  } 
  else if (CS_Mode.EqualValue(CString("Legendre"))){
    cout << "CFits::CalcFeatureOffsets: ERROR: Legendre polynomial not yet implemented" << endl;
    return false;
    if (!this->PolyFit(D_A1_X, D_A1_Y, I_Order, CS_A1_Args, PP_Args, &D_A1_Coeffs)){
      cout << "CFits::CalcFeatureOffsets: ERROR: PolyFit returned FALSE" << endl;
      return false;
    }
  } 
  else{
    cout << "CFits::CalcFeatureOffsets: ERROR: Mode not recognised" << endl;
    return false;
  }

  #ifdef __DEBUG_FITS_CALCFEATUREOFFSETS__
    /// write fitted offsets
    CString CS_FileNameTemp("/home/azuri/spectra/WiFes/Red/FittedOffsets_order");
    cout << "CFits::CalcFeatureOffsets: CS_FileNameTemp = " << CS_FileNameTemp << endl;
    CString *P_CS_Order = CS_FileNameTemp.IToA(I_Order);
    cout << "CFits::CalcFeatureOffsets: *P_CS_Order = " << *P_CS_Order << endl;
    CS_FileNameTemp += (*P_CS_Order);
    cout << "CFits::CalcFeatureOffsets: CS_FileNameTemp = " << CS_FileNameTemp << endl;
    CS_FileNameTemp += CString(".dat");
    cout << "CFits::CalcFeatureOffsets: CS_FileNameTemp = " << CS_FileNameTemp << endl;
    if (!this->WriteArrayToFile(D_A1_Out, CS_FileNameTemp, CString("ascii"))){
      cout << "CFits::CalcFeatureOffsets: ERROR: this->WriteArrayToFile returned FALSE" << endl;
      return false;
    }
    CS_FileNameTemp.Set("/home/azuri/spectra/WiFes/Red/FittedOffsets_x.dat");
    if (!this->WriteArrayToFile(D_A1_X, CS_FileNameTemp, CString("ascii"))){
      cout << "CFits::CalcFeatureOffsets: ERROR: this->WriteArrayToFile returned FALSE" << endl;
      return false;
    }
    cout << "CFits::CalcFeatureOffsets:  WriteArrayToFile finished" << endl;
    delete(P_CS_Order);
  #endif

  /// check result
  Array<double, 1> D_A1_Diff(D_A1_Y.size());
  D_A1_Diff = D_A1_Y - D_A1_Out;
  #ifdef __DEBUG_FITS_CALCFEATUREOFFSETS__
    cout << "CFits::CalcFeatureOffsets: D_A1_Diff = " << D_A1_Diff << endl;
  #endif
  return true;
}

/**
      Shift
        Shifts column D_A1_In by D_Offset
        D_Offset < 0: shift up
        D_Offset > 0: shift down
 **/
bool CFits::Shift(Array<double, 1> &D_A1_InOut,
                  double D_Offset,
                  const Array<CString, 1> &CS_A1_In) const{
#ifdef __DEBUG_FITS_SHIFT__
  cout << "CFits::Shift: D_A1_InOut = " << D_A1_InOut << endl;
  cout << "CFits::Shift: D_Offset = " << D_Offset << endl;
#endif
  int len = D_A1_InOut.size();
  Array<double, 1> *P_D_A1_Row = this->DIndGenArr(len);
  Array<double, 1> D_A1_XNew(len);
  D_A1_XNew = (*P_D_A1_Row) - D_Offset;

  Array<double, 1> D_A1_InterPol(1);
  if (!this->InterPol(D_A1_InOut, *P_D_A1_Row, D_A1_XNew, CS_A1_In, D_A1_InterPol)){
    cout << "CFits::Shift: ERROR: InterPol returned FALSE" << endl;
    return false;
  }
#ifdef __DEBUG_FITS_SHIFT__
  cout << "CFits::Shift: InterPol finished, D_A1_InterPol = " << D_A1_InterPol << endl;
#endif
  D_A1_InOut = D_A1_InterPol;

  /// clean up
  P_D_A1_Row->resize(0);
  return true;
}

/**
  ShiftColumns
    Shifts columns I_A1_Cols of D_A2_In by D_A1_Offset
    I_A1_Cols and D_A1_Offset must have same length
    D_Offset < 0: shift up
    D_Offset > 0: shift down
 **/
bool CFits::ShiftColumns(Array<double, 2> &D_A2_InOut,
                         const Array<int, 1> &I_A1_Cols,
                         const Array<double, 1> &D_A1_Offset,
                         const Array<CString, 1> &CS_A1_In) const{
//  cout << "CFits::Shift: D_A2_InOut = " << D_A2_InOut << endl;
#ifdef __DEBUG_FITS_SHIFT__
  cout << "CFits::ShiftColumns(3): I_A1_Cols = " << I_A1_Cols << endl;
  cout << "CFits::ShiftColumns(3): D_A1_Offset = " << D_A1_Offset << endl;
#endif
  Array<double, 2> D_A2_Temp(D_A2_InOut.rows(), D_A2_InOut.cols());
  D_A2_Temp = D_A2_InOut;
  /// check sizes of I_A1_Cols and D_A1_Offset
  if (I_A1_Cols.size() < 1 || I_A1_Cols.size() >= D_A2_InOut.cols()){
    cout << "CFits::ShiftColumns: ERROR: Something is wrong with the size of I_A1_Cols" << endl;
    return false;
  }
  if (I_A1_Cols.size() != D_A1_Offset.size()){
    cout << "CFits::ShiftColumns: ERROR: sizes of I_A1_Cols and D_A1_Offset not the same" << endl;
    return false;
  }
  Array<double, 1> D_A1_Col(D_A2_InOut.rows());
  for (int i=0; i<I_A1_Cols.size(); i++){
    D_A1_Col = D_A2_InOut(Range::all(), I_A1_Cols(i));
    if (!this->Shift(D_A1_Col, D_A1_Offset(i), CS_A1_In)){
      cout << "CFits::ShiftColumns: ERROR: Shift() returned FALSE" << endl;
      return false;
    }
    D_A2_Temp(Range::all(), I_A1_Cols(i)) = D_A1_Col;
  }
  D_A2_InOut = D_A2_Temp;
  return true;
}

/**
  ShiftColumns
    Shifts columns I_A1_Cols of this->P_D_A2_PixArray by D_A1_Offset
    I_A1_Cols and D_A1_Offset must have same length
    D_Offset < 0: shift up
    D_Offset > 0: shift down
  **/
bool CFits::ShiftColumns(const Array<int, 1> &I_A1_Cols,
                         const Array<double, 1> &D_A1_Offset,
                         const Array<CString, 1> &CS_A1_In){
#ifdef __DEBUG_FITS_SHIFT__
  cout << "CFits::ShiftColumns(2): I_A1_Cols = " << I_A1_Cols << endl;
  cout << "CFits::ShiftColumns(2): D_A1_Offset = " << D_A1_Offset << endl;
#endif
  return(this->ShiftColumns((*this->P_D_A2_PixArray), I_A1_Cols, D_A1_Offset, CS_A1_In));
}

/**
  CalculateFeatureOffsetAndShiftAllImages
   - calculates Feature Offsets for spectral features with respect to colum I_ColWithRespectTo of image CS_ArcFile, straightens the spectral features in images in CS_FileListToShift, and writes them to images in CS_FileListOut (See CalcFeatureOffsets)
   - NOTE: only works if spectral features in one aperture all have the same curvature
 **/
bool CFits::CalculateFeatureOffsetAndShiftAllImages(const CString &CS_ArcFile,
                                                    const CString &CS_ArcDatabaseFile,
                                                    const CString &CS_FileListToShift,
                                                    const CString &CS_FileListOut,
                                                    int I_ColWithRespectTo,
                                                    int I_NPixMaxUp,
                                                    int I_NPixMaxDown,
                                                    int I_FitOrder,
                                                    const CString &CS_Mode) const{
  Array<CString, 2> CS_A2_FileListIn(2,2);
  if (!this->ReadFileToStrArr(CS_FileListToShift, CS_A2_FileListIn, CString(" "))){
    cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: ReadFileToStrArr returned FALSE" << endl;
    return false;
  }
  Array<CString, 2> CS_A2_FileListOut(2,2);
  if (!this->ReadFileToStrArr(CS_FileListOut, CS_A2_FileListOut, CString(" "))){
    cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: ReadFileToStrArr returned FALSE" << endl;
    return false;
  }

  ///Create ArcFits
  CFits CF_ArcFile;
  CFits CF_ToShift;
  if (!CF_ArcFile.SetFileName(CS_ArcFile)){
    cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ArcFile.SetFileName(" << CS_ArcFile << ") returned FALSE" << endl;
    return false;
  }
  if (!CF_ArcFile.ReadArray()){
    cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ArcFile.ReadArray() returned FALSE" << endl;
    return false;
  }
  if (!CF_ArcFile.SetDatabaseFileName(CS_ArcDatabaseFile)){
    cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ArcFile.SetFileName(" << CS_ArcFile << ") returned FALSE" << endl;
    return false;
  }
  if (!CF_ArcFile.ReadDatabaseEntry()){
    cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ArcFile.ReadDatabaseEntry() returned FALSE" << endl;
    return false;
  }
  if (!CF_ArcFile.CalcTraceFunctions()){
    cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ArcFile.CalcTraceFunction() returned FALSE" << endl;
    return false;
  }

  ///Calculate Feature Offsets for every column in an aperture
  Array<int, 1> I_A1_X(1);
  Array<int, 2> I_A2_ColsMinMax(2,2);
  Array<double, 1> D_A1_FeatureOffsets(1);

  if (!CF_ArcFile.CalcFeatureOffsets(I_ColWithRespectTo, I_NPixMaxUp, I_NPixMaxDown, I_FitOrder, I_A1_X, I_A2_ColsMinMax, D_A1_FeatureOffsets, CString("Poly"))){
    cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ArcFile.CalcFeatureOffsets() returned FALSE" << endl;
    return false;
  }

  /// Calculate minimum shift per aperture
  Array<int, 1> I_A1_Where(I_A1_X.size());
  Array<int, 1> I_A1_Indices(1);
  double D_MinShift, D_MaxShift, D_Shift, D_ShiftOffset;
  int I_NInd, I_MinInd, I_MaxInd;
  Array<double, 1> D_A1_Temp(2);
  for (int i=0; i < this->Get_NApertures(); i++){
    cout << "i = " << i << ": I_A1_X = " << I_A1_X << endl;
    cout << "i = " << i << ": I_A2_ColsMinMax(i,0) = " << I_A2_ColsMinMax(i,0) << endl;
    cout << "i = " << i << ": I_A2_ColsMinMax(i,1) = " << I_A2_ColsMinMax(i,1) << endl;

    I_A1_Where = where(I_A1_X == I_A2_ColsMinMax(i,0),1,0);
    cout << "i = " << i << ": I_A1_Where = " << I_A1_Where << endl;
    this->GetIndex(I_A1_Where, I_NInd, I_A1_Indices);
    cout << "i = " << i << ": I_NInd = " << I_NInd << ", I_A1_Indices = " << I_A1_Indices << endl;
    I_MinInd = I_A1_Indices(0);
    cout << "i = " << i << ": I_MinInd = " << I_MinInd << endl;
    D_MinShift = D_A1_FeatureOffsets(I_MinInd);
    cout << "i =" << i << ": D_MinShift = " << D_MinShift << endl;

    I_A1_Where = where(I_A1_X == I_A2_ColsMinMax(i,1),1,0);
    this->GetIndex(I_A1_Where, I_NInd, I_A1_Indices);
    cout << "i = " << i << ": I_NInd = " << I_NInd << ", I_A1_Indices = " << I_A1_Indices << endl;
    I_MaxInd = I_A1_Indices(0);
    cout << "i = " << i << ": I_MaxInd = " << I_MaxInd << endl;
    D_MaxShift = D_A1_FeatureOffsets(I_MaxInd);
    cout << "i =" << i << ": D_MaxShift = " << D_MaxShift << endl;

    if (D_MinShift > D_MaxShift)
      this->Swap(D_MinShift, D_MaxShift);

/**    if (this->Signum(D_MinShift) == this->Signum(D_MaxShift)){
    D_A1_Temp(0) = D_MinShift;
    D_A1_Temp(1) = D_MaxShift;
    D_Shift = min(fabs(D_A1_Temp));

    if (abs(D_Shift - abs(D_MinShift)) < 0.000000001){/// min(D_MinShift, D_MaxShift) = D_MinShift
    if (D_MinShift < 0.)
    D_Shift = 0. - D_Shift;
  }
    else if (abs(D_Shift - abs(D_MaxShift)) < 0.000000001){/// min(D_MinShift, D_MaxShift) = D_MaxShift
    if (D_MaxShift < 0.)
    D_Shift = 0. - D_Shift;
  }
    cout << "i=" << i << ": D_Shift = " << D_Shift << endl;

  } else{
    D_Shift = 0.;
  }
    D_ShiftOffset = (D_MaxShift - D_MinShift) / 2.;
    if (D_MaxShift > 0.){

  }**/

    D_Shift = ((D_MaxShift - D_MinShift) / 2.);// + D_MinShift;
    cout << "i = " << i << ": D_Shift = " << D_Shift << endl;

    D_A1_FeatureOffsets(Range(I_MinInd, I_MaxInd)) = D_A1_FeatureOffsets(Range(I_MinInd, I_MaxInd))
        - D_MinShift
        - D_Shift;
    cout << "i = " << i << ": D_A1_FeatureOffsets(Range(I_MinInd=" << I_MinInd << ", I_MaxInd=" << I_MaxInd << ") = " << D_A1_FeatureOffsets(Range(I_MinInd, I_MaxInd)) << endl;
  }

  ///Shift columns in every aperture for every image in CS_A2_FileListIn
  Array<CString, 1> CS_A1_Temp(1);
  CS_A1_Temp(0) = CString(" ");
  for (int i_file=0; i_file < CS_A2_FileListIn.rows(); i_file++){
    if (!CF_ToShift.SetFileName(CS_A2_FileListIn(i_file,0))){
      cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ToShift.SetFileName(" << CS_A2_FileListIn(i_file,0) << ") returned FALSE" << endl;
      return false;
    }
    if (!CF_ToShift.ReadArray()){
      cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ToShift.ReadArray() returned FALSE" << endl;
      return false;
    }
    ///Shift Columns for every file

    if (!CF_ToShift.ShiftColumns(I_A1_X, D_A1_FeatureOffsets, CS_A1_Temp)){
      cout << "CFtits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ToShift.ShiftColumns() returned FALSE" << endl;
    }
    if (!CF_ToShift.SetFileName(CS_A2_FileListOut(i_file,0))){
      cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ToShift.SetFileName(" << CS_A2_FileListOut(i_file,0) << ") returned FALSE" << endl;
      return false;
    }
    if (!CF_ToShift.WriteArray()){
      cout << "CFits::CalculateFeatureOffsetAndShiftAllImages: ERROR: CF_ToShift.WriteArray() returned FALSE" << endl;
      return false;
    }
  }/// end for all files in CS_FileListToShift
  return true;
}

bool CFits::CastIntArrToDblArr(const Array<int, 1> &I_A1_In, Array<double, 1> &D_A1_Out) const{
  D_A1_Out.resize(I_A1_In.size());
  for (int i=0; i<I_A1_In.size(); i++){
    D_A1_Out(i) = I_A1_In(i);
  }
  return true;
}

bool CFits::CastIntArrToDblArr(const Array<int, 2> &I_A2_In, Array<double, 2> &D_A2_Out) const{
  D_A2_Out.resize(I_A2_In.rows(), I_A2_In.cols());
  for (int i_row=0; i_row<I_A2_In.rows(); i_row++){
    for (int i_col=0; i_col<I_A2_In.cols(); i_col++){
      D_A2_Out(i_row, i_col) = (double)(I_A2_In(i_row, i_col));
    }
  }
  return true;
}

/**
  GetSubArrCopy(Array<double, 1> &DA1_In, Array<int, 1> &IA1_Indices, Array<double, 1> &DA1_Out) const
 **/
bool CFits::GetSubArrCopy(const Array<double, 1> &DA1_In,
                          const Array<int, 1> &IA1_Indices,
                          Array<double, 1> &DA1_Out) const
{
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
  cout << "CFits::GetSubArrCopy: IA1_Indices = " << IA1_Indices << endl;
#endif
  DA1_Out.resize(IA1_Indices.size());
  if (DA1_In.size() < max(IA1_Indices)){
    cout << "CFits::GetSubArrCopy: ERROR: DA1_In.size(=" << DA1_In.size() << ") < max(IA1_Indices=" << max(IA1_Indices) << endl;
    return false;
  }
  for (int m = 0; m < IA1_Indices.size(); m++)
  {
    DA1_Out(m) = DA1_In(IA1_Indices(m));
  }
  return true;
}

/**
  GetSubArr(Array<double, 1> &DA1_In, Array<int, 1> &IA1_Indices) const
  Copies the adresses of DA1_In(IA1_Indices) to IA1_Out
 **/
Array<double, 1>& CFits::GetSubArr(const Array<double, 1> &D_A1_In, const Array<int, 1> &I_A1_Indices) const
{
  Array<double, 1> *P_D_A1_Out = new Array<double, 1>(I_A1_Indices.size());
///  for (int l=0; l < I_A1_Indices.size(); l++)
///    &((*P_D_A1_Out)(l)) = &(D_A1_In(I_A1_Indices(l)));
  //  Array<double, 1>::iterator pdm1 = const_cast<Array<double, 1>*>(&D_A1_In)->begin();
  Array<double, 1>::iterator pdm2 = P_D_A1_Out->begin();
  Array<double, 1>::iterator pend = P_D_A1_Out->end();
  Array<int, 1>::iterator pind = const_cast<Array<int, 1>*>(&I_A1_Indices)->begin();
  for (; pdm2 != pend; ++pdm2, ++pind)
    *pdm2 = D_A1_In(*pind);
/**  double d_temp = D_A1_In(I_A1_Indices(0));
  (*P_D_A1_Out)(0) = 2. * d_temp;
  cout << "CFits::GetSubArr: &((*P_D_A1_Out)(0)) = " << &((*P_D_A1_Out)(0)) << endl;
  cout << "CFits::GetSubArr: &(D_A1_In(I_A1_Indices(0))) = " << &(D_A1_In(I_A1_Indices(0))) << endl;
  cout << "CFits::GetSubArr: (*P_D_A1_Out)(0) = " << (*P_D_A1_Out)(0) << endl;
  cout << "CFits::GetSubArr: D_A1_In(I_A1_Indices(0)) = " << D_A1_In(I_A1_Indices(0)) << endl;
  (*P_D_A1_Out)(0) = d_temp;**/
  return *P_D_A1_Out;
}

/**
  GetSubArrCopy(Array<int, 1> &IA1_In, Array<int, 1> &IA1_Indices, Array<int, 1> &IA1_Out) const
  Copies the values of IA1_In(IA1_Indices) to IA1_Out
 **/
bool CFits::GetSubArrCopy(const Array<int, 1> &IA1_In,
                          const Array<int, 1> &IA1_Indices,
                          Array<int, 1> &IA1_Out) const
{
  if (IA1_In.size() < max(IA1_Indices)){
    cout << "CFits::GetSubArrCopy: ERROR: IA1_In.size() < max(IA1_Indices)." << endl;
    return false;
  }
  if (IA1_Indices.size() < 0){
    cout << "CFits::GetSubArrCopy: ERROR: IA1_Indices.size < 0" << endl;
    return false;
  }
  if (IA1_Indices(0) < 0){
    cout << "CFits::GetSubArrCopy: ERROR: IA1_Indices(0) = " << IA1_Indices(0) << " < 0" << endl;
    return false;
  }
  IA1_Out.resize(IA1_Indices.size());
  for (int m = 0; m < IA1_Indices.size(); m++)
  {
    IA1_Out(m) = IA1_In(IA1_Indices(m));
  }
  return true;
}

/**
  GetSubArr(Array<int, 1> &IA1_In, Array<int, 1> &IA1_Indices, Array<int, 1> &IA1_Out) const
  Copies the adresses of IA1_In(IA1_Indices) to IA1_Out
 **/
Array<int, 1>& CFits::GetSubArr(const Array<int, 1> &I_A1_In, const Array<int, 1> &I_A1_Indices) const
{
  Array<int, 1> *P_I_A1_Out = new Array<int, 1>(I_A1_Indices.size());
  Array<int, 1>::iterator pdm2 = P_I_A1_Out->begin();
  Array<int, 1>::iterator pend = P_I_A1_Out->end();
  Array<int, 1>::iterator pind = const_cast<Array<int, 1>*>(&I_A1_Indices)->begin();
  for (; pdm2 != pend; ++pdm2, ++pind)
    *pdm2 = I_A1_In(*pind);
  return *P_I_A1_Out;
}


/**
  GetSubArrCopy(Array<double, 2> &DA2_In, Array<int, 1> &IA1_Indices, int I_Mode_In, Array<double, 2> &DA2_Out) const
  Copies the values of DA2_In(*,IA1_Indices) or DA2_In(IA1_Indices,*) to DA1_Out
  I_Mode_In: 0: IA1_Indices are row numbers
             1: IA1_Indices are column numbers
 **/
bool CFits::GetSubArrCopy(const Array<double, 2> &DA2_In,
                          const Array<int, 1> &I_A1_Indices,
                          int I_Mode_In,
                          Array<double, 2> &DA2_Out) const
{
  int row, col;
  if (I_Mode_In > 1){
    cout << "CFits::GetSubArrCopy: ERROR: I_Mode_In > 1" << endl;
    return false;
  }
  if (I_Mode_In == 0){
    if (max(I_A1_Indices) >= DA2_In.rows()){
      cout << "CFits::GetSubArrCopy: ERROR: max(I_A1_Indices) >= DA2_In.rows()" << endl;
      return false;
    }
    DA2_Out.resize(I_A1_Indices.size(),DA2_In.cols());
  }
  else{// if (I_Mode_In == 1){
    if (max(I_A1_Indices) >= DA2_In.cols()){
      cout << "CFits::GetSubArrCopy: ERROR: max(I_A1_Indices) >= DA2_In.cols()" << endl;
      return false;
    }
    DA2_Out.resize(DA2_In.rows(),I_A1_Indices.size());
  }
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
  cout << "CFits::GetSubArrCopy: DA2_In.rows() " << DA2_In.rows() << endl;
  cout << "CFits::GetSubArrCopy: DA2_In.cols() " << DA2_In.cols() << endl;
#endif

  row = -1;
  col = -1;
  for (int m=0; m < I_A1_Indices.size(); m++){
    if (I_Mode_In == 0){
      DA2_Out(m,Range::all()) = DA2_In(I_A1_Indices(m),Range::all());
    }
    else{// if (I_Mode_In == 1){
      DA2_Out(Range::all(),m) = DA2_In(Range::all(),I_A1_Indices(m));
    }
  }
  return true;
}

/**
  GetSubArrCopy(Array<double, 2> &DA2_In, Array<int, 1> &IA1_Indices, int I_Mode_In, Array<double, 1> &DA1_Out) const
  Copies the values of DA2_In(*,IA1_Indices) or DA2_In(IA1_Indices,*) to DA1_Out
  I_Mode_In: 0: IA1_Indices are running numbers going through rows, then cols
             1: IA1_Indices are running numbers going through cols, then rows
 **/
bool CFits::GetSubArrCopy(const Array<double, 2> &DA2_In,
                          const Array<int, 1> &I_A1_Indices,
                          int I_Mode_In,
                          Array<double, 1> &DA1_Out) const
{
  int row, col;
  if (I_Mode_In > 1){
    cout << "CFits::GetSubArrCopy: ERROR: I_Mode_In > 1" << endl;
    return false;
  }
  if (max(I_A1_Indices) >= DA2_In.rows() * DA2_In.cols()){
    cout << "CFits::GetSubArrCopy: ERROR: max(I_A1_Indices)=" << I_A1_Indices << " >= DA2_In.rows(=" << DA2_In.rows() << ") * DA2_In.cols(=" << DA2_In.cols() << ")" << endl;
    return false;
  }
  DA1_Out.resize(I_A1_Indices.size());
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
  cout << "CFits::GetSubArrCopy: DA2_In.rows() " << DA2_In.rows() << endl;
  cout << "CFits::GetSubArrCopy: DA2_In.cols() " << DA2_In.cols() << endl;
#endif

  row = -1;
  col = -1;
  for (int m=0; m < I_A1_Indices.size(); m++){
    if (I_Mode_In == 0){
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
      cout << "CFits::GetSubArrCopy: I_A1_Indices(m=" << m << ") = " << I_A1_Indices(m) << endl;
#endif
      row = I_A1_Indices(m) % DA2_In.rows();
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
      cout << "CFits::GetSubArrCopy: row set to " << row << endl;
#endif
      col = int(I_A1_Indices(m) / DA2_In.rows());
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
      cout << "CFits::GetSubArrCopy: col set to " << col << endl;
#endif
      DA1_Out(m) = DA2_In(row,col);
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
      cout << "CFits::GetSubArrCopy: DA1_Out(m) set to " << DA1_Out(m) << endl;
#endif
    }
    else{// if(I_Mode_In == 1){
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
      cout << "CFits::GetSubArrCopy: I_A1_Indices(m=" << m << ") = " << I_A1_Indices(m) << endl;
#endif
      col = I_A1_Indices(m) % DA2_In.cols();
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
      cout << "CFits::GetSubArrCopy: col set to " << col << endl;
#endif
      row = int(I_A1_Indices(m) / DA2_In.cols());
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
      cout << "CFits::GetSubArrCopy: row set to " << row << endl;
#endif
      DA1_Out(m) = DA2_In(row,col);
#ifdef __DEBUG_FITS_GETSUBARRCOPY__
      cout << "CFits::GetSubArrCopy: DA1_Out(m) set to " << DA1_Out(m) << endl;
#endif
    }
  }
  return true;
}

/**
  GetSubArr(Array<double, 1> &DA1_In, Array<double, 1> &IA1_Indices) const
  Copies the adresses of DA1_In(IA1_Indices) to IA1_Out
  I_Mode_In: 0: IA1_Indices are row numbers
             1: IA1_Indices are column numbers
             2: IA1_Indices are running numbers going through rows, then cols: rows=5, cols=7, Ind=10 => (0,2)
             3: IA1_Indices are running numbers going through cols, then rows: rows=5, cols=7, Ind=10 => (1,3)
 **/
Array<double, 2>& CFits::GetSubArr(const Array<double, 2> &D_A2_In,
                                   const Array<int, 1> &I_A1_Indices,
                                   int I_Mode_In) const
{
  int nrows,ncols,row,col;
  if (I_Mode_In == 0){
    nrows = I_A1_Indices.size();
    ncols = D_A2_In.cols();
  }
  else if (I_Mode_In == 1){
    ncols = I_A1_Indices.size();
    nrows = D_A2_In.rows();
  }
  else{
    nrows = I_A1_Indices.size();
    ncols = 1;
  }

  Array<double,2> *P_D_A2_Out = new Array<double,2>(nrows,ncols);

  for (int m=0; m < I_A1_Indices.size(); m++){
    if (I_Mode_In == 0){
      (*P_D_A2_Out)(m,Range::all()) = D_A2_In(I_A1_Indices(m),Range::all());
    }
    else if (I_Mode_In == 1){
      (*P_D_A2_Out)(Range::all(),m) = D_A2_In(Range::all(),I_A1_Indices(m));
    }
    else if (I_Mode_In == 2){
      cout << "CFits::GetSubArr: I_A1_Indices(m=" << m << ") = " << I_A1_Indices(m) << endl;
      row = I_A1_Indices(m) % nrows;
      cout << "CFits::GetSubArr: row set to " << row << endl;
      col = int(I_A1_Indices(m) / nrows);
      cout << "CFits::GetSubArr: col set to " << col << endl;
      (*P_D_A2_Out)(m,0) = D_A2_In(row,col);
      cout << "CFits::GetSubArr: DA2_Out(m,0) set to " << (*P_D_A2_Out)(m,0) << endl;
    }
    else if (I_Mode_In == 3){
      cout << "CFits::GetSubArr: I_A1_Indices(m=" << m << ") = " << I_A1_Indices(m) << endl;
      col = I_A1_Indices(m) % ncols;
      cout << "CFits::GetSubArr: col set to " << col << endl;
      row = int(I_A1_Indices(m) / ncols);
      cout << "CFits::GetSubArr: row set to " << row << endl;
      (*P_D_A2_Out)(m,0) = D_A2_In(row,col);
      cout << "CFits::GetSubArr: DA2_Out(m,0) set to " << (*P_D_A2_Out)(m,0) << endl;
    }
  }
  return (*P_D_A2_Out);
}

/**
  GetSubArrCopy(Array<int, 2> &IA2_In, Array<int, 1> &IA1_Indices, int I_Mode_In, Array<int, 2> &IA2_Out) const
  Copies the values of IA1_In(IA1_Indices) to IA1_Out
  I_Mode_In: 0: IA1_Indices are row numbers
             1: IA1_Indices are column numbers
 **/
bool CFits::GetSubArrCopy(const Array<int, 2> &I_A2_In,
                          const Array<int, 1> &I_A1_Indices,
                          int I_Mode_In,
                          Array<int, 2> &I_A2_Out) const
{
  int row, col;
  if (I_Mode_In > 1){
    cout << "CFits::GetSubArrCopy: ERROR: I_Mode_In > 1" << endl;
    return false;
  }
  if (I_Mode_In == 0){
    I_A2_Out.resize(I_A1_Indices.size(),I_A2_In.cols());
    if (max(I_A1_Indices) >= I_A2_In.rows()){
      cout << "CFits::GetSubArrCopy: ERROR: max(I_A1_Indices) >= I_A2_In.rows()" << endl;
      return false;
    }
  }
  else{// if (I_Mode_In == 1){
    I_A2_Out.resize(I_A2_In.rows(),I_A1_Indices.size());
    if (max(I_A1_Indices) >= I_A2_In.cols()){
      cout << "CFits::GetSubArrCopy: ERROR: max(I_A1_Indices) >= I_A2_In.cols()" << endl;
      return false;
    }
  }

  for (int m=0; m < I_A1_Indices.size(); m++){
    if (I_Mode_In == 0){
      I_A2_Out(m,Range::all()) = I_A2_In(I_A1_Indices(m),Range::all());
    }
    else{// if (I_Mode_In == 1){
      I_A2_Out(Range::all(),m) = I_A2_In(Range::all(),I_A1_Indices(m));
    }
  }
  return true;
}

/**
  GetSubArrCopy(Array<int, 2> &IA2_In, Array<int, 1> &IA1_Indices, int I_Mode_In, Array<int, 1> &IA1_Out) const
  Copies the values of IA1_In(IA1_Indices) to IA1_Out
  I_Mode_In: 0: IA1_Indices are running numbers going through rows, then cols: rows=5, cols=7, Ind=10 => (0,2)
             1: IA1_Indices are running numbers going through cols, then rows: rows=5, cols=7, Ind=10 => (1,3)
 **/
bool CFits::GetSubArrCopy(const Array<int, 2> &I_A2_In,
                          const Array<int, 1> &I_A1_Indices,
                          int I_Mode_In,
                          Array<int, 1> &I_A1_Out) const
{
  int row, col;
  if (I_Mode_In > 1){
    cout << "CFits::GetSubArrCopy: ERROR: I_Mode_In > 1" << endl;
    return false;
  }
  I_A1_Out.resize(I_A1_Indices.size());
  if (max(I_A1_Indices) >= I_A2_In.rows() * I_A2_In.cols()){
    cout << "CFits::GetSubArrCopy: ERROR: max(I_A1_Indices) >= I_A2_In.rows() * I_A2_In.cols()" << endl;
    return false;
  }

  for (int m=0; m < I_A1_Indices.size(); m++){
    if (I_Mode_In == 0){
      cout << "CFits::GetSubArrCopy: I_A1_Indices(m=" << m << ") = " << I_A1_Indices(m) << endl;
      row = I_A1_Indices(m) % I_A2_In.rows();
      cout << "CFits::GetSubArrCopy: row set to " << row << endl;
      col = int(I_A1_Indices(m) / I_A2_In.rows());
      cout << "CFits::GetSubArrCopy: col set to " << col << endl;
      I_A1_Out(m) = I_A2_In(row,col);
      cout << "CFits::GetSubArrCopy: I_A1_Out(m) set to " << I_A1_Out(m) << endl;
    }
    else{// if (I_Mode_In == 3){
      cout << "CFits::GetSubArrCopy: I_A1_Indices(m=" << m << ") = " << I_A1_Indices(m) << endl;
      col = I_A1_Indices(m) % I_A2_In.cols();
      cout << "CFits::GetSubArrCopy: col set to " << col << endl;
      row = int(I_A1_Indices(m) / I_A2_In.cols());
      cout << "CFits::GetSubArrCopy: row set to " << row << endl;
      I_A1_Out(m) = I_A2_In(row,col);
      cout << "CFits::GetSubArrCopy: I_A1_Out(m) set to " << I_A1_Out(m) << endl;
    }
  }
  return true;
}

/**
  GetSubArr(Array<int, 1> &IA1_In, Array<int, 1> &IA1_Indices,
  Array<int, 1> &IA1_Out) const
  Copies the adresses of IA1_In(IA1_Indices) to IA1_Out
  I_Mode_In: 0: IA1_Indices are row numbers
             1: IA1_Indices are column numbers
             2: IA1_Indices are running numbers going through rows, then cols: rows=5, cols=7, Ind=10 => (0,2)
             3: IA1_Indices are running numbers going through cols, then rows: rows=5, cols=7, Ind=10 => (1,3)
 **/
Array<int, 2>& CFits::GetSubArr(const Array<int, 2> &I_A2_In,
                                const Array<int, 1> &I_A1_Indices,
                                int I_Mode_In) const
{
  int nrows,ncols,row,col;
  if (I_Mode_In == 0){
    nrows = I_A1_Indices.size();
    ncols = I_A2_In.cols();
  }
  else if (I_Mode_In == 1){
    ncols = I_A1_Indices.size();
    nrows = I_A2_In.rows();
  }
  else{
    nrows = I_A1_Indices.size();
    ncols = 1;
  }

  Array<int,2> *P_I_A2_Out = new Array<int,2>(nrows,ncols);

  for (int m=0; m < I_A1_Indices.size(); m++){
    if (I_Mode_In == 0){
      (*P_I_A2_Out)(m,Range::all()) = I_A2_In(I_A1_Indices(m),Range::all());
    }
    else if (I_Mode_In == 1){
      (*P_I_A2_Out)(Range::all(),m) = I_A2_In(Range::all(),I_A1_Indices(m));
    }
    else if (I_Mode_In == 2){
      cout << "CFits::GetSubArr: I_A1_Indices(m=" << m << ") = " << I_A1_Indices(m) << endl;
      row = I_A1_Indices(m) % nrows;
      cout << "CFits::GetSubArr: row set to " << row << endl;
      col = int(I_A1_Indices(m) / nrows);
      cout << "CFits::GetSubArr: col set to " << col << endl;
      (*P_I_A2_Out)(m,0) = I_A2_In(row,col);
      cout << "CFits::GetSubArr: I_A2_Out(m,0) set to " << (*P_I_A2_Out)(m,0) << endl;
    }
    else if (I_Mode_In == 3){
      cout << "CFits::GetSubArr: I_A1_Indices(m=" << m << ") = " << I_A1_Indices(m) << endl;
      col = I_A1_Indices(m) % ncols;
      cout << "CFits::GetSubArr: col set to " << col << endl;
      row = int(I_A1_Indices(m) / ncols);
      cout << "CFits::GetSubArr: row set to " << row << endl;
      (*P_I_A2_Out)(m,0) = I_A2_In(row,col);
      cout << "CFits::GetSubArr: P_I_A2_Out(m,0) set to " << (*P_I_A2_Out)(m,0) << endl;
    }
  }
  return (*P_I_A2_Out);
}

/**
  GetSubArr(Array<double, 1> &DA1_In, Array<int, 3> &I_A3_Indices) const
  Copies the adresses of DA1_In(I_A3_Indices(row,col,0), I_A3_Indices(row,col,1)) to D_A2_Out
**/
Array<double, 2>& CFits::GetSubArr(const Array<double, 2> &D_A2_In, const Array<int, 3> &I_A3_Indices) const{
  Array<double, 2> *P_D_A2_Out = new Array<double, 2>(I_A3_Indices.rows(), I_A3_Indices.cols());
  for (int u=0; u < I_A3_Indices.rows(); u++){
    for (int v=0; v < I_A3_Indices.cols(); v++){
      (*P_D_A2_Out)(u,v) = D_A2_In(I_A3_Indices(u,v,0), I_A3_Indices(u,v,1));
    }
  }
  return (*P_D_A2_Out);
}

/**
  GetSubArr(Array<int, 2> &I_A2_In, Array<int, 1> &I_A3_Indices) const
  Copies the adresses of I_A1_In(I_A3_Indices(row,col,0), I_A3_Indices(row,col,1)) to I_A2_Out
  **/
Array<int, 2>& CFits::GetSubArr(const Array<int, 2> &I_A2_In, const Array<int, 3> &I_A3_Indices) const{
  Array<int, 2> *P_I_A2_Out = new Array<int, 2>(I_A3_Indices.rows(), I_A3_Indices.cols());
  for (int u=0; u < I_A3_Indices.rows(); u++){
    for (int v=0; v < I_A3_Indices.cols(); v++){
      (*P_I_A2_Out)(u,v) = I_A2_In(I_A3_Indices(u,v,0), I_A3_Indices(u,v,1));
    }
  }
  return (*P_I_A2_Out);
}

bool CFits::GetSubArrCopy(const Array<double, 2> &D_A2_In,
                          const Array<int, 2> &I_A2_Indices,
                          Array<double, 1> &D_A1_Out) const{
  D_A1_Out.resize(I_A2_Indices.rows());
  for (int i=0; i<I_A2_Indices.rows(); i++){
    if (I_A2_Indices(i,0) >= D_A2_In.rows()){
      cout << "CFits::GetSubArrCopy: ERROR: I_A2_Indices(i=" << i << ",0) = " << I_A2_Indices(i,0) << " >= D_A2_In.rows = " << D_A2_In.rows() << " => Returning FALSE" << endl;
      return false;
    }
    if (I_A2_Indices(i,1) >= D_A2_In.cols()){
      cout << "CFits::GetSubArrCopy: ERROR: I_A2_Indices(i=" << i << ",1) = " << I_A2_Indices(i,1) << " >= D_A2_In.cols = " << D_A2_In.cols() << " => Returning FALSE" << endl;
      return false;
    }
    D_A1_Out(i) = D_A2_In(I_A2_Indices(i,0), I_A2_Indices(i,1));
  }
  return true;
}

/**
 Ceil(double D_In)
 Returns the closest long integer greater than or equal to its argument.
 **/
long CFits::Ceil(double D_In) const
{
  long L_Temp = (long)D_In;
  if ((double)L_Temp < D_In)
    L_Temp++;
  return L_Temp;
}

/**
 Ceil(Array<double, 1> &D_A1_In)
 Returns the closest long integer greater than or equal to its argument.
 **/
Array<long, 1>* CFits::Ceil(Array<double, 1> &D_A1_In) const
{
  int I_Size = D_A1_In.size();
  Array<long, 1> *P_L_A1_Temp = new Array<long, 1>(I_Size);
  for (int m = 0; m < I_Size; m++)
    (*P_L_A1_Temp)(m) = this->Ceil(D_A1_In(m));
  return (P_L_A1_Temp);
}

/**
  Floor(double D_In)
  Returns the closest long integer lower than or equal to its
  argument.
 **/
long CFits::Floor(double D_In) const{
  long L_Temp = (long)D_In;
  if ((double)L_Temp > D_In)
    L_Temp--;
  return L_Temp;
}

/**
  Floor(Array<double, 1> D_A1_In)
  Returns the closest long integer lower than or equal to its
  argument.
 **/
Array<long, 1>* CFits::Floor(Array<double, 1> &D_A1_In) const{
  int I_Size = D_A1_In.size();
  Array<long, 1> *P_L_A1_Temp = new Array<long, 1>(I_Size);
  for (int m = 0; m < I_Size; m++)
    (*P_L_A1_Temp)(m) = this->Floor(D_A1_In(m));
  return (P_L_A1_Temp);
}

/**
  Signum(double D_In)
  Returns +1 if D_In >= 0., else returns -1
 **/
int CFits::Signum(double D_In) const{
  if (D_In < 0.)
    return -1;
  return 1;
}

/**
 SortIndices(Array<double, 1> D_A1_In)
 Returns an integer array of the same size like <D_A1_In>, containing the indixes of <D_A1_In> in sorted order.
 **/
Array<int, 1>* CFits::SortIndices(const Array<double, 1> &D_A1_In) const
{
#ifdef __DEBUG_FITS_SORT__
  cout << "CFits::SortIndices(D_A1_In = " << D_A1_In << ") started" << endl;
#endif
  int I_M = 7;
  int I_NStack = 50;
  firstIndex i;

  int I_I, I_Indxt, I_Ir, I_J, I_K, I_L, I_SizeIn;
  int I_JStack = 0;
  Array<int, 1> I_A1_IStack(I_NStack);
  Array<int, 1> *P_I_A1_Indx = new Array<int, 1>();
  double D_A;

  I_SizeIn = D_A1_In.size();
  I_Ir = I_SizeIn - 1;
  I_L = 0;

  I_A1_IStack = 0;
  P_I_A1_Indx->resize(I_SizeIn);
  (*P_I_A1_Indx) = i;

#ifdef __DEBUG_FITS_SORT__
  cout << "CFits::SortIndices() starting for(;;)" << endl;
#endif
  for(;;)
  {
    if (I_Ir - I_L < I_M)
    {
      for (I_J = I_L + 1; I_J <= I_Ir; I_J++)
      {
        I_Indxt = (*P_I_A1_Indx)(I_J);
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(): I_Indxt set to " << I_Indxt << endl;
#endif
        D_A = D_A1_In(I_Indxt);
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(): D_A set to " << D_A << endl;
#endif
        for (I_I = I_J - 1; I_I >= I_L; I_I--)
        {
          if (D_A1_In((*P_I_A1_Indx)(I_I)) <= D_A)
          {
#ifdef __DEBUG_FITS_SORT__
            cout << "CFits::SortIndices(): D_A1_In(P_I_A1_Indx(I_I = " << I_I << ") = " << (*P_I_A1_Indx)(I_I) << " <= D_A = " << D_A << " =>  BREAK" << endl;
#endif
            break;
          }
          (*P_I_A1_Indx)(I_I + 1) = (*P_I_A1_Indx)(I_I);
#ifdef __DEBUG_FITS_SORT__
          cout << "CFits::SortIndices(): 1. P_I_A1_Indx(I_I+1 = " << I_I + 1 << ") set to " << (*P_I_A1_Indx)(I_I+1) << " => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif

        }
        (*P_I_A1_Indx)(I_I + 1) = I_Indxt;
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(): 2. P_I_A1_Indx(I_I+1 = " << I_I + 1 << ") set to " << (*P_I_A1_Indx)(I_I+1) << " => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif

      }
      if (I_JStack == 0)
      {
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(): I_JStack <= 0 =>  BREAK" << endl;
#endif
        break;
      }
      I_Ir = I_A1_IStack(I_JStack--);
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(): I_Ir(=" << I_Ir << ") set to I_A1_IStack(I_JStack--=" << I_JStack << ") = " << I_A1_IStack(I_JStack) << endl;
#endif
      I_L  = I_A1_IStack(I_JStack--);
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(): I_L(=" << I_L << ") set to I_A1_IStack(I_JStack--=" << I_JStack << ") = " << I_A1_IStack(I_JStack) << endl;
#endif

    }
    else
    {
      I_K = (I_L + I_Ir) >> 1;
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(): I_K(=" << I_K << ") set to (I_L[=" << I_L << "] + I_Ir[=" << I_Ir << "] >> 1)  = " << ((I_L + I_Ir) >> 1) << endl;
#endif
      Swap((*P_I_A1_Indx)(I_K),
           (*P_I_A1_Indx)(I_L + 1));
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(D_A1_In): P_I_A1_Indx(I_K=" << I_K << ")=" << (*P_I_A1_Indx)(I_K) << " and P_I_A1_Indx(I_L(=" << I_L << ")+1)=" << (*P_I_A1_Indx)(I_L+1) << " Swapped" << " => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif
      if (D_A1_In((*P_I_A1_Indx)(I_L))
          > D_A1_In((*P_I_A1_Indx)(I_Ir)))
      {
        Swap((*P_I_A1_Indx)(I_L),
             (*P_I_A1_Indx)(I_Ir));
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(D_A1_In): P_I_A1_Indx(I_L=" << I_L << ")=" << (*P_I_A1_Indx)(I_L) << " and P_I_A1_Indx(I_Ir(=" << I_Ir << "))=" << (*P_I_A1_Indx)(I_Ir) << " Swapped" << " => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif

      }
      if (D_A1_In((*P_I_A1_Indx)(I_L + 1))
          > D_A1_In((*P_I_A1_Indx)(I_Ir)))
      {
        Swap((*P_I_A1_Indx)(I_L + 1),
             (*P_I_A1_Indx)(I_Ir));
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(D_A1_In): P_I_A1_Indx(I_L=" << I_L << "+1)=" << (*P_I_A1_Indx)(I_L + 1) << " and P_I_A1_Indx(I_Ir(=" << I_Ir << "))=" << (*P_I_A1_Indx)(I_L+1) << " Swapped" << " => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif

      }
      if (D_A1_In((*P_I_A1_Indx)(I_L))
          > D_A1_In((*P_I_A1_Indx)(I_L + 1)))
      {
        Swap((*P_I_A1_Indx)(I_L),
             (*P_I_A1_Indx)(I_L + 1));
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(D_A1_In): P_I_A1_Indx(I_L=" << I_L << ")=" << (*P_I_A1_Indx)(I_L) << " and P_I_A1_Indx(I_L(=" << I_L << ")+1)=" << (*P_I_A1_Indx)(I_L+1) << " Swapped" << " => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif

      }
      I_I = I_L + 1;
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(D_A1_In): I_I(=" << I_I << ") set to (I_L[=" << I_L << "] + 1)  = " << I_L + 1 << endl;
#endif
      I_J = I_Ir;
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(D_A1_In): I_J(=" << I_J << ") set to I_Ir[=" << I_Ir << "]" << endl;
#endif
      I_Indxt = (*P_I_A1_Indx)(I_L + 1);
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(D_A1_In): I_Indxt(=" << I_Indxt << ") set to P_I_A1_Indx(I_L = " << I_L << "+1)" << endl;
#endif
      D_A = D_A1_In(I_Indxt);
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(D_A1_In): D_A(=" << D_A << ") set to D_A1_In(I_Indxt = " << I_Indxt << ")" << endl;
#endif
      for (;;)
      {
        do
        {
          I_I++;
#ifdef __DEBUG_FITS_SORT__
          cout << "CFits::SortIndices(D_A1_In): I_I set to " << I_I << " => D_A1_In(P_I_A1_Indx(I_I)) = " << D_A1_In((*P_I_A1_Indx)(I_I)) << endl;
#endif

        }
        while(D_A1_In((*P_I_A1_Indx)(I_I)) < D_A && I_I < I_SizeIn - 2);
        do
        {
          I_J--;
#ifdef __DEBUG_FITS_SORT__
          cout << "CFits::SortIndices(D_A1_In): I_J set to " << I_J << " => D_A1_In(P_I_A1_Indx(I_J)) = " << D_A1_In((*P_I_A1_Indx)(I_J)) << endl;
#endif

        }
        while(D_A1_In((*P_I_A1_Indx)(I_J)) > D_A && I_J > 0);
        if (I_J < I_I)
        {
#ifdef __DEBUG_FITS_SORT__
          cout << "CFits::SortIndices(D_A1_In): I_J(=" << I_J << ") < I_I(=" << I_I << ") => BREAK" << endl;
#endif
          break;
        }
        Swap((*P_I_A1_Indx)(I_I),
             (*P_I_A1_Indx)(I_J));
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(D_A1_In): P_I_A1_Indx(I_I=" << I_I << ")=" << (*P_I_A1_Indx)(I_I) << " and P_I_A1_Indx(I_J(=" << I_J << "))=" << (*P_I_A1_Indx)(I_J) << " Swapped" << " => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif

      }
      (*P_I_A1_Indx)(I_L + 1) = (*P_I_A1_Indx)(I_J);
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(D_A1_In): P_I_A1_Indx(I_L=" << I_L << "+1) set to P_I_A1_Indx(I_J=" << I_J << ") = " << (*P_I_A1_Indx)(I_L+1) << ") => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif
      (*P_I_A1_Indx)(I_J) = I_Indxt;
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(D_A1_In): P_I_A1_Indx(I_J=" << I_J << ") set to I_Indxt(=" << I_Indxt << ") => P_I_A1_Indx = " << *P_I_A1_Indx << endl;
#endif
      I_JStack += 2;
#ifdef __DEBUG_FITS_SORT__
      cout << "CFits::SortIndices(D_A1_In): I_JStack = " << I_JStack << endl;
#endif
      if (I_JStack > I_NStack)
      {
        cout << "CFits::SortIndices: ERROR: I_NStack ( = " << I_NStack << ") too small!!!";
        (*P_OFS_Log) << "CFits::SortIndices: ERROR: I_NStack ( = " << I_NStack << ") too small!!!";
        exit(EXIT_FAILURE);
      }
      if (I_Ir - I_I + 1 >= I_J - I_L)
      {
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(D_A1_In): I_Ir(= " << I_Ir << ") - I_I(=" << I_I << ") + 1 = " << I_Ir - I_I + 1 << " >= I_J(="<< I_J << ") + I_L(=" << I_L << ") = " << I_J - I_L << endl;
#endif
        I_A1_IStack(I_JStack) = I_Ir;
        I_A1_IStack(I_JStack - 1) = I_I;
        I_Ir = I_J - 1;
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(D_A1_In): I_I set to I_J(=" << I_J << ") - 1" << endl;
#endif

      }
      else
      {
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(D_A1_In): I_Ir(= " << I_Ir << ") - I_I(=" << I_I << ") + 1 = " << I_Ir - I_I + 1 << " < I_J(="<< I_J << ") + I_L(=" << I_L << ") = " << I_J - I_L << endl;
#endif
        I_A1_IStack(I_JStack) = I_J - 1;
        I_A1_IStack(I_JStack - 1) = I_L;
        I_L = I_I;
#ifdef __DEBUG_FITS_SORT__
        cout << "CFits::SortIndices(D_A1_In): I_L set to I_I(=" << I_I << endl;
#endif

      }
    }
  }
  I_A1_IStack.resize(0);
  return (P_I_A1_Indx);
}

/**
 ReadApertureDefinition
 Reads Aperture-Definition table from database file <CS_FileName_In> to P_D_A2_Coeffs(I_Aperture_In) and the other output parameters
**/

bool CFits::ReadApertureDefinition(int I_Aperture_In)
//                           Array<double, 1> &D_A1_CoeffArr_Out,
//                           double &D_Center_Out,
//                           double &D_Low_Out,
//                           double &D_High_Out,
//                           int &I_DispAxis_Out,
//                           CString &CS_Function_Out,
//                           int &I_Order_Out,
//                           double &D_XMin_Out,
//                           double &D_XMax_Out)
{
  FILE *P_DatabaseFile;
  long L_NLines;
  firstIndex i;
  secondIndex j;//, k;
  int  I_IAperture = 0, I_TempNApertures = 0;
  int m, n, o;
  int  I_NCoeffs = 0;
  char OneWord[255];
  char *P_Line, *P_FirstWord, *P_Func;
  CString CS_FirstWord;
  CString CS_KeyWordAperture("aperture");
  CString CS_KeyWordCurve("curve");
  CString CS_KeyWordAxis("axis");
  CString CS_KeyWordCenter("center");
  CString CS_KeyWordLow("low");
  CString CS_KeyWordHigh("high");
  CString CS_KeyWordXMin("xmin");
  CString CS_KeyWordXMax("xmax");
  CString CS_KeyWordFunction("function");
  //  Array<CString, 1> CS_A1_Functions;

  #ifdef __DEBUG_FITS_READAPERTURES__
    cout << "CFits::ReadApertureDefinition: CS_KeyWordAperture = " << CS_KeyWordAperture << endl;
    cout << "CFits::ReadApertureDefinition: CS_KeyWordCurve = " << CS_KeyWordCurve << endl;
    cout << "CFits::ReadApertureDefinition: CS_KeyWordAxis = " << CS_KeyWordAxis << endl;
    cout << "CFits::ReadApertureDefinition: CS_KeyWordCenter = " << CS_KeyWordCenter << endl;
    cout << "CFits::ReadApertureDefinition: CS_KeyWordLow = " << CS_KeyWordLow << endl;
    cout << "CFits::ReadApertureDefinition: CS_KeyWordHigh = " << CS_KeyWordHigh << endl;
  #endif

  Array<CString, 1>CS_A1_Functions(5);
  CS_A1_Functions(0).Set("chebyshev");
  CS_A1_Functions(1).Set("legendre");
  CS_A1_Functions(2).Set("cubic");
  CS_A1_Functions(3).Set("linear");
  CS_A1_Functions(4).Set("polynomial");

  #ifdef __DEBUG_FITS_READAPERTURES__
    printf("CFits.ReadApertureDefinition: function started\n");
  #endif
  P_DatabaseFile = fopen(this->P_CS_DatabaseFileName->Get(), "r");
  if (P_DatabaseFile == NULL)
  {
    cout << "CFits.ReadApertureDefinition: Failed to open file CS_FileName_In (=<" << this->P_CS_DatabaseFileName->Get() << ">)" << endl;
    (*P_OFS_Log) << "CFits.ReadApertureDefinition: Failed to open file CS_FileName_In (=<" << this->P_CS_DatabaseFileName->Get() << ">)" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_READAPERTURES__
    cout << "CFits.ReadApertureDefinition: File CS_FileName_In(=<" << this->P_CS_DatabaseFileName->Get() << ">) opened";
  #endif

  L_NLines = this->CountLines( this->P_CS_DatabaseFileName->Get() );

  // --- open file <fname> with name <filename> for reading
  P_DatabaseFile = fopen(this->P_CS_DatabaseFileName->Get(), "r");
  if (P_DatabaseFile == NULL)
  {
    cout << "CFits.ReadApertureDefinition: Failed to open file P_DatabaseFile (=<" << P_CS_DatabaseFileName->Get() << ">)" << endl;
    return false;
  }

  for (m = 0; m < L_NLines; m++)
  {
    P_Line = fgets(OneWord, 200, P_DatabaseFile);
    if (P_Line != NULL)
    {
      #ifdef __DEBUG_FITS_READAPERTURES__
        printf("CFits.ReadApertureDefinition: P_Line =<%s>\n", P_Line);
      #endif
      P_FirstWord = strtok(P_Line," \t\n\0");
      #ifdef __DEBUG_FITS_READAPERTURES__
        printf("CFits.ReadApertureDefinition: P_FirstWord =<%s>\n", P_FirstWord);
      #endif
      if (P_FirstWord != NULL)
      {
        CS_FirstWord.Set(P_FirstWord);
        #ifdef __DEBUG_FITS_READAPERTURES__
          cout << "CFits.ReadApertureDefinition: CS_FirstWord(=" << CS_FirstWord << ") set to P_FirstWord =<" << P_FirstWord << ">>>>>>>>>>>>>>>>>>>>" << endl;
        #endif
        if (CS_FirstWord.EqualValue(CS_KeyWordAperture))
        {
          #ifdef __DEBUG_FITS_READAPERTURES__
            printf("CFits.ReadApertureDefinition: Found KeyWord <%s> at line(m=%d) = <%s>!\n", CS_KeyWordAperture.Get(), m, P_Line);
          #endif
          I_IAperture = atoi(strtok(NULL, " \t\n\0"));
          I_TempNApertures = I_IAperture;

          #ifdef __DEBUG_FITS_READAPERTURES__
            printf("CFits.ReadApertureDefinition: Aperture No %d\n", I_IAperture);
            printf("CFits.ReadApertureDefinition: I_TempNApertures = %d\n", I_TempNApertures);
          #endif
        }// end if (strcmp(P_FirstWord, CS_KeyWordAperture) == 0)
        else
        {
          if (I_Aperture_In < 0 || I_IAperture == I_Aperture_In)
          {
            if (I_Aperture_In < 0)
            {
              if (I_IAperture > this->I_NApertures)
              {
                if (!this->Set_NApertures(I_IAperture))
                {
                  cout << "CFits::ReadApertureDefinition: this->Set_NApertures(I_IAperture=" << I_IAperture << ") returned FALSE => Returning FALSE" << endl;
                  (*P_OFS_Log) << "CFits::ReadApertureDefinition: this->Set_NApertures(I_IAperture=" << I_IAperture << ") returned FALSE => Returning FALSE" << endl;
                  return false;
                }
              }
            }
            if (CS_FirstWord.EqualValue(CS_KeyWordAxis))
            {
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: Found KeyWord <%s> at line(m=%d) = <%s>!\n", CS_KeyWordAxis.Get(), m, P_Line);
              #endif
              this->I_DispAxis = atoi(strtok(NULL, " \t\n\0"));
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: P_Axis = %d\n", this->I_DispAxis);
              #endif
            }// end if (strcmp(P_FirstWord, CS_KeyWordAxis) == 0)
            else if (CS_FirstWord.EqualValue(CS_KeyWordCenter))
            {
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: Found KeyWord <%s> at line(m=%d) = <%s>!\n", CS_FirstWord.Get(), m, P_Line);
              #endif
              (*this->P_D_A1_XCenter)(I_IAperture-1) = atof(strtok(NULL, " \t\n\0")) - 1.;
              (*this->P_D_A1_YCenter)(I_IAperture-1) = atof(strtok(NULL, " \t\n\0")) - 1.;
              #ifdef __DEBUG_FITS_READAPERTURES__
                cout << "CFits.ReadApertureDefinition: D_XCenter = " << (*this->P_D_A1_XCenter)(I_IAperture-1) << ", D_YCenter = " << (*this->P_D_A1_YCenter)(I_IAperture-1) << endl;
              #endif
            }// end if (strcmp(P_FirstWord, CS_KeyWordCenter) == 0)
            else if (CS_FirstWord.EqualValue(CS_KeyWordLow))
            {
              #ifdef __DEBUG_FITS_READAPERTURES__
                cout << "CFits.ReadApertureDefinition: Found KeyWord <" << CS_FirstWord.Get() << "> at line(m=" << m << ") = <" << P_Line << ">!" << endl;
                (*P_OFS_Log) << "CFits.ReadApertureDefinition: Found KeyWord <" << CS_FirstWord.Get() << "> at line(m=" << m << ") = <" << P_Line << ">!" << endl;
              #endif
              (*P_D_A1_XLow)(I_IAperture-1) = atof(strtok(NULL, " \t\n\0"));
              #ifdef __DEBUG_FITS_READAPERTURES__
                cout << "CFits.ReadApertureDefinition: P_XLow(I_IAperture-1=" << I_IAperture - 1 << ") set to " << (*P_D_A1_XLow)(I_IAperture-1) << endl;
                (*P_OFS_Log) << "CFits.ReadApertureDefinition: P_XLow(I_IAperture-1=" << I_IAperture - 1 << ") set to "  << (*P_D_A1_XLow)(I_IAperture-1) << endl;
              #endif
              (*P_D_A1_YLow)(I_IAperture-1) = atof(strtok(NULL, " \t\n\0"));
//              (*P_D_A1_XMin)(I_IAperture-1) = (*P_D_A1_YCenter)(I_IAperture-1) + (*P_D_A1_YLow)(I_IAperture-1);
              #ifdef __DEBUG_FITS_READAPERTURES__
                cout << "CFits.ReadApertureDefinition: P_YLow(I_IAperture-1=" << I_IAperture - 1 << ") set to " << (*P_D_A1_YLow)(I_IAperture-1) << endl;
                (*P_OFS_Log) << "CFits.ReadApertureDefinition: P_YLow(I_IAperture-1=" << I_IAperture - 1 << ") set to "  << (*P_D_A1_YLow)(I_IAperture-1) << endl;
              #endif
            }// end if (strcmp(P_FirstWord, CS_KeyWordLow) == 0)
            else if (CS_FirstWord.EqualValue(CS_KeyWordHigh))
            {
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: Found KeyWord <%s> at line(m=%d) = <%s>!\n", CS_FirstWord.Get(), m, P_Line);
              #endif
              (*P_D_A1_XHigh)(I_IAperture-1) = atof(strtok(NULL, " \t\n\0"));
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: (*P_D_A1_XHigh)(I_IAperture-1) = %.7f\n", (*P_D_A1_XHigh)(I_IAperture-1));
              #endif
              (*P_D_A1_YHigh)(I_IAperture-1) = atof(strtok(NULL, " \t\n\0"));
//              (*P_D_A1_XMax)(I_IAperture-1) = (*P_D_A1_YCenter)(I_IAperture-1) + (*P_D_A1_YHigh)(I_IAperture-1);
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: (*P_D_A1_YHigh)(I_IAperture-1) = %.7f\n", (*P_D_A1_YHigh)(I_IAperture-1));
              #endif
            }// end if (strcmp(P_FirstWord, CS_KeyWordHigh) == 0)
            else if (CS_FirstWord.EqualValue(CS_KeyWordXMin))
            {
              #ifdef __DEBUG_FITS_READAPERTURES__
                cout << "CFits.ReadApertureDefinition: Found KeyWord <" << CS_FirstWord.Get() << "> at line(m=" << m << ") = <" << P_Line << ">!" << endl;
                (*P_OFS_Log) << "CFits.ReadApertureDefinition: Found KeyWord <" << CS_FirstWord.Get() << "> at line(m=" << m << ") = <" << P_Line << ">!" << endl;
              #endif
              (*P_D_A1_XMin)(I_IAperture-1) = atof(strtok(NULL, " \t\n\0"));
              #ifdef __DEBUG_FITS_READAPERTURES__
                cout << "CFits.ReadApertureDefinition: P_XMin(I_IAperture-1=" << I_IAperture - 1 << ") set to " << (*P_D_A1_XMin)(I_IAperture-1) << endl;
                (*P_OFS_Log) << "CFits.ReadApertureDefinition: P_XMin(I_IAperture-1=" << I_IAperture - 1 << ") set to "  << (*P_D_A1_XMin)(I_IAperture-1) << endl;
              #endif
            }// end if (strcmp(P_FirstWord, CS_KeyWordLow) == 0)
            else if (CS_FirstWord.EqualValue(CS_KeyWordXMax))
            {
              #ifdef __DEBUG_FITS_READAPERTURES__
                cout << "CFits.ReadApertureDefinition: Found KeyWord <" << CS_FirstWord.Get() << "> at line(m=" << m << ") = <" << P_Line << ">!" << endl;
                (*P_OFS_Log) << "CFits.ReadApertureDefinition: Found KeyWord <" << CS_FirstWord.Get() << "> at line(m=" << m << ") = <" << P_Line << ">!" << endl;
              #endif
              (*P_D_A1_XMax)(I_IAperture-1) = atof(strtok(NULL, " \t\n\0"));
              #ifdef __DEBUG_FITS_READAPERTURES__
              cout << "CFits.ReadApertureDefinition: P_XMax(I_IAperture-1=" << I_IAperture - 1 << ") set to " << (*P_D_A1_XMax)(I_IAperture-1) << endl;
              (*P_OFS_Log) << "CFits.ReadApertureDefinition: P_XMax(I_IAperture-1=" << I_IAperture - 1 << ") set to "  << (*P_D_A1_XMax)(I_IAperture-1) << endl;
              #endif
            }// end if (strcmp(P_FirstWord, CS_KeyWordLow) == 0)
            else if (CS_FirstWord.EqualValue(CS_KeyWordFunction))
            {
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: Found KeyWord <%s> at line(m=%d) = <%s>!\n", CS_FirstWord.Get(), m, P_Line);
              #endif
              P_Func = strtok(NULL, " \t\n\0");
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: Function = <%s>!\n", P_Func);
                printf("CFits.ReadApertureDefinition: P_CS_A1_Functions->size() = <%d>!\n", P_CS_A1_Functions->size());
                printf("CFits.ReadApertureDefinition: I_IAperture = %d\n", I_IAperture);
              #endif
              (*P_CS_A1_Functions)(I_IAperture-1).Copy(CString(P_Func));
              #ifdef __DEBUG_FITS_READAPERTURES__
                cout << "CFits.ReadApertureDefinition: (*P_CS_A1_Functions)(" << I_IAperture-1 << ") set to " << (*P_CS_A1_Functions)(I_IAperture-1) << endl;
                (*P_OFS_Log) << "CFits.ReadApertureDefinition: (*P_CS_A1_Functions)(" << I_IAperture-1 << ") set to " << (*P_CS_A1_Functions)(I_IAperture-1) << endl;
              #endif
            }// end if (strcmp(P_FirstWord, CS_KeyWordHigh) == 0)
            else if (CS_FirstWord.EqualValue(CS_KeyWordCurve))
            {
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: Found KeyWord <%s> at line(m=%d) = <%s>!\n", CS_KeyWordCurve.Get(), m, P_Line);
              #endif
              I_NCoeffs = atoi(strtok(NULL, " \t\n\0"));
              #ifdef __DEBUG_FITS_READAPERTURES__
                printf("CFits.ReadApertureDefinition: I_NCoeffs = %d\n", I_NCoeffs);
              #endif
              for (n = 0; n < 4; n++)
              {
                m++;
                P_Line = fgets(OneWord, 200, P_DatabaseFile);
                if (P_Line == NULL)
                {
                  cout << "CFits.ReadApertureDefinition: n = " << n << ": Cannot read P_Line!" << endl;
                  (*P_OFS_Log) << "CFits.ReadApertureDefinition: n = " << n << ": Cannot read P_Line!" << endl;
                  return false;
                }
                #ifdef __DEBUG_FITS_READAPERTURES__
                  printf("CFits.ReadApertureDefinition: P_Line =<%s>\n", P_Line);
                #endif
                P_FirstWord = strtok(P_Line," \t\n\0");
                #ifdef __DEBUG_FITS_READAPERTURES__
                  printf("CFits.ReadApertureDefinition: P_FirstWord =<%s>\n", P_FirstWord);
                #endif
                if (P_FirstWord == NULL)
                {
                  cout << "CFits.ReadApertureDefinition: n = " << n << ": Cannot read P_FirstWord from P_Line=<" << P_Line << ">!" << endl;
                  (*P_OFS_Log) << "CFits.ReadApertureDefinition: n = " << n << ": Cannot read P_FirstWord from P_Line=<" << P_Line << ">!" << endl;
                  return false;
                }
                CS_FirstWord.Set(P_FirstWord);
                #ifdef __DEBUG_FITS_READAPERTURES__
                  printf("CFits.ReadApertureDefinition: n = %d: P_FirstWord = <%s>!\n", n, P_FirstWord);
                #endif
                if (n == 0)
                {
                  (*this->P_CS_A1_Functions)(I_IAperture-1).Copy(CS_A1_Functions(atoi(P_FirstWord) - 1));
                  #ifdef __DEBUG_FITS_READAPERTURES__
                    printf("CFits.ReadApertureDefinition: P_Function = <%s>\n", (*P_CS_A1_Functions)(I_IAperture-1).Get());
                  #endif
                }
                else if (n == 1)
                {
                  (*P_I_A1_Orders)(I_IAperture-1) = atoi(P_FirstWord);
                  #ifdef __DEBUG_FITS_READAPERTURES__
                    printf("CFits.ReadApertureDefinition: Order = <%d>\n", (*P_I_A1_Orders)(I_IAperture-1));
                  #endif
                  if ((*P_CS_A1_Functions)(I_IAperture - 1).EqualValue(CS_A1_Functions(0)))
                  {///Chebyshev
                    (*this->P_I_A1_NCoeffs)(I_IAperture - 1) = (*P_I_A1_Orders)(I_IAperture - 1);
                  }
                  else if ((*this->P_CS_A1_Functions)(I_IAperture - 1).EqualValue(CS_A1_Functions(1)))
                  {///Legendre
                    (*this->P_I_A1_NCoeffs)(I_IAperture - 1) = (*P_I_A1_Orders)(I_IAperture - 1);
                  }
                  else if ((*this->P_CS_A1_Functions)(I_IAperture - 1).EqualValue(CS_A1_Functions(2)))
                  {///CubicSpline
                    (*this->P_I_A1_NCoeffs)(I_IAperture - 1) = (*P_I_A1_Orders)(I_IAperture - 1) + 3;
                  }
                  else if ((*this->P_CS_A1_Functions)(I_IAperture - 1).EqualValue(CS_A1_Functions(3)))
                  {///LinarSpline
                    (*this->P_I_A1_NCoeffs)(I_IAperture - 1) = (*P_I_A1_Orders)(I_IAperture - 1) + 1;
                  }
                  else// if (PP_CS_A1_Functions[I_IAperture - 1]->EqualValue(*(PP_Functions[3])))
                  {///Polynomial
                    (*this->P_I_A1_NCoeffs)(I_IAperture - 1) = (*P_I_A1_Orders)(I_IAperture - 1) + 1;
                  }
                  if (this->P_D_A2_Coeffs->cols() < (*this->P_I_A1_NCoeffs)(I_IAperture - 1))
                  {
                    int oldcols = this->P_D_A2_Coeffs->cols();
                    this->P_D_A2_Coeffs->resizeAndPreserve(this->I_NApertures, (*this->P_I_A1_NCoeffs)(I_IAperture - 1));
                    (*this->P_D_A2_Coeffs)(Range::all(), Range(oldcols, this->P_D_A2_Coeffs->cols() - 1)) = 0.;
                  }
                }
                else if (n == 2)
                {
//                  (*P_D_A1_XMin)(I_IAperture-1) = atof(P_FirstWord)-1;
//                  #ifdef __DEBUG_FITS_READAPERTURES__
//                    printf("CFits.ReadApertureDefinition: (*P_D_A1_XMin)(I_IAperture-1) = <%.7f>\n", (*P_D_A1_XMin)(I_IAperture-1));
//                  #endif
                }
                else if (n == 3)
                {
//                  (*P_D_A1_XMax)(I_IAperture-1) = atof(P_FirstWord)-1;
//                  #ifdef __DEBUG_FITS_READAPERTURES__
//                    printf("CFits.ReadApertureDefinition: (*P_D_A1_XMax)(I_IAperture-1) = <%.7f>\n", (*P_D_A1_XMax)(I_IAperture-1));
//                  #endif
                }
              }
              for (n = 4; n < I_NCoeffs; n++)
              {
//                if ((*this->P_CS_A1_Functions)(I_IAperture-1).EqualValue(CS_A1_Functions(3)))
//                {///LinearSpline
//                  #ifdef __DEBUG_FITS_READAPERTURES__
//                    printf("CFits.ReadApertureDefinition: P_Function == <%s>\n", CS_A1_Functions(3).Get());
//                  #endif
                  for (o = 1; o <= (*P_I_A1_NCoeffs)(I_IAperture-1); o++)
                  {
                    n++;
                    m++;
                    P_Line = fgets(OneWord, 200, P_DatabaseFile);
                    if (P_Line == NULL)
                    {
                      cout << "CFits.ReadApertureDefinition: o = " << o << ": Cannot read P_Line!" << endl;
                      (*P_OFS_Log) << "CFits.ReadApertureDefinition: o = " << o << ": Cannot read P_Line!" << endl;
                      return false;
                    }
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: P_Line =<%s>\n", P_Line);
                    #endif
                    P_FirstWord = strtok(P_Line," \t\n\0");
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: P_FirstWord =<%s>\n", P_FirstWord);
                    #endif
                    if (P_FirstWord == NULL)
                    {
                      cout << "CFits.ReadApertureDefinition: o = " << o << ": Cannot read P_FirstWord from P_Line=<" << P_Line << ">!" << endl;
                      (*P_OFS_Log) << "CFits.ReadApertureDefinition: o = " << o << ": Cannot read P_FirstWord from P_Line=<" << P_Line << ">!" << endl;
                      return false;
                    }
                    CS_FirstWord.Set(P_FirstWord);
                    (*P_D_A2_Coeffs)(I_IAperture-1, o-1) = atof(P_FirstWord);
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: CoeffArr[%d] = %.7f\n", o-1, (*P_D_A2_Coeffs)(I_IAperture-1, o-1));
                    #endif
                  }// end for (k = 1; k <= I_NCoeffs - 4 + 1; k++)
/*                }// end if (strcmp(P_Function, PP_Functions[3]) == 0)
                else if ((*this->P_CS_A1_Functions)(I_IAperture-1).EqualValue(CS_A1_Functions(2)))
                {/// CubicSpline
                  #ifdef __DEBUG_FITS_READAPERTURES__
                    printf("CFits.ReadApertureDefinition: P_Function == <%s>\n", CS_A1_Functions(2).Get());
                  #endif
                  for (o = 1; o <= (*P_I_A1_Orders)(I_IAperture-1) + 3; o++)
                  {
                    n++;
                    m++;
                    P_Line = fgets(OneWord, 200, P_DatabaseFile);
                    if (P_Line == NULL)
                    {
                      cout << "CFits.ReadApertureDefinition: o = " << o << ": Cannot read P_Line!" << endl;
                      (*P_OFS_Log) << "CFits.ReadApertureDefinition: o = " << o << ": Cannot read P_Line!" << endl;
                      return false;
                    }
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: P_Line =<%s>\n", P_Line);
                    #endif
                    P_FirstWord = strtok(P_Line," \t\n\0");
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: P_FirstWord =<%s>\n", P_FirstWord);
                    #endif
                    if (P_FirstWord == NULL)
                    {
                      cout << "CFits.ReadApertureDefinition: o = " << o << ": Cannot read P_FirstWord from P_Line=<" << P_Line << ">!" << endl;
                      (*P_OFS_Log) << "CFits.ReadApertureDefinition: o = " << o << ": Cannot read P_FirstWord from P_Line=<" << P_Line << ">!" << endl;
                      return false;
                    }
                    CS_FirstWord.Set(P_FirstWord);
                    (*P_D_A2_Coeffs)(I_IAperture-1, o-1) = atof(P_FirstWord);
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: CoeffArr[%d] = %.7f\n", o-1, (*P_D_A2_Coeffs)(I_IAperture-1, o-1));
                    #endif
                  }// end for (o = 1; o <= I_NCoeffs - 4 + 3; o++)
                }// end else if (strcmp(P_Function, PP_Functions[2]) == 0)
                else// if (strcmp(P_Function, PP_Functions[2]) == 0)
                {///Legendre & Chebyshev & Polynomial
                  #ifdef __DEBUG_FITS_READAPERTURES__
                    printf("CFits.ReadApertureDefinition: n = %d: CS_Function_Out == <%s>\n", n, (*this->P_CS_A1_Functions)(I_IAperture-1).Get());
                  #endif
                  for (o = 1; o <= (*P_I_A1_Orders)(I_IAperture-1); o++)
                  {
                    n++;
                    m++;
                    P_Line = fgets(OneWord, 200, P_DatabaseFile);
                    if (P_Line == NULL)
                    {
                      cout << "CFits.ReadApertureDefinition: n = " << n << ": o = " << o << ": Cannot read P_Line!" << endl;
                      (*P_OFS_Log) << "CFits.ReadApertureDefinition: n = " << n << ": o = " << o << ": Cannot read P_Line!" << endl;
                      return false;
                    }
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: n = %d, o = %d: P_Line =<%s>\n", n, o, P_Line);
                    #endif
                    P_FirstWord = strtok(P_Line," \t\n\0");
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: n = %d: o = %d: P_FirstWord =<%s>\n", n, o, P_FirstWord);
                    #endif
                    if (P_FirstWord == NULL)
                    {
                      cout << "CFits.ReadApertureDefinition: n = " << n << ": o = " << o << ": Cannot read P_FirstWord from P_Line=<" << P_Line << ">!" << endl;
                      (*P_OFS_Log) << "CFits.ReadApertureDefinition: n = " << n << ": o = " << o << ": Cannot read P_FirstWord from P_Line=<" << P_Line << ">!" << endl;
                      return false;
                    }
                    CS_FirstWord.Set(P_FirstWord);
                    (*P_D_A2_Coeffs)(I_IAperture-1, o-1) = atof(P_FirstWord);
                    #ifdef __DEBUG_FITS_READAPERTURES__
                      printf("CFits.ReadApertureDefinition: n = %d: o = %d: CoeffArr[%d] = %.7f\n", n, o, o-1, (*P_D_A2_Coeffs)(I_IAperture-1, o-1));
                    #endif
                  }// end for (o = 1; o <= I_NCoeffs - 4; o++)
                }// end else if (strcmp(P_Function, PP_Functions[2]) == 0)
                *///  n += o;
              }// end for (n = 4; n < I_NCoeffs; n++)
              //m += n + 1;
            }// end if (strcmp(P_FirstWord, CS_KeyWordCurve) == 0)
          }// end if (I_IAperture == I_Aperture)
        }// enb if (strcmp(P_FirstWord, CS_KeyWordAperture) != 0)
      }// end if (P_FirstWord != NULL)
      else
      {
        #ifdef __DEBUG_FITS_READAPERTURES__
          printf("CFits.ReadApertureDefinition: P_FirstWord == NULL\n");
        #endif
      }
    }// end if (P_Line != NULL)
  }// end for (i = 0; i < L_NLines; i++)
  #ifdef __DEBUG_FITS_READAPERTURES__
    cout << "CFits.ReadApertureDefinition: *P_CS_A1_Functions set to " << *P_CS_A1_Functions << endl;
    (*P_OFS_Log) << "CFits.ReadApertureDefinition: *P_CS_A1_Functions set to " << *P_CS_A1_Functions << endl;
  #endif

  I_TempNApertures = I_IAperture;
  #ifdef __DEBUG_FITS_READAPERTURES__
    cout << "CFits::ReadApertureDefinition: I_TempNApertures = " << I_TempNApertures << "!!!!!!!!!!!!!" << endl;
  #endif
  //  for (int mm = 0; mm < 4; mm++)
  //    delete PP_Functions[mm];
  CS_A1_Functions.resize(0);
  //  delete PP_Functions;
  fclose(P_DatabaseFile);
  return true;//I_NCoeffs;
}

/** **********************************************************/

void CFits::Show (ostream &os) const
{
#ifdef __DEBUG_FITS_SHOW__
  cout << "CFits::Show(ostream &os) started" << endl;
#endif
  os << "P_CS_FileName: " << *(this->P_CS_FileName) << endl;
  os << "I_NApertures: " << this->I_NApertures << endl;
  os << "P_I_A1_Orders: " << *this->P_I_A1_Orders << endl;
  os << "P_D_A1_XLow: " << *this->P_D_A1_XLow << endl;
  os << "P_D_A1_XHigh: " << *this->P_D_A1_XHigh << endl;
  os << "P_D_A1_YLow: " << *this->P_D_A1_YLow << endl;
  os << "P_D_A1_YHigh: " << *this->P_D_A1_YHigh << endl;
  os << "P_D_A1_XMin: " << *this->P_D_A1_XMin << endl;
  os << "P_D_A1_XMax: " << *this->P_D_A1_XMax << endl;
  os << "P_D_A1_XCenter: " << *this->P_D_A1_XCenter << endl;
  os << "P_D_A1_YCenter: " << *this->P_D_A1_YCenter << endl;
  os << "P_D_A2_Coeffs: " << *this->P_D_A2_Coeffs << endl;
  os << "P_D_A2_XCenters: " << *this->P_D_A2_XCenters << endl;
  //  os << "P_D_A2_XCenters.rows: " << this->P_D_A2_XCenters->rows() << endl;
  //  os << "P_D_A2_XCenters.cols: " << this->P_D_A2_XCenters->cols() << endl;
  os << "NRows: " << this->NRows << endl;
  os << "NCols: " << this->NCols << endl;
  //  os << *(this->P_D_A2_PixArray);

#ifdef __DEBUG_FITS_SHOW__
  cout << "CFits::Show(ostream &os) ready" << endl;
#endif

}

/**
 task: Sets the aperture centers to 0
 **/
bool CFits::MarkCenters()
{
  Array<int, 1> I_A1_Temp(this->NRows);
  I_A1_Temp = 0;
  int m = 0, lin, i_start, i_end;
  for (m = 0; m < this->I_NApertures; m++)
  {
    i_start = int((*this->P_D_A1_YCenter)(m) + (*this->P_D_A1_YLow)(m));
    i_end = int((*this->P_D_A1_YCenter)(m) + (*this->P_D_A1_YHigh)(m));
    #ifdef __DEBUG_FITS_MARK__
      cout << "CFits::MarkCenters: Aperture " << m << ": (*P_D_A1_YCenter)(m) = " << (*this->P_D_A1_YCenter)(m) << ", (*this->P_D_A1_YLow)(m) = " << (*this->P_D_A1_YLow)(m) << ", (*this->P_D_A1_YHigh)(m) = " << (*this->P_D_A1_YHigh)(m) << endl;
      cout << "CFits::MarkCenters: Aperture " << m << ": i_start = " << i_start << ", i_end = " << i_end << endl;
    #endif

    for (lin = i_start; lin < i_end; lin++)
    {
      cout << "CFits::MarkCenters: P_D_A2_XCenters(" << P_D_A2_XCenters->rows() << " rows, " << P_D_A2_XCenters->cols() << " cols)" << endl;
      cout << "CFits::MarkCenters: P_D_A2_PixArray(" << P_D_A2_PixArray->rows() << " rows, " << P_D_A2_PixArray->cols() << " cols), lin = " << lin << endl;
      cout << "CFits::MarkCenters: P_D_A2_PixArray(" << P_D_A2_PixArray->rows() << " rows, " << P_D_A2_PixArray->cols() << " cols), lin = " << lin << ", this->Round((*this->P_D_A2_XCenters)(m, lin)) = " << this->Round((*this->P_D_A2_XCenters)(m, lin)) << endl;
//      cout << "CFits::MarkCenters: P_D_A2_XCenters(m=" << m << ", Range(" << i_start << ", " << i_end-1 << ")) = " << (*P_D_A2_XCenters)(m,Range(i_start, i_end-1)) << endl;

      (*this->P_D_A2_PixArray)(lin, this->Round((*this->P_D_A2_XCenters)(m, lin))) = 0.;
      #ifdef __DEBUG_FITS_MARK__
        cout << "CFits::MarkCenters: (int)(P_D_A2_XCenters(m=" << m << ", lin=" << lin << ")) = " << this->Round((*P_D_A2_XCenters)(m, lin)) << endl;
        cout << "CFits::MarkCenters: P_D_A2_PixArray(" << lin << ", " << this->Round((*this->P_D_A2_XCenters)(m, lin)) << ") = " << (*P_D_A2_PixArray)(lin, (int)((*this->P_D_A2_XCenters)(m, lin))) << endl;
      #endif
//      return false;
    }
  }
  #ifdef __DEBUG_FITS_MARK__
    cout << "CFits::MarkCenters: (*(this->P_D_A1_YLow)) = " << (*(this->P_D_A1_YLow)) << endl;
    cout << "CFits::MarkCenters: (*(this->P_D_A1_YHigh)) = " << (*(this->P_D_A1_YHigh)) << endl;
  #endif
  //  for (m = 0; m < this->NCols; m++)
  //    (*this->P_D_A2_PixArray)(0, Range::all()) = 10.;
  //  for (m = 0; m < this->NRows; m++)
  //    (*this->P_D_A2_PixArray)(Range::all(), 0) = 20.;

  I_A1_Temp.resize(0);
  return true;
}

/**
 task: Writes the aperture centers of aperture no <iap> to file <fn>
 **/
bool CFits::WriteCenters(int iap, CString &fn)
{
  FILE *p_file;
  p_file = fopen(fn.Get(), "w");

  int m = 0;
  for (m = 0; m < this->NRows; m++)
    fprintf(p_file, "%.7f\n", (*this->P_D_A2_XCenters)(iap, m));

  fclose(p_file);
  return true;
}

/**
 task: Writes Array <I_A1_In> to file <CS_FileName_In>
 **/
bool CFits::WriteArrayToFile(const Array<int, 1> &I_A1_In, const CString &CS_FileName_In, const CString &CS_Mode) const
{
  FILE *p_file;
  p_file = fopen(CS_FileName_In.Get(), "w");

  if (CS_Mode.EqualValue(CString("binary"))){
    fwrite(I_A1_In.data(), sizeof(int), I_A1_In.size(), p_file);
  } else{
    int m = 0;
    for (m = 0; m < I_A1_In.size(); m++)
      fprintf(p_file, "%d\n", (I_A1_In)(m));
  }

  fclose(p_file);
  return true;
}

/**
 * task: Writes Array <D_A1_In> to file <CS_FileName_In>
 **/
bool CFits::WriteArrayToFile(const Array<double, 1> &D_A1_In, const CString &CS_FileName_In, const CString &CS_Mode) const
{
  FILE *p_file;
  p_file = fopen(CS_FileName_In.Get(), "w");

  if (CS_Mode.EqualValue(CString("binary"))){
    fwrite(D_A1_In.data(), sizeof(double), D_A1_In.size(), p_file);
  } else{
    bool B_Exp = false;
    if (max(D_A1_In < 1e-7))
      B_Exp = true;
    int m = 0;
    if (!B_Exp){
      for (m = 0; m < D_A1_In.size(); m++)
        fprintf(p_file, "%.17f\n", (D_A1_In)(m));
    }
    else{
      for (m = 0; m < D_A1_In.size(); m++)
        fprintf(p_file, "%.8e\n", (D_A1_In)(m));
    }
  }

  fclose(p_file);
  return true;
}

/**
  task: Writes Array <D_A2_In> to file <CS_FileName_In>
 **/
bool CFits::WriteArrayToFile(const Array<double, 2> &D_A2_In, const CString &CS_FileName_In, const CString &CS_Mode) const
{
  int m, n;
  ofstream ofs(CS_FileName_In.Get());
  //  FILE *p_file;
  FILE *p_file;
  //  p_file = fopen(CS_FileName_In.Get(), "w");
  
  p_file = fopen((*(const_cast<CString*>(&CS_FileName_In))).Get(), "w");

  if (CS_Mode.EqualValue(CString("binary"))){
    for (m = 0; m < D_A2_In.rows(); m++)
    {
      fwrite(D_A2_In(m, Range::all()).data(), sizeof(double), D_A2_In.cols(), p_file);
      for (n = 0; n < D_A2_In.cols(); n++)
        ofs << D_A2_In(m, n) << " ";
      ofs << endl;
    }
  }
  else{
    Array<bool, 1> B_A1_Exp(D_A2_In.cols());
    B_A1_Exp = false;
    for (m=0; m<D_A2_In.cols(); m++){
      if (max(D_A2_In(Range::all(), m)) < 1e-7)
        B_A1_Exp(m) = true;
    }
    for (m = 0; m < D_A2_In.rows(); m++)
    {
      for (n = 0; n < D_A2_In.cols(); n++){
	if (B_A1_Exp(n))
          fprintf(p_file, " %.8e", (D_A2_In)(m,n));
	else
          fprintf(p_file, " %.10f", (D_A2_In)(m,n));
      }
      fprintf(p_file, "\n");
    }
  }
  //  fclose(p_file);
  fclose(p_file);
  return true;
}

/**
  task: Writes Array <I_A2_In> to file <CS_FileName_In>
 **/
bool CFits::WriteArrayToFile(const Array<int, 2> &D_A2_In, const CString &CS_FileName_In, const CString &CS_Mode) const
{
  int m, n;
  ofstream ofs(CS_FileName_In.Get());
  //  FILE *p_file;
  FILE *p_file;
  //  p_file = fopen(CS_FileName_In.Get(), "w");
  p_file = fopen((*(const_cast<CString*>(&CS_FileName_In))).Get(), "w");

  if (CS_Mode.EqualValue(CString("binary"))){
    for (m = 0; m < D_A2_In.rows(); m++)
    {
      fwrite(D_A2_In(m, Range::all()).data(), sizeof(int), D_A2_In.cols(), p_file);
      for (n = 0; n < D_A2_In.cols(); n++)
        ofs << D_A2_In(m, n) << " ";
      ofs << endl;
    }
  } else{
    for (m = 0; m < D_A2_In.rows(); m++)
    {
      fprintf(p_file, "%d", (D_A2_In)(m,0));
      for (n = 1; n < D_A2_In.cols(); n++){
        fprintf(p_file, " %d", (D_A2_In)(m,n));
      }
      fprintf(p_file, "\n");
    }
  }
  //  fclose(p_file);
  fclose(p_file);
  return true;
}

/**
function Bubble Sort
 **/
Array<int, 1>* CFits::BubbleSort(const Array<int, 1> &I_A1_ArrIn) const
{
  long Size = I_A1_ArrIn.size();
  Array<int, 1> *P_I_A1_Out = new Array<int, 1>();
  P_I_A1_Out->resize(Size);
  (*P_I_A1_Out) = I_A1_ArrIn;
  long UpperLimit = Size - 1;
  long LastSwap;
  long Pos;

  while(UpperLimit > 0)
  {
    LastSwap = 0;
    for(Pos = 0;Pos < UpperLimit; ++Pos)
    {
      if((*P_I_A1_Out)(Pos) > (*P_I_A1_Out)(Pos+1))
      {
//        cout << "BubbleSort: (*P_D_A1_Out)(Pos=" << Pos << ")=" << (*P_D_A1_Out)(Pos) << " > (*P_D_A1_Out)(Pos+1=" << Pos+1 << ") = " << (*P_D_A1_Out)(Pos+1) << " => Swapping Positions" << endl;
        Swap((*P_I_A1_Out)(Pos), (*P_I_A1_Out)(Pos+1));
        LastSwap = Pos;
//        cout << "BubbleSort: LastSwap set to " << LastSwap << endl;
      }
    }
    UpperLimit = LastSwap;
//    cout << "BubbleSort: UpperLimit set to " << LastSwap << endl;
  }
  return (P_I_A1_Out);
}

Array<double, 1>* CFits::BubbleSort(const Array<double, 1> &D_A1_ArrIn) const
{
  long Size = D_A1_ArrIn.size();
  Array<double, 1> *P_D_A1_Out = new Array<double, 1>();
  P_D_A1_Out->resize(Size);
  (*P_D_A1_Out) = D_A1_ArrIn;
  long UpperLimit = Size - 1;
  long LastSwap;
  long Pos;

  while(UpperLimit > 0)
  {
    LastSwap = 0;
    for(Pos = 0;Pos < UpperLimit; ++Pos)
    {
      if((*P_D_A1_Out)(Pos) > (*P_D_A1_Out)(Pos+1))
      {
//        cout << "BubbleSort: (*P_D_A1_Out)(Pos=" << Pos << ")=" << (*P_D_A1_Out)(Pos) << " > (*P_D_A1_Out)(Pos+1=" << Pos+1 << ") = " << (*P_D_A1_Out)(Pos+1) << " => Swapping Positions" << endl;
        Swap((*P_D_A1_Out)(Pos), (*P_D_A1_Out)(Pos+1));
        LastSwap = Pos;
//        cout << "BubbleSort: LastSwap set to " << LastSwap << endl;
      }
    }
    UpperLimit = LastSwap;
//    cout << "BubbleSort: UpperLimit set to " << LastSwap << endl;
  }
  return (P_D_A1_Out);
}

/**
function Sort - seems faster than Bubble Sort
**/
Array<double, 1>* CFits::Sort(const Array<double, 1> &D_A1_ArrIn) const{
  Array<double, 1> *P_D_A1_Sorted = new Array<double, 1>(D_A1_ArrIn.size());
  (*P_D_A1_Sorted) = D_A1_ArrIn;
  for (size_t i = 0;i < D_A1_ArrIn.size();i++)
  {
    cout << "CFits::Sort: i = " << i << endl;
    for (size_t j = i + 1;j < D_A1_ArrIn.size();j++)
    {
      if ((*P_D_A1_Sorted)(i) > (*P_D_A1_Sorted)(j))
      {
        std::swap((*P_D_A1_Sorted)(i), (*P_D_A1_Sorted)(j));
      }
    }
  }
  return P_D_A1_Sorted;
}

/**
  function CountPixGTZero
  replaces input vector with vector of the same size where values are zero where the input vector is zero and all other values represent the number of non-zero values since the last zero value
 **/
bool CFits::CountPixGTZero(Array<int, 1> &I_A1_VecInOut) const{
  int count = 0;
  if (I_A1_VecInOut.size() < 1)
    return false;
  for (int i=0; i < I_A1_VecInOut.size(); i++){
    #ifdef __DEBUG_FITS_COUNTPIXGTZERO__
      cout << "CFits::CountPixGTZero: i = " << i << ": I_A1_VecInOut(i) = " << I_A1_VecInOut(i) << endl;
    #endif
    if (I_A1_VecInOut(i) == 0)
      count = 0;
    else
      count++;
    #ifdef __DEBUG_FITS_COUNTPIXGTZERO__
      cout << "CFits::CountPixGTZero: i = " << i << ": count set to " << count << endl;
    #endif
    I_A1_VecInOut(i) = count;
    #ifdef __DEBUG_FITS_COUNTPIXGTZERO__
      cout << "CFits::CountPixGTZero: i = " << i << ": I_A1_VecInOut(i) set to " << I_A1_VecInOut(i) << endl;
    #endif
  }
  return true;
}

/**
  function FirstIndexWithValueGE
  Returns first index of integer input vector where value is greater than or equal to I_MinValue
  Returns -1 if values are always smaller than I_MinValue
 **/
int CFits::FirstIndexWithValueGE(const Array<int, 1> &I_A1_VecIn, const int I_MinValue) const{
  return this->FirstIndexWithValueGEFrom(I_A1_VecIn, I_MinValue, 0);
}

/**
 *        function FirstIndexWithValueGE
 *        returns first index of double input vector where value is greater than or equal to D_MinValue_In
 *        returns -1 if values are always smaller than D_MinValue_In
 **/
int CFits::FirstIndexWithValueGE(const Array<double, 1> &D_A1_VecIn, const double D_MinValue_In) const{
  return this->FirstIndexWithValueGEFrom(D_A1_VecIn, D_MinValue_In, 0);
}


/**
  function FirstIndexWithValueGEFrom
  Returns first index of integer input vector where value is greater than or equal to I_MinValue, starting at index I_FromIndex
  Returns -1 if values are always smaller than I_MinValue
 **/
int CFits::FirstIndexWithValueGEFrom(const Array<int, 1> &I_A1_VecIn, const int I_MinValue, const int I_FromIndex) const{
  //cout << "CFits::FirstIndexWithValueGEFrom: I_A1_VecIn = " << I_A1_VecIn << endl;
  //cout << "CFits::FirstIndexWithValueGEFrom: I_MinValue = " << I_MinValue << endl;
  //cout << "CFits::FirstIndexWithValueGEFrom: I_FromIndex = " << I_FromIndex << endl;
  if (I_A1_VecIn.size() < 1 || I_FromIndex >= I_A1_VecIn.size()){
    cout << "CFits::FirstIndexWithValueGEFrom: Error: I_A1_VecIn.size(=" << I_A1_VecIn.size() << ") < 1 or I_FromIndex >= I_A1_VecIn.size() => Returning -1" << endl;
    return -1;
  }
  for (int i=I_FromIndex; i < I_A1_VecIn.size(); i++){
    if (I_A1_VecIn(i) >= I_MinValue)
      return i;
  }
  cout << "CFits::FirstIndexWithValueGEFrom: not found => Returning -1" << endl;
  return -1;
}

/**
 *        function FirstIndexWithValueGEFrom
 *        returns first index of double input vector where value is greater than or equal to D_MinValue_In, starting at index I_FromIndex
 *        returns -1 if values are always smaller than D_MinValue_In
 **/
int CFits::FirstIndexWithValueGEFrom(const Array<double, 1> &D_A1_VecIn, const double D_MinValue_In, const int I_FromIndex) const{
  if (D_A1_VecIn.size() < 1 || I_FromIndex >= D_A1_VecIn.size()){
    cout << "CFits::FirstIndexWithValueGEFrom: Error: D_A1_VecIn.size(=" << D_A1_VecIn.size() << ") < 1 or I_FromIndex >= I_A1_VecIn.size() => Returning -1" << endl;
    return -1;
  }
  for (int i=I_FromIndex; i < D_A1_VecIn.size(); i++){
    if (D_A1_VecIn(i) >= D_MinValue_In)
      return i;
  }
  cout << "CFits::FirstIndexWithValueGEFrom: not found => Returning -1" << endl;
  return -1;
}

/**
  function FirstIndexWithValueGT
  Returns first index of integer input vector where value is greater than I_MinValue
  Returns -1 if values are always smaller than or equal to I_MinValue
 **/
int CFits::FirstIndexWithValueGT(const Array<int, 1> &I_A1_VecIn, const int I_MinValue) const{
  return this->FirstIndexWithValueGTFrom(I_A1_VecIn, I_MinValue, 0);
}

/**
 *        function FirstIndexWithValueGT
 *        returns first index of double input vector where value is greater than D_MinValue_In
 *        returns -1 if values are always smaller than or equal to D_MinValue_In
 **/
int CFits::FirstIndexWithValueGT(const Array<double, 1> &D_A1_VecIn, const double D_MinValue_In) const{
  return this->FirstIndexWithValueGTFrom(D_A1_VecIn, D_MinValue_In, 0);
}

/**
  function FirstIndexWithValueGTFrom
  Returns first index of integer input vector where value is greater than I_MinValue, starting at index I_FromIndex
  Returns -1 if values are always smaller than or equal to I_MinValue
 **/
int CFits::FirstIndexWithValueGTFrom(const Array<int, 1> &I_A1_VecIn, const int I_MinValue, const int I_FromIndex) const{
  if (I_A1_VecIn.size() < 1 || I_FromIndex >= I_A1_VecIn.size())
    return -1;
  for (int i=I_FromIndex; i < I_A1_VecIn.size(); i++){
    if (I_A1_VecIn(i) > I_MinValue)
      return i;
  }
  return -1;
}

/**
 *        function FirstIndexWithValueGTFrom
 *        returns first index of double input vector where value is greater than D_MinValue_In, starting at index I_FromIndex
 *        returns -1 if values are always smaller than or equal to D_MinValue_In
 **/
int CFits::FirstIndexWithValueGTFrom(const Array<double, 1> &D_A1_VecIn, const double D_MinValue_In, const int I_FromIndex) const{
  if (D_A1_VecIn.size() < 1 || I_FromIndex >= D_A1_VecIn.size())
    return -1;
  for (int i=I_FromIndex; i < D_A1_VecIn.size(); i++){
    if (D_A1_VecIn(i) > D_MinValue_In)
      return i;
  }
  return -1;
}

/**
  function LastIndexWithZeroValueBefore
  returns last index of integer input vector where value is equal to zero before index I_StartPos
  returns -1 if values are always greater than 0 before I_StartPos
 **/
int CFits::LastIndexWithZeroValueBefore(const Array<int, 1> &I_A1_VecIn, const int I_StartPos) const{
  if (I_StartPos < 0 || I_StartPos >= I_A1_VecIn.size())
    return -1;
  for (int i=I_StartPos; i >= 0; i--){
    if (I_A1_VecIn(i) == 0)
      return i;
  }
  return -1;
}

/**
 *        function LastIndexWithZeroValueBefore
 *        returns last index of double input vector where value is equal to zero, starting at index I_StartPos
 *        returns -1 if values are always greater than 0 before I_StartPos
 **/
int CFits::LastIndexWithZeroValueBefore(const Array<double, 1> &D_A1_VecIn, const int I_StartPos) const{
  if (I_StartPos < 0 || I_StartPos >= D_A1_VecIn.size())
    return -1;
  for (int i=I_StartPos; i >= 0; i--){
    if (fabs(D_A1_VecIn(i)) < 0.00000000000000001)
      return i;
  }
  return -1;
}

/**
  function FirstIndexWithZeroValueFrom
  returns first index of integer input vector where value is equal to zero, starting at index I_StartPos
  returns -1 if values are always greater than 0
 **/
int CFits::FirstIndexWithZeroValueFrom(const Array<int, 1> &I_A1_VecIn, const int I_StartPos) const{
  if (I_StartPos < 0 || I_StartPos >= I_A1_VecIn.size())
    return -1;
  for (int i=I_StartPos; i < I_A1_VecIn.size(); i++){
    #ifdef __DEBUG_FITS_FINDANDTRACE__
      cout << "CFits::FirstIndexWithZeroValueFrom: i = " << i << ":" << endl;
      cout << "CFits::FirstIndexWithZeroValueFrom: I_A1_VecIn(i) = " << I_A1_VecIn(i) << endl;
    #endif
    if (I_A1_VecIn(i) == 0)
      return i;
  }
  return -1;
}

/**
 *        function FirstIndexWithZeroValueFrom
 *        returns first index of double input vector where value is equal to zero, starting at index I_StartPos
 *        returns -1 if values are always greater than 0 past I_StartPos
 **/
int CFits::FirstIndexWithZeroValueFrom(const Array<double, 1> &D_A1_VecIn, const int I_StartPos) const{
  if (I_StartPos < 0 || I_StartPos >= D_A1_VecIn.size())
    return -1;
  for (int i=I_StartPos; i < D_A1_VecIn.size(); i++){
    #ifdef __DEBUG_FITS_FINDANDTRACE__
      cout << "CFits::FirstIndexWithZeroValueFrom: i = " << i << ":" << endl;
      cout << "CFits::FirstIndexWithZeroValueFrom: D_A1_VecIn(i) = " << D_A1_VecIn(i) << endl;
    #endif
    if (fabs(D_A1_VecIn(i)) < 0.00000000000000001)
      return i;
  }
  return -1;
}

/**
 *        function LastIndexWithNonZeroValueBefore
 *        returns last index of integer input vector where value is not equal to zero, starting at index I_StartPos
 *        returns -1 if values are always equal to 0 before I_StartPos
 **/
int CFits::LastIndexWithNonZeroValueBefore(const Array<int, 1> &I_A1_VecIn, const int I_StartPos) const{
  if (I_StartPos < 0 || I_StartPos >= I_A1_VecIn.size())
    return -1;
  for (int i=I_StartPos; i >= 0; i--){
    if (I_A1_VecIn(i) != 0)
      return i;
  }
  return -1;
}

/**
 *        function LastIndexWithNonZeroValueBefore
 *        returns last index of double input vector where value is not equal to zero, starting at index I_StartPos
 *        returns -1 if values are always equal to 0 before I_StartPos
 **/
int CFits::LastIndexWithNonZeroValueBefore(const Array<double, 1> &D_A1_VecIn, const int I_StartPos) const{
  if (I_StartPos < 0 || I_StartPos >= D_A1_VecIn.size())
    return -1;
  for (int i=I_StartPos; i >= 0; i--){
    if (fabs(D_A1_VecIn(i)) >= 0.00000000000000001)
      return i;
  }
  return -1;
}

/**
 function GetRowFromIndex(int I_Index_In, int I_NRows_In) const
 task: Returns Row specified by I_Index_In from the formula
       Col = (int)(I_Index_In / I_NRows_In)
       Row = I_IAperture_In - Col * I_NRows_In
 **/
int CFits::GetRowFromIndex(int I_Index_In, int I_NRows_In) const
{
  return (I_Index_In - (I_NRows_In * this->GetColFromIndex(I_Index_In, I_NRows_In)));
}

/**
 function GetColFromIndex(int I_Index_In, int I_NRows_In) const
 task: Returns Col specified by I_Index_In from the formula
       Col = (int)(I_Index_In / I_NRows_In)
       Row = I_IAperture_In - Col * I_NRows_In
 **/
int CFits::GetColFromIndex(int I_Index_In, int I_NRows_In) const
{
  return ((int)(I_Index_In / I_NRows_In));
}

/** ***********************************************************/

bool CFits::InsertAt(Array<double,1> *P_D_A1_In, double D_ToInsert, int I_Pos) const
{
  int size_old = P_D_A1_In->size();
  if (I_Pos > size_old || I_Pos < 0)
    return false;
  P_D_A1_In->resizeAndPreserve(size_old+1);
  if (I_Pos == size_old){
    (*P_D_A1_In)(size_old) = D_ToInsert;
    return true;
  }
  Array<double,1> D_A1_Temp(size_old);
  D_A1_Temp = (*P_D_A1_In)(Range(I_Pos,size_old-1));
  (*P_D_A1_In)(Range(I_Pos+1,size_old)) = D_A1_Temp;
  (*P_D_A1_In)(I_Pos) = D_ToInsert;
  return true;
}

/** ***********************************************************/

bool CFits::InsertAt(Array<int,1> *P_I_A1_In, int I_ToInsert, int I_Pos) const{
  cout << "CFits::InsertAt: START: (*P_I_A1_In) = " << (*P_I_A1_In) << endl;
  int size_old = P_I_A1_In->size();
  if (I_Pos > size_old || I_Pos < 0){
    cout << "CFits::InsertAt: I_Pos(=" << I_Pos << ") > size_old(=" << size_old << ") || I_Pos < 0 => returning FALSE" << endl;
    return false;
  }
  P_I_A1_In->resizeAndPreserve(size_old+1);
  if (I_Pos == size_old){
    (*P_I_A1_In)(size_old) = I_ToInsert;
    cout << "CFits::InsertAt: I_ToInsert(=" << I_ToInsert << ") inserted at position size_old(=" << size_old << ")" << endl;
    cout << "CFits::InsertAt: (*P_I_A1_In) set to " << (*P_I_A1_In) << endl;
    return true;
  }
  Array<int,1> I_A1_Temp(size_old);
  I_A1_Temp = (*P_I_A1_In)(Range(I_Pos,size_old-1));
  cout << "CFits::InsertAt: I_A1_Temp set to " << I_A1_Temp << endl;
  (*P_I_A1_In)(Range(I_Pos+1,size_old)) = I_A1_Temp;
  cout << "CFits::InsertAt: (*P_I_A1_In) set to " << (*P_I_A1_In) << endl;
  (*P_I_A1_In)(I_Pos) = I_ToInsert;
  cout << "CFits::InsertAt: I_ToInsert(=" << I_ToInsert << ") inserted at position I_Pos(=" << I_Pos << ")" << endl;
  cout << "CFits::InsertAt: (*P_I_A1_In) set to " << (*P_I_A1_In) << endl;
  return true;
}

/** **********************************************************/

/**
  Returns Indexes of I_A1_Where where I_A1_Where equals 1 and writes of sum(I_A1_Where) to I_NInd_Out
 **/
Array<int,1>* CFits::GetIndex(const Array<int,1> &I_A1_Where, int &I_NInd_Out) const
{
  I_NInd_Out = sum(I_A1_Where);
  int arrsize = I_NInd_Out;
  if (arrsize == 0){
    arrsize = 1;
  }
  Array<int,1> *P_Index_Out = new Array<int,1>(arrsize);
  (*P_Index_Out) = -1;
  int j=0;
  for (int i=0;i<I_A1_Where.size();i++){
    if (I_A1_Where(i) == 1){
      (*P_Index_Out)(j) = i;
      j++;
    }
  }
  return P_Index_Out;
}

/**
  Returns Indexes of I_A1_Where where I_A1_Where equals 1 and writes of sum(I_A1_Where) to I_NInd_Out
 **/
bool CFits::GetIndex(const Array<int,1> &I_A1_Where, int &I_NInd_Out, Array<int, 1> &I_IndArr_Out) const
{
  I_NInd_Out = sum(I_A1_Where);
  int arrsize = I_NInd_Out;
  if (arrsize == 0)
    arrsize = 1;
  I_IndArr_Out.resize(arrsize);
  I_IndArr_Out = -1;
  if (I_NInd_Out == 0)
    return false;
  int j=0;
  for (int i=0;i<I_A1_Where.size();i++){
    if (I_A1_Where(i) == 1){
      I_IndArr_Out(j) = i;
      j++;
    }
  }
  return true;
}

/**
Returns Indexes of I_A2_Where where I_A2_Where equals 1 and writes of sum(I_A2_Where) to I_NInd_Out
**/
Array<int,2>* CFits::GetIndex(const Array<int,2> &I_A2_Where, int &I_NInd_Out) const
{
  I_NInd_Out = sum(I_A2_Where);
  int arrsize = I_NInd_Out;
  if (arrsize == 0)
    arrsize = 1;
  Array<int,2> *P_Index_Out = new Array<int,2>(arrsize,2);
  (*P_Index_Out) = -1;
  int j=0;
  for (int i_row = 0; i_row < I_A2_Where.rows(); i_row++){
    for (int i_col = 0; i_col < I_A2_Where.cols(); i_col++){
      if (I_A2_Where(i_row, i_col) == 1){
        (*P_Index_Out)(j,0) = i_row;
        (*P_Index_Out)(j,1) = i_col;
        j++;
      }
    }
  }
  return P_Index_Out;
}

/**
Returns Indexes of I_A2_Where where I_A2_Where equals 1 and writes of sum(I_A2_Where) to I_NInd_Out
**/
bool CFits::GetIndex(const Array<int,2> &I_A2_Where, int &I_NInd_Out, Array<int, 2> &I_IndArr_Out) const
{
  I_NInd_Out = sum(I_A2_Where);
  int arrsize = I_NInd_Out;
  if (arrsize == 0)
    arrsize = 1;
  I_IndArr_Out.resize(arrsize,2);
  I_IndArr_Out = -1;
  if (I_NInd_Out == 0)
    return false;
  int j=0;
  for (int i_row = 0; i_row < I_A2_Where.rows(); i_row++){
    for (int i_col = 0; i_col < I_A2_Where.cols(); i_col++){
      if (I_A2_Where(i_row, i_col) == 1){
        I_IndArr_Out(j,0) = i_row;
        I_IndArr_Out(j,1) = i_col;
        j++;
      }
    }
  }
  return true;
}

/**
  Returns integer array containing the number of elements in D_A1_In within bin i
 **/
Array<int, 1>* CFits::Histogram(const Array<double,1> &D_A1_In, double D_BinSize_In) const
{
#ifdef __DEBUG_FITS_HISTOGRAM__
  cout << "CFits::Histogram: Start: D_A1_In = " << D_A1_In << endl;
  cout << "CFits::Histogram: Start: D_BinSize_In = " << D_BinSize_In << endl;
#endif

  double d_min = min(D_A1_In);
#ifdef __DEBUG_FITS_HISTOGRAM__
  cout << "CFits::Histogram: d_min = min(D_A1_In) set to " << d_min << endl;
#endif

  double d_max = max(D_A1_In);
#ifdef __DEBUG_FITS_HISTOGRAM__
  cout << "CFits::Histogram: d_max = max(D_A1_In) set to " << d_max << endl;
#endif

  int nbins = int((d_max-d_min)/D_BinSize_In) + 1;
#ifdef __DEBUG_FITS_HISTOGRAM__
  cout << "CFits::Histogram: nbins set to " << nbins << endl;
  Array<double,1> D_A1_Debug(1);
  Array<int,1> *P_I_A1_Debug;
  int nn;
#endif

  Array<int, 1> *P_I_A1_Out = new Array<int,1>(nbins);
  Array<int, 1> I_A1_Ind(D_A1_In.size());
  double bin_min = d_min;
  double bin_max = bin_min + D_BinSize_In;
  for (int i=0; i < nbins; i++){
#ifdef __DEBUG_FITS_HISTOGRAM__
    cout << "CFits::Histogram: for (i(=" << i << ")=0; i < nbins: i++): bin_min set to " << bin_min << endl;
    cout << "CFits::Histogram: for (i(=" << i << ")=0; i < nbins: i++): bin_max set to " << bin_max << endl;
#endif

    I_A1_Ind = where(D_A1_In >= bin_min && D_A1_In < bin_max,1,0);
#ifdef __DEBUG_FITS_HISTOGRAM__
    cout << "CFits::Histogram: for (i(=" << i << ")=0; i < nbins: i++): I_A1_Ind set to " << I_A1_Ind << endl;
    P_I_A1_Debug = GetIndex(I_A1_Ind,nn);
    D_A1_Debug.resize(sum(I_A1_Ind));
    GetSubArrCopy(D_A1_In,
                  *P_I_A1_Debug,
                  D_A1_Debug);
    cout << "CFits::Histogram: for (i(=" << i << ")=0; i < nbins: i++): D_A1_In(I_A1_Ind) = " << D_A1_Debug << endl;
    delete(P_I_A1_Debug);
#endif

    (*P_I_A1_Out)(i) = sum(I_A1_Ind);
#ifdef __DEBUG_FITS_HISTOGRAM__
    cout << "CFits::Histogram: for (i(=" << i << ")=0; i < nbins: i++): (*P_I_A1_Out)(i) set to " << (*P_I_A1_Out)(i) << endl;
#endif
    bin_min += D_BinSize_In;
    bin_max += D_BinSize_In;
  }
  return P_I_A1_Out;
}


/**
  Find
  Returns and Array<int, 1> containing the
 **
Array<int,1>* CFits::Find(const TinyVector<int,1> &I_TV_Index) const
{
//  Array<int,1> I_A1_Where(I_TV_Index.size());
//  int i_nind;
  Array<int,1> *P_I_A1_Index = this->GetIndex(expr,1,0);
//  cout << "CFits::Find: P_I_A1_Index set to " << *P_I_A1_Index << endl;
  return P_I_A1_Index;
}


/**
 Returns Array<int,1> with values of I_TV_Index
 **/
Array<int,1>* CFits::MaxIndex(TinyVector<int,1> &I_TV_Index) const
{
  Array<int,1> *P_Index_Out = new Array<int,1>(I_TV_Index.length());
  for (int i=0; i<I_TV_Index.length(); i++){
    (*P_Index_Out)(i) = I_TV_Index(i);
  }
  return P_Index_Out;
}

/**
  Returns I_A1_Index as Array<int,2>
  I_Mode == 0: IA1_Indices are running numbers going through rows, then cols: rows=5, cols=7, Ind=10 => (0,2)
            1: IA1_Indices are running numbers going through cols, then rows: rows=5, cols=7, Ind=10 => (1,3) **/
bool CFits::A1ToA2(Array<int,1> &I_A1_Indices, int I_NRows, int I_NCols, Array<int,2>& I_A2_Out, int I_Mode) const{
  int row, col;
  I_A2_Out.resize(I_A1_Indices.size(), 2);
  for (int m = 0; m < I_A1_Indices.size(); m++){
    if (I_A1_Indices(m) >= I_NRows * I_NCols){
      cout << "CFits::A1ToA2: ERROR: I_A1_Indices(m) >= I_NRows * I_NCols" << endl;
      return false;
    }
    if (I_Mode == 0){
      row = I_A1_Indices(m) % I_NRows;
#ifdef __DEBUG_FITS_A1TOA2__
      cout << "CFits::A1ToA2: row set to " << row << endl;
#endif
      col = int(I_A1_Indices(m) / I_NRows);
#ifdef __DEBUG_FITS_A1TOA2__
      cout << "CFits::A1ToA2: col set to " << col << endl;
#endif
    }
    else{
      col = I_A1_Indices(m) % I_NCols;
#ifdef __DEBUG_FITS_A1TOA2__
      cout << "CFits::A1ToA2: col set to " << col << endl;
#endif
      row = int(I_A1_Indices(m) / I_NCols);
#ifdef __DEBUG_FITS_A1TOA2__
      cout << "CFits::A1ToA2: row set to " << row << endl;
#endif
    }
    I_A2_Out(m,0) = row;
    I_A2_Out(m,1) = col;
  }
  return true;
}

/**
  LinearRegression(Array<double, 1> y, const Array<double, 1> x, a1, a0);
  calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
 **/
bool CFits::LinearRegression(const Array<double, 1> &D_A1_CCD_In,
                             const Array<double, 1> &D_A1_SF_In,
                             double &D_SP_Out,
                             double &D_Sky_Out,
                             double &D_STDDEV_Out,/// double &D_CorrelationCoefficient_Out,
                             double &D_Covariance_Out) const
{
  if (D_A1_CCD_In.size() != D_A1_SF_In.size()){
    cout << "CFits::LinearRegression: ERROR: D_A1_CCD_In.size(=" << D_A1_CCD_In.size() << ") != D_A1_SF_In.size(=" << D_A1_SF_In.size() << ") => returning false" << endl;
    D_SP_Out = 0.;
    D_Sky_Out = 0.;
    D_STDDEV_Out = 0.;
    D_Covariance_Out = 0.;
    return false;
  }

  /// Set D_A1_SF_In to zero where D_A1_CCD_In == zero
  Array<double, 1> D_A1_SF(D_A1_SF_In.size());
  D_A1_SF = where(fabs(D_A1_CCD_In) < 0.000000001, 0., D_A1_SF_In);

  double y_mean = sum(D_A1_CCD_In) / D_A1_CCD_In.size();
  double x_mean = sum(D_A1_SF) / D_A1_SF.size();
  double sum_xi_yi = sum(D_A1_SF * D_A1_CCD_In);
  double sum_xi = sum(D_A1_SF);
  double sum_xi_sqared = sum(pow(D_A1_SF,2));
  double sum_yi = sum(D_A1_CCD_In);
  D_SP_Out = (sum_xi_yi - y_mean * sum_xi)/(sum_xi_sqared - x_mean * sum_xi);
  D_Sky_Out = y_mean - x_mean * D_SP_Out;
  Array<double,1> D_A1_CCD_Theoretical(D_A1_CCD_In.size());
  D_A1_CCD_Theoretical = D_SP_Out * (D_A1_SF - x_mean) + y_mean;
  D_STDDEV_Out = sqrt((sum(pow(D_A1_CCD_In - D_A1_CCD_Theoretical,2)))/(D_A1_SF.size()-2));
///  D_CorrelationCoefficient_Out = sum((D_A1_SF - x_mean) * (D_A1_CCD_In - y_mean)) / sqrt(sum(pow(D_A1_SF - x,2)) + sum(D_A1_CCD_In - ;
  D_Covariance_Out = (sum_xi_yi - ((sum_xi * sum_yi)/D_A1_SF.size())) / (D_A1_SF.size() - 1.);
  return true;
}

/**
  LinearRegression(Array<double, 1> y, const Array<double, 1> x, a1, a0);
  calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
 **/
bool CFits::LinearRegression(const Array<double, 2> &D_A2_CCD_In,
                             const Array<double, 2> &D_A2_SF_In,
                             Array<double,1> &D_A1_SP_Out,
                             Array<double,1> &D_A1_Sky_Out,
                             Array<double,1> &D_A1_STDDEV_Out,/// double &D_CorrelationCoefficient_Out,
                             Array<double,1> &D_A1_Covariance_Out) const
{
  if (D_A2_CCD_In.rows() != D_A2_SF_In.rows()){
    cout << "CFits::LinearRegression: ERROR: D_A2_CCD_In.rows(=" << D_A2_CCD_In.rows() << ") != D_A2_SF_In.rows(=" << D_A2_SF_In.rows() << ") => returning false" << endl;
    D_A1_SP_Out = 0.;
    D_A1_Sky_Out = 0.;
    D_A1_STDDEV_Out = 0.;
    D_A1_Covariance_Out = 0.;
    return false;
  }
  if (D_A2_CCD_In.cols() != D_A2_SF_In.cols()){
    cout << "CFits::LinearRegression: ERROR: D_A2_CCD_In.cols(=" << D_A2_CCD_In.cols() << ") != D_A2_SF_In.cols(=" << D_A2_SF_In.cols() << ") => returning false" << endl;
    D_A1_SP_Out = 0.;
    D_A1_Sky_Out = 0.;
    D_A1_STDDEV_Out = 0.;
    D_A1_Covariance_Out = 0.;
    return false;
  }

  D_A1_SP_Out.resize(D_A2_CCD_In.rows());
  D_A1_Sky_Out.resize(D_A2_CCD_In.rows());
  D_A1_STDDEV_Out.resize(D_A2_CCD_In.rows());
  D_A1_Covariance_Out.resize(D_A2_CCD_In.rows());
  for (int i=0; i < D_A2_CCD_In.rows(); i++){
    if (!this->LinearRegression(D_A2_CCD_In(i,Range::all()),
                                D_A2_SF_In(i,Range::all()),
                                D_A1_SP_Out(i),
                                D_A1_Sky_Out(i),
                                D_A1_STDDEV_Out(i),
                                D_A1_Covariance_Out(i))){
      cout << "CFits::LinearRegression: ERROR: this->LinearRegression(D_A2_CCD_In(i,Range::all()),D_A2_SF_In(i,Range::all()),D_A1_SP_Out(i),D_A1_Sky_Out(i),D_A1_STDDEV_Out(i),D_A1_Covariance_Out(i)) returned false" << endl;
      return false;
    }
  }

  return true;
}


/**
  LinFit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
  calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
 **/
bool CFits::LinFit(const Array<double, 1> &D_A1_CCD_In,      /// yvec: in
                   const Array<double, 1> &D_A1_SF_In,       /// xvec: in
                   double &D_SP_Out,                         /// a1: out
                   double &D_Sky_Out,                        /// a0: out
                   const Array<CString, 1> &CS_A1_Args_In,   ///: in
                   void *ArgV_In[]) const                    ///: in
    ///            COVAR =   double &D_Covariance_Out) const          : out
    ///            SDEV_IN = Array<double,1>(D_A1_CCD_In.size)        : in
    ///            REJECT = double                                    : in
    ///            MEASURE_ERRORS = Array<double,1>(D_A1_CCD_In.size) : in
    ///            CHISQ = double                                     : out
    ///            PROB = double                                      : out
    ///            SIGMA = Array<double,1>(2)                         : out
    ///            COVAR = Array<double,2>(2,2)                       : out
    ///            YFIT = Array<double,1>(D_A1_CCD_In.size)           : out
{
  int I_KeywordSet_SDev, I_KeywordSet_MeasureErrors, I_KeywordSet_Mask, I_KeywordSet_Reject, I_KeywordSet_YFit, I_KeywordSet_Prob, I_KeywordSet_ChiSq;

  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: starting " << endl;
  #endif
  if (D_A1_CCD_In.size() != D_A1_SF_In.size()){
    cout << "CFits::LinFit: ERROR: D_A1_CCD_In.size(=" << D_A1_CCD_In.size() << ") != D_A1_SF_In.size(=" << D_A1_SF_In.size() << ") => returning false" << endl;
    D_SP_Out = 0.;
    D_Sky_Out = 0.;
    return false;
  }

  ///  nX = N_ELEMENTS(x)
  ///  nY = N_ELEMENTS(y)
  int nX = D_A1_SF_In.size();
  int nY = D_A1_CCD_In.size();
  int I_NDataPoints;
  #ifdef __DEBUG_FITS_LINFIT__
  cout << "CFits::LinFit: nX = " << nX << ", nY = " << nY << endl;
  #endif

  if (nX != nY){
    cout << "CFits::LinFit: X and Y must be vectors of equal length." << endl;
    return false;
  }

  /// Set D_A1_SF_In to zero where D_A1_CCD_In == zero
///  Array<double, 1> D_A1_SF(D_A1_SF_In.size());
///  D_A1_SF = where(fabs(D_A1_CCD_In) < 0.000000001, 0., D_A1_SF_In);
///  #ifdef __DEBUG_FITS_LINFIT__
///    cout << "CFits::LinFit: D_A1_SF set to " << D_A1_SF << endl;
///  #endif

  int I_Pos;
  Array<double, 1> D_A1_SF(1);
  Array<double, 1> D_A1_CCD(1);//D_A1_CCD_In.size());

  Array<int, 1> *P_I_A1_Mask = new Array<int, 1>(nX);
  Array<int, 1> I_A1_Mask_Orig(nX);
  I_KeywordSet_Mask = KeyWord_Set(CS_A1_Args_In,CString("MASK"));
  if (I_KeywordSet_Mask >= 0){
    delete(P_I_A1_Mask);
    P_I_A1_Mask = (Array<int, 1>*)ArgV_In[I_KeywordSet_Mask];
  }
  else{
    *P_I_A1_Mask = 1;
  }
  I_A1_Mask_Orig = (*P_I_A1_Mask);
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_I_A1_Mask set to " << *P_I_A1_Mask << endl;
  #endif

  double *P_D_Reject = new double(-1);
  bool B_Reject = false;
  I_KeywordSet_Reject = KeyWord_Set(CS_A1_Args_In,CString("REJECT"));
  if (I_KeywordSet_Reject >= 0){
    delete(P_D_Reject);
    P_D_Reject = (double*)ArgV_In[I_KeywordSet_Reject];
  }
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_Reject set to " << *P_D_Reject << endl;
  #endif
  if (*P_D_Reject >= 0)
    B_Reject = true;

///  FUNCTION LinFit, x, y, $
///     chisqr = chisqr, Double = DoubleIn, prob = prob, $
///     sig_ab = sig_ab, sigma = sigma, $
///     COVAR=covar,YFIT=yfit, MEASURE_ERRORS=measure_errors, $
///     SDEV = sdevIn  ; obsolete keyword (still works)

///  ;If the DOUBLE keyword is not set then the internal precision and
///  ;result are identical to the type of input.
///  double = (N_ELEMENTS(doubleIn) gt 0) ? KEYWORD_SET(doubleIn) : $
///    (SIZE(x, /TYPE) eq 5) || (SIZE(y, /TYPE) eq 5)

  Array<double,1> *P_D_A1_SDev = new Array<double, 1>(1);
  Array<double,1> D_A1_SDev(1);
  Array<double,1> D_A1_WT(1);
  Array<double,1> D_A1_T(1);
  Array<int,1> I_A1_Mask(1);

  int nSDev;
  double D_SDev = 0.;
  bool B_Run = true;
  ///  isSdev = N_ELEMENTS(sdevIn) GT 0
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: starting to look for SDEV_IN " << endl;
  #endif
  I_KeywordSet_SDev = KeyWord_Set(CS_A1_Args_In,CString("SDEV_IN"));
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: I_KeywordSet_SDev set to " << I_KeywordSet_SDev << endl;
  #endif

  ///  isMeasure = N_ELEMENTS(measure_errors) GT 0
  I_KeywordSet_MeasureErrors = KeyWord_Set(CS_A1_Args_In,CString("MEASURE_ERRORS"));
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: I_KeywordSet_MeasureErrors set to " << I_KeywordSet_MeasureErrors << endl;
  #endif

  ///  IF (isSdev OR isMeasure) THEN BEGIN
  if (I_KeywordSet_SDev >= 0 || I_KeywordSet_MeasureErrors >= 0){
    ///    IF (isSdev AND isMeasure) THEN $
    if (I_KeywordSet_SDev >= 0 && I_KeywordSet_MeasureErrors >= 0){
      cout << "CFits::LinFit: ERROR: Conflicting keywords SDEV and MEASURE_ERRORS." << endl;
      return false;
    }

    ///    sdev = isMeasure ? measure_errors : sdevIn
    delete(P_D_A1_SDev);
    if (I_KeywordSet_MeasureErrors >= 0)
      P_D_A1_SDev = (Array<double,1> *)ArgV_In[I_KeywordSet_MeasureErrors];
    else
      P_D_A1_SDev = (Array<double,1> *)ArgV_In[I_KeywordSet_SDev];//this->Replicate(*((double*)ArgV_In[I_KeywordSet_SDev]), nX);

    ///    nsdev = N_ELEMENTS(sdev)
    nSDev = P_D_A1_SDev->size();

    ///    IF (nsdev NE nX) THEN MESSAGE, $
    if (nSDev != nX){
      cout << "CFits::LinFit: ERROR: MEASURE_ERRORS must have the number of elements as X and Y." << endl;
      return false;
    ///  ENDIF ELSE BEGIN
    }
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: *P_D_A1_SDev set to " << *P_D_A1_SDev << endl;
      cout << "CFits::LinFit: nSDev set to " << nSDev << endl;
    #endif
  }
  else{
    D_SDev = 1.;
    nSDev = 0;
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_SDev set to " << D_SDev << endl;
      cout << "CFits::LinFit: nSDev set to " << nSDev << endl;
    #endif
    ///    sdev = double ? 1d : 1.0
    ///    nsdev = 0
    ///  ENDELSE
  }

  double *P_D_Prob;// = new double(0.);
  I_KeywordSet_Prob = KeyWord_Set(CS_A1_Args_In,CString("PROB"));
  if (I_KeywordSet_Prob >= 0){
    P_D_Prob = (double*)ArgV_In[I_KeywordSet_Prob];
  }
  else
    P_D_Prob = new double(0.);
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_Prob set to " << *P_D_Prob << endl;
  #endif

  double D_sdevdat;
  double D_CoVar;
  Array<double,2> D_A2_CoVar(2,2);
  Array<double,1> D_A1_Check(nX);
  Array<int,1> I_A1_LastMask(nX);

  double D_st2;
  double D_sdeva;
  double D_sdevb;
  double D_SDevReject;
  int I_NRejected, I_SumMaskLast;
  double D_ss, D_sx, D_sy, D_b, D_a;

  Array<double,1> *P_D_A1_YFit = new Array<double,1>(1);
  Array<double,1> D_A1_YFit(1);
  I_KeywordSet_YFit = KeyWord_Set(CS_A1_Args_In,CString("YFIT"));
  if (I_KeywordSet_YFit >= 0){
    delete(P_D_A1_YFit);
    P_D_A1_YFit = (Array<double,1>*)ArgV_In[I_KeywordSet_YFit];
  }
  P_D_A1_YFit->resize(nX);
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_A1_YFit set to " << *P_D_A1_YFit << endl;
  #endif

  double *P_D_ChiSqr = new double(0.);
  I_KeywordSet_ChiSq = KeyWord_Set(CS_A1_Args_In,CString("CHISQ"));
  if (I_KeywordSet_ChiSq >= 0){
    delete(P_D_ChiSqr);
    P_D_ChiSqr = (double*)ArgV_In[I_KeywordSet_ChiSq];
  }
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_ChiSq set to " << *P_D_ChiSqr << endl;
  #endif

  Array<double, 1> D_A1_YFitTemp(D_A1_CCD_In.size());

  ///; for explanation of constants see Numerical Recipes sec. 15-2
  ///  if nsdev eq nX then begin ;Standard deviations are supplied.
  int I_NGood;
  while (B_Run){
    I_NDataPoints = sum(*P_I_A1_Mask);
    I_A1_Mask.resize(I_NDataPoints);
    D_A1_WT.resize(I_NDataPoints);
    D_A1_T.resize(I_NDataPoints);
    D_A1_CCD.resize(I_NDataPoints);
    D_A1_SF.resize(I_NDataPoints);
    D_A1_SDev.resize(I_NDataPoints);
    D_A1_YFit.resize(I_NDataPoints);

    I_NGood = 0;
    for (int i = 0; i < nX; i++){
      if ((*P_I_A1_Mask)(i) > 0){
        I_A1_Mask(I_NGood) = 1;
        D_A1_SF(I_NGood) = D_A1_SF_In(i);
        D_A1_SDev(I_NGood) = (*P_D_A1_SDev)(i);
        D_A1_CCD(I_NGood) = D_A1_CCD_In(i);

        I_NGood++;
      }
      else{
        cout << "CFits::LinFit: Element " << i << " removed from calculations" << endl;
      }
    }
    #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: D_A1_CCD set to " << D_A1_CCD << endl;
    #endif

    if (nSDev == nX){
      /// wt = 1/(sdev^(double ? 2d : 2.0))
      D_A1_WT = 1. / pow(D_A1_SDev,2.);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == nX: D_A1_WT set to " << D_A1_WT << endl;
      #endif

      /// ss = TOTAL(wt, DOUBLE=double)
      D_ss = sum(D_A1_WT);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == nX: D_ss set to " << D_ss << endl;
      #endif

      /// sx = TOTAL(wt * x, DOUBLE=double)
      D_sx = sum(D_A1_WT * D_A1_SF);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == nX: D_sx set to " << D_sx << endl;
      #endif

      /// sy = TOTAL(wt * y, DOUBLE=double)
      D_sy = sum(D_A1_WT * D_A1_CCD);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == nX: D_sy set to " << D_sy << endl;
      #endif

      ///    t =  (x - sx/ss) / sdev
      D_A1_T = (D_A1_SF - D_sx/D_ss) / (D_A1_SDev);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == nX: D_A1_T set to " << D_A1_T << endl;
      #endif

      ///    b = TOTAL(t * y / sdev, DOUBLE=double)
      D_b = sum(D_A1_T * D_A1_CCD / (D_A1_SDev));
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == nX: D_b set to " << D_b << endl;
      #endif
      ///  endif else begin
    }
    else{
      /// ss = nX
      D_ss = I_NDataPoints;
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev != nX: D_ss set to " << D_ss << endl;
      #endif

      /// sx = TOTAL(x, DOUBLE=double)
      D_sx = sum(D_A1_SF);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev != nX: D_sx set to " << D_sx << endl;
      #endif

      /// sy = TOTAL(y, DOUBLE=double)
      D_sy = sum(D_A1_CCD);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev != nX: D_sy set to " << D_sy << endl;
      #endif

      ///    t = x - sx/ss
      D_A1_T = D_A1_SF - D_sx / D_ss;
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev != nX: D_A1_T set to " << D_A1_T << endl;
      #endif

      ///    b = TOTAL(t * y)
      D_b = sum(D_A1_T * D_A1_CCD);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev != nX: D_b set to " << D_b << endl;
      #endif
      ///  endelse
    }

    ///  st2 = TOTAL(t^2, DOUBLE=double)
    D_st2 = sum(pow(D_A1_T,2.));
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_st2 set to " << D_st2 << endl;
    #endif

    ///  IF (NOT double) THEN BEGIN
    ///   ss = FLOAT(ss)
    ///   sx = FLOAT(sx)
    ///   sy = FLOAT(sy)
    ///   st2 = FLOAT(st2)
    ///   b = FLOAT(b)
    ///  ENDIF

    ///; parameter estimates
    ///  b = b / st2
    D_b = D_b / D_st2;
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_b set to " << D_b << endl;
    #endif

    ///  a = (sy - sx * b) / ss
    D_a = (D_sy - D_sx * D_b) / D_ss;
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_a set to " << D_a << endl;
    #endif

    ///; error estimates
    ///  sdeva = SQRT((1.0 + sx * sx / (ss * st2)) / ss)
    D_sdeva = sqrt ((1. + D_sx * D_sx / (D_ss * D_st2)) / D_ss);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_sdeva set to " << D_sdeva << endl;
    #endif

    ///  sdevb = SQRT(1.0 / st2)
    D_sdevb = sqrt(1. / D_st2);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_sdevb set to " << D_sdevb << endl;
    #endif

    ///  covar = -sx/(ss*st2)
    D_CoVar = 0. - D_sx / (D_ss * D_st2);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_CoVar set to " << D_CoVar << endl;
    #endif
    D_A2_CoVar = D_CoVar;
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_A2_CoVar set to " << D_A2_CoVar << endl;
    #endif

    ///  covar = [[sdeva^2, covar], [covar, sdevb^2]]
    D_A2_CoVar(0,0) = pow(D_sdeva,2.);
    D_A2_CoVar(1,1) = pow(D_sdevb,2.);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_A2_CoVar set to " << D_A2_CoVar << endl;
    #endif
    I_Pos = KeyWord_Set(CS_A1_Args_In,CString("COVAR"));
    if (I_Pos >= 0)
      *((Array<double, 2>*)ArgV_In[I_Pos]) = D_A2_CoVar;

    ///  yfit = b*x + a
    D_A1_YFit = D_b * D_A1_SF + D_a;
    *P_D_A1_YFit = D_b * D_A1_SF_In + D_a;
//    D_A1_YFitTemp = where(*P_D_A1_YFit
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: D_A1_YFit set to " << D_A1_YFit << endl;
      cout << "CFits::LinFit: *P_D_A1_YFit set to " << *P_D_A1_YFit << endl;
    #endif

    ///  if nsdev ne 0 then begin
    if (nSDev != 0){
      ///    chisqr = TOTAL( ((y - yfit) / sdev)^2, Double = Double )
      *P_D_ChiSqr = sum( pow((D_A1_CCD - D_A1_YFit) / (D_A1_SDev),2.));
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev != 0: *P_D_ChiSqr set to " << *P_D_ChiSqr << endl;
      #endif
      ///    if ~Double then $
      ///        chisqr = FLOAT(chisqr)
      ///    prob = 1 - IGAMMA(0.5*(nX-2), 0.5*chisqr)
      if (!this->GammQ(0.5 * (I_NDataPoints-2), 0.5 * (*P_D_ChiSqr), P_D_Prob)){
        cout << "CFits::LinFit: ERROR: GammQ returned false" << endl;
        return false;
      }
      *P_D_Prob = 1. - (*P_D_Prob);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev != 0: *P_D_Prob set to " << *P_D_Prob << endl;
      #endif
      ///  endif else begin
    }
    else{
      ///    chisqr = TOTAL( (y - yfit)^2, Double = Double )
      *P_D_ChiSqr = sum(pow(D_A1_CCD - D_A1_YFit,2.));
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == 0: *P_D_ChiSqr set to " << *P_D_ChiSqr << endl;
      #endif
      ///    if ~Double then $
      ///        chisqr = FLOAT(chisqr)
      ///    prob = double ? 1d : 1.0
      *P_D_Prob = 1.;
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == 0: *P_D_Prob set to " << *P_D_Prob << endl;
      #endif

      ///    sdevdat = SQRT(chisqr / (nX-2))
      D_sdevdat = sqrt((*P_D_ChiSqr) / (nX-2));
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == 0: D_sdevdat set to " << D_sdevdat << endl;
      #endif

      ///    sdeva = sdeva * sdevdat
      D_sdeva = D_sdeva * D_sdevdat;
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == 0: D_sdeva set to " << D_sdeva << endl;
      #endif

      ///    sdevb = sdevb * sdevdat
      D_sdevb = D_sdevb * D_sdevdat;
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: nSDev == 0: D_sdevb set to " << D_sdevb << endl;
      #endif
      ///  endelse
    }
    if (!B_Reject)
      B_Run = false;
    else{
      I_SumMaskLast = sum(*P_I_A1_Mask);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: Reject: I_SumMaskLast = " << I_SumMaskLast << endl;
      #endif
      D_SDevReject = sqrt((sum(pow((D_A1_CCD - D_A1_YFit) / D_A1_YFit,2.))) / (I_NDataPoints));//(sum(pow(D_A1_CCD - (D_A1_YFit),2)) / I_SumMaskLast);
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: Reject: D_SDevReject = " << D_SDevReject << endl;
      #endif
      D_A1_Check = fabs((D_A1_CCD_In - (*P_D_A1_YFit)) / where((*P_D_A1_YFit) < 0.0000000001, 0.0000001, (*P_D_A1_YFit)));
      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: Reject: *P_D_A1_YFit = " << *P_D_A1_YFit << endl;
        cout << "CFits::LinFit: Reject: D_A1_Check = " << D_A1_Check << endl;
      #endif

      I_A1_LastMask = *P_I_A1_Mask;
      *P_I_A1_Mask = where(D_A1_Check > (*P_D_Reject) * D_SDevReject, 0, 1);
      *P_I_A1_Mask = where(I_A1_Mask_Orig < 1, 0, *P_I_A1_Mask);
      if (sum(*P_I_A1_Mask) == sum(I_A1_Mask_Orig))
        B_Reject = false;
      else
        *P_I_A1_Mask = where(I_A1_LastMask < 1, 0, *P_I_A1_Mask);
//      #ifdef __DEBUG_FITS_LINFIT__
        cout << "CFits::LinFit: Reject: *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
//      #endif
      if (fabs(min(*P_D_A1_YFit)) < 0.000000001)
        return false;

      if (I_SumMaskLast == sum(*P_I_A1_Mask)){
        B_Run = false;
        #ifdef __DEBUG_FITS_LINFIT__
          cout << "CFits::LinFit: leaving while loop" << endl;
        #endif
      }
    }
  }/// end while (B_Run)
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: while loop left" << endl;
  #endif

  ///  sigma = (sig_ab = [sdeva, sdevb])
  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("SIGMA"));
  if (I_Pos >= 0){
    Array<double,1> *P_D_A1_Sigma = (Array<double,1>*)ArgV_In[I_Pos];
    (*P_D_A1_Sigma)(0) = D_sdevb;
    (*P_D_A1_Sigma)(1) = D_sdeva;
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: SIGMA: *P_D_A1_Sigma = " << *P_D_A1_Sigma << endl;
    #endif
  }

  D_SP_Out = D_b;
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: D_SP_Out = " << D_SP_Out << endl;
  #endif

  D_Sky_Out = D_a;
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: D_Sky_Out = " << D_Sky_Out << endl;
  #endif
  ///  RETURN, [a, b]

  /// clean up
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_A1_SDev = " << *P_D_A1_SDev << endl;
  #endif
  if (I_KeywordSet_MeasureErrors < 0){
    P_D_A1_SDev->resize(0);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: P_D_A1_SDev deleted" << endl;
    #endif
  }

  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_Prob = " << *P_D_Prob << endl;
  #endif
  if (I_KeywordSet_Prob < 0){
    delete(P_D_Prob);
    #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: P_D_Prob deleted" << endl;
    #endif
  }

  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_A1_YFit = " << *P_D_A1_YFit << endl;
  #endif
  if (I_KeywordSet_YFit < 0){
    delete(P_D_A1_YFit);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: P_D_A1_YFit deleted" << endl;
    #endif
  }

  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_ChiSqr = " << *P_D_ChiSqr << endl;
  #endif
  if (I_KeywordSet_ChiSq < 0){
    delete(P_D_ChiSqr);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: P_D_ChiSqr deleted" << endl;
    #endif
  }

  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
  #endif
  if (I_KeywordSet_Mask < 0){
    delete(P_I_A1_Mask);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: P_I_A1_Mask deleted" << endl;
    #endif
  }

  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit: *P_D_Reject(=" << P_D_Reject << ") = " << *P_D_Reject << endl;
    cout << "CFits::LinFit: I_KeywordSet_Reject = " << I_KeywordSet_Reject << endl;
  #endif
  if (I_KeywordSet_Reject < 0){
    delete(P_D_Reject);
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit: P_D_Reject deleted" << endl;
    #endif
  }

  return true;
}

/**
  LinFit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
  calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
 **/
bool CFits::LinFit(const Array<double, 2> &D_A2_CCD_In,      ///: in
                   const Array<double, 2> &D_A2_SF_In,       ///: in
                   Array<double,1> &D_A1_SP_Out,             ///: out
                   Array<double,1> &D_A1_Sky_Out,            ///: out
                   const Array<CString, 1> &CS_A1_Args_In,   ///: in
                   void *ArgV_In[]) const                    ///: in
    ///            SDEV_IN = Array<double,2>(D_A2_CCD_In.rows, D_A2_CCD_In.cols)        : in
    ///            MEASURE_ERRORS = Array<double,2>(D_A2_CCD_In.rows, D_A2_CCD_In.cols) : in
    ///            REJECT = double                                    : in
    ///            CHISQ = Array<double,1>(D_A2_CCD_In.rows)                            : out
    ///            PROB = Array<double,1>(D_A2_CCD_In.rows)                             : out
    ///            SIGMA = Array<double,2>(D_A2_CCD_In.rows, 2)                         : out
    ///            COVAR = Array<double,3>(D_A2_CCD_In.rows, 2, 2)                      : out
    ///            YFIT = Array<double,2>(D_A2_CCD_In.rows, D_A2_CCD_In.cols)           : out
{
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit2D: starting " << endl;
  #endif

  Array<double,2> *P_D_A2_CoVar;
  Array<double,1> *P_D_A1_SDev;
  Array<double,1> *P_D_A1_MeasureErrors;
  Array<double,1> *P_D_A1_Sigma;
  Array<double,1> *P_D_A1_YFit;
  Array<int, 1> *P_I_A1_Mask;
  double *P_D_Reject;

  if (D_A2_CCD_In.rows() != D_A2_SF_In.rows()){
    cout << "CFits::LinFit: ERROR: D_A2_CCD_In.rows(=" << D_A2_CCD_In.rows() << ") != D_A2_SF_In.rows(=" << D_A2_SF_In.rows() << ") => returning false" << endl;
    D_A1_SP_Out = 0.;
    D_A1_Sky_Out = 0.;
    return false;
  }
  if (D_A2_CCD_In.cols() != D_A2_SF_In.cols()){
    cout << "CFits::LinFit: ERROR: D_A2_CCD_In.cols(=" << D_A2_CCD_In.cols() << ") != D_A2_SF_In.cols(=" << D_A2_SF_In.cols() << ") => returning false" << endl;
    D_A1_SP_Out = 0.;
    D_A1_Sky_Out = 0.;
    return false;
  }

  D_A1_SP_Out.resize(D_A2_CCD_In.rows());
  D_A1_Sky_Out.resize(D_A2_CCD_In.rows());

  Array<CString,1> CS_A1_Args_LinFit(10);
  CS_A1_Args_LinFit = CString(" ");
  void **PP_Args_LinFit = (void**)malloc(sizeof(void*) * 10);

  int I_Pos;
  int pos = 0;

  /// input paramters
  Array<double,2> *P_D_A2_SDev;
  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("SDEV_IN"));
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::LinFit2D: starting " << endl;
  #endif
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking SDEV_IN" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("SDEV_IN");
    P_D_A2_SDev = (Array<double,2>*)ArgV_In[I_Pos];
    if (P_D_A2_SDev->rows() != D_A2_CCD_In.rows()){
      cout << "CFits::LinFit2D: ERROR: P_D_A2_SDev->rows() != D_A2_CCD_In.rows() => returning FALSE" << endl;
      return false;
    }
    if (P_D_A2_SDev->cols() != D_A2_CCD_In.cols()){
      cout << "CFits::LinFit2D: ERROR: P_D_A2_SDev->cols() != D_A2_CCD_In.cols() => returning FALSE" << endl;
      return false;
    }
    pos++;
  }

  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS"));
  Array<double,2> *P_D_A2_MeasureErrors;
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking MEASURE_ERRORS" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("MEASURE_ERRORS");
    P_D_A2_MeasureErrors = (Array<double,2>*)ArgV_In[I_Pos];
    if (P_D_A2_MeasureErrors->rows() != D_A2_CCD_In.rows()){
      cout << "CFits::LinFit2D: ERROR: P_D_A2_MeasureErrors->rows() != D_A2_CCD_In.rows() => returning FALSE" << endl;
      return false;
    }
    if (P_D_A2_MeasureErrors->cols() != D_A2_CCD_In.cols()){
      cout << "CFits::LinFit2D: ERROR: P_D_A2_MeasureErrors->cols() != D_A2_CCD_In.cols() => returning FALSE" << endl;
      return false;
    }
    pos++;
  }

  Array<int,2> *P_I_A2_Mask;
  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("MASK"));
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking MASK" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("MASK");
    P_I_A2_Mask = (Array<int,2>*)ArgV_In[I_Pos];
    if (P_I_A2_Mask->rows() != D_A2_CCD_In.rows()){
      cout << "CFits::LinFit2D: ERROR: P_I_A2_Mask->rows() != D_A2_CCD_In.rows() => returning FALSE" << endl;
      return false;
    }
    if (P_I_A2_Mask->cols() != D_A2_CCD_In.cols()){
      cout << "CFits::LinFit2D: ERROR: P_I_A2_Mask->cols() != D_A2_CCD_In.cols() => returning FALSE" << endl;
      return false;
    }
    pos++;
  }

  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("REJECT"));
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking REJECT" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("REJECT");
    P_D_Reject = (double*)ArgV_In[I_Pos];
    pos++;
  }

  /// output parameters
  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("COVAR"));
  Array<double,3> *P_D_A3_CoVar;
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking COVAR" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("COVAR");
    P_D_A3_CoVar = (Array<double,3>*)ArgV_In[I_Pos];
    P_D_A3_CoVar->resize(D_A2_CCD_In.rows(), 2, 2);
    *P_D_A3_CoVar = 0.;
    pos++;
  }

  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("CHISQ"));
  Array<double,1> *P_D_A1_ChiSq;
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking CHISQ" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("CHISQ");
    P_D_A1_ChiSq = (Array<double,1>*)ArgV_In[I_Pos];
    P_D_A1_ChiSq->resize(D_A2_CCD_In.rows());
    (*P_D_A1_ChiSq) = 0.;
    pos++;
  }

  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("PROB"));
  Array<double,1> *P_D_A1_Prob;
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking PROB" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("PROB");
    P_D_A1_Prob = (Array<double,1>*)ArgV_In[I_Pos];
    P_D_A1_Prob->resize(D_A2_CCD_In.rows());
    (*P_D_A1_Prob) = 0.;
    pos++;
  }

  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("SIGMA"));
  Array<double,2> *P_D_A2_Sigma;
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking SIGMA" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("SIGMA");
    P_D_A2_Sigma = (Array<double,2>*)ArgV_In[I_Pos];
    P_D_A2_Sigma->resize(D_A2_CCD_In.rows(), 2);
    *P_D_A2_Sigma = 0.;
    pos++;
  }

  I_Pos = KeyWord_Set(CS_A1_Args_In, CString("YFIT"));
  Array<double,2> *P_D_A2_YFit;
  if (I_Pos >= 0){
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: checking YFIT" << endl;
    #endif
    CS_A1_Args_LinFit(pos).Set("YFIT");
    P_D_A2_YFit = (Array<double,2>*)ArgV_In[I_Pos];
    P_D_A2_YFit->resize(D_A2_CCD_In.rows(), D_A2_CCD_In.cols());
    *P_D_A2_YFit = 0.;
    pos++;
  }

  for (int m=0; m < D_A2_CCD_In.rows(); m++){
    pos = 0;
    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("SDEV_IN"));
    if (I_Pos >= 0){
///      delete(P_D_A1_SDev);
      P_D_A1_SDev = new Array<double,1>((*P_D_A2_SDev)(m, Range::all()));
      PP_Args_LinFit[pos] = P_D_A1_SDev;
      pos++;
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS"));
    if (I_Pos >= 0){
      P_D_A1_MeasureErrors = new Array<double,1>((*P_D_A2_MeasureErrors)(m, Range::all()));
      PP_Args_LinFit[pos] = P_D_A1_MeasureErrors;
      pos++;
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("MASK"));
    if (I_Pos >= 0){
      P_I_A1_Mask = new Array<int,1>((*P_I_A2_Mask)(m, Range::all()));
      PP_Args_LinFit[pos] = P_I_A1_Mask;
      pos++;
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("REJECT"));
    if (I_Pos >= 0){
      PP_Args_LinFit[pos] = P_D_Reject;
      pos++;
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("COVAR"));
    if (I_Pos >= 0){
      P_D_A2_CoVar = new Array<double,2>((*P_D_A3_CoVar)(m, Range::all(), Range::all()));
      PP_Args_LinFit[pos] = P_D_A2_CoVar;
      pos++;
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("CHISQ"));
    if (I_Pos >= 0){
      PP_Args_LinFit[pos] = &((*P_D_A1_ChiSq)(m));
      pos++;
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("PROB"));
    if (I_Pos >= 0){
      PP_Args_LinFit[pos] = &((*P_D_A1_Prob)(m));
      pos++;
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("SIGMA"));
    if (I_Pos >= 0){
      P_D_A1_Sigma = new Array<double,1>((*P_D_A2_Sigma)(m,Range::all()));
      PP_Args_LinFit[pos] = P_D_A1_Sigma;
      pos++;
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("YFIT"));
    if (I_Pos >= 0){
      P_D_A1_YFit = new Array<double,1>((*P_D_A2_YFit)(m, Range::all()));
      PP_Args_LinFit[pos] = P_D_A1_YFit;
      pos++;
    }
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::LinFit2D: starting LinFit1D for row " << m << endl;
    #endif
    if (!this->LinFit(D_A2_CCD_In(m,Range::all()),
                      D_A2_SF_In(m,Range::all()),
                      D_A1_SP_Out(m),
                      D_A1_Sky_Out(m),
                      CS_A1_Args_LinFit,
                      PP_Args_LinFit)){
      cout << "CFits::LinFit: ERROR: this->LinFit(D_A2_CCD_In(i,Range::all()),D_A2_SF_In(i,Range::all()),D_A1_SP_Out(i),D_A1_Sky_Out(i),D_A1_STDDEV_Out(i),D_A1_Covariance_Out(i)) returned false" << endl;
      return false;
    }

    /// copy output values to output parameters
    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("SDEV_IN"));
    if (I_Pos >= 0){
      P_D_A1_SDev->resize(0);
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS"));
    if (I_Pos >= 0){
      P_D_A1_MeasureErrors->resize(0);
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("MASK"));
    if (I_Pos >= 0){
      (*P_I_A2_Mask)(m, Range::all()) = (*P_I_A1_Mask);
      P_I_A1_Mask->resize(0);
    }

//    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("REJECT"));
//    if (I_Pos >= 0){
//      delete(P_D_Reject);
//    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("COVAR"));
    if (I_Pos >= 0){
      (*P_D_A3_CoVar)(m, Range::all(), Range::all()) = (*P_D_A2_CoVar);
      P_D_A2_CoVar->resize(0,0);
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("SIGMA"));
    if (I_Pos >= 0){
      (*P_D_A2_Sigma)(m, Range::all()) = (*P_D_A1_Sigma);
      P_D_A1_Sigma->resize(0);
    }

    I_Pos = KeyWord_Set(CS_A1_Args_In, CString("YFIT"));
    if (I_Pos >= 0){
      (*P_D_A2_YFit)(m, Range::all()) = (*P_D_A1_YFit);
      P_D_A1_YFit->resize(0);
    }
  }

  return true;
}


/**
Fit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
**/
bool CFits::Fit(const Array<double, 1> &D_A1_CCD_In,      /// yvec: in
                const Array<double, 1> &D_A1_SF_In,       /// xvec: in
                double &D_SP_Out,                         /// a1: out
                double &D_Sky_Out,                        /// a0: in/out
                const Array<CString, 1> &CS_A1_Args_In,   ///: in
                void *ArgV_In[]) const                    ///: in
{
  bool B_WithSky = true;
  if (D_Sky_Out < 0.00000001)
    B_WithSky = false;
  return this->Fit(D_A1_CCD_In, D_A1_SF_In, D_SP_Out, D_Sky_Out, B_WithSky, CS_A1_Args_In, ArgV_In);
}

/**
  Fit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
  calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
 **/
bool CFits::Fit(const Array<double, 1> &D_A1_CCD_In,      /// yvec: in
                const Array<double, 1> &D_A1_SF_In,       /// xvec: in
                double &D_SP_Out,                         /// a1: out
                double &D_Sky_Out,                        /// a0: in/out
                bool B_WithSky,                        /// with sky: in
                const Array<CString, 1> &CS_A1_Args_In,   ///: in
                void *ArgV_In[]) const                    ///: in
    /// MEASURE_ERRORS_IN = Array<double,1>(D_A1_CCD_In.size)
    /// REJECT_IN = double
    /// MASK_INOUT = Array<double,1>(D_A1_CCD_In.size)
    /// CHISQ_OUT = double
    /// Q_OUT = double
    /// SIGMA_OUT = Array<double,1>(2): [0]: sigma_sp, [1]: sigma_sky
    /// YFIT_OUT = Array<double, 1>(D_A1_CCD_In.size)
{
//  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::Fit(Array, Array, double, double, bool, CSArr, PPArr) started" << endl;
    cout << "CFits::Fit: D_A1_CCD_In = " << D_A1_CCD_In << endl;
    cout << "CFits::Fit: D_A1_SF_In = " << D_A1_SF_In << endl;
//  #endif

  if (D_A1_CCD_In.size() != D_A1_SF_In.size()){
    cout << "CFits::Fit: ERROR: D_A1_CCD_In.size(=" << D_A1_CCD_In.size() << ") != D_A1_SF_In.size(=" << D_A1_SF_In.size() << ") => returning false" << endl;
    D_SP_Out = 0.;
    D_Sky_Out = 0.;
    return false;
  }

//  /// Set D_A1_SF_In to zero where D_A1_CCD_In == zero
  Array<double, 1> D_A1_SF(D_A1_SF_In.size());
  D_A1_SF = D_A1_SF_In;//(fabs(D_A1_CCD_In) < 0.000000001, 0., D_A1_SF_In);
  Array<double, 1> D_A1_CCD(D_A1_CCD_In.size());
  D_A1_CCD = D_A1_CCD_In;//(fabs(D_A1_CCD_In) < 0.000000001, 0., D_A1_SF_In);

  if (sum(D_A1_CCD_In) == 0. || sum(D_A1_SF) == 0.){
    cout << "CFits::Fit: Warning: (sum(D_A1_CCD_In)=" << sum(D_A1_CCD_In) << " == 0. || sum(D_A1_SF)=" << sum(D_A1_SF) << " == 0.) => returning false" << endl;
    D_SP_Out = 0.;
    D_Sky_Out = 0.;
    return true;
  }
  int i, I_Pos;
  int I_KeywordSet_Reject, I_KeywordSet_Mask, I_KeywordSet_MeasureErrors, I_KeywordSet_SigmaOut, I_KeywordSet_ChiSqOut, I_KeywordSet_QOut, I_KeywordSet_YFitOut;
  double wtmax, wtmin, t, sxoss, sx=0.0, sy=0.0, st2=0.0, ss=0.0, sigdat, sxy=0.0, sxx=0.0;
  int ndata = D_A1_CCD_In.size();
  Array<double, 1> *P_D_A1_Sig = new Array<double, 1>(D_A1_CCD_In.size());
  (*P_D_A1_Sig) = 0.;
  Array<double, 1> D_A1_Sig(D_A1_CCD_In.size());
  Array<double, 1> D_A1_WT(ndata);

  /// a: D_Sky_Out
  /// b: D_SP_Out
  /// x: D_A1_SF_In
  /// y: D_A1_CCD_In


  double *P_D_Reject = new double(-1.);
  I_KeywordSet_Reject = this->KeyWord_Set(CS_A1_Args_In, CString("REJECT_IN"));
  if (I_KeywordSet_Reject >= 0)
  {
    delete(P_D_Reject);
    P_D_Reject = (double*)ArgV_In[I_KeywordSet_Reject];
  }
  bool B_Reject = false;
  if (*P_D_Reject > 0.)
    B_Reject = true;

  Array<int, 1> *P_I_A1_Mask = new Array<int, 1>(D_A1_CCD_In.size());
  Array<int, 1> I_A1_Mask_Orig(D_A1_CCD_In.size());
  //Array<int, 1> I_A1_Mask(D_A1_CCD_In.size());
  *P_I_A1_Mask = 1;

  I_KeywordSet_Mask = this->KeyWord_Set(CS_A1_Args_In, CString("MASK_INOUT"));
  if (I_KeywordSet_Mask >= 0)
  {
    delete(P_I_A1_Mask);
    P_I_A1_Mask = (Array<int, 1>*)ArgV_In[I_KeywordSet_Mask];
  }
  //I_A1_Mask = (*P_I_A1_Mask);
  I_A1_Mask_Orig = (*P_I_A1_Mask);
  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::Fit: *P_I_A1_Mask set to " << *P_I_A1_Mask << endl;
    //cout << "CFits::Fit: I_A1_Mask set to " << I_A1_Mask << endl;
    cout << "CFits::Fit: I_A1_Mask_Orig set to " << I_A1_Mask_Orig << endl;
  #endif

  Array<double, 1> *P_D_A1_Sigma_Out;
  Array<double, 1> D_A1_Sigma_Out(2);
  I_KeywordSet_SigmaOut = this->KeyWord_Set(CS_A1_Args_In, CString("SIGMA_OUT"));
  if (I_KeywordSet_SigmaOut >= 0)
  {
    P_D_A1_Sigma_Out = (Array<double, 1>*)ArgV_In[I_KeywordSet_SigmaOut];
    P_D_A1_Sigma_Out->resize(2);
  }
  else
  {
    P_D_A1_Sigma_Out = new Array<double, 1>(2);
  }
  *P_D_A1_Sigma_Out = 0.;
  D_A1_Sigma_Out = *P_D_A1_Sigma_Out;

  double* P_D_ChiSqr_Out;
  I_KeywordSet_ChiSqOut = this->KeyWord_Set(CS_A1_Args_In, CString("CHISQ_OUT"));
  if (I_KeywordSet_ChiSqOut >= 0)
  {
    P_D_ChiSqr_Out = (double*)ArgV_In[I_KeywordSet_ChiSqOut];
  }
  else
  {
    P_D_ChiSqr_Out = new double();
  }
  *P_D_ChiSqr_Out = 0.;

  double* P_D_Q_Out;
  I_KeywordSet_QOut = this->KeyWord_Set(CS_A1_Args_In, CString("Q_OUT"));
  if (I_KeywordSet_QOut >= 0)
  {
    P_D_Q_Out = (double*)ArgV_In[I_KeywordSet_QOut];
  }
  else
  {
    P_D_Q_Out = new double();
  }
  *P_D_Q_Out = 1.;



  D_SP_Out = 0.0;
  I_KeywordSet_MeasureErrors = this->KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS_IN"));
  if (I_KeywordSet_MeasureErrors >= 0)
  {
    /// Accumulate sums...
    delete(P_D_A1_Sig);
    P_D_A1_Sig = (Array<double, 1>*)ArgV_In[I_KeywordSet_MeasureErrors];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit: ArgV_In[I_KeywordSet_MeasureErrors=" << I_KeywordSet_MeasureErrors << "] = " << *((Array<double,1>*)ArgV_In[I_KeywordSet_MeasureErrors]) << endl;
      cout << "CFits::Fit: *P_D_A1_Sig = " << *P_D_A1_Sig << endl;
    #endif
    if (D_A1_CCD_In.size() != P_D_A1_Sig->size()){
      cout << "CFits::Fit: ERROR: D_A1_CCD_In.size(=" << D_A1_CCD_In.size() << ") != P_D_A1_Sig->size(=" << P_D_A1_Sig->size() << ") => returning false" << endl;
      D_SP_Out = 0.;
      D_Sky_Out = 0.;
      return false;
    }
  }

  Array<double, 1> D_A1_YFit(1);
  Array<double, 1> *P_D_A1_YFit = new Array<double, 1>(D_A1_CCD_In.size());
  I_KeywordSet_YFitOut = this->KeyWord_Set(CS_A1_Args_In, CString("YFIT_OUT"));
  if (I_KeywordSet_YFitOut >= 0)
  {
    delete(P_D_A1_YFit);
    P_D_A1_YFit = (Array<double, 1>*)ArgV_In[I_KeywordSet_YFitOut];
    P_D_A1_YFit->resize(D_A1_CCD_In.size());
    (*P_D_A1_YFit) = 0.;
  }
  if (sum(*P_I_A1_Mask) == 0){
    cout << "CFits::Fit: WARNING: sum(*P_I_A1_Mask = " << *P_I_A1_Mask << ") == 0" << endl;
    D_SP_Out = 0.;
    D_Sky_Out = 0.;
    return true;
  }

  int I_SumMaskLast;
  double D_SDevReject;
  Array<double, 1> D_A1_Check(D_A1_CCD_In.size());
  Array<int, 1> I_A1_LastMask(P_I_A1_Mask->size());
  Array<double, 1> D_A1_Diff(D_A1_CCD_In.size());
  D_A1_Diff = 0.;

  bool B_Run = true;
  int I_Run = -1;
  int I_MaskSum;
  while (B_Run){
    sx=0.0;
    sy=0.0;
    st2=0.0;
    ss=0.0;
    sxy=0.0;
    sxx=0.0;
    D_SP_Out = 0.0;

    I_Run++;
    /// remove bad pixels marked by mask
    I_MaskSum = sum(*P_I_A1_Mask);
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit: I_Run=" << I_Run << ": I_MaskSum = " << I_MaskSum << endl;
    #endif
//    if (I_MaskSum < P_I_A1_Mask->size()){
      D_A1_Sig.resize(I_MaskSum);
      D_A1_CCD.resize(I_MaskSum);
      D_A1_SF.resize(I_MaskSum);
      D_A1_WT.resize(I_MaskSum);
      D_A1_YFit.resize(I_MaskSum);
//    }
    D_A1_Sig = 0.;
    D_A1_CCD = 0.;
    D_A1_SF = 0.;
    D_A1_WT = 0.;
    D_A1_YFit = 0.;

    I_Pos = 0;
    for (i = 0; i < P_I_A1_Mask->size(); i++){
//      #ifdef __DEBUG_FITS_FIT__
//        cout << "CFits::Fit: I_Run=" << I_Run << ": i=" << i << ": I_A1_Mask(i) = " << I_A1_Mask(i) << endl;
//      #endif
      if ((*P_I_A1_Mask)(i) == 1){
        D_A1_CCD(I_Pos) = D_A1_CCD_In(i);
        D_A1_SF(I_Pos) = D_A1_SF_In(i);
        D_A1_Sig(I_Pos) = (*P_D_A1_Sig)(i);
//        #ifdef __DEBUG_FITS_FIT__
//          cout << "CFits::Fit: I_Run=" << I_Run << ": i=" << i << ": I_A1_Mask(i) = " << I_A1_Mask << ": D_A1_CCD(I_Pos=" << I_Pos << ") set to " << D_A1_CCD(I_Pos) << endl;
//        #endif
        I_Pos++;
      }
    }
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit: I_Run=" << I_Run << ": D_A1_CCD set to " << D_A1_CCD << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": D_A1_SF set to " << D_A1_SF << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": D_A1_Sig set to " << D_A1_Sig << endl;
    #endif

    if (I_KeywordSet_MeasureErrors >= 0)
    {
      ///    D_A1_WT = D_A1_SF;
      for (i=0; i < I_MaskSum; i++)
      {
        /// ... with weights
	if (abs(D_A1_Sig(i)) < 0.00000000000000001){
	  cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig = " << D_A1_Sig << endl;
	  cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig(" << i << ") == 0. => Returning FALSE" << endl;
	  return false;
	}
        D_A1_WT(i) = 1. / pow(D_A1_Sig(i),2);
      }
      #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit: I_Run=" << I_Run << ":: D_A1_WT set to " << D_A1_WT << endl;
      #endif
//      wtmax = max(D_A1_WT);
//      wtmin = 1.e-4;
//      D_A1_WT = where(D_A1_WT < wtmin, 0., D_A1_WT);
//      #ifdef __DEBUG_FITS_FIT__
//        cout << "CFits::Fit: I_Run=" << I_Run << ": D_A1_WT set to " << D_A1_WT << endl;
//      #endif
      for (i=0; i < I_MaskSum; i++)
      {
        ss += D_A1_WT(i);
        sx += D_A1_SF(i) * D_A1_WT(i);
        sy += D_A1_CCD(i) * D_A1_WT(i);
        sxy += D_A1_SF(i) * D_A1_CCD(i) * D_A1_WT(i);
        sxx += D_A1_SF(i) * D_A1_SF(i) * D_A1_WT(i);
      }
    }
    else
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        /// ... or without weights
        sx += D_A1_SF(i);
        sy += D_A1_CCD(i);
        sxy += D_A1_SF(i) * D_A1_CCD(i);
        sxx += D_A1_SF(i) * D_A1_SF(i);
      }
      ss = I_MaskSum;
    }
    sxoss = sx / ss;

    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit: I_Run=" << I_Run << ": ss set to " << ss << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": sx set to " << sx << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": sy set to " << sy << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": sxy set to " << sxy << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": sxx set to " << sxx << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": sxoss set to " << sxoss << endl;
    #endif


    if (!B_WithSky)
    {
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": D_Sky_Out < 0. = setting D_Sky_Out to 0 " << endl;
      #endif
      D_SP_Out = sxy / sxx;
      D_Sky_Out = 0.0;
    }
    else
    {
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": D_Sky_Out >= 0." << ss << endl;
      #endif
      for (i = 0; i < I_MaskSum; i++)
      {
        if (I_KeywordSet_MeasureErrors >= 0)
        {
          if (abs(D_A1_Sig(i)) < 0.00000000000000001){
	    cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig(" << i << ") == 0. => Returning FALSE" << endl;
	    return false;
	  }
          t = (D_A1_SF(i) - sxoss) / D_A1_Sig(i);
          st2 += t * t;
          D_SP_Out += t * D_A1_CCD(i) / D_A1_Sig(i);
        }
        else
        {
          t = D_A1_SF(i) - sxoss;
          st2 += t * t;
          D_SP_Out += t * D_A1_CCD(i);
        }
      }
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": t set to " << t << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": st2 set to " << st2 << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": D_SP_Out set to " << D_SP_Out << endl;
      #endif

      if (st2 == 0.){
        D_SP_Out = 0.;
        Array<double, 1> *P_D_A1_Moment = this->Moment(D_A1_CCD, 2);
        D_Sky_Out = (*P_D_A1_Moment)(0);
        (*P_D_A1_Sigma_Out)(0) = (*P_D_A1_Moment)(1);
        (*P_D_A1_Sigma_Out)(1) = (*P_D_A1_Moment)(1);
        delete(P_D_A1_Moment);
      }
      else{
        /// Solve for a, b, siga, and sigb and calculate Chi^2
        D_SP_Out /= st2;
        D_Sky_Out = (sy - sx * D_SP_Out) / ss;
        (*P_D_A1_Sigma_Out)(0) = sqrt(1. / st2);
        (*P_D_A1_Sigma_Out)(1) = sqrt((1. + sx * sx / (ss * st2)) / ss);
      }
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": D_SP_Out set to " << D_SP_Out << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": D_Sky_Out set to " << D_Sky_Out << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": P_D_A1_Sigma_Out(0) set to " << (*P_D_A1_Sigma_Out)(0) << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": P_D_A1_Sigma_Out(1) set to " << (*P_D_A1_Sigma_Out)(1) << endl;
      #endif
    }
    if (!B_WithSky)
    {
      D_Sky_Out = 0.0;
      D_SP_Out = sxy / sxx;
    }
    if (D_SP_Out < 0.)
      D_SP_Out = 0.;

//    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit: I_Run=" << I_Run << ": D_Sky_Out set to " << D_Sky_Out << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": D_SP_Out set to " << D_SP_Out << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": fabs(D_SP_Out) = " << fabs(D_SP_Out) << endl;
//    #endif

    *P_D_A1_YFit = D_Sky_Out + D_SP_Out * D_A1_SF_In;
    D_A1_YFit = D_Sky_Out + D_SP_Out * D_A1_SF;
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit: I_Run=" << I_Run << ": *P_D_A1_YFit set to " << *P_D_A1_YFit << endl;
      cout << "CFits::Fit: I_Run=" << I_Run << ": D_A1_YFit set to " << D_A1_YFit << endl;
    #endif
    *P_D_ChiSqr_Out = 0.;
    if (I_KeywordSet_MeasureErrors < 0)
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        *P_D_ChiSqr_Out += pow(D_A1_CCD(i) - D_A1_YFit(i),2);
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
        #endif
      }

      /// for unweighted data evaluate typical sig using chi2, and adjust the standard deviations
      if (I_MaskSum == 2){
	cout << "CFits::Fit: I_Run=" << I_Run << ": ERROR: Sum of Mask (=" << I_MaskSum << ") must be greater than 2 => Returning FALSE" << endl;
	return false;
      }
      sigdat = sqrt((*P_D_ChiSqr_Out) / (I_MaskSum - 2));
      (*P_D_A1_Sigma_Out)(0) *= sigdat;
      (*P_D_A1_Sigma_Out)(1) *= sigdat;
    }
    else
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": D_A1_CCD(" << i << ") = " << D_A1_CCD(i) << endl;
          cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": D_A1_SF(" << i << ") = " << D_A1_SF(i) << endl;
          cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": D_A1_Sig(" << i << ") = " << D_A1_Sig(i) << endl;
          cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": D_A1_YFit(" << i << ") = " << D_A1_YFit(i) << endl;
        #endif
	if (abs(D_A1_Sig(i)) < 0.00000000000000001){
	  cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig(" << i << ") == 0. => Returning FALSE" << endl;
	  return false;
	}
        *P_D_ChiSqr_Out += pow((D_A1_CCD(i) - D_A1_YFit(i)) / D_A1_Sig(i),2);
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::Fit: I_Run=" << I_Run << ": i = " << i << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
        #endif
      }
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
      #endif
      if (I_MaskSum > 2)
      {
        if (!this->GammQ(0.5 * (I_MaskSum - 2), 0.5 * (*P_D_ChiSqr_Out), P_D_Q_Out))
        {
          cout << "CFits::Fit: I_Run=" << I_Run << ": ERROR: GammQ returned FALSE" << endl;
          return false;
        }
      }
    }
    if (fabs(D_SP_Out) < 0.000001)
      B_Reject = false;
    if (!B_Reject)
      B_Run = false;
    else{

      I_SumMaskLast = sum(*P_I_A1_Mask);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: I_SumMaskLast = " << I_SumMaskLast << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: D_A1_CCD = " << D_A1_CCD << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: D_A1_YFit = " << D_A1_YFit << endl;
      #endif
//      D_SDevReject = sqrt((sum(pow((D_A1_CCD - D_A1_YFit) / where(fabs(D_A1_YFit) > 0.0001, D_A1_YFit, 0.0001),2.))) / (I_SumMaskLast));//(sum(pow(D_A1_CCD - (D_A1_YFit),2)) / I_SumMaskLast);
      D_SDevReject = sqrt(sum(pow2(D_A1_CCD - D_A1_YFit)) / double(I_SumMaskLast));//(sum(pow(D_A1_CCD - (D_A1_YFit),2)) / I_SumMaskLast);
      D_A1_Diff = D_A1_CCD_In - (*P_D_A1_YFit);
//      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: D_SDevReject = " << D_SDevReject << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: D_A1_CCD_In = " << D_A1_CCD_In << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: *P_D_A1_YFit = " << *P_D_A1_YFit << endl;
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: D_A1_CCD_In - (*P_D_A1_YFit) = " << D_A1_Diff << endl;
//      #endif
//      D_A1_Check = fabs((D_A1_Diff) / where(fabs(*P_D_A1_YFit) > 0., (*P_D_A1_YFit), 0.0001));
      D_A1_Check = fabs(D_A1_Diff);
//      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: D_A1_Check = " << D_A1_Check << endl;
//      #endif

      cout << "CFits::Fit: I_Run=" << I_Run << ": before Reject: *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
      I_A1_LastMask = *P_I_A1_Mask;
      *P_I_A1_Mask = where(D_A1_Check > (*P_D_Reject) * D_SDevReject, 0, 1);
      *P_I_A1_Mask = where(I_A1_Mask_Orig < 1, 0, *P_I_A1_Mask);
      if (sum(*P_I_A1_Mask) == sum(I_A1_Mask_Orig))
        B_Reject = false;
      else
        *P_I_A1_Mask = where(I_A1_LastMask < 1, 0, *P_I_A1_Mask);
//      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": Reject: *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
//      #endif
      if (fabs(min(*P_D_A1_YFit)) < 0.00000001)
        return false;
      if (I_SumMaskLast == sum(*P_I_A1_Mask)){
        B_Run = false;
        #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit: I_Run=" << I_Run << ": leaving while loop" << endl;
        #endif
      }
      else{
        D_Sky_Out = 0.;
      }
    }
    if (D_Sky_Out < 0.){
      B_Run = true;
      B_WithSky = false;
    }
  }/// end while (B_Run)

  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::Fit: *P_D_A1_YFit set to " << *P_D_A1_YFit << endl;
    cout << "CFits::Fit: *P_I_A1_Mask set to " << *P_I_A1_Mask << endl;
  #endif


  /// clean up
  if (I_KeywordSet_Mask < 0)
  {
    delete(P_I_A1_Mask);
  }
  if (I_KeywordSet_Reject < 0)
  {
    delete(P_D_Reject);
  }
  if (I_KeywordSet_MeasureErrors < 0)
  {
    delete(P_D_A1_Sig);
  }
  if (I_KeywordSet_ChiSqOut < 0)
  {
    delete(P_D_ChiSqr_Out);
  }
  if (I_KeywordSet_QOut < 0)
  {
    delete(P_D_Q_Out);
  }
  if (I_KeywordSet_SigmaOut < 0)
  {
    delete(P_D_A1_Sigma_Out);
  }
  if (I_KeywordSet_YFitOut < 0){
    delete(P_D_A1_YFit);
  }

  return true;
}

/**
Fit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
**/
bool CFits::Fit(const Array<double, 2> &D_A2_CCD_In,      /// yvec: in
                const Array<double, 2> &D_A2_SF_In,       /// xvec: in
                Array<double, 1> &D_A1_SP_Out,                         /// a1: out
                Array<double, 1> &D_A1_Sky_Out,                        /// a0: out
                const Array<CString, 1> &CS_A1_Args_In,   ///: in
                void *ArgV_In[]) const                    ///: in
{
  bool B_WithSky = true;
  if (max(D_A1_Sky_Out) < 0.0000001)
    B_WithSky = false;
  return this->Fit(D_A2_CCD_In, D_A2_SF_In, D_A1_SP_Out, D_A1_Sky_Out, B_WithSky, CS_A1_Args_In, ArgV_In);
}

/**
  Fit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
  calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
 **/
bool CFits::Fit(const Array<double, 2> &D_A2_CCD_In,      /// yvec: in
                const Array<double, 2> &D_A2_SF_In,       /// xvec: in
                Array<double, 1> &D_A1_SP_Out,                         /// a1: out
                Array<double, 1> &D_A1_Sky_Out,                        /// a0: out
                bool B_WithSky,                           /// with sky: in
                const Array<CString, 1> &CS_A1_Args_In,   ///: in
                void *ArgV_In[]) const                    ///: in
    /// MEASURE_ERRORS_IN = Array<double, 2>(D_A2_CCD_In.rows(), D_A2_CCD_In.cols())
    /// REJECT_IN         = double
    /// MASK_INOUT        = Array<double, 2>(D_A2_CCD_In.rows(), D_A2_CCD_In.cols())
    /// CHISQ_OUT         = Array<double, 1>(D_A2_CCD_In.rows())
    /// Q_OUT             = Array<double, 1>(D_A2_CCD_In.rows())
    /// SIGMA_OUT         = Array<double, 2>(D_A2_CCD_In.rows(),2)
    /// YFIT_OUT          = Array<double, 2>(D_A2_CCD_In.rows(), D_A2_CCD_In.cols())
{
  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::Fit(Array, Array, Array, Array, bool, CSArr, PPArr) started" << endl;
    cout << "CFits::Fit(Array, Array, Array, Array, bool, CSArr, PPArr): D_A2_CCD_In = " << D_A2_CCD_In << endl;
    cout << "CFits::Fit(Array, Array, Array, Array, bool, CSArr, PPArr): D_A2_SF_In = " << D_A2_SF_In << endl;
  #endif
  if (D_A2_CCD_In.size() != D_A2_SF_In.size()){
    cout << "CFits::Fit: ERROR: D_A2_CCD_In.size(=" << D_A2_CCD_In.size() << ") != D_A2_SF_In.size(=" << D_A2_SF_In.size() << ") => returning false" << endl;
    D_A1_SP_Out = 0.;
    D_A1_Sky_Out = 0.;
    return false;
  }
  int i, I_Pos, I_ArgPos = 0;
  int I_KeywordSet_MeasureErrors, I_KeywordSet_Reject, I_KewordSet_Mask, I_KeywordSet_ChiSq, I_KeywordSet_Q, I_KeywordSet_Sigma, I_KeywordSet_YFit;
  if (D_A1_SP_Out.size() != D_A2_CCD_In.rows())
  {
    D_A1_SP_Out.resize(D_A2_CCD_In.rows());
  }
  D_A1_SP_Out = 0.;
  if (D_A1_Sky_Out.size() != D_A2_CCD_In.rows())
  {
    D_A1_Sky_Out.resize(D_A2_CCD_In.rows());
  }
  D_A1_Sky_Out = 0.;

  double *P_D_Reject;

  Array<double, 1> *P_D_A1_YFit;
  Array<double, 2> *P_D_A2_YFit;
  Array<int, 1> *P_I_A1_Mask;
  Array<int, 2> *P_I_A2_Mask;

  Array<double, 1> *P_D_A1_Sigma;
  Array<double, 1> *P_D_A1_Sigma_Out;
  Array<CString, 1> CS_A1_Args_Fit(10);
  CS_A1_Args_Fit = CString(" ");
  void **PP_Args_Fit = (void**)malloc(sizeof(void*) * 10);

  Array<double, 2> *P_D_A2_Sigma;
  I_KeywordSet_MeasureErrors = this->KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS_IN"));
  if (I_KeywordSet_MeasureErrors >= 0)
  {
    P_D_A2_Sigma = (Array<double,2>*)ArgV_In[I_KeywordSet_MeasureErrors];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit(Array, Array, Array, Array): P_D_A2_Sigma = " << *P_D_A2_Sigma << endl;
    #endif
    CS_A1_Args_Fit(I_ArgPos) = CString("MEASURE_ERRORS_IN");
    I_ArgPos++;
  }

  Array<double, 1> *P_D_A1_ChiSq;
  I_KeywordSet_ChiSq = this->KeyWord_Set(CS_A1_Args_In, CString("CHISQ_OUT"));
  if (I_KeywordSet_ChiSq >= 0)
  {
    P_D_A1_ChiSq = (Array<double,1>*)ArgV_In[I_KeywordSet_ChiSq];
    P_D_A1_ChiSq->resize(D_A2_CCD_In.rows());
    CS_A1_Args_Fit(I_ArgPos) = CString("CHISQ_OUT");
    I_ArgPos++;
  }

  Array<double, 1> *P_D_A1_Q;
  I_KeywordSet_Q = this->KeyWord_Set(CS_A1_Args_In, CString("Q_OUT"));
  if (I_KeywordSet_Q >= 0)
  {
    P_D_A1_Q = (Array<double,1>*)ArgV_In[I_KeywordSet_Q];
    P_D_A1_Q->resize(D_A2_CCD_In.rows());
    CS_A1_Args_Fit(I_ArgPos) = CString("Q_OUT");
    I_ArgPos++;
  }

  Array<double, 2> *P_D_A2_Sigma_Out;
  I_KeywordSet_Sigma = this->KeyWord_Set(CS_A1_Args_In, CString("SIGMA_OUT"));
  if (I_KeywordSet_Sigma >= 0)
  {
    P_D_A2_Sigma_Out = (Array<double,2>*)ArgV_In[I_KeywordSet_Sigma];
    P_D_A2_Sigma_Out->resize(D_A2_CCD_In.rows(), 2);
    CS_A1_Args_Fit(I_ArgPos) = CString("SIGMA_OUT");
    I_ArgPos++;
  }

  I_KeywordSet_YFit = this->KeyWord_Set(CS_A1_Args_In, CString("YFIT_OUT"));
  if (I_KeywordSet_YFit >= 0)
  {
    P_D_A2_YFit = (Array<double,2>*)ArgV_In[I_KeywordSet_YFit];
    #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::Fit2D: P_D_A2_YFit = " << *P_D_A2_YFit << endl;
    #endif
    CS_A1_Args_Fit(I_ArgPos) = CString("YFIT_OUT");
    I_ArgPos++;
  }

  I_KeywordSet_Reject = this->KeyWord_Set(CS_A1_Args_In, CString("REJECT_IN"));
  if (I_KeywordSet_Reject >= 0)
  {
    P_D_Reject = (double*)ArgV_In[I_KeywordSet_Reject];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit2D: P_D_Reject = " << *P_D_Reject << endl;
    #endif
    CS_A1_Args_Fit(I_ArgPos) = CString("REJECT_IN");
    I_ArgPos++;
  }

  I_KewordSet_Mask = this->KeyWord_Set(CS_A1_Args_In, CString("MASK_INOUT"));
  if (I_KewordSet_Mask >= 0)
  {
    P_I_A2_Mask = (Array<int,2>*)ArgV_In[I_KewordSet_Mask];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit2D: P_I_A2_Mask = " << *P_I_A2_Mask << endl;
    #endif
    CS_A1_Args_Fit(I_ArgPos) = CString("MASK_INOUT");
    I_ArgPos++;
  }

  bool B_DoFit = true;
  for (i = 0; i < D_A2_CCD_In.rows(); i++)
  {
    I_ArgPos = 0;
    if (I_KeywordSet_MeasureErrors >= 0){
      P_D_A1_Sigma = new Array<double,1>((*P_D_A2_Sigma)(i, Range::all()));
      #ifdef __DEBUG_FITS_FIT__
//        cout << "CFits::Fit(Array, Array, Array, Array): 2. P_D_A2_Sigma = " << *P_D_A2_Sigma << endl;
        cout << "CFits::Fit(Array, Array, Array, Array): P_D_A1_Sigma set to " << *P_D_A1_Sigma << endl;
      #endif
      PP_Args_Fit[I_ArgPos] = P_D_A1_Sigma;
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit(Array, Array, Array, Array): PP_Args_Fit[I_ArgPos=" << I_ArgPos << "] = " << *((Array<double,1>*)PP_Args_Fit[I_ArgPos]) << endl;
      #endif
      I_ArgPos++;
    }

    if (I_KeywordSet_ChiSq >= 0){
      PP_Args_Fit[I_ArgPos] = &((*P_D_A1_ChiSq)(i));
      I_ArgPos++;
    }

    if (I_KeywordSet_Q >= 0){
      PP_Args_Fit[I_ArgPos] = &((*P_D_A1_Q)(i));
      I_ArgPos++;
    }

    if (I_KeywordSet_Sigma >= 0){
      P_D_A1_Sigma_Out = new Array<double,1>((*P_D_A2_Sigma_Out)(i, Range::all()));
      PP_Args_Fit[I_ArgPos] = P_D_A1_Sigma_Out;
      I_ArgPos++;
    }

    if (I_KeywordSet_YFit >= 0){
      P_D_A1_YFit = new Array<double,1>((*P_D_A2_YFit)(i, Range::all()));
      PP_Args_Fit[I_ArgPos] = P_D_A1_YFit;
      I_ArgPos++;
    }

    if (I_KeywordSet_Reject >= 0){
      PP_Args_Fit[I_ArgPos] = P_D_Reject;
      I_ArgPos++;
    }

    B_DoFit = true;
    if (I_KewordSet_Mask >= 0){
      P_I_A1_Mask = new Array<int,1>((*P_I_A2_Mask)(i, Range::all()));
      PP_Args_Fit[I_ArgPos] = P_I_A1_Mask;
      I_ArgPos++;
      if (sum(*P_I_A1_Mask) == 0)
	B_DoFit = false;
    }

    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit: Starting Fit1D: D_A2_CCD_In(i=" << i << ", *) = " << D_A2_CCD_In(i,Range::all()) << endl;
    #endif
    if (B_DoFit){
      cout << "CFits::Fit: D_A2_SF_In(i=" << i << ", *) = " << D_A2_SF_In(i, Range::all()) << endl;
      if (!this->Fit(D_A2_CCD_In(i,Range::all()),
                     D_A2_SF_In(i,Range::all()),
                     D_A1_SP_Out(i),
                     D_A1_Sky_Out(i),
                     B_WithSky,
                     CS_A1_Args_Fit,
                     PP_Args_Fit)){
        cout << "CFits::Fit: ERROR: this->Fit(D_A2_CCD_In(i,Range::all()),D_A2_SF_In(i,Range::all()),D_A1_SP_Out(i),D_A1_Sky_Out(i),D_A1_STDDEV_Out(i),D_A1_Covariance_Out(i)) returned false" << endl;
        free(PP_Args_Fit);
        cout << "CFits::Fit: D_A2_SF_In(0, *) = " << D_A2_SF_In(0,Range::all()) << endl;
        return false;
      }
    }

    I_ArgPos = 0;
    if (I_KeywordSet_MeasureErrors >= 0){
      (*P_D_A2_Sigma)(i, Range::all()) = (*P_D_A1_Sigma);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit(Array, Array, Array, Array): P_D_A2_Sigma(i=" << i << ",*) set to " << (*P_D_A2_Sigma)(i, Range::all()) << endl;
      #endif
      I_ArgPos++;
      delete(P_D_A1_Sigma);/// or not
    }

  //  if (I_KeywordSet_ChiSq >= 0){
  //    PP_Args_Fit[I_ArgPos] = &((*P_D_A1_ChiSq)(i));
  //    I_ArgPos++;
  //  }

  //  if (I_KeywordSet_Q >= 0){
  //    PP_Args_Fit[I_ArgPos] = &((*P_D_A1_Q)(i));
  //    I_ArgPos++;
  //  }

    if (I_KeywordSet_Sigma >= 0){
      (*P_D_A2_Sigma_Out)(i, Range::all()) = (*P_D_A1_Sigma_Out);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit(Array, Array, Array, Array): P_D_A2_Sigma_Out(i=" << i << ",*) set to " << (*P_D_A2_Sigma_Out)(i, Range::all()) << endl;
      #endif
      I_ArgPos++;
      delete(P_D_A1_Sigma_Out);// or not
    }

    if (I_KeywordSet_YFit >= 0){
      (*P_D_A2_YFit)(i, Range::all()) = (*P_D_A1_YFit);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::Fit(Array, Array, Array, Array): P_D_A2_YFit(i=" << i << ",*) set to " << (*P_D_A2_YFit)(i, Range::all()) << endl;
      #endif
      I_ArgPos++;
      delete(P_D_A1_YFit);// or not
    }

    if (I_KewordSet_Mask >= 0){
      (*P_I_A2_Mask)(i, Range::all()) = (*P_I_A1_Mask);
      #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::Fit(Array, Array, Array, Array): P_I_A1_Mask = " << (*P_I_A1_Mask) << endl;
      cout << "CFits::Fit(Array, Array, Array, Array): P_I_A2_Mask(i=" << i << ",*) set to " << (*P_I_A2_Mask)(i, Range::all()) << endl;
      #endif
      I_ArgPos++;
      delete(P_I_A1_Mask);// or not
    }

  }
//  free(*PP_Args_Fit);
  free(PP_Args_Fit);
  return true;
}


/**
 * D_A1_CCD_In(N): N pixels
 * D_A2_SF_In(N,2): N pixels x 2 profiles
 * D_A1_SP_Out(2): spectrum values for profiles in D_A2_SF_In
 * D_Sky_Out: constant sky under both profiles
 **/
bool CFits::LinFitBevingtonTwoProfiles(const Array<double, 1> &D_A1_CCD_In,      /// y: in
                                       const Array<double, 2> &D_A2_SF_In,       /// x: in
                                       Array<double, 1> &D_A1_SP_Out,                         /// a1: out
                                       double &D_Sky_Out,                        /// a0: in/out
                                       bool B_WithSky,                           /// with sky: in
                                       const Array<CString, 1> &CS_A1_Args_In,   ///: in
                                       void *ArgV_In[]) const{                   ///: in/out
                                   /// MEASURE_ERRORS_IN = Array<double,1>(D_A1_CCD_In.size)             : in
                                   /// REJECT_IN = double                                                : in
                                   /// MASK_INOUT = Array<int,1>(D_A1_CCD_In.size)                    : in/out
                                   /// CHISQ_OUT = double                                                : out
                                   /// Q_OUT = double                                                    : out
                                   /// SIGMA_OUT = Array<double,2>(2,2): [*,0]: sigma_sp, [*,1]: sigma_sky : out
                                   /// YFIT_OUT = Array<double, 1>(D_A1_CCD_In.size)                     : out
                                   /// ALLOW_SKY_LT_ZERO = 1
                                   /// ALLOW_SPEC_LT_ZERO = 1
  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::LinFitBevingtonTwoProfiles(Array, Array, double, double, bool, CSArr, PPArr) started" << endl;
    cout << "CFits::LinFitBevingtonTwoProfiles: D_A1_CCD_In = " << D_A1_CCD_In << endl;
    cout << "CFits::LinFitBevingtonTwoProfiles: D_A2_SF_In = " << D_A2_SF_In << endl;
  #endif

  if (D_A1_CCD_In.size() != D_A2_SF_In.rows()){
    cout << "CFits::LinFitBevingtonTwoProfiles: ERROR: D_A1_CCD_In.size(=" << D_A1_CCD_In.size() << ") != D_A2_SF_In.rows(=" << D_A2_SF_In.rows() << ") => returning false" << endl;
    D_A1_SP_Out = 0.;
    D_Sky_Out = 0.;
    return false;
  }
  if (D_A2_SF_In.cols() != 2){
    cout << "CFits::LinFitBevingtonTwoProfiles: ERROR: D_A2_SF_In.cols(=" << D_A2_SF_In.cols() << ") != 2 => returning FALSE" << endl;
    return false;
  }

//  /// Set D_A1_SF_In to zero where D_A1_CCD_In == zero
  Array<double, 2> D_A2_SF(D_A2_SF_In.rows(), D_A2_SF_In.cols());
  D_A2_SF = D_A2_SF_In;//(fabs(D_A1_CCD_In) < 0.000000001, 0., D_A1_SF_In);
  Array<double, 1> D_A1_CCD(D_A1_CCD_In.size());
  D_A1_CCD = D_A1_CCD_In;//(fabs(D_A1_CCD_In) < 0.000000001, 0., D_A1_SF_In);

  if (sum(D_A1_CCD_In) == 0. || sum(D_A2_SF) == 0.){
    cout << "CFits::LinFitBevingtonTwoProfiles: Warning: (sum(D_A1_CCD_In)=" << sum(D_A1_CCD_In) << " == 0. || sum(D_A2_SF)=" << sum(D_A2_SF) << " == 0.) => returning false" << endl;
    D_A1_SP_Out = 0.;
    D_Sky_Out = 0.;
    return true;
  }
  int i, I_Pos;
  int I_KeywordSet_Reject, I_KeywordSet_Mask, I_KeywordSet_MeasureErrors, I_KeywordSet_SigmaOut, I_KeywordSet_ChiSqOut, I_KeywordSet_QOut, I_KeywordSet_YFitOut, I_KeywordSet_AllowSkyLTZero, I_KeywordSet_AllowSpecLTZero;
  double sigdat;
  int ndata = D_A1_CCD_In.size();
  Array<double, 1> *P_D_A1_Sig = new Array<double, 1>(D_A1_CCD_In.size());
  (*P_D_A1_Sig) = 0.;
  Array<double, 1> D_A1_Sig(D_A1_CCD_In.size());
  Array<double, 1> D_A1_WT(ndata);

  /// a: D_Sky_Out
  /// b: D_SP_Out
  /// x: D_A1_SF_In
  /// y: D_A1_CCD_In

  int *P_I_TempInt = new int(0);

  bool B_AllowSkyLTZero = false;
  I_KeywordSet_AllowSkyLTZero = this->KeyWord_Set(CS_A1_Args_In, CString("ALLOW_SKY_LT_ZERO"));
  if (I_KeywordSet_AllowSkyLTZero >= 0)
  {
    delete(P_I_TempInt);
    P_I_TempInt = (int*)ArgV_In[I_KeywordSet_AllowSkyLTZero];

    if (*P_I_TempInt > 0){
      B_AllowSkyLTZero = true;
      cout << "CFits::LinFitBevingtonTwoProfiles: KeyWord_Set(ALLOW_SKY_LT_ZERO)" << endl;
    }
  }

  bool B_AllowSpecLTZero = false;
  I_KeywordSet_AllowSpecLTZero = this->KeyWord_Set(CS_A1_Args_In, CString("ALLOW_SPEC_LT_ZERO"));
  if (I_KeywordSet_AllowSpecLTZero >= 0)
  {
    if (I_KeywordSet_AllowSkyLTZero < 0)
      delete(P_I_TempInt);
    P_I_TempInt = (int*)ArgV_In[I_KeywordSet_AllowSkyLTZero];

    if (*P_I_TempInt > 0){
      B_AllowSpecLTZero = true;
      cout << "CFits::LinFitBevingtonTwoProfiles: KeyWord_Set(ALLOW_SPEC_LT_ZERO)" << endl;
    }
  }

  double *P_D_Reject = new double(-1.);
  I_KeywordSet_Reject = this->KeyWord_Set(CS_A1_Args_In, CString("REJECT_IN"));
  if (I_KeywordSet_Reject >= 0)
  {
    delete(P_D_Reject);
    P_D_Reject = (double*)ArgV_In[I_KeywordSet_Reject];
    cout << "CFits::LinFitBevingtonTwoProfiles: KeyWord_Set(REJECT_IN): *P_D_Reject = " << *P_D_Reject << endl;
  }
  bool B_Reject = false;
  if (*P_D_Reject > 0.)
    B_Reject = true;

  Array<int, 1> *P_I_A1_Mask = new Array<int, 1>(D_A1_CCD_In.size());
  Array<int, 1> I_A1_Mask_Orig(D_A1_CCD_In.size());
  //Array<int, 1> I_A1_Mask(D_A1_CCD_In.size());
  *P_I_A1_Mask = 1;

  I_KeywordSet_Mask = this->KeyWord_Set(CS_A1_Args_In, CString("MASK_INOUT"));
  if (I_KeywordSet_Mask >= 0)
  {
    delete(P_I_A1_Mask);
    P_I_A1_Mask = (Array<int, 1>*)ArgV_In[I_KeywordSet_Mask];
    cout << "CFits::LinFitBevingtonTwoProfiles: KeyWord_Set(MASK_INOUT): *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
  }
  //I_A1_Mask = (*P_I_A1_Mask);
  I_A1_Mask_Orig = (*P_I_A1_Mask);
  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::LinFitBevingtonTwoProfiles: *P_I_A1_Mask set to " << *P_I_A1_Mask << endl;
    //cout << "CFits::LinFitBevingtonTwoProfiles: I_A1_Mask set to " << I_A1_Mask << endl;
    cout << "CFits::LinFitBevingtonTwoProfiles: I_A1_Mask_Orig set to " << I_A1_Mask_Orig << endl;
  #endif

  Array<double, 2> *P_D_A2_Sigma_Out;
  Array<double, 2> D_A2_Sigma_Out(2,2);
  I_KeywordSet_SigmaOut = this->KeyWord_Set(CS_A1_Args_In, CString("SIGMA_OUT"));
  if (I_KeywordSet_SigmaOut >= 0)
  {
    P_D_A2_Sigma_Out = (Array<double, 2>*)ArgV_In[I_KeywordSet_SigmaOut];
    P_D_A2_Sigma_Out->resize(2,2);
    cout << "CFits::LinFitBevingtonTwoProfiles: KeyWord_Set(SIGMA_OUT)" << endl;
  }
  else
  {
    P_D_A2_Sigma_Out = new Array<double, 2>(2,2);
  }
  *P_D_A2_Sigma_Out = 0.;
  D_A2_Sigma_Out = *P_D_A2_Sigma_Out;

  double* P_D_ChiSqr_Out;
  I_KeywordSet_ChiSqOut = this->KeyWord_Set(CS_A1_Args_In, CString("CHISQ_OUT"));
  if (I_KeywordSet_ChiSqOut >= 0)
  {
    P_D_ChiSqr_Out = (double*)ArgV_In[I_KeywordSet_ChiSqOut];
    cout << "CFits::LinFitBevingtonTwoProfiles: KeyWord_Set(CHISQ_OUT)" << endl;
  }
  else
  {
    P_D_ChiSqr_Out = new double();
  }
  *P_D_ChiSqr_Out = 0.;

  double* P_D_Q_Out;
  I_KeywordSet_QOut = this->KeyWord_Set(CS_A1_Args_In, CString("Q_OUT"));
  if (I_KeywordSet_QOut >= 0)
  {
    P_D_Q_Out = (double*)ArgV_In[I_KeywordSet_QOut];
    cout << "CFits::LinFitBevingtonTwoProfiles: KeyWord_Set(Q_OUT)" << endl;
  }
  else
  {
    P_D_Q_Out = new double();
  }
  *P_D_Q_Out = 1.;



  D_A1_SP_Out.resize(2);
  D_A1_SP_Out = 0.0;
  I_KeywordSet_MeasureErrors = this->KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS_IN"));
  if (I_KeywordSet_MeasureErrors >= 0)
  {
    /// Accumulate sums...
    delete(P_D_A1_Sig);
    P_D_A1_Sig = (Array<double, 1>*)ArgV_In[I_KeywordSet_MeasureErrors];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevingtonTwoProfiles: ArgV_In[I_KeywordSet_MeasureErrors=" << I_KeywordSet_MeasureErrors << "] = " << *((Array<double,1>*)ArgV_In[I_KeywordSet_MeasureErrors]) << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: *P_D_A1_Sig = " << *P_D_A1_Sig << endl;
    #endif
    if (D_A1_CCD_In.size() != P_D_A1_Sig->size()){
      cout << "CFits::LinFitBevingtonTwoProfiles: ERROR: D_A1_CCD_In.size(=" << D_A1_CCD_In.size() << ") != P_D_A1_Sig->size(=" << P_D_A1_Sig->size() << ") => returning false" << endl;
      D_A1_SP_Out = 0.;
      D_Sky_Out = 0.;
      return false;
    }
    cout << "CFits::LinFitBevingtonTwoProfiles: KeyWord_Set(MEASURE_ERRORS_IN): *P_D_A1_Sig = " << *P_D_A1_Sig << endl;
  }

  Array<double, 1> D_A1_YFit(1);
  Array<double, 1> *P_D_A1_YFit = new Array<double, 1>(D_A1_CCD_In.size());
  I_KeywordSet_YFitOut = this->KeyWord_Set(CS_A1_Args_In, CString("YFIT_OUT"));
  if (I_KeywordSet_YFitOut >= 0)
  {
    delete(P_D_A1_YFit);
    P_D_A1_YFit = (Array<double, 1>*)ArgV_In[I_KeywordSet_YFitOut];
    P_D_A1_YFit->resize(D_A1_CCD_In.size());
    (*P_D_A1_YFit) = 0.;
  }
  if (sum(*P_I_A1_Mask) == 0){
    cout << "CFits::LinFitBevingtonTwoProfiles: WARNING: sum(*P_I_A1_Mask = " << *P_I_A1_Mask << ") == 0" << endl;
    D_A1_SP_Out = 0.;
    D_Sky_Out = 0.;
    return true;
  }

  int I_SumMaskLast;
  double D_SDevReject;
  Array<double, 1> D_A1_Check(D_A1_CCD_In.size());
  Array<int, 1> I_A1_LastMask(P_I_A1_Mask->size());
  Array<double, 1> D_A1_Diff(D_A1_CCD_In.size());
  D_A1_Diff = 0.;
  double D_Sum_Weights = 0.;
  double D_Sum_X1SquareTimesWeight = 0;
  double D_Sum_X1TimesWeight = 0.;
  double D_Sum_YTimesWeight = 0.;
  double D_Sum_X1YTimesWeight = 0.;
  double D_Sum_X2TimesWeight = 0.;
  double D_Sum_X1X2TimesWeight = 0.;
  double D_Sum_X2SquareTimesWeight = 0.;
  double D_Sum_X2YTimesWeight = 0.;
  double D_Delta = 0.;

  bool B_Run = true;
  int I_Run = -1;
  int I_MaskSum;
  while (B_Run){
    D_A1_SP_Out = 0.0;

    I_Run++;
    /// remove bad pixels marked by mask
    I_MaskSum = sum(*P_I_A1_Mask);
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": I_MaskSum = " << I_MaskSum << endl;
    #endif
//    if (I_MaskSum < P_I_A1_Mask->size()){
      D_A1_Sig.resize(I_MaskSum);
      D_A1_CCD.resize(I_MaskSum);
      D_A2_SF.resize(I_MaskSum,2);
      D_A1_WT.resize(I_MaskSum);
      D_A1_YFit.resize(I_MaskSum);
//    }
    D_A1_Sig = 0.;
    D_A1_CCD = 0.;
    D_A2_SF = 0.;
    D_A1_WT = 0.;
    D_A1_YFit = 0.;

    I_Pos = 0;
    for (i = 0; i < P_I_A1_Mask->size(); i++){
//      #ifdef __DEBUG_FITS_FIT__
//        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i=" << i << ": I_A1_Mask(i) = " << I_A1_Mask(i) << endl;
//      #endif
      if ((*P_I_A1_Mask)(i) == 1){
        D_A1_CCD(I_Pos) = D_A1_CCD_In(i);
        D_A2_SF(I_Pos,0) = D_A2_SF_In(i,0);
        D_A2_SF(I_Pos,1) = D_A2_SF_In(i,1);
        D_A1_Sig(I_Pos) = (*P_D_A1_Sig)(i);
//        #ifdef __DEBUG_FITS_FIT__
//          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i=" << i << ": I_A1_Mask(i) = " << I_A1_Mask << ": D_A1_CCD(I_Pos=" << I_Pos << ") set to " << D_A1_CCD(I_Pos) << endl;
//        #endif
        I_Pos++;
      }
    }
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_A1_CCD set to " << D_A1_CCD << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_A2_SF set to " << D_A2_SF << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_A1_Sig set to " << D_A1_Sig << endl;
    #endif

    D_Sum_Weights = 0.;
    D_Sum_X1SquareTimesWeight = 0.;
    D_Sum_X1TimesWeight = 0.;
    D_Sum_X1YTimesWeight = 0.;
    D_Sum_YTimesWeight = 0.;
    D_Sum_X1X2TimesWeight = 0.;
    D_Sum_X2SquareTimesWeight = 0.;
    D_Sum_X2TimesWeight = 0.;
    D_Sum_X2YTimesWeight = 0.;
    if (I_KeywordSet_MeasureErrors >= 0)
    {
      ///    D_A1_WT = D_A1_SF;
      for (i=0; i < I_MaskSum; i++)
      {
        /// ... with weights
        if (fabs(D_A1_Sig(i)) < 0.00000000000000001){
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig = " << D_A1_Sig << endl;
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig(" << i << ") == 0. => Returning FALSE" << endl;
          return false;
        }
        D_A1_WT(i) = 1. / pow2(D_A1_Sig(i));
      }
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ":: D_A1_WT set to " << D_A1_WT << endl;
      #endif
//      wtmax = max(D_A1_WT);
//      wtmin = 1.e-4;
//      D_A1_WT = where(D_A1_WT < wtmin, 0., D_A1_WT);
//      #ifdef __DEBUG_FITS_FIT__
//        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_A1_WT set to " << D_A1_WT << endl;
//      #endif
      for (i=0; i < I_MaskSum; i++)
      {
        D_Sum_Weights += D_A1_WT(i);
        D_Sum_X1TimesWeight += D_A2_SF(i,0) * D_A1_WT(i);
        D_Sum_YTimesWeight += D_A1_CCD(i) * D_A1_WT(i);
        D_Sum_X1YTimesWeight += D_A2_SF(i,0) * D_A1_CCD(i) * D_A1_WT(i);
        D_Sum_X1SquareTimesWeight += D_A2_SF(i,0) * D_A2_SF(i,0) * D_A1_WT(i);
        D_Sum_X1X2TimesWeight += D_A2_SF(i,0) * D_A2_SF(i,1) * D_A1_WT(i);
        D_Sum_X2SquareTimesWeight += D_A2_SF(i,1) * D_A2_SF(i,1) * D_A1_WT(i);
        D_Sum_X2TimesWeight += D_A2_SF(i,1) * D_A1_WT(i);
        D_Sum_X2YTimesWeight += D_A2_SF(i,1) * D_A1_CCD(i) * D_A1_WT(i);
      }
    }
    else
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        /// ... or without weights
        D_Sum_X1TimesWeight += D_A2_SF(i,0);
        D_Sum_YTimesWeight += D_A1_CCD(i);
        D_Sum_X1YTimesWeight += D_A2_SF(i,0) * D_A1_CCD(i);
        D_Sum_X1SquareTimesWeight += D_A2_SF(i,0) * D_A2_SF(i,0);
        D_Sum_X1X2TimesWeight += D_A2_SF(i,0) * D_A2_SF(i,1);
        D_Sum_X2SquareTimesWeight += D_A2_SF(i,1) * D_A2_SF(i,1);
        D_Sum_X2TimesWeight += D_A2_SF(i,1);
        D_Sum_X2YTimesWeight += D_A2_SF(i,1) * D_A1_CCD(i);
      }
      D_Sum_Weights = I_MaskSum;
    }
//    D_Delta = D_Sum_Weights * D_Sum_XSquareTimesWeight - pow2(D_Sum_XTimesWeight);

    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_Weights set to " << D_Sum_Weights << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_X1TimesWeight set to " << D_Sum_X1TimesWeight << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_X2TimesWeight set to " << D_Sum_X2TimesWeight << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_YTimesWeight set to " << D_Sum_YTimesWeight << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_X1YTimesWeight set to " << D_Sum_X1YTimesWeight << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_X2YTimesWeight set to " << D_Sum_X2YTimesWeight << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_X1SquareTimesWeight set to " << D_Sum_X1SquareTimesWeight << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_X2SquareTimesWeight set to " << D_Sum_X2SquareTimesWeight << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sum_X1X2TimesWeight set to " << D_Sum_X1X2TimesWeight << endl;
      //      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Delta set to " << D_Delta << endl;
    #endif

    if (!B_WithSky)
    {
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sky_Out < 0. = setting D_Sky_Out to 0 " << endl;
      #endif
      D_Delta = D_Sum_X1SquareTimesWeight * D_Sum_X2SquareTimesWeight - pow2(D_Sum_X1X2TimesWeight);
      D_A1_SP_Out(0) = ((D_Sum_X1YTimesWeight * D_Sum_X2SquareTimesWeight) - (D_Sum_X1X2TimesWeight * D_Sum_X2YTimesWeight)) / D_Delta;
      D_A1_SP_Out(1) = ((D_Sum_X1SquareTimesWeight * D_Sum_X2YTimesWeight) - (D_Sum_X1YTimesWeight * D_Sum_X1X2TimesWeight)) / D_Delta;
      D_Sky_Out = 0.0;
    }
/**    else
    {
      here!!!
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sky_Out >= 0." << D_Sky_Out << endl;
      #endif
      D_Sky_Out = ((D_Sum_XSquareTimesWeight * D_Sum_YTimesWeight) - (D_Sum_XTimesWeight * D_Sum_XYTimesWeight)) / D_Delta;

      D_SP_Out = ((D_Sum_Weights * D_Sum_XYTimesWeight) - (D_Sum_XTimesWeight * D_Sum_YTimesWeight)) / D_Delta;
      (*P_D_A1_Sigma_Out)(0) = sqrt(D_Sum_Weights / D_Delta);
      (*P_D_A1_Sigma_Out)(1) = sqrt(D_Sum_XSquareTimesWeight / D_Delta);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_SP_Out set to " << D_SP_Out << endl;
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sky_Out set to " << D_Sky_Out << endl;
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": P_D_A1_Sigma_Out(0) set to " << (*P_D_A1_Sigma_Out)(0) << endl;
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": P_D_A1_Sigma_Out(1) set to " << (*P_D_A1_Sigma_Out)(1) << endl;
      #endif
    }
    if ((!B_AllowSpecLTZero) && (D_SP_Out < 0.))
      D_SP_Out = 0.;

    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_Sky_Out set to " << D_Sky_Out << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_SP_Out set to " << D_SP_Out << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": fabs(D_SP_Out) = " << fabs(D_SP_Out) << endl;
    #endif

    *P_D_A1_YFit = D_Sky_Out + D_SP_Out * D_A1_SF_In;
    D_A1_YFit = D_Sky_Out + D_SP_Out * D_A1_SF;
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": *P_D_A1_YFit set to " << *P_D_A1_YFit << endl;
      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": D_A1_YFit set to " << D_A1_YFit << endl;
    #endif
    *P_D_ChiSqr_Out = 0.;
    if (I_KeywordSet_MeasureErrors < 0)
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        *P_D_ChiSqr_Out += pow2(D_A1_CCD(i) - D_A1_YFit(i));
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
        #endif
      }

      /// for unweighted data evaluate typical sig using chi2, and adjust the standard deviations
      if (I_MaskSum == 2){
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": ERROR: Sum of Mask (=" << I_MaskSum << ") must be greater than 2 => Returning FALSE" << endl;
        return false;
      }
      sigdat = sqrt((*P_D_ChiSqr_Out) / (I_MaskSum - 2));
      (*P_D_A1_Sigma_Out)(0) *= sigdat;
      (*P_D_A1_Sigma_Out)(1) *= sigdat;
    }
    else
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": D_A1_CCD(" << i << ") = " << D_A1_CCD(i) << endl;
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": D_A1_SF(" << i << ") = " << D_A1_SF(i) << endl;
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": D_A1_Sig(" << i << ") = " << D_A1_Sig(i) << endl;
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": D_A1_YFit(" << i << ") = " << D_A1_YFit(i) << endl;
        #endif
        if (abs(D_A1_Sig(i)) < 0.00000000000000001){
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig(" << i << ") == 0. => Returning FALSE" << endl;
          return false;
        }
        *P_D_ChiSqr_Out += pow((D_A1_CCD(i) - D_A1_YFit(i)) / D_A1_Sig(i),2);
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": i = " << i << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
        #endif
      }
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
      #endif
      if (I_MaskSum > 2)
      {
        if (!this->GammQ(0.5 * (I_MaskSum - 2), 0.5 * (*P_D_ChiSqr_Out), P_D_Q_Out))
        {
          cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": ERROR: GammQ returned FALSE" << endl;
          return false;
        }
      }
    }
    if (fabs(D_SP_Out) < 0.000001)
      B_Reject = false;
    if (!B_Reject)
      B_Run = false;
    else{

      I_SumMaskLast = sum(*P_I_A1_Mask);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: I_SumMaskLast = " << I_SumMaskLast << endl;
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: D_A1_CCD = " << D_A1_CCD << endl;
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: D_A1_YFit = " << D_A1_YFit << endl;
      #endif
//      D_SDevReject = sqrt((sum(pow((D_A1_CCD - D_A1_YFit) / where(fabs(D_A1_YFit) > 0.0001, D_A1_YFit, 0.0001),2.))) / (I_SumMaskLast));//(sum(pow(D_A1_CCD - (D_A1_YFit),2)) / I_SumMaskLast);
      D_SDevReject = sqrt(sum(pow2(D_A1_CCD - D_A1_YFit)) / double(I_SumMaskLast));//(sum(pow(D_A1_CCD - (D_A1_YFit),2)) / I_SumMaskLast);
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      /// NOTE: Should be square! Test!!!
      D_A1_Diff = D_A1_CCD_In - (*P_D_A1_YFit);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: D_SDevReject = " << D_SDevReject << endl;
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: D_A1_CCD_In = " << D_A1_CCD_In << endl;
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: *P_D_A1_YFit = " << *P_D_A1_YFit << endl;
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: D_A1_CCD_In - (*P_D_A1_YFit) = " << D_A1_Diff << endl;
      #endif
//      D_A1_Check = fabs((D_A1_Diff) / where(fabs(*P_D_A1_YFit) > 0., (*P_D_A1_YFit), 0.0001));
      D_A1_Check = fabs(D_A1_Diff);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: D_A1_Check = " << D_A1_Check << endl;
      #endif

      cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": before Reject: *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
      I_A1_LastMask = *P_I_A1_Mask;
      *P_I_A1_Mask = where(D_A1_Check > (*P_D_Reject) * D_SDevReject, 0, 1);
      *P_I_A1_Mask = where(I_A1_Mask_Orig < 1, 0, *P_I_A1_Mask);
      if (sum(*P_I_A1_Mask) == sum(I_A1_Mask_Orig))
        B_Reject = false;
      else
        *P_I_A1_Mask = where(I_A1_LastMask < 1, 0, *P_I_A1_Mask);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": Reject: *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
      #endif
      if (I_SumMaskLast == sum(*P_I_A1_Mask)){
        B_Run = false;
        #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevingtonTwoProfiles: I_Run=" << I_Run << ": leaving while loop" << endl;
        #endif
      }
      else{
        D_Sky_Out = 0.;
      }
    }
    if ((!B_AllowSkyLTZero) && (D_Sky_Out < 0.)){
      B_Run = true;
      B_WithSky = false;
    }
    
    
    
    **/
  }/// end while (B_Run)

  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::LinFitBevingtonTwoProfiles: *P_D_A1_YFit set to " << *P_D_A1_YFit << endl;
    cout << "CFits::LinFitBevingtonTwoProfiles: *P_I_A1_Mask set to " << *P_I_A1_Mask << endl;
  #endif


  /// clean up
  if (I_KeywordSet_Mask < 0)
  {
    delete(P_I_A1_Mask);
  }
  if (I_KeywordSet_Reject < 0)
  {
    delete(P_D_Reject);
  }
  if ((I_KeywordSet_AllowSkyLTZero < 0) && (I_KeywordSet_AllowSpecLTZero < 0)){
    delete(P_I_TempInt);
  }
  if (I_KeywordSet_MeasureErrors < 0)
  {
    delete(P_D_A1_Sig);
  }
  if (I_KeywordSet_ChiSqOut < 0)
  {
    delete(P_D_ChiSqr_Out);
  }
  if (I_KeywordSet_QOut < 0)
  {
    delete(P_D_Q_Out);
  }
  if (I_KeywordSet_SigmaOut < 0)
  {
    delete(P_D_A2_Sigma_Out);
  }
  if (I_KeywordSet_YFitOut < 0){
    delete(P_D_A1_YFit);
  }

  return true;
  
}

/**
Fit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
**/
bool CFits::LinFitBevington(const Array<double, 1> &D_A1_CCD_In,      /// yvec: in
                            const Array<double, 1> &D_A1_SF_In,       /// xvec: in
                            double &D_SP_Out,                         /// a1: out
                            double &D_Sky_Out,                        /// a0: in/out
                            const Array<CString, 1> &CS_A1_Args_In,   ///: in
                            void *ArgV_In[]) const                    ///: in
{
  bool B_WithSky = true;
  if (D_Sky_Out < 0.00000001)
    B_WithSky = false;
  return this->LinFitBevington(D_A1_CCD_In,
                               D_A1_SF_In,
                               D_SP_Out,
                               D_Sky_Out,
                               B_WithSky,
                               CS_A1_Args_In,
                               ArgV_In);
}

/**
Fit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
**/
bool CFits::LinFitBevington(const Array<double, 2> &D_A2_CCD_In,      /// yvec: in
                            const Array<double, 2> &D_A2_SF_In,       /// xvec: in
                            Array<double, 1> &D_A1_SP_Out,                         /// a1: out
                            Array<double, 1> &D_A1_Sky_Out,                        /// a0: out
                            const Array<CString, 1> &CS_A1_Args_In,   ///: in
                            void *ArgV_In[]) const                    ///: in
{
  bool B_WithSky = true;
  if (max(D_A1_Sky_Out) < 0.0000001)
    B_WithSky = false;
  return this->LinFitBevington(D_A2_CCD_In,
                               D_A2_SF_In,
                               D_A1_SP_Out,
                               D_A1_Sky_Out,
                               B_WithSky,
                               CS_A1_Args_In,
                               ArgV_In);
}

/**
  Fit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
  calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
 **/
bool CFits::LinFitBevington(const Array<double, 2> &D_A2_CCD_In,      /// yvec: in
                            const Array<double, 2> &D_A2_SF_In,       /// xvec: in
                            Array<double, 1> &D_A1_SP_Out,                         /// a1: out
                            Array<double, 1> &D_A1_Sky_Out,                        /// a0: out
                            bool B_WithSky,                           /// with sky: in
                            const Array<CString, 1> &CS_A1_Args_In,   ///: in
                            void *ArgV_In[]) const                    ///: in
    /// MEASURE_ERRORS_IN = Array<double, 2>(D_A2_CCD_In.rows(), D_A2_CCD_In.cols())
    /// REJECT_IN         = double
    /// MASK_INOUT        = Array<double, 2>(D_A2_CCD_In.rows(), D_A2_CCD_In.cols())
    /// CHISQ_OUT         = Array<double, 1>(D_A2_CCD_In.rows())
    /// Q_OUT             = Array<double, 1>(D_A2_CCD_In.rows())
    /// SIGMA_OUT         = Array<double, 2>(D_A2_CCD_In.rows(),2)
    /// YFIT_OUT          = Array<double, 2>(D_A2_CCD_In.rows(), D_A2_CCD_In.cols())
{
  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::LinFitBevington(Array, Array, Array, Array, bool, CSArr, PPArr) started" << endl;
    cout << "CFits::LinFitBevington(Array, Array, Array, Array, bool, CSArr, PPArr): D_A2_CCD_In = " << D_A2_CCD_In << endl;
    cout << "CFits::LinFitBevington(Array, Array, Array, Array, bool, CSArr, PPArr): D_A2_SF_In = " << D_A2_SF_In << endl;
  #endif
  if (D_A2_CCD_In.size() != D_A2_SF_In.size()){
    cout << "CFits::LinFitBevington: ERROR: D_A2_CCD_In.size(=" << D_A2_CCD_In.size() << ") != D_A2_SF_In.size(=" << D_A2_SF_In.size() << ") => returning false" << endl;
    D_A1_SP_Out = 0.;
    D_A1_Sky_Out = 0.;
    return false;
  }
  int i, I_Pos, I_ArgPos = 0;
  int I_KeywordSet_MeasureErrors, I_KeywordSet_Reject, I_KewordSet_Mask, I_KeywordSet_ChiSq, I_KeywordSet_Q, I_KeywordSet_Sigma, I_KeywordSet_YFit;
  if (D_A1_SP_Out.size() != D_A2_CCD_In.rows())
  {
    D_A1_SP_Out.resize(D_A2_CCD_In.rows());
  }
  D_A1_SP_Out = 0.;
  if (D_A1_Sky_Out.size() != D_A2_CCD_In.rows())
  {
    D_A1_Sky_Out.resize(D_A2_CCD_In.rows());
  }
  D_A1_Sky_Out = 0.;

  double *P_D_Reject;

  Array<double, 1> *P_D_A1_YFit;
  Array<double, 2> *P_D_A2_YFit;
  Array<int, 1> *P_I_A1_Mask;
  Array<int, 2> *P_I_A2_Mask;

  Array<double, 1> *P_D_A1_Sigma;
  Array<double, 1> *P_D_A1_Sigma_Out;
  Array<CString, 1> CS_A1_Args_Fit(10);
  CS_A1_Args_Fit = CString(" ");
  void **PP_Args_Fit = (void**)malloc(sizeof(void*) * 10);

  Array<double, 2> *P_D_A2_Sigma;
  I_KeywordSet_MeasureErrors = this->KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS_IN"));
  if (I_KeywordSet_MeasureErrors >= 0)
  {
    P_D_A2_Sigma = (Array<double,2>*)ArgV_In[I_KeywordSet_MeasureErrors];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington(Array, Array, Array, Array): P_D_A2_Sigma = " << *P_D_A2_Sigma << endl;
    #endif
    CS_A1_Args_Fit(I_ArgPos) = CString("MEASURE_ERRORS_IN");
    I_ArgPos++;
  }

  Array<double, 1> *P_D_A1_ChiSq;
  I_KeywordSet_ChiSq = this->KeyWord_Set(CS_A1_Args_In, CString("CHISQ_OUT"));
  if (I_KeywordSet_ChiSq >= 0)
  {
    P_D_A1_ChiSq = (Array<double,1>*)ArgV_In[I_KeywordSet_ChiSq];
    P_D_A1_ChiSq->resize(D_A2_CCD_In.rows());
    CS_A1_Args_Fit(I_ArgPos) = CString("CHISQ_OUT");
    I_ArgPos++;
  }

  Array<double, 1> *P_D_A1_Q;
  I_KeywordSet_Q = this->KeyWord_Set(CS_A1_Args_In, CString("Q_OUT"));
  if (I_KeywordSet_Q >= 0)
  {
    P_D_A1_Q = (Array<double,1>*)ArgV_In[I_KeywordSet_Q];
    P_D_A1_Q->resize(D_A2_CCD_In.rows());
    CS_A1_Args_Fit(I_ArgPos) = CString("Q_OUT");
    I_ArgPos++;
  }

  Array<double, 2> *P_D_A2_Sigma_Out;
  I_KeywordSet_Sigma = this->KeyWord_Set(CS_A1_Args_In, CString("SIGMA_OUT"));
  if (I_KeywordSet_Sigma >= 0)
  {
    P_D_A2_Sigma_Out = (Array<double,2>*)ArgV_In[I_KeywordSet_Sigma];
    P_D_A2_Sigma_Out->resize(D_A2_CCD_In.rows(), 2);
    CS_A1_Args_Fit(I_ArgPos) = CString("SIGMA_OUT");
    I_ArgPos++;
  }

  I_KeywordSet_YFit = this->KeyWord_Set(CS_A1_Args_In, CString("YFIT_OUT"));
  if (I_KeywordSet_YFit >= 0)
  {
    P_D_A2_YFit = (Array<double,2>*)ArgV_In[I_KeywordSet_YFit];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington2D: P_D_A2_YFit = " << *P_D_A2_YFit << endl;
    #endif
    CS_A1_Args_Fit(I_ArgPos) = CString("YFIT_OUT");
    I_ArgPos++;
  }

  I_KeywordSet_Reject = this->KeyWord_Set(CS_A1_Args_In, CString("REJECT_IN"));
  if (I_KeywordSet_Reject >= 0)
  {
    P_D_Reject = (double*)ArgV_In[I_KeywordSet_Reject];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington2D: P_D_Reject = " << *P_D_Reject << endl;
    #endif
    CS_A1_Args_Fit(I_ArgPos) = CString("REJECT_IN");
    I_ArgPos++;
  }

  I_KewordSet_Mask = this->KeyWord_Set(CS_A1_Args_In, CString("MASK_INOUT"));
  if (I_KewordSet_Mask >= 0)
  {
    P_I_A2_Mask = (Array<int,2>*)ArgV_In[I_KewordSet_Mask];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington2D: P_I_A2_Mask = " << *P_I_A2_Mask << endl;
    #endif
    CS_A1_Args_Fit(I_ArgPos) = CString("MASK_INOUT");
    I_ArgPos++;
  }

  bool B_DoFit = true;
  for (i = 0; i < D_A2_CCD_In.rows(); i++)
  {
    I_ArgPos = 0;
    if (I_KeywordSet_MeasureErrors >= 0){
      P_D_A1_Sigma = new Array<double,1>((*P_D_A2_Sigma)(i, Range::all()));
      #ifdef __DEBUG_FITS_FIT__
//        cout << "CFits::LinFitBevington(Array, Array, Array, Array): 2. P_D_A2_Sigma = " << *P_D_A2_Sigma << endl;
        cout << "CFits::LinFitBevington(Array, Array, Array, Array): P_D_A1_Sigma set to " << *P_D_A1_Sigma << endl;
      #endif
      PP_Args_Fit[I_ArgPos] = P_D_A1_Sigma;
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington(Array, Array, Array, Array): PP_Args_Fit[I_ArgPos=" << I_ArgPos << "] = " << *((Array<double,1>*)PP_Args_Fit[I_ArgPos]) << endl;
      #endif
      I_ArgPos++;
    }

    if (I_KeywordSet_ChiSq >= 0){
      PP_Args_Fit[I_ArgPos] = &((*P_D_A1_ChiSq)(i));
      I_ArgPos++;
    }

    if (I_KeywordSet_Q >= 0){
      PP_Args_Fit[I_ArgPos] = &((*P_D_A1_Q)(i));
      I_ArgPos++;
    }

    if (I_KeywordSet_Sigma >= 0){
      P_D_A1_Sigma_Out = new Array<double,1>((*P_D_A2_Sigma_Out)(i, Range::all()));
      PP_Args_Fit[I_ArgPos] = P_D_A1_Sigma_Out;
      I_ArgPos++;
    }

    if (I_KeywordSet_YFit >= 0){
      P_D_A1_YFit = new Array<double,1>((*P_D_A2_YFit)(i, Range::all()));
      PP_Args_Fit[I_ArgPos] = P_D_A1_YFit;
      I_ArgPos++;
    }

    if (I_KeywordSet_Reject >= 0){
      PP_Args_Fit[I_ArgPos] = P_D_Reject;
      I_ArgPos++;
    }

    B_DoFit = true;
    if (I_KewordSet_Mask >= 0){
      P_I_A1_Mask = new Array<int,1>((*P_I_A2_Mask)(i, Range::all()));
      PP_Args_Fit[I_ArgPos] = P_I_A1_Mask;
      I_ArgPos++;
      if (sum(*P_I_A1_Mask) == 0)
        B_DoFit = false;
    }

    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: Starting Fit1D: D_A2_CCD_In(i=" << i << ", *) = " << D_A2_CCD_In(i,Range::all()) << endl;
    #endif
    if (B_DoFit){
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: D_A2_SF_In(i=" << i << ", *) = " << D_A2_SF_In(i, Range::all()) << endl;
      #endif
      if (!this->LinFitBevington(D_A2_CCD_In(i,Range::all()),
                                 D_A2_SF_In(i,Range::all()),
                                 D_A1_SP_Out(i),
                                 D_A1_Sky_Out(i),
                                 B_WithSky,
                                 CS_A1_Args_Fit,
                                 PP_Args_Fit)){
        cout << "CFits::LinFitBevington: ERROR: this->Fit(D_A2_CCD_In(i,Range::all()),D_A2_SF_In(i,Range::all()),D_A1_SP_Out(i),D_A1_Sky_Out(i),D_A1_STDDEV_Out(i),D_A1_Covariance_Out(i)) returned false" << endl;
        free(PP_Args_Fit);
        cout << "CFits::LinFitBevington: D_A2_SF_In(0, *) = " << D_A2_SF_In(0,Range::all()) << endl;
        return false;
      }
    }

    I_ArgPos = 0;
    if (I_KeywordSet_MeasureErrors >= 0){
      (*P_D_A2_Sigma)(i, Range::all()) = (*P_D_A1_Sigma);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington(Array, Array, Array, Array): P_D_A2_Sigma(i=" << i << ",*) set to " << (*P_D_A2_Sigma)(i, Range::all()) << endl;
      #endif
      I_ArgPos++;
      delete(P_D_A1_Sigma);/// or not
    }

  //  if (I_KeywordSet_ChiSq >= 0){
  //    PP_Args_Fit[I_ArgPos] = &((*P_D_A1_ChiSq)(i));
  //    I_ArgPos++;
  //  }

  //  if (I_KeywordSet_Q >= 0){
  //    PP_Args_Fit[I_ArgPos] = &((*P_D_A1_Q)(i));
  //    I_ArgPos++;
  //  }

    if (I_KeywordSet_Sigma >= 0){
      (*P_D_A2_Sigma_Out)(i, Range::all()) = (*P_D_A1_Sigma_Out);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington(Array, Array, Array, Array): P_D_A2_Sigma_Out(i=" << i << ",*) set to " << (*P_D_A2_Sigma_Out)(i, Range::all()) << endl;
      #endif
      I_ArgPos++;
      delete(P_D_A1_Sigma_Out);// or not
    }

    if (I_KeywordSet_YFit >= 0){
      (*P_D_A2_YFit)(i, Range::all()) = (*P_D_A1_YFit);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington(Array, Array, Array, Array): P_D_A2_YFit(i=" << i << ",*) set to " << (*P_D_A2_YFit)(i, Range::all()) << endl;
      #endif
      I_ArgPos++;
      delete(P_D_A1_YFit);// or not
    }

    if (I_KewordSet_Mask >= 0){
      (*P_I_A2_Mask)(i, Range::all()) = (*P_I_A1_Mask);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington(Array, Array, Array, Array): P_I_A1_Mask = " << (*P_I_A1_Mask) << endl;
        cout << "CFits::LinFitBevington(Array, Array, Array, Array): P_I_A2_Mask(i=" << i << ",*) set to " << (*P_I_A2_Mask)(i, Range::all()) << endl;
      #endif
      I_ArgPos++;
      delete(P_I_A1_Mask);// or not
    }

  }
//  free(*PP_Args_Fit);
  free(PP_Args_Fit);
  return true;
}

/**
  Fit(Array<double, 1> y, const Array<double, 1> x, a1, a0);
  calculates a0 and a1 for the system of equations yvec = a0 + a1 * xvec
 **/
bool CFits::LinFitBevington(const Array<double, 1> &D_A1_CCD_In,      /// yvec: in
                            const Array<double, 1> &D_A1_SF_In,       /// xvec: in
                            double &D_SP_Out,                         /// a1: out
                            double &D_Sky_Out,                        /// a0: in/out
                            bool B_WithSky,                        /// with sky: in
                            const Array<CString, 1> &CS_A1_Args_In,   ///: in
                            void *ArgV_In[]) const                    ///: in
    /// MEASURE_ERRORS_IN = Array<double,1>(D_A1_CCD_In.size)
    /// REJECT_IN = double
    /// MASK_INOUT = Array<double,1>(D_A1_CCD_In.size)
    /// CHISQ_OUT = double
    /// Q_OUT = double
    /// SIGMA_OUT = Array<double,1>(2): [0]: sigma_sp, [1]: sigma_sky
    /// YFIT_OUT = Array<double, 1>(D_A1_CCD_In.size)
    /// ALLOW_SKY_LT_ZERO = 1
    /// ALLOW_SPEC_LT_ZERO = 1
{
  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::LinFitBevington(Array, Array, double, double, bool, CSArr, PPArr) started" << endl;
    cout << "CFits::LinFitBevington: D_A1_CCD_In = " << D_A1_CCD_In << endl;
    cout << "CFits::LinFitBevington: D_A1_SF_In = " << D_A1_SF_In << endl;
  #endif

  if (D_A1_CCD_In.size() != D_A1_SF_In.size()){
    cout << "CFits::LinFitBevington: ERROR: D_A1_CCD_In.size(=" << D_A1_CCD_In.size() << ") != D_A1_SF_In.size(=" << D_A1_SF_In.size() << ") => returning false" << endl;
    D_SP_Out = 0.;
    D_Sky_Out = 0.;
    return false;
  }

//  /// Set D_A1_SF_In to zero where D_A1_CCD_In == zero
  Array<double, 1> D_A1_SF(D_A1_SF_In.size());
  D_A1_SF = D_A1_SF_In;//(fabs(D_A1_CCD_In) < 0.000000001, 0., D_A1_SF_In);
  Array<double, 1> D_A1_CCD(D_A1_CCD_In.size());
  D_A1_CCD = D_A1_CCD_In;//(fabs(D_A1_CCD_In) < 0.000000001, 0., D_A1_SF_In);

  if (sum(D_A1_CCD_In) == 0. || sum(D_A1_SF) == 0.){
    cout << "CFits::LinFitBevington: Warning: (sum(D_A1_CCD_In)=" << sum(D_A1_CCD_In) << " == 0. || sum(D_A1_SF)=" << sum(D_A1_SF) << " == 0.) => returning false" << endl;
    D_SP_Out = 0.;
    D_Sky_Out = 0.;
    return true;
  }
  int i, I_Pos;
  int I_KeywordSet_Reject, I_KeywordSet_Mask, I_KeywordSet_MeasureErrors, I_KeywordSet_SigmaOut, I_KeywordSet_ChiSqOut, I_KeywordSet_QOut, I_KeywordSet_YFitOut, I_KeywordSet_AllowSkyLTZero, I_KeywordSet_AllowSpecLTZero;
  double sigdat;
  int ndata = D_A1_CCD_In.size();
  Array<double, 1> *P_D_A1_Sig = new Array<double, 1>(D_A1_CCD_In.size());
  (*P_D_A1_Sig) = 0.;
  Array<double, 1> D_A1_Sig(D_A1_CCD_In.size());
  Array<double, 1> D_A1_WT(ndata);

  /// a: D_Sky_Out
  /// b: D_SP_Out
  /// x: D_A1_SF_In
  /// y: D_A1_CCD_In

  int *P_I_TempInt = new int(0);

  bool B_AllowSkyLTZero = false;
  I_KeywordSet_AllowSkyLTZero = this->KeyWord_Set(CS_A1_Args_In, CString("ALLOW_SKY_LT_ZERO"));
  if (I_KeywordSet_AllowSkyLTZero >= 0)
  {
    delete(P_I_TempInt);
    P_I_TempInt = (int*)ArgV_In[I_KeywordSet_AllowSkyLTZero];

    if (*P_I_TempInt > 0){
      B_AllowSkyLTZero = true;
      cout << "CFits::LinFitBevington: KeyWord_Set(ALLOW_SKY_LT_ZERO)" << endl;
    }
  }

  bool B_AllowSpecLTZero = false;
  I_KeywordSet_AllowSpecLTZero = this->KeyWord_Set(CS_A1_Args_In, CString("ALLOW_SPEC_LT_ZERO"));
  if (I_KeywordSet_AllowSpecLTZero >= 0)
  {
    if (I_KeywordSet_AllowSkyLTZero < 0)
      delete(P_I_TempInt);
    P_I_TempInt = (int*)ArgV_In[I_KeywordSet_AllowSkyLTZero];

    if (*P_I_TempInt > 0){
      B_AllowSpecLTZero = true;
      cout << "CFits::LinFitBevington: KeyWord_Set(ALLOW_SPEC_LT_ZERO)" << endl;
    }
  }

  double *P_D_Reject = new double(-1.);
  I_KeywordSet_Reject = this->KeyWord_Set(CS_A1_Args_In, CString("REJECT_IN"));
  if (I_KeywordSet_Reject >= 0)
  {
    delete(P_D_Reject);
    P_D_Reject = (double*)ArgV_In[I_KeywordSet_Reject];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: KeyWord_Set(REJECT_IN): *P_D_Reject = " << *P_D_Reject << endl;
    #endif
  }
  bool B_Reject = false;
  if (*P_D_Reject > 0.)
    B_Reject = true;

  Array<int, 1> *P_I_A1_Mask = new Array<int, 1>(D_A1_CCD_In.size());
  Array<int, 1> I_A1_Mask_Orig(D_A1_CCD_In.size());
  //Array<int, 1> I_A1_Mask(D_A1_CCD_In.size());
  *P_I_A1_Mask = 1;

  I_KeywordSet_Mask = this->KeyWord_Set(CS_A1_Args_In, CString("MASK_INOUT"));
  if (I_KeywordSet_Mask >= 0)
  {
    delete(P_I_A1_Mask);
    P_I_A1_Mask = (Array<int, 1>*)ArgV_In[I_KeywordSet_Mask];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: KeyWord_Set(MASK_INOUT): *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
    #endif
  }
  //I_A1_Mask = (*P_I_A1_Mask);
  I_A1_Mask_Orig = (*P_I_A1_Mask);
  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::LinFitBevington: *P_I_A1_Mask set to " << *P_I_A1_Mask << endl;
    //cout << "CFits::LinFitBevington: I_A1_Mask set to " << I_A1_Mask << endl;
    cout << "CFits::LinFitBevington: I_A1_Mask_Orig set to " << I_A1_Mask_Orig << endl;
  #endif

  Array<double, 1> *P_D_A1_Sigma_Out;
  Array<double, 1> D_A1_Sigma_Out(2);
  I_KeywordSet_SigmaOut = this->KeyWord_Set(CS_A1_Args_In, CString("SIGMA_OUT"));
  if (I_KeywordSet_SigmaOut >= 0)
  {
    P_D_A1_Sigma_Out = (Array<double, 1>*)ArgV_In[I_KeywordSet_SigmaOut];
    P_D_A1_Sigma_Out->resize(2);
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: KeyWord_Set(SIGMA_OUT)" << endl;
    #endif
  }
  else
  {
    P_D_A1_Sigma_Out = new Array<double, 1>(2);
  }
  *P_D_A1_Sigma_Out = 0.;
  D_A1_Sigma_Out = *P_D_A1_Sigma_Out;

  double* P_D_ChiSqr_Out;
  I_KeywordSet_ChiSqOut = this->KeyWord_Set(CS_A1_Args_In, CString("CHISQ_OUT"));
  if (I_KeywordSet_ChiSqOut >= 0)
  {
    P_D_ChiSqr_Out = (double*)ArgV_In[I_KeywordSet_ChiSqOut];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: KeyWord_Set(CHISQ_OUT)" << endl;
    #endif
  }
  else
  {
    P_D_ChiSqr_Out = new double();
  }
  *P_D_ChiSqr_Out = 0.;

  double* P_D_Q_Out;
  I_KeywordSet_QOut = this->KeyWord_Set(CS_A1_Args_In, CString("Q_OUT"));
  if (I_KeywordSet_QOut >= 0)
  {
    P_D_Q_Out = (double*)ArgV_In[I_KeywordSet_QOut];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: KeyWord_Set(Q_OUT)" << endl;
    #endif
  }
  else
  {
    P_D_Q_Out = new double();
  }
  *P_D_Q_Out = 1.;



  D_SP_Out = 0.0;
  I_KeywordSet_MeasureErrors = this->KeyWord_Set(CS_A1_Args_In, CString("MEASURE_ERRORS_IN"));
  if (I_KeywordSet_MeasureErrors >= 0)
  {
    /// Accumulate sums...
    delete(P_D_A1_Sig);
    P_D_A1_Sig = (Array<double, 1>*)ArgV_In[I_KeywordSet_MeasureErrors];
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: ArgV_In[I_KeywordSet_MeasureErrors=" << I_KeywordSet_MeasureErrors << "] = " << *((Array<double,1>*)ArgV_In[I_KeywordSet_MeasureErrors]) << endl;
      cout << "CFits::LinFitBevington: *P_D_A1_Sig = " << *P_D_A1_Sig << endl;
    #endif
    if (D_A1_CCD_In.size() != P_D_A1_Sig->size()){
      cout << "CFits::LinFitBevington: ERROR: D_A1_CCD_In.size(=" << D_A1_CCD_In.size() << ") != P_D_A1_Sig->size(=" << P_D_A1_Sig->size() << ") => returning false" << endl;
      D_SP_Out = 0.;
      D_Sky_Out = 0.;
      return false;
    }
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: KeyWord_Set(MEASURE_ERRORS_IN): *P_D_A1_Sig = " << *P_D_A1_Sig << endl;
    #endif
  }

  Array<double, 1> D_A1_YFit(1);
  Array<double, 1> *P_D_A1_YFit = new Array<double, 1>(D_A1_CCD_In.size());
  I_KeywordSet_YFitOut = this->KeyWord_Set(CS_A1_Args_In, CString("YFIT_OUT"));
  if (I_KeywordSet_YFitOut >= 0)
  {
    delete(P_D_A1_YFit);
    P_D_A1_YFit = (Array<double, 1>*)ArgV_In[I_KeywordSet_YFitOut];
    P_D_A1_YFit->resize(D_A1_CCD_In.size());
    (*P_D_A1_YFit) = 0.;
  }
  if (sum(*P_I_A1_Mask) == 0){
    cout << "CFits::LinFitBevington: WARNING: sum(*P_I_A1_Mask = " << *P_I_A1_Mask << ") == 0" << endl;
    D_SP_Out = 0.;
    D_Sky_Out = 0.;
    return true;
  }

  int I_SumMaskLast;
  double D_SDevReject;
  Array<double, 1> D_A1_Check(D_A1_CCD_In.size());
  Array<int, 1> I_A1_LastMask(P_I_A1_Mask->size());
  Array<double, 1> D_A1_Diff(D_A1_CCD_In.size());
  D_A1_Diff = 0.;
  double D_Sum_Weights = 0.;
  double D_Sum_XSquareTimesWeight = 0;
  double D_Sum_XTimesWeight = 0.;
  double D_Sum_YTimesWeight = 0.;
  double D_Sum_XYTimesWeight = 0.;
  double D_Delta = 0.;

  bool B_Run = true;
  int I_Run = -1;
  int I_MaskSum;
  while (B_Run){
    D_SP_Out = 0.0;

    I_Run++;
    /// remove bad pixels marked by mask
    I_MaskSum = sum(*P_I_A1_Mask);
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": I_MaskSum = " << I_MaskSum << endl;
    #endif
//    if (I_MaskSum < P_I_A1_Mask->size()){
      D_A1_Sig.resize(I_MaskSum);
      D_A1_CCD.resize(I_MaskSum);
      D_A1_SF.resize(I_MaskSum);
      D_A1_WT.resize(I_MaskSum);
      D_A1_YFit.resize(I_MaskSum);
//    }
    D_A1_Sig = 0.;
    D_A1_CCD = 0.;
    D_A1_SF = 0.;
    D_A1_WT = 0.;
    D_A1_YFit = 0.;

    I_Pos = 0;
    for (i = 0; i < P_I_A1_Mask->size(); i++){
//      #ifdef __DEBUG_FITS_FIT__
//        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i=" << i << ": I_A1_Mask(i) = " << I_A1_Mask(i) << endl;
//      #endif
      if ((*P_I_A1_Mask)(i) == 1){
        D_A1_CCD(I_Pos) = D_A1_CCD_In(i);
        D_A1_SF(I_Pos) = D_A1_SF_In(i);
        D_A1_Sig(I_Pos) = (*P_D_A1_Sig)(i);
//        #ifdef __DEBUG_FITS_FIT__
//          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i=" << i << ": I_A1_Mask(i) = " << I_A1_Mask << ": D_A1_CCD(I_Pos=" << I_Pos << ") set to " << D_A1_CCD(I_Pos) << endl;
//        #endif
        I_Pos++;
      }
    }
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_A1_CCD set to " << D_A1_CCD << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_A1_SF set to " << D_A1_SF << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_A1_Sig set to " << D_A1_Sig << endl;
    #endif

    D_Sum_Weights = 0.;
    D_Sum_XSquareTimesWeight = 0.;
    D_Sum_XTimesWeight = 0.;
    D_Sum_XYTimesWeight = 0.;
    D_Sum_YTimesWeight = 0.;
    if (I_KeywordSet_MeasureErrors >= 0)
    {
      ///    D_A1_WT = D_A1_SF;
      for (i=0; i < I_MaskSum; i++)
      {
        /// ... with weights
        if (fabs(D_A1_Sig(i)) < 0.00000000000000001){
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig = " << D_A1_Sig << endl;
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig(" << i << ") == 0. => Returning FALSE" << endl;
          return false;
        }
        D_A1_WT(i) = 1. / pow2(D_A1_Sig(i));
      }
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ":: D_A1_WT set to " << D_A1_WT << endl;
      #endif
//      wtmax = max(D_A1_WT);
//      wtmin = 1.e-4;
//      D_A1_WT = where(D_A1_WT < wtmin, 0., D_A1_WT);
//      #ifdef __DEBUG_FITS_FIT__
//        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_A1_WT set to " << D_A1_WT << endl;
//      #endif
      for (i=0; i < I_MaskSum; i++)
      {
        D_Sum_Weights += D_A1_WT(i);
        D_Sum_XTimesWeight += D_A1_SF(i) * D_A1_WT(i);
        D_Sum_YTimesWeight += D_A1_CCD(i) * D_A1_WT(i);
        D_Sum_XYTimesWeight += D_A1_SF(i) * D_A1_CCD(i) * D_A1_WT(i);
        D_Sum_XSquareTimesWeight += D_A1_SF(i) * D_A1_SF(i) * D_A1_WT(i);
      }
    }
    else
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        /// ... or without weights
        D_Sum_XTimesWeight += D_A1_SF(i);
        D_Sum_YTimesWeight += D_A1_CCD(i);
        D_Sum_XYTimesWeight += D_A1_SF(i) * D_A1_CCD(i);
        D_Sum_XSquareTimesWeight += D_A1_SF(i) * D_A1_SF(i);
      }
      D_Sum_Weights = I_MaskSum;
    }
    D_Delta = D_Sum_Weights * D_Sum_XSquareTimesWeight - pow2(D_Sum_XTimesWeight);

    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sum_Weights set to " << D_Sum_Weights << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sum_XTimesWeight set to " << D_Sum_XTimesWeight << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sum_YTimesWeight set to " << D_Sum_YTimesWeight << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sum_XYTimesWeight set to " << D_Sum_XYTimesWeight << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sum_XSquareTimesWeight set to " << D_Sum_XSquareTimesWeight << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Delta set to " << D_Delta << endl;
    #endif


    if (!B_WithSky)
    {
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sky_Out < 0. = setting D_Sky_Out to 0 " << endl;
      #endif
      D_SP_Out = D_Sum_XYTimesWeight / D_Sum_XSquareTimesWeight;
      D_Sky_Out = 0.0;
    }
    else
    {
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sky_Out >= 0." << D_Sky_Out << endl;
      #endif
      D_Sky_Out = ((D_Sum_XSquareTimesWeight * D_Sum_YTimesWeight) - (D_Sum_XTimesWeight * D_Sum_XYTimesWeight)) / D_Delta;

      D_SP_Out = ((D_Sum_Weights * D_Sum_XYTimesWeight) - (D_Sum_XTimesWeight * D_Sum_YTimesWeight)) / D_Delta;
      (*P_D_A1_Sigma_Out)(0) = sqrt(D_Sum_Weights / D_Delta);
      (*P_D_A1_Sigma_Out)(1) = sqrt(D_Sum_XSquareTimesWeight / D_Delta);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_SP_Out set to " << D_SP_Out << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sky_Out set to " << D_Sky_Out << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": P_D_A1_Sigma_Out(0) set to " << (*P_D_A1_Sigma_Out)(0) << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": P_D_A1_Sigma_Out(1) set to " << (*P_D_A1_Sigma_Out)(1) << endl;
      #endif
    }
    if ((!B_AllowSpecLTZero) && (D_SP_Out < 0.))
      D_SP_Out = 0.;

    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_Sky_Out set to " << D_Sky_Out << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_SP_Out set to " << D_SP_Out << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": fabs(D_SP_Out) = " << fabs(D_SP_Out) << endl;
    #endif

    *P_D_A1_YFit = D_Sky_Out + D_SP_Out * D_A1_SF_In;
    D_A1_YFit = D_Sky_Out + D_SP_Out * D_A1_SF;
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": *P_D_A1_YFit set to " << *P_D_A1_YFit << endl;
      cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": D_A1_YFit set to " << D_A1_YFit << endl;
    #endif
    *P_D_ChiSqr_Out = 0.;
    if (I_KeywordSet_MeasureErrors < 0)
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        *P_D_ChiSqr_Out += pow2(D_A1_CCD(i) - D_A1_YFit(i));
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
        #endif
      }

      /// for unweighted data evaluate typical sig using chi2, and adjust the standard deviations
      if (I_MaskSum == 2){
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": ERROR: Sum of Mask (=" << I_MaskSum << ") must be greater than 2 => Returning FALSE" << endl;
        return false;
      }
      sigdat = sqrt((*P_D_ChiSqr_Out) / (I_MaskSum - 2));
      (*P_D_A1_Sigma_Out)(0) *= sigdat;
      (*P_D_A1_Sigma_Out)(1) *= sigdat;
    }
    else
    {
      for (i = 0; i < I_MaskSum; i++)
      {
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": D_A1_CCD(" << i << ") = " << D_A1_CCD(i) << endl;
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": D_A1_SF(" << i << ") = " << D_A1_SF(i) << endl;
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": D_A1_Sig(" << i << ") = " << D_A1_Sig(i) << endl;
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": D_A1_YFit(" << i << ") = " << D_A1_YFit(i) << endl;
        #endif
        if (abs(D_A1_Sig(i)) < 0.00000000000000001){
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": ERROR: D_A1_Sig(" << i << ") == 0. => Returning FALSE" << endl;
          return false;
        }
        *P_D_ChiSqr_Out += pow((D_A1_CCD(i) - D_A1_YFit(i)) / D_A1_Sig(i),2);
        #ifdef __DEBUG_FITS_FIT__
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": i = " << i << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
        #endif
      }
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": P_D_ChiSqr_Out set to " << *P_D_ChiSqr_Out << endl;
      #endif
      if (I_MaskSum > 2)
      {
        if (!this->GammQ(0.5 * (I_MaskSum - 2), 0.5 * (*P_D_ChiSqr_Out), P_D_Q_Out))
        {
          cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": ERROR: GammQ returned FALSE" << endl;
          return false;
        }
      }
    }
    if (fabs(D_SP_Out) < 0.000001)
      B_Reject = false;
    if (!B_Reject)
      B_Run = false;
    else{

      I_SumMaskLast = sum(*P_I_A1_Mask);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: I_SumMaskLast = " << I_SumMaskLast << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: D_A1_CCD = " << D_A1_CCD << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: D_A1_YFit = " << D_A1_YFit << endl;
      #endif
//      D_SDevReject = sqrt((sum(pow((D_A1_CCD - D_A1_YFit) / where(fabs(D_A1_YFit) > 0.0001, D_A1_YFit, 0.0001),2.))) / (I_SumMaskLast));//(sum(pow(D_A1_CCD - (D_A1_YFit),2)) / I_SumMaskLast);
      D_SDevReject = sqrt(sum(pow2(D_A1_CCD - D_A1_YFit)) / double(I_SumMaskLast));//(sum(pow(D_A1_CCD - (D_A1_YFit),2)) / I_SumMaskLast);
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      /// NOTE: Should be square! Test!!!
      D_A1_Diff = D_A1_CCD_In - (*P_D_A1_YFit);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: D_SDevReject = " << D_SDevReject << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: D_A1_CCD_In = " << D_A1_CCD_In << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: *P_D_A1_YFit = " << *P_D_A1_YFit << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: D_A1_CCD_In - (*P_D_A1_YFit) = " << D_A1_Diff << endl;
      #endif
//      D_A1_Check = fabs((D_A1_Diff) / where(fabs(*P_D_A1_YFit) > 0., (*P_D_A1_YFit), 0.0001));
      D_A1_Check = fabs(D_A1_Diff);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: D_A1_Check = " << D_A1_Check << endl;
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": before Reject: *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
      #endif
      I_A1_LastMask = *P_I_A1_Mask;
      *P_I_A1_Mask = where(D_A1_Check > (*P_D_Reject) * D_SDevReject, 0, 1);
      *P_I_A1_Mask = where(I_A1_Mask_Orig < 1, 0, *P_I_A1_Mask);
      if (sum(*P_I_A1_Mask) == sum(I_A1_Mask_Orig))
        B_Reject = false;
      else
        *P_I_A1_Mask = where(I_A1_LastMask < 1, 0, *P_I_A1_Mask);
      #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": Reject: *P_I_A1_Mask = " << *P_I_A1_Mask << endl;
      #endif
/*      if (fabs(min(*P_D_A1_YFit)) < 0.00000001){
        cout << "CFits::LinFitBevington: D_A1_CCD_In = " << D_A1_CCD_In << endl;
        cout << "CFits::LinFitBevington: D_A1_CCD_In = " << D_A1_SF_In << endl;
        cout << "CFits::LinFitBevington: ERROR: fabs(min(*P_D_A1_YFit=" << *P_D_A1_YFit << ")) < 0.00000001 => Returning FALSE" << endl;
        return false;
      }*/
      if (I_SumMaskLast == sum(*P_I_A1_Mask)){
        B_Run = false;
        #ifdef __DEBUG_FITS_FIT__
        cout << "CFits::LinFitBevington: I_Run=" << I_Run << ": leaving while loop" << endl;
        #endif
      }
      else{
        D_Sky_Out = 0.;
      }
    }
    if ((!B_AllowSkyLTZero) && (D_Sky_Out < 0.)){
      B_Run = true;
      B_WithSky = false;
    }
  }/// end while (B_Run)

  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::LinFitBevington: *P_D_A1_YFit set to " << *P_D_A1_YFit << endl;
    cout << "CFits::LinFitBevington: *P_I_A1_Mask set to " << *P_I_A1_Mask << endl;
  #endif


  /// clean up
  if (I_KeywordSet_Mask < 0)
  {
    delete(P_I_A1_Mask);
  }
  if (I_KeywordSet_Reject < 0)
  {
    delete(P_D_Reject);
  }
  if ((I_KeywordSet_AllowSkyLTZero < 0) && (I_KeywordSet_AllowSpecLTZero < 0)){
    delete(P_I_TempInt);
  }
  if (I_KeywordSet_MeasureErrors < 0)
  {
    delete(P_D_A1_Sig);
  }
  if (I_KeywordSet_ChiSqOut < 0)
  {
    delete(P_D_ChiSqr_Out);
  }
  if (I_KeywordSet_QOut < 0)
  {
    delete(P_D_Q_Out);
  }
  if (I_KeywordSet_SigmaOut < 0)
  {
    delete(P_D_A1_Sigma_Out);
  }
  if (I_KeywordSet_YFitOut < 0){
    delete(P_D_A1_YFit);
  }

  return true;
}

/** ****************************************************************/

bool CFits::ExtractErrors()
{
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args = CString(" ");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  return this->ExtractErrors(CS_A1_Args, PP_Args);
}

bool CFits::ExtractErrors(const Array<CString, 1> &CS_A1_Args_In, void *ArgV_In[]){
  if (!this->ErrorsRead){
    cout << "CFits::ExtractErrors: Errors not read yet" << endl;
    return false;
  }
  cout << "CFits::ExtractErrors: Errors read, starting ExtractFromProfile" << endl;
//  cout << "CFits::ExtractErrors: *this->P_D_A2_ErrArray = " << *this->P_D_A2_ErrArray << endl;
  if (!this->ExtractFromProfile(*(this->P_D_A2_ErrArray), CS_A1_Args_In, ArgV_In)){
    cout << "CFits::ExtractErrors: ERRORS: this->ExtractFromProfile returned false" << endl;
    return false;
  }
  Array<int, 1> *P_I_A1_Apertures = new Array<int, 1>(1);
  (*P_I_A1_Apertures)(0) = 0;
  int I_Pos = 0;
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("APERTURES"));
  if (I_Pos >= 0){
    delete(P_I_A1_Apertures);
    P_I_A1_Apertures = (Array<int, 1>*)ArgV_In[I_Pos];
    for (int i=0; i<P_I_A1_Apertures->size(); i++){
      (*this->P_D_A2_Errors_Ec)((*P_I_A1_Apertures)(i), Range::all()) = (*this->P_D_A2_LastExtracted)((*P_I_A1_Apertures)(i), Range::all());
      (*(this->P_D_A2_Errors_Ec))((*P_I_A1_Apertures)(i), Range::all()) = (*(this->P_D_A2_Errors_Ec))((*P_I_A1_Apertures)(i), Range::all()) * (*(this->P_D_A2_Blaze))((*P_I_A1_Apertures)(i), Range::all());
    }
  }
  else{
    (*this->P_D_A2_Errors_Ec) = (*this->P_D_A2_LastExtracted);
    (*(this->P_D_A2_Errors_Ec)) = (*(this->P_D_A2_Errors_Ec)) * (*(this->P_D_A2_Blaze));
  }
  return true;
}

/** ****************************************************************/

bool CFits::ExtractSimpleSum()
{
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args = CString(" ");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  return this->ExtractSimpleSum(*this->P_D_A2_PixArray, CS_A1_Args, PP_Args);
}

/** ****************************************************************/

bool CFits::ExtractSimpleSum(const Array<CString, 1> &CS_A1_Args_In,       ///: in
                             void *ArgV_In[])
{
  return this->ExtractSimpleSum(*this->P_D_A2_PixArray, CS_A1_Args_In, ArgV_In);
}

/** ****************************************************************/

bool CFits::ExtractSimpleSum(const Array<double, 2> &D_A2_ArrayToExtract,
                             const Array<CString, 1> &CS_A1_Args_In,       ///: in
                             void *ArgV_In[])
{

//  cout << "CFits::ExtractSimpleSum: (919,817) = " << (*(this->P_D_A2_PixArray))(919,817) << endl;
//  return false;
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::ExtractSimpleSum: ERROR: Trace functions not calculated" << endl;
    return false;
  }
  if (D_A2_ArrayToExtract.rows() != this->NRows){
    cout << "CFits::ExtractSimpleSum: ERROR: D_A2_ArrayToExtract.rows() != this->NRows" << endl;
  }
  if (D_A2_ArrayToExtract.cols() != this->NCols){
    cout << "CFits::ExtractSimpleSum: ERROR: D_A2_ArrayToExtract.cols() != this->NCols" << endl;
  }

  int I_Pos;
  int I_XMin = 0;
  int I_XMax = this->NCols-1;
  int I_YMin = 0;
  int I_YMax = this->NRows-1;
  Array<int, 1> *P_I_A1_AperturesToExtract = this->IndGenArr(this->I_NApertures);

  ///Area to extract
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("AREA"));
  if (I_Pos >= 0)
  {
    Array<int, 1> I_A1_Area(4);
    I_A1_Area = *(Array<int, 1>*)ArgV_In[I_Pos];
//    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::ExtractSimpleSum: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
      (*P_OFS_Log) << "CFits::ExtractSimpleSum: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
//    #endif
    I_XMin = I_A1_Area(0);
    I_XMax = I_A1_Area(1);
    I_YMin = I_A1_Area(2);
    I_YMax = I_A1_Area(3);
//    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::ExtractSimpleSum: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
      (*P_OFS_Log) << "CFits::ExtractSimpleSum: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
//    #endif
    //      return false;
  }
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("APERTURES"))) >= 0)
  {
    delete(P_I_A1_AperturesToExtract);
    P_I_A1_AperturesToExtract = (Array<int, 1>*)ArgV_In[I_Pos];
  }

  Array<double, 2> D_A2_ArrayTemp(this->NRows, this->NCols);
  Array<double, 1> D_A1_Deb(1);
  D_A2_ArrayTemp = D_A2_ArrayToExtract;
  int XFirst, XLast;
  double D_WeightFirst, D_WeightLast;
  (*this->P_D_A2_LastExtracted) = 0.;
  int iap = 0;
  for (int i_ap=0; i_ap < P_I_A1_AperturesToExtract->size(); i_ap++){
    iap = (*P_I_A1_AperturesToExtract)(i_ap);
    #ifdef __DEBUG_EXTRACT_SIMPLESUM__
      cout << "CFits::ExtractSimpleSum: Aperture " << iap << ": (*(this->P_D_A1_XCenter))(iap) = " << (*(this->P_D_A1_XCenter))(iap) << endl;
      cout << "CFits::ExtractSimpleSum: Aperture " << iap << ": (*(this->P_D_A1_YCenter))(iap) = " << (*(this->P_D_A1_YCenter))(iap) << endl;
      cout << "CFits::ExtractSimpleSum: Aperture " << iap << ": (*(this->P_D_A1_YLow))(iap) = " << (*(this->P_D_A1_YLow))(iap) << endl;
      cout << "CFits::ExtractSimpleSum: Aperture " << iap << ": (*(this->P_D_A1_YHigh))(iap) = " << (*(this->P_D_A1_YHigh))(iap) << endl;
    #endif
    if (((*(this->P_D_A1_XCenter))(iap) >= I_XMin)
        && ((*(this->P_D_A1_XCenter))(iap) <= I_XMax)
        && ((((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) >= I_YMin)
             && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) <= I_YMax))
            || (((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) >= I_YMin)
             && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) <= I_YMax)))){
      cout << "CFits::ExtractSimpleSum: Extracting Aperture " << iap << endl;

//    if (((*(this->P_D_A1_XCenter))(iap) >= I_XMin)
//        && ((*(this->P_D_A1_XCenter))(iap) <= I_XMax)
//        && ((((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) >= I_YMin)
//             && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) <= I_YMax))
//            || (((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) >= I_YMin)
//             && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) <= I_YMax)))){
      for (int m=(*this->P_D_A1_YCenter)(iap)+(*this->P_D_A1_YLow)(iap); m <= (*this->P_D_A1_YCenter)(iap)+(*this->P_D_A1_YHigh)(iap); m++){

        XFirst = int((*this->P_D_A2_XCenters)(iap,m) + (*this->P_D_A1_XLow)(iap));
        #ifdef __DEBUG_EXTRACT_SIMPLESUM__
          cout << "CFits::ExtractSimpleSum: XFirst = " << XFirst << endl;
        #endif

        XLast = int((*this->P_D_A2_XCenters)(iap,m) + (*this->P_D_A1_XHigh)(iap));
        #ifdef __DEBUG_EXTRACT_SIMPLESUM__
          cout << "CFits::ExtractSimpleSum: XLast = " << XLast << endl;

          cout << "CFits::ExtractSimpleSum: (*this->P_D_A2_XCenters)(iap,m) = " << (*this->P_D_A2_XCenters)(iap,m) << endl;
        #endif
        D_WeightFirst = 1. - ((*this->P_D_A2_XCenters)(iap,m) + (*this->P_D_A1_XLow)(iap) - double(XFirst));
        #ifdef __DEBUG_EXTRACT_SIMPLESUM__
          cout << "CFits::ExtractSimpleSum: D_WeightFirst = " << D_WeightFirst << endl;
        #endif

        D_WeightLast = (*this->P_D_A2_XCenters)(iap,m) + (*this->P_D_A1_XHigh)(iap) - double(XLast);
        #ifdef __DEBUG_EXTRACT_SIMPLESUM__
          cout << "CFits::ExtractSimpleSum: D_WeightLast = " << D_WeightLast << endl;
        #endif
        D_A1_Deb.resize(XLast-XFirst+1);
        D_A1_Deb = D_A2_ArrayTemp(m,Range(XFirst, XLast));
        D_A1_Deb(0) = D_A1_Deb(0) * D_WeightFirst;
        D_A1_Deb(D_A1_Deb.size()-1) = D_A1_Deb(D_A1_Deb.size()-1) * D_WeightLast;
        (*this->P_D_A2_LastExtracted)(iap,m) = sum(D_A1_Deb);
//        cout << "CFits::ExtractSimpleSum: PixArray(919,817) = " << (*(this->P_D_A2_PixArray))(919,817) << endl;
//        cout << "CFits::ExtractSimpleSum: D_A2_ArrayToExtract(919,817) = " << D_A2_ArrayToExtract(919,817) << endl;
//        cout << "CFits::ExtractSimpleSum: D_A2_ArrayTemp(919,817) = " << D_A2_ArrayTemp(919,817) << endl;
//        cout << "CFits::ExtractSimpleSum: PixArray(817,919) = " << (*(this->P_D_A2_PixArray))(817,919) << endl;
//        cout << "CFits::ExtractSimpleSum: D_A2_ArrayToExtract(817,919) = " << D_A2_ArrayToExtract(817,919) << endl;
//        cout << "CFits::ExtractSimpleSum: D_A2_ArrayTemp(817,919) = " << D_A2_ArrayTemp(817,919) << endl;
//        if (D_A2_ArrayTemp(817,919) < 10.)
//          return false;
//        cout << "CFits::ExtractSimpleSum: D_A1_Deb = " << D_A1_Deb << endl;
        #ifdef __DEBUG_EXTRACT_SIMPLESUM__
          cout << "CFits::ExtractSimpleSum: (*this->P_D_A2_LastExtracted)(" << iap << ", " << m << ") set to " << (*this->P_D_A2_LastExtracted)(iap,m) << endl;
        #endif
      }
//      if (i_ap == 749)
//        return false;
    }
  }

  return true;
}

/** ****************************************************************/

bool CFits::ExtractFromProfile(const Array<double, 2> &D_A2_ArrayToExtract)
{
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args = CString(" ");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);

  if (!this->ExtractFromProfile(D_A2_ArrayToExtract, CS_A1_Args, PP_Args)){
    cout << "CFits::ExtractFromProfile: ERROR: ExtractFromProfile returned FALSE" << endl;
    free(PP_Args);
    return false;
  }
  free(PP_Args);
  return true;
}

/** ****************************************************************/

bool CFits::ExtractFromProfile(const Array<double, 2> &D_A2_ArrayToExtract, const Array<CString, 1> &CS_A1_Args_In, void *ArgV_In[])
{
  if (D_A2_ArrayToExtract.cols() != this->NCols){
    cout << "CFits::ExtractFromProfile: ERROR: D_A2_ArrayToExtract.cols(=" << D_A2_ArrayToExtract.cols() << ") != this->NCols(=" << this->NCols << endl;
    return false;
  }

  if (D_A2_ArrayToExtract.rows() != this->NRows){
    cout << "CFits::ExtractFromProfile: ERROR: D_A2_ArrayToExtract.rows(=" << D_A2_ArrayToExtract.rows() << ") != this->NRows(=" << this->NRows << endl;
    return false;
  }

  int I_XMin = 0;
  int I_XMax = this->NCols-1;
  int I_YMin = 0;
  int I_YMax = this->NRows-1;
  int I_Pos;

  Array<int, 1> *P_I_A1_AperturesToExtract = this->IndGenArr(this->I_NApertures);
  Array<CString, 1> CS_A1_Args_MkProfIm(1);
  CS_A1_Args_MkProfIm = CString(" ");
  void **PP_Args_MkProfIm = (void**)malloc(sizeof(void*) * 1);

  ///Area to extract
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("AREA"))) >= 0)
  {
    Array<int, 1> I_A1_Area(4);
    I_A1_Area = *(Array<int, 1>*)ArgV_In[I_Pos];
    #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
      cout << "CFits::ExtractFromProfile: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
      (*P_OFS_Log) << "CFits::ExtractFromProfile: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
    #endif
    I_XMin = I_A1_Area(0);
    I_XMax = I_A1_Area(1);
    I_YMin = I_A1_Area(2);
    I_YMax = I_A1_Area(3);
    #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
      cout << "CFits::ExtractFromProfile: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
      (*P_OFS_Log) << "CFits::ExtractFromProfile: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
    #endif
    //      return false;
  }

  ///Apertures to extract
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("APERTURES"))) >= 0)
  {
    delete(P_I_A1_AperturesToExtract);
    P_I_A1_AperturesToExtract = (Array<int, 1>*)ArgV_In[I_Pos];
    #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
      cout << "CFits::ExtractFromProfile: KeyWord_Set(APERTURES): P_I_A1_AperturesToExtract set to " << *P_I_A1_AperturesToExtract << endl;
      (*P_OFS_Log) << "CFits::ExtractFromProfile: KeyWord_Set(APERTURES): P_I_A1_AperturesToExtract set to " << *P_I_A1_AperturesToExtract << endl;
    #endif
    CS_A1_Args_MkProfIm(0) = CString("APERTURES");
    PP_Args_MkProfIm[0] = P_I_A1_AperturesToExtract;
  }

  if (!ProfileCalculated){
    cout << "CFits::ExtractFromProfile: ProfileCalculated == FALSE => Starting MkProfIm" << endl;
    if (!this->MkProfIm(CS_A1_Args_MkProfIm, PP_Args_MkProfIm)){
      cout << "CFits::ExtractFromProfile: Profile not calculated yet and MkProfIm returned false" << endl;
      free(PP_Args_MkProfIm);
      return false;
    }
  }
  else{
    cout << "CFits::ExtractFromProfile: ProfileCalculated == TRUE" << endl;
  }

  Array<double,2> D_A2_ArrayTemp(D_A2_ArrayToExtract.rows(), D_A2_ArrayToExtract.cols());
  D_A2_ArrayTemp = D_A2_ArrayToExtract * (*(this->P_D_A2_ProfArray));
//  #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
//    cout << "CFits::ExtractFromProfile: D_A2_ArrayTemp set to " << D_A2_ArrayTemp << endl;
//  #endif

  double WeightFirst, WeightLast;
  int XFirst, XLast, npix;

  /// input paramters
//  Array<double,2> *P_D_A2_SDev;
  int iap = 0;
  for (int i_ap = 0; i_ap < P_I_A1_AperturesToExtract->size(); i_ap++){
    #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
      cout << "CFits::ExtractFromProfile: i_ap = " << i_ap << endl;
    #endif
    iap = (*P_I_A1_AperturesToExtract)(i_ap);
    #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
      cout << "CFits::ExtractFromProfile: iap = " << iap << endl;
    #endif
    if (((*(this->P_D_A1_XCenter))(iap) >= I_XMin)
        && ((*(this->P_D_A1_XCenter))(iap) <= I_XMax)
        && ((((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) >= I_YMin)
             && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) <= I_YMax))
            || (((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) >= I_YMin)
             && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) <= I_YMax)))){

//    if (((*(this->P_D_A1_XCenter))(iap) >= I_XMin)
//        && ((*(this->P_D_A1_XCenter))(iap) <= I_XMax)
//        && ((((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) >= I_YMin)
//             && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) <= I_YMax))
//            || (((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) >= I_YMin)
//             && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) <= I_YMax)))){
      for (int m = (*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap); m <= (*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap); m++){
        WeightFirst = (*(this->P_D_A2_XCenters))(iap, m) +
                      (*(this->P_D_A1_XLow))(iap);
        XFirst = (int)WeightFirst;
        WeightFirst -= (double)XFirst;
        WeightFirst = 1. - WeightFirst;
        #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
          cout << "CFits::ExtractFromProfile: for (m(=" << m << "); m < NRows(=" << this->NRows << "); m++): XFirst set to " << XFirst << endl;
          cout << "CFits::ExtractFromProfile: for (m(=" << m << "); m < NRows(=" << this->NRows << "); m++): WeightFirst set to " << WeightFirst << endl;
        #endif

        WeightLast = (*this->P_D_A2_XCenters)(iap, m) +
                     (*this->P_D_A1_XHigh)(iap);
        XLast = (int)WeightLast;
        WeightLast -= (double)XLast;
        #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
          cout << "CFits::ExtractFromProfile: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XLast set to " << XLast << endl;
          cout << "CFits::ExtractFromProfile: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): WeightLast set to " << WeightLast << endl;
        #endif

        npix = XLast - XFirst + 1;
        #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
          cout << "CFits::ExtractFromProfile: npix " << npix << endl;
        #endif

// #ifdef __DEBUG_EXTRACT_ERRORS__
//      cout << "CFits::ExtractFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: (*this->P_D_A2_XCenters)(iap,m) = " << (*this->P_D_A2_XCenters)(iap,m) << endl;
//      cout << "CFits::ExtractFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: (*P_D_A1_XLow)(iap) = " << (*P_D_A1_XLow)(iap) << endl;
// #endif
//      int I_Beg = int((*this->P_D_A2_XCenters)(iap,m) + (*P_D_A1_XLow)(iap));
// #ifdef __DEBUG_EXTRACT_ERRORS__
//      cout << "CFits::ExtractFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: I_Beg set to " << I_Beg << endl;
// #endif
        if (XFirst < 0){
          XFirst = 0;
          #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
            cout << "CFits::ExtractFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: XFirst < 0: XFirst set to " << XFirst << endl;
          #endif
        }

//      int XLast = int((*this->P_D_A2_XCenters)(iap,m) + (*this->P_D_A1_XHigh)(iap));
        if (double(XLast) < (*this->P_D_A2_XCenters)(iap,m) + (*this->P_D_A1_XHigh)(iap))
          XLast++;
        #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
          cout << "CFits::ExtractFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: XLast set to " << XLast << endl;
        #endif
        if (XLast >= D_A2_ArrayTemp.cols()){
          XLast = D_A2_ArrayTemp.cols() - 1;
          #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
            cout << "CFits::ExtractFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: XLast >= D_A2_ArrayTemp.cols()=" << D_A2_ArrayTemp.cols() << ": XLast set to " << XLast << endl;
          #endif
        }

        #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
          cout << "CFits::ExtractFromProfile: D_A2_ArrayTemp(m,Range(XFirst=" << XFirst << ", XLast = " << XLast << ")) = " << D_A2_ArrayTemp(m,Range(XFirst,XLast)) << endl;

          cout << "CFits::ExtractFromProfile: D_A2_ArrayTemp(m,Range(XFirst,XLast)) = " << D_A2_ArrayTemp(m,Range(XFirst,XLast)) << endl;
        #endif

        D_A2_ArrayTemp(m,XFirst) *= WeightFirst;
        D_A2_ArrayTemp(m,XLast) *= WeightLast;
        (*(this->P_D_A2_LastExtracted))(iap,m) = sum(D_A2_ArrayTemp(m,Range(XFirst, XLast)));

        #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
          cout << "CFits::ExtractFromProfile: this->P_D_A2_LastExtracted(iap=" << iap << ",m=" << m << ") = sum(D_A2_ArrayTemp(m,Range(XFirst,XLast))) set to " << (*this->P_D_A2_LastExtracted)(iap,m) << endl;
        #endif
      }
    }
  }

  //double minindex = min((*P_D_A2_XCenters)
  free(PP_Args_MkProfIm);
  #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
    cout << "CFits::ExtractFromProfile: returning TRUE" << endl;
  #endif

  return true;
}

/** ****************************************************************/

/// performs linear fitting to profile, with sky
bool CFits::ExtractSpecFromProfile()
{
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::ExtractSpecFromProfile: Trace Functions not calculated yet" << endl;
    return false;
  }

  return this->ExtractSpecFromProfile(*this->P_D_A2_PixArray);
}

/** ****************************************************************/

/// performs linear fitting to profile, with or without sky
bool CFits::ExtractSpecFromProfile(bool B_WithSky)
{
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::ExtractSpecFromProfile: Trace Functions not calculated yet" << endl;
    return false;
  }
  Array<CString,1> CS_A1_Args(1);
  CS_A1_Args(0) = CString("WITH_SKY");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  PP_Args[0] = &B_WithSky;

  return this->ExtractSpecFromProfile(*this->P_D_A2_PixArray, CS_A1_Args, PP_Args);
}

/** ****************************************************************/

/// performs linear fitting to profile, with sky
bool CFits::ExtractSpecFromProfile(const Array<double, 2> &D_A2_ArrayToExtract)
{
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args(0) = CString("WITH_SKY");
  void** PP_Args = (void**)malloc(sizeof(void*) * 1);
  bool B_WithSky = true;
  PP_Args[0] = &B_WithSky;
  return (this->ExtractSpecFromProfile(D_A2_ArrayToExtract, CS_A1_Args, PP_Args));
}

/** ****************************************************************/

/// performs linear fitting to profile, with or without sky
bool CFits::ExtractSpecFromProfile(const Array<double, 2> &D_A2_ArrayToExtract,
                                   const Array<CString, 1> &CS_A1_Args_In,
                                   void* PP_Args_In[])
{
  if (D_A2_ArrayToExtract.cols() != this->NCols){
    cout << "CFits::ExtractSpecFromProfile: ERROR: D_A2_ArrayToExtract.cols(=" << D_A2_ArrayToExtract.cols() << ") != this->NCols(=" << this->NCols << endl;
    return false;
  }

  if (D_A2_ArrayToExtract.rows() != this->NRows){
    cout << "CFits::ExtractSpecFromProfile: ERROR: D_A2_ArrayToExtract.rows(=" << D_A2_ArrayToExtract.rows() << ") != this->NRows(=" << this->NRows << endl;
    return false;
  }

  Array<double,2> D_A2_ArrayTemp(D_A2_ArrayToExtract.rows(), D_A2_ArrayToExtract.cols());
  D_A2_ArrayTemp = D_A2_ArrayToExtract;/// * (*this->P_D_A2_ProfArray);
  #ifdef __DEBUG_EXTRACT_ERRORS__
    cout << "CFits::ExtractSpecFromProfile: D_A2_ArrayTemp set to " << D_A2_ArrayTemp << endl;
  #endif

  double WeightFirst, WeightLast;
  int XFirst, XLast, npix;
  bool B_WithSky = false;
  Array<CString,1> CS_A1_Args_Fit(5);
  CS_A1_Args_Fit = CString(" ");
  void **PP_Args_Fit = (void**)malloc(sizeof(void*) * 5);

  int I_XMin = 0;
  int I_XMax = this->NCols-1;
  int I_YMin = 0;
  int I_YMax = this->NRows-1;
  int I_Pos;

  Array<int, 1> *P_I_A1_AperturesToExtract = this->IndGenArr(this->I_NApertures);

  ///Extract with sky?
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("WITH_SKY"))) >= 0)
  {
    B_WithSky = *(bool*)PP_Args_In[I_Pos];
  }

  ///Area to extract
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("AREA"))) >= 0)
  {
    Array<int, 1> I_A1_Area(4);
    I_A1_Area = *(Array<int, 1>*)PP_Args_In[I_Pos];
    #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
      cout << "CFits::ExtractSpecFromProfile: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
      (*P_OFS_Log) << "CFits::ExtractSpecFromProfile: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
    #endif
    I_XMin = I_A1_Area(0);
    I_XMax = I_A1_Area(1);
    I_YMin = I_A1_Area(2);
    I_YMax = I_A1_Area(3);
    #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
      cout << "CFits::ExtractSpecFromProfile: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
      (*P_OFS_Log) << "CFits::ExtractSpecFromProfile: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
    #endif
  }

  Array<CString, 1> CS_A1_Args_MkProfIm(1);
  CS_A1_Args_MkProfIm = CString(" ");
  void **PP_Args_MkProfIm = (void**)malloc(sizeof(void*) * 1);
  ///Apertures to extract
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("APERTURES"))) >= 0)
  {
    delete(P_I_A1_AperturesToExtract);
    P_I_A1_AperturesToExtract = (Array<int, 1>*)PP_Args_In[I_Pos];
    #ifdef __DEBUG_FITS_EXTRACTFROMPROFILE__
      cout << "CFits::ExtractFromProfile: KeyWord_Set(APERTURES): P_I_A1_AperturesToExtract set to " << *P_I_A1_AperturesToExtract << endl;
      (*P_OFS_Log) << "CFits::ExtractFromProfile: KeyWord_Set(APERTURES): P_I_A1_AperturesToExtract set to " << *P_I_A1_AperturesToExtract << endl;
    #endif
    CS_A1_Args_MkProfIm(0) = CString("APERTURES");
    PP_Args_MkProfIm[0] = P_I_A1_AperturesToExtract;
  }
  if (!ProfileCalculated){
    if (!this->MkProfIm(CS_A1_Args_MkProfIm, PP_Args_MkProfIm)){
      cout << "CFits::ExtractSpecFromProfile: Profile not calculated yet and MkProfIm returned false" << endl;
      return false;
    }
  }



  /// input paramters
  Array<double,2> *P_D_A2_SDev;
  CS_A1_Args_Fit(0).Set("MEASURE_ERRORS_IN");
  Array<double,1> D_A1_ErrTemp(1);
  PP_Args_Fit[0] = &D_A1_ErrTemp;
  #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
    cout << "CFits::ExtractSpecFromProfile: MEASURE_ERRORS_IN set" << endl;
  #endif

  CS_A1_Args_Fit(1).Set("YFIT_OUT");
  Array<double,1> D_A1_YFit(1);
  PP_Args_Fit[1] = &D_A1_YFit;
  #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
    cout << "CFits::ExtractSpecFromProfile: YFIT_OUT set" << endl;
  #endif

  CS_A1_Args_Fit(2).Set("SIGMA_OUT");
  Array<double,1> D_A1_Sigma(2);
  PP_Args_Fit[2] = &D_A1_Sigma;
  #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
    cout << "CFits::ExtractSpecFromProfile: SIGMA_OUT set" << endl;
  #endif

  CS_A1_Args_Fit(3).Set("MASK_INOUT");
  Array<int,1> I_A1_Mask(1);
  PP_Args_Fit[3] = &I_A1_Mask;
  #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
    cout << "CFits::ExtractSpecFromProfile: MASK_INOUT set" << endl;
  #endif

  double D_Sky_Temp, D_Spec;
  int iap = 0;
  for (int i_ap = 0; i_ap < this->I_NApertures; i_ap++){
    iap = (*P_I_A1_AperturesToExtract)(i_ap);
    if (((*(this->P_D_A1_XCenter))(iap) >= I_XMin)
        && ((*(this->P_D_A1_XCenter))(iap) <= I_XMax)
        && ((((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) >= I_YMin)
            && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) <= I_YMax))
           || (((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) >= I_YMin)
            && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) <= I_YMax)))){

//    if (((*(this->P_D_A1_XCenter))(iap) >= I_XMin)
//        && ((*(this->P_D_A1_XCenter))(iap) <= I_XMax)
//        && ((((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) >= I_YMin)
//            && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YLow))(iap) <= I_YMax))
//           || (((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) >= I_YMin)
//            && ((*(this->P_D_A1_YCenter))(iap)+(*(this->P_D_A1_YHigh))(iap) <= I_YMax)))){
      for (int m = int((*this->P_D_A1_YCenter)(iap)+(*P_D_A1_YLow)(iap)); m <= int((*this->P_D_A1_YCenter)(iap)+(*P_D_A1_YHigh)(iap)); m++){
        WeightFirst = (*this->P_D_A2_XCenters)(iap, m) +
                      (double)((*this->P_D_A1_XLow)(iap));
        XFirst = (int)WeightFirst;
        WeightFirst -= (double)XFirst;
        WeightFirst = 1. - WeightFirst;
        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XFirst set to " << XFirst << endl;
          cout << "CFits::ExtractSpecFromProfile: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): WeightFirst set to " << WeightFirst << endl;
        #endif

        WeightLast = (*this->P_D_A2_XCenters)(iap, m) +
                     (*this->P_D_A1_XHigh)(iap);
        XLast = (int)WeightLast;
        WeightLast -= (double)XLast;
        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XLast set to " << XLast << endl;
          cout << "CFits::ExtractSpecFromProfile: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): WeightLast set to " << WeightLast << endl;
        #endif

// #ifdef __DEBUG_EXTRACT_ERRORS__
//      cout << "CFits::ExtractSpecFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: (*this->P_D_A2_XCenters)(iap,m) = " << (*this->P_D_A2_XCenters)(iap,m) << endl;
//      cout << "CFits::ExtractSpecFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: (*P_D_A1_XLow)(iap) = " << (*P_D_A1_XLow)(iap) << endl;
// #endif
//      int I_Beg = int((*this->P_D_A2_XCenters)(iap,m) + (*P_D_A1_XLow)(iap));
// #ifdef __DEBUG_EXTRACT_ERRORS__
//      cout << "CFits::ExtractSpecFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: I_Beg set to " << I_Beg << endl;
// #endif
        if (XFirst < 0){
          XFirst = 0;
          #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
            cout << "CFits::ExtractSpecFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: XFirst < 0: XFirst set to " << XFirst << endl;
          #endif
        }

//      int XLast = int((*this->P_D_A2_XCenters)(iap,m) + (*this->P_D_A1_XHigh)(iap));
        if (double(XLast) < (*this->P_D_A2_XCenters)(iap,m) + (*this->P_D_A1_XHigh)(iap))
          XLast++;
        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: XLast set to " << XLast << endl;
        #endif
        if (XLast >= D_A2_ArrayTemp.cols()){
          XLast = D_A2_ArrayTemp.cols() - 1;
          #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
            cout << "CFits::ExtractSpecFromProfile: for(iap(=" << iap << ");...): for m(=" << m << ")...: XLast >= D_A2_ArrayTemp.cols()=" << D_A2_ArrayTemp.cols() << ": XLast set to " << XLast << endl;
          #endif
        }

        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: D_A2_ArrayTemp(m,Range(XFirst=" << XFirst << ", XLast = " << XLast << ")) = " << D_A2_ArrayTemp(m,Range(XFirst,XLast)) << endl;

          cout << "CFits::ExtractSpecFromProfile: D_A2_ArrayTemp(m,Range(XFirst,XLast)) = " << D_A2_ArrayTemp(m,Range(XFirst,XLast)) << endl;
        #endif

        npix = XLast - XFirst + 1;

        D_A1_YFit.resize(npix);
        I_A1_Mask.resize(npix);
        I_A1_Mask = 1;
//        PP_Args_Fit[1] = P_D_A1_YFit;

        D_A2_ArrayTemp(m,XFirst) *= WeightFirst;
        D_A2_ArrayTemp(m,XLast) *= WeightLast;
        D_A1_ErrTemp.resize(npix);
        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: npix = " << npix << ", XFirst = " << XFirst << ", XLast = " << XLast << ", XLast - XFirst + 1 = " << XLast - XFirst + 1 << endl;
        #endif
        D_A1_ErrTemp = (*P_D_A2_ErrArray)(m,Range(XFirst, XLast));
//        PP_Args_Fit[0] = P_D_A1_ErrTemp;
        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: Starting Fit" << endl;
        #endif
        if (!Fit(D_A2_ArrayTemp(m,Range(XFirst, XLast)),      /// y: in
                 (*this->P_D_A2_ProfArray)(m,Range(XFirst, XLast)), /// x: in
                 D_Spec,        /// a1: out
                 D_Sky_Temp,                                  /// a0: in/out
                 B_WithSky,                                   ///: in
                 CS_A1_Args_Fit,                              ///: in
                 PP_Args_Fit)){                               ///: in/out
          cout << "CFits::ExtractSpecFromProfile: ERROR: Fit returned false => Returning false" << endl;
          return false;
        }
        (*this->P_D_A2_LastExtracted)(iap,m) = D_Spec;
//        delete(P_D_A1_ErrTemp);
        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: D_A2_ArrayTemp(m,Range(XFirst, XLast)) = " << D_A2_ArrayTemp(m,Range(XFirst, XLast)) << endl;
          cout << "CFits::ExtractSpecFromProfile: (*P_D_A2_ProfArray)(m,Range(XFirst, XLast)) = " << (*P_D_A2_ProfArray)(m,Range(XFirst, XLast)) << endl;
          cout << "CFits::ExtractSpecFromProfile: (*this->P_D_A2_LastExtracted)(iap=" << iap << ",m) = " << (*this->P_D_A2_LastExtracted)(iap,m) << endl;
          cout << "CFits::ExtractSpecFromProfile: D_Sky_Temp = " << D_Sky_Temp << endl;
          cout << "CFits::ExtractSpecFromProfile: D_A1_YFit = " << D_A1_YFit << endl;
        #endif
//        (*P_D_A1_YFit) = (*P_D_A2_ProfArray)(m,Range(XFirst, XLast)) * (*this->P_D_A2_LastExtracted)(iap,m) + D_Sky_Temp;
//        cout << "CFits::ExtractSpecFromProfile: *P_D_A1_YFit from prof, SP, Sky = " << *P_D_A1_YFit << endl;

        if (B_WithSky){
          (*(this->P_D_A2_Sky))(iap,m) = D_Sky_Temp;
          (*(this->P_D_A2_SkyError))(iap,m) = D_A1_Sigma(1);
          (*(this->P_D_A2_RecSkyArray))(m,Range(XFirst, XLast)) = D_Sky_Temp;
        }

        (*(this->P_D_A2_RecFitArray))(m,Range(XFirst, XLast)) = D_A1_YFit;
        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: (*this.P_D_A2_RecFitArray)(m=" << m << ",Range(XFirst=" << XFirst << ", XLast=" << XLast << ")) = " << (*(this->P_D_A2_RecFitArray))(m,Range(XFirst, XLast)) << endl;
        #endif
        ///      (*this->P_D_A2_LastExtracted)(iap,m) = sum(D_A2_ArrayTemp(m,Range(XFirst, XLast)));

        (*(this->P_D_A2_Errors_Ec))(iap,m) = D_A1_Sigma(0);

        (*(this->P_I_A2_MaskArray))(m,Range(XFirst, XLast)) = I_A1_Mask;

        #ifdef __DEBUG_EXTRACTSPECFROMPROFILE__
          cout << "CFits::ExtractSpecFromProfile: this->P_D_A2_LastExtracted(iap=" << iap << ",m=" << m << ") = sum(D_A2_ArrayTemp(m,Range(XFirst,XLast))) set to " << (*this->P_D_A2_LastExtracted)(iap,m) << endl;
        #endif
      }
    }
  }

  //double minindex = min((*P_D_A2_XCenters)

  return true;
}


/**
 Helper function to calculate incomplete Gamma Function
 **/
double CFits::GammLn(double xx) const
{
  double x,y,tmp,ser;
  static double cof[6]={76.18009172947146, -86.50532032941677,24.01409824083091,-1.231739572450155,0.1208650973866179e-2,-0.5395239384953e-5};

  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::GammLn: xx = " << xx << endl;
  #endif

  y = x = xx;
  tmp = x + 5.5;
  tmp -= (x+0.5) * log(tmp);
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::GammLn: tmp = " << tmp << endl;
  #endif
  ser = 1.000000000190015;
  for (int o = 0; o <= 5; o++){
    ser += cof[o] / ++y;
  }
  double D_Result = (-tmp + log(2.5066282746310005 * ser / x));
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::GammLn: ser = " << ser << endl;
    cout << "CFits::GammLn: returning (-tmp + log(2.5066282746310005 * ser / xx)) = " << D_Result << endl;
  #endif
  return D_Result;
}


/**
 Helper function to calculate incomplete Gamma Function
 **/
bool CFits::GSER(double *P_D_Gamser_Out, double a, double x, double *P_D_GLn_Out) const
{
  int n;
  int ITMax = 100;
  double d_sum, del, ap;

  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::GSER: *P_D_Gamser_Out = " << *P_D_Gamser_Out << endl;
    cout << "CFits::GSER: a = " << a << endl;
    cout << "CFits::GSER: x = " << x << endl;
  #endif

  *P_D_GLn_Out = this->GammLn(a);
  #ifdef __DEBUG_FITS_LINFIT__
    cout << "CFits::GSER: *P_D_GLn_Out = " << *P_D_GLn_Out << endl;
  #endif
  if (x <= 0.){
    if (x < 0.){
      cout << "CFits::GSER: ERROR: x less than 0!" << endl;
      return false;
    }
    *P_D_Gamser_Out = 0.;
    #ifdef __DEBUG_FITS_LINFIT__
      cout << "CFits::GSER: x<=0: *P_D_Gamser_Out = " << *P_D_Gamser_Out << endl;
      cout << "CFits::GSER: x<=0: *P_D_GLn_Out = " << *P_D_GLn_Out << endl;
    #endif
    return true;
  }
  else{
    ap = a;
    del = d_sum = 1. / a;
    for (n=1; n <= ITMax; n++){
      ++ap;
      del *= x/ap;
      d_sum += del;
      if (fabs(del) < fabs(d_sum) * 3.e-7){
        *P_D_Gamser_Out = d_sum * exp(-x+a*log(x) - (*P_D_GLn_Out));
        #ifdef __DEBUG_FITS_LINFIT__
          cout << "CFits::GSER: x>0: *P_D_Gamser_Out = " << *P_D_Gamser_Out << endl;
          cout << "CFits::GSER: x>0: *P_D_GLn_Out = " << *P_D_GLn_Out << endl;
        #endif
        return true;
      }
    }
    cout << "CFits::GSER: ERROR: a too large, ITMax too small in routine GSER" << endl;
    return false;
  }
}

/**
 Helper function to calculate incomplete Gamma Function
 **/
bool CFits::GCF(double *P_D_GammCF_Out, double a, double x, double *P_D_GLn_Out) const
{
  int n;
  int ITMAX = 100;             /// Maximum allowed number of iterations
  double an, b, c, d, del, h;
  double FPMIN = 1.0e-30;      /// Number near the smallest representable floating-point number
  double EPS = 1.0e-7;         /// Relative accuracy

  *P_D_GLn_Out = this->GammLn(a);
#ifdef __DEBUG_FITS_FIT__
  cout << "CFits::GCF: P_D_GLn_Out set to " << *P_D_GLn_Out << endl;
#endif

  b = x + 1. - a;
#ifdef __DEBUG_FITS_FIT__
  cout << "CFits::GCF: x=" << x << ", a=" << a << ": b set to " << b << endl;
#endif
  c = 1. / FPMIN;
#ifdef __DEBUG_FITS_FIT__
  cout << "CFits::GCF: c set to " << c << endl;
#endif
  d = 1. / b;
#ifdef __DEBUG_FITS_FIT__
  cout << "CFits::GCF: d set to " << d << endl;
#endif
  h = d;
  for (n=1; n <= ITMAX; n++){
    an = -n * (n - a);
#ifdef __DEBUG_FITS_FIT__
    cout << "CFits::GCF: n = " << n << ": an set to " << an << endl;
#endif
    b += 2.;
#ifdef __DEBUG_FITS_FIT__
    cout << "CFits::GCF: n = " << n << ": b set to " << b << endl;
#endif
    d = an * d + b;
#ifdef __DEBUG_FITS_FIT__
    cout << "CFits::GCF: n = " << n << ": d set to " << d << endl;
#endif
    if (fabs(d) < FPMIN)
      d = FPMIN;
    c = b + an / c;
#ifdef __DEBUG_FITS_FIT__
    cout << "CFits::GCF: n = " << n << ": c set to " << c << endl;
#endif
    if (fabs(c) < FPMIN)
      c = FPMIN;
    d = 1. / d;
#ifdef __DEBUG_FITS_FIT__
    cout << "CFits::GCF: n = " << n << ": d set to " << d << endl;
#endif
    del = d * c;
#ifdef __DEBUG_FITS_FIT__
    cout << "CFits::GCF: n = " << n << ": del set to " << del << endl;
#endif

    h *= del;
    if (fabs(del-1.) < EPS)
      break;
  }
  if (n > ITMAX){
    cout << "CFits::GCF: ERROR: a too large, ITMAX too small in GCF" << endl;
    return false;
  }
  *P_D_GammCF_Out = exp(-x+a*log(x) - (*P_D_GLn_Out)) * h;
  return true;
}

/**
 Function to calculate incomplete Gamma Function P(a,x)
 **/
bool CFits::GammP(double a, double x, double* D_Out) const{
#ifdef __DEBUG_FITS_FIT__
  cout << "CFits::GammP started: a = " << a << ", x = " << x << endl;
#endif
  double gamser, gammcf, gln;
  if (x < 0. || a <= 0.){
    cout << "CFits::GammP: ERROR: Invalid arguments in routine GammP" << endl;
    return false;
  }
  if (x < (a+1.)){
    if (!this->GSER(&gamser, a, x, &gln)){
      cout << "CFits::GammP: ERROR: GSER returned FALSE" << endl;
      return false;
    }
    *D_Out = gamser;
    return true;
  }
  else{
    if (!this->GCF(&gammcf, a, x, &gln))
    {
      cout << "CFits::GammP: ERROR: GCF returned FALSE" << endl;
      return false;
    }
    *D_Out = 1. - gammcf;
    return true;
  }
}

/**
 Function to calculate incomplete Gamma Function Q(a,x) = 1. - P(a,x)
 **/
bool CFits::GammQ(double a, double x, double* D_Out) const{
  #ifdef __DEBUG_FITS_FIT__
    cout << "CFits::GammQ started: a = " << a << ", x = " << x << endl;
  #endif
  double gamser = 0.;
  double gammcf = 0.;
  double gln = 0.;
  if (x < 0. || a <= 0.){
    cout << "CFits::GammQ: ERROR: Invalid arguments in routine GammQ" << endl;
    return false;
  }
  if (x < (a+1.)){
    if (!this->GSER(&gamser, a, x, &gln)){
      cout << "CFits::GammQ: ERROR: GSER returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::GammQ: x < (a+1.): gamser = " << gamser << endl;
    #endif
    *D_Out = 1. - gamser;
    return true;
  }
  else{
    if (!this->GCF(&gammcf, a, x, &gln))
    {
      cout << "CFits::GammQ: ERROR: GCF returned false" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_FIT__
      cout << "CFits::GammQ: x < (a+1.): gammcf = " << gammcf << endl;
    #endif
    *D_Out = gammcf;
    return true;
  }
}

/**
 From Numerical Recipes in C, 2.6.
 Solves A*X=B for a vector X, where A is specified by the Arrays U[0...M-1][0...N-1], W[0...N-1], V[0...N-1][0...N-1] as returned by SVDCMP. M and N are the dimensions of A, and will be equal for square matrices. B[0...M-1] is the input right-hand side. X[0...N-1] is the output solution vector. No input quantities are destroyed, so the routine may be called sequentially with different B's.
  **/
bool CFits::SVBKSB(const Array<double, 2> &U, const Array<double, 1> &W, const Array<double, 2> &V, int M, int N, const Array<double, 1> &B, Array<double, 1> &X) const{
  int jj, j, i;
  double s;
  Array<double, 1> D_A1_Tmp(N);

  /// Calculate U^T B
  for (j = 0; j < N; j++){
    s=0.0;
    if (W(j)){/// Nonzero result only if W[j] is nonzero
      for (i = 0; i < M; i++){
        s += U(i,j) * B(i);
      }
      s /= W(j);/// This is divided by B[j]
    }
    D_A1_Tmp(j) = s;
  }

  /// Matrix multiply by V to get answer
  for (j = 0; j < N; j++){
    s = 0.0;
    for (jj = 0; jj < N; jj++){
      s += V(j, jj) * D_A1_Tmp(jj);
    }
    X(j) = s;
  }
  return true;
}

/** *****************************************************************************
    Given a matrix a[1..m][1..n], this routine computes its singular value
    decomposition, A = U.W.VT.  The matrix U replaces a on output.  The diagonal
    matrix of singular values W is output as a vector w[1..n].  The matrix V (not
    the transpose VT) is output as v[1..n][1..n].
*******************************************************************************/
bool CFits::SVDCMP(Array<double, 2> &A, int M, int N, Array<double, 1> &W, Array<double, 2> &V) const
{
  int flag,i,its,j,jj,k,l,nm;
  double anorm,c,f,g,h,s,scale,x,y,z;
  Array<double, 1> rv1(N);

  g=scale=anorm=0.0; /// Householder reduction to bidiagonal form
  for (i=0;i<N;i++) {
    l=i+1;
    rv1(i)=scale*g;
    g=s=scale=0.0;
    if (i < M) {
      for (k=i;k<M;k++){
        scale += fabs(A(k,i));
      }
      if (scale) {
        for (k=i;k<M;k++) {
          A(k,i) /= scale;
          s += A(k,i)*A(k,i);
        }
        f=A(i,i);
        g = -SIGN(sqrt(s),f);
        h=f*g-s;
        A(i,i)=f-g;
        for (j=l;j<N;j++) {
          for (s=0.0,k=i;k<M;k++){
            s += A(k,i)*A(k,j);
          }
          f=s/h;
          for (k=i;k<M;k++){
            A(k,j) += f*A(k,i);
          }
        }
        for (k=i;k<M;k++){
          A(k,i) *= scale;
        }
      }
    }
    W(i)=scale *g;
    g=s=scale=0.0;
    if (i < M && i != N-1) {
      for (k=l;k<N;k++){
        scale += fabs(A(i,k));
      }
      if (scale) {
        for (k=l;k<N;k++) {
          A(i,k) /= scale;
          s += A(i,k)*A(i,k);
        }
        f=A(i,l);
        g = -SIGN(sqrt(s),f);
        h=f*g-s;
        A(i,l)=f-g;
        for (k=l;k<N;k++){
          rv1(k)=A(i,k)/h;
        }
        for (j=l;j<M;j++) {
          for (s=0.0,k=l;k<N;k++) {
            s += A(j,k)*A(i,k);
          }
          for (k=l;k<N;k++){
            A(j,k) += s*rv1(k);
          }
        }
        for (k=l;k<N;k++){
          A(i,k) *= scale;
        }
      }
    }
    anorm = DMAX(anorm,(fabs(W(i))+fabs(rv1(i))));
  }
  for (i=N-1;i>=0;i--) { /* Accumulation of right-hand transformations. */
    if (i < N-1) {
      if (g) {
        for (j=l;j<N;j++) /* Double division to avoid possible underflow. */
          V(j,i)=(A(i,j)/A(i,l))/g;
        for (j=l;j<N;j++) {
          for (s=0.0,k=l;k<N;k++){
            s += A(i,k)*V(k,j);
          }
          for (k=l;k<N;k++){
            V(k,j) += s*V(k,i);
          }
        }
      }
      for (j=l;j<N;j++){
        V(i,j)=V(j,i)=0.0;
      }
    }
    V(i,i)=1.0;
    g=rv1(i);
    l=i;
  }
  for (i=IMIN(M,N)-1;i>=0;i--) { /* Accumulation of left-hand transformations. */
    l=i+1;
    g=W(i);
    for (j=l;j<N;j++){
      A(i,j)=0.0;
    }
    if (g) {
      g=1.0/g;
      for (j=l;j<N;j++) {
        for (s=0.0,k=l;k<M;k++){
          s += A(k,i)*A(k,j);
        }
        f=(s/A(i,i))*g;
        for (k=i;k<M;k++){
          A(k,j) += f*A(k,i);
        }
      }
      for (j=i;j<M;j++){
        A(j,i) *= g;
      }
    } else{
      for (j=i;j<M;j++){
        A(j,i)=0.0;
      }
    }
    ++A(i,i);
  }
  for (k=N-1;k>=0;k--) { /* Diagonalization of the bidiagonal form. */
    for (its=1;its<=30;its++) {
      flag=1;
      for (l=k;l>=0;l--) { /* Test for splitting. */
        nm=l-1; /* Note that rv1[1] is always zero. */
        if ((double)(fabs(rv1(l))+anorm) == anorm) {
          flag=0;
          break;
        }
        if ((double)(fabs(W(nm))+anorm) == anorm) break;
      }
      if (flag) {
        c=0.0; /* Cancellation of rv1[l], if l > 1. */
        s=1.0;
        for (i=l;i<=k;i++) {
          f=s*rv1(i);
          rv1(i)=c*rv1(i);
          if ((double)(fabs(f)+anorm) == anorm) break;
          g=W(i);
          h=Pythag(f,g);
          W(i)=h;
          h=1.0/h;
          c=g*h;
          s = -f*h;
          for (j=0;j<M;j++) {
            y=A(j,nm);
            z=A(j,i);
            A(j,nm)=y*c+z*s;
            A(j,i)=z*c-y*s;
          }
        }
      }
      z=W(k);
      if (l == k) { /* Convergence. */
        if (z < 0.0) { /* Singular value is made nonnegative. */
          W(k) = -z;
          for (j=0;j<N;j++){
            V(j,k) = -V(j,k);
          }
        }
        break;
      }
      if (its == 30)
        cout << "CFits::SVDCMP: no convergence in 30 svdcmp iterations" << endl;
      x=W(l); /* Shift from bottom 2-by-2 minor. */
      nm=k-1;
      y=W(nm);
      g=rv1(nm);
      h=rv1(k);
      f=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
      g=Pythag(f,1.0);
      f=((x-z)*(x+z)+h*((y/(f+SIGN(g,f)))-h))/x;
      c=s=1.0; /* Next QR transformation: */
      for (j=l;j<=nm;j++) {
        i = j+1;
        g = rv1(i);
        y = W(i);
        h = s*g;
        g = c*g;
        z = Pythag(f,h);
        rv1(j) = z;
        c = f/z;
        s = h/z;
        f = x*c+g*s;
        g = g*c-x*s;
        h = y*s;
        y *= c;
        for (jj=0;jj<N;jj++) {
          x = V(jj,j);
          z = V(jj,i);
          V(jj,j) = x*c+z*s;
          V(jj,i) = z*c-x*s;
        }
        z = Pythag(f,h);
        W(j) = z; /* Rotation can be arbitrary if z = 0. */
        if (z) {
          z = 1.0/z;
          c = f*z;
          s = h*z;
        }
        f = c*g+s*y;
        x = c*y-s*g;
        for (jj=0;jj<M;jj++) {
          y = A(jj,j);
          z = A(jj,i);
          A(jj,j) = y*c+z*s;
          A(jj,i) = z*c-y*s;
        }
      }
      rv1(l) = 0.0;
      rv1(k) = f;
      W(k) = x;
    }
  }
  return true;
}


/**
  From Numerical Recipes in C
  Computes sqrt(a^2 + b^2) without distructive underflow or overflow
 **/
double CFits::Pythag(double a, double b) const{
  double absa, absb;
  absa = fabs(a);
  absb = fabs(b);
  if (absa > absb)
    return absa * sqrt(1.0 + pow2(absb / absa));
  return (absb == 0.0 ? 0.0 : absb * sqrt(1.0 + pow2(absa / absb)));
}


/**
  From Numerical Recipes in C $15.4
  Given a set of data points X[0..n-1], Y[0..n-1] with individual standard deviations Sig[0..n-1], use Chi^2 minimization to determine the coefficients a[0..ma-1] of the fitting function y = sum(a_i * aFunc_i(X), i). Here we solve the fitting equations using singular value decomposition of the n by ma matrix, as in $2.6. Arrays U[0..n-1][0..ma-1], V[0..ma-1][0..ma-1], and W[0..ma] provide workspace on input; on output they define the singular value decomposition, and can be used to obtain the covariance matrix. The program returns values for the ma fit parameters A, and Chi^2, ChiSq. The user supplies a routine Funcs(X, AFunc, ma) that returns the ma basis functions evaluated at x = X in the array AFunc[0..ma].
  **/
bool CFits::SVDFit(const Array<double, 1> &X,
                   const Array<double, 1> &Y,
                   const Array<double, 1> &Sig,
                   Array<double, 1> &A,
                   Array<double, 2> &U,
                   Array<double, 2> &V,
                   Array<double, 1> &W,
                   Array<double, 1> &ChiSq,
                   void (*Funcs)(double, Array<double, 1>, int)) const{
  double TOL = 1.0e-5; /// Default value for single precision and variables scaled to order unity
  int i,j;
  int ndata = X.size();
  int ma = A.size();
  double D_WMax, D_Tmp, D_Thresh, D_Sum;
  Array<double, 1> D_A1_B(ndata);
  Array<double, 1> D_A1_AFunc(ma);
  for (i = 0; i < ndata; i++){      /// Accumulate coefficients of the fitting matrix
    (*Funcs)(X(i), D_A1_AFunc, ma);
    D_Tmp = 1.0 / Sig(i);
    for (j = 0; j < ma; j++){
      U(i,j) = D_A1_AFunc(j) * D_Tmp;
    }
    D_A1_B(i) = Y(i) * D_Tmp;
  }
  if (!this->SVDCMP(U, ndata, ma, W, V)){   /// Singular Value Decomposition
    cout << "CFits::SVDFit: ERROR: SVDCMP returned FALSE" << endl;
    return false;
  }
  D_WMax = 0.0;             /// Edit the singular values, given TOL,
  for (j = 0; j < ma; j++){ ///  between here...
    if (W(j) < D_WMax)
      D_WMax = W(j);
  }
  D_Thresh = TOL * D_WMax;
  for (j = 0; j < ma; j++){ ///  between here...
    if (W(j) < D_Thresh)
      W(j) = 0.0;           /// ... and here
  }
  if (!this->SVBKSB(U, W, V, ndata, ma, D_A1_B, A)){
    cout << "CFits::SVDFit: ERROR: SVBKSB returned FALSE" << endl;
    return false;
  }
  ChiSq = 0.0; /// Evaluate Chi^2
  for (i = 0; i < ndata; i++){
    (*Funcs)(X(i), D_A1_AFunc, ma);
    for (D_Sum = 0.0, j = 0; j < ma; j++){
      D_Sum += A(j) * D_A1_AFunc(j);
    }
    ChiSq += (D_Tmp = (Y(i) - D_Sum) / Sig(i), D_Tmp * D_Tmp);
  }
  return true;
}

//void CFits::Funcs(double X, Array<double, 1> &P, int n){
  /// TODO: Fill in function
//  return;
//}

bool CFits::ReadFileToStrArr(const CString &CS_FileName_In,
                             Array<CString, 2> &CS_A2_Out,
                             const CString &CS_Delimiter) const{
  CString CS("");
  return CS.ReadFileToStrArr(CS_FileName_In, CS_A2_Out, CS_Delimiter);
/*
  if (!this->FileAccess(CS_FileName_In)){
    cout << "CFits::ReadFileToStrArr: ERROR: Access(CS_FileName_In) returned FALSE" << endl;
    return false;
  }
  int I_NLines = this->CountLines(CS_FileName_In);
  int I_NCols = this->CountCols(CS_FileName_In, CS_Delimiter);
  cout << "CFits::ReadFileToStrArr: I_NLines = " << I_NLines << ", I_NCols = " << I_NCols << endl;
  CString templine(" ");
  FILE *ffile;
  long nelements;
  char oneword[255];
  char fname[255];
  char *line;
  strcpy(fname, CS_FileName_In.Get());
  CString CS_Line;

  CS_A2_Out.resize(I_NLines, I_NCols);

#ifdef __DEBUG_FITS_READFILETOSTRARR__
  printf("CFits::ReadFileToStrArr: function started\n");
#endif
  ffile = fopen(fname, "r");
  if (ffile == NULL)
  {
    cout << "CFits::ReadFileToStrArr: Failed to open file fname (=<" << fname << ">)" << endl;
#ifdef __DEBUG_FITS_READFILETOSTRARR__
    (*P_OFS_Log) << "CFits::ReadFileToStrArr: Failed to open file fname (=<" << fname << ">)" << endl;
    return false;
#endif
    //return 0;
  }
#ifdef __DEBUG_FITS_READFILETOSTRARR__
  printf("CFits::ReadFileToStrArr: File fname(=<%s>) opened\n", fname);
#endif

  int I_Row = 0;
  int I_Col = 0;
  int I_Pos;
  CString *P_CS_Temp;
  char *chr_cstring;
  do
  {
    line = fgets(oneword, 255, ffile);
    if (line != NULL)
    {
      if (!CS_Line.Set(line)){
        cout << "CFits::ReadFileToStrArr: ERROR: CS_Line.Set(line) returned FALSE." << endl;
        return false;
      }
      I_Pos = CS_Line.CharPos('\n');
#ifdef __DEBUG_FITS_READFILETOSTRARR__
      cout << "CFits::ReadFileToStrArr: I_Row = " << I_Row << ": I_Pos(tempchar) set to " << I_Pos << endl;
#endif
      if (I_Pos >= 0){
        chr_cstring = CS_Line.Get();
        chr_cstring[I_Pos] = '\0';
        CS_Line = CString(chr_cstring);
#ifdef __DEBUG_FITS_READFILETOSTRARR__
        cout << "CFits::ReadFileToStrArr: I_Row = " << I_Row << ": CS_Line set to " << CS_Line << endl;
#endif
      }
      I_Pos = CS_Line.StrPos(CString("#"));
      if (I_Pos != 0){
        I_Col = 0;
        while (I_Pos = CS_Line.StrPos(CS_Delimiter) >= 0){
          I_Pos = CS_Line.StrPos(CS_Delimiter);
#ifdef __DEBUG_FITS_READFILETOSTRARR__
          cout << "CFits::ReadFileToStrArr: while: I_Pos set to " << I_Pos << endl;
#endif
          P_CS_Temp = CS_Line.SubString(0,I_Pos-1);
#ifdef __DEBUG_FITS_READFILETOSTRARR__
          cout << "CFits::ReadFileToStrArr: while: P_CS_Temp set to " << *P_CS_Temp << endl;
#endif
          CS_A2_Out(I_Row, I_Col) = (*P_CS_Temp);//)){
#ifdef __DEBUG_FITS_READFILETOSTRARR__
          cout << "CFits::ReadFileToStrArr: CS_A2_Out(I_Row, I_Col) set to '" << *P_CS_Temp << "'" << endl;
#endif
          delete(P_CS_Temp);

          P_CS_Temp = CS_Line.SubString(CS_Line.StrPos(CS_Delimiter)+1);
#ifdef __DEBUG_FITS_READFILETOSTRARR__
          cout << "CFits::ReadFileToStrArr: while: P_CS_Temp set to " << *P_CS_Temp << endl;
#endif
          P_CS_Temp->TrimChar(CS_Delimiter.Get(),2);
#ifdef __DEBUG_FITS_READFILETOSTRARR__
          cout << "CFits::ReadFileToStrArr: while: P_CS_Temp set to " << *P_CS_Temp << endl;
#endif
          CS_Line = *P_CS_Temp;
#ifdef __DEBUG_FITS_READFILETOSTRARR__
          cout << "CFits::ReadFileToStrArr: while: CS_Line set to " << CS_Line << endl;
#endif
          delete(P_CS_Temp);
          I_Col++;
        }
#ifdef __DEBUG_FITS_READFILETOSTRARR__
        cout << "CFits::ReadFileToStrArr: end of while: I_Row = " << I_Row << ", I_Col = " << I_Col << ", CS_Line set to " << CS_Line << endl;
#endif
        CS_A2_Out(I_Row, I_Col) = CS_Line;//))){
//          cout << "CFits::ReadFileToStrArr: ERROR: CS_A2_Out.(I_Row, I_Col).Set(" << *P_CS_Temp << ") returned FALSE." << endl;
//          return false;
//        }
      }
      I_Row++;
    }
  }
  while (line != NULL);
#ifdef __DEBUG_FITS_READFILETOSTRARR__
  printf("CFits::ReadFileToStrArr: File fname(=<%s>) contains %d data lines\n",fname,I_Row);
#endif
  // --- close input file
  fclose(ffile);
#ifdef __DEBUG_FITS_READFILETOSTRARR__
  printf("CFits::ReadFileToStrArr: File fname (=<%s>) closed\n", fname);
#endif
  return true;
  */
}

bool CFits::ReadFileToDblArr(const CString &CS_FileName_In,
                             Array<double, 2> &D_A2_Out,
                             const CString &CS_Delimiter) const{
  CString CS("");
  return CS.ReadFileToDblArr(CS_FileName_In, D_A2_Out, CS_Delimiter);
  /**
  Array<CString, 2> CS_A2_Arr(2,2);
  if (!this->ReadFileToStrArr(CS_FileName_In, CS_A2_Arr, CS_Delimiter)){
    cout << "CFits::ReadFileToDblArr: ERROR: ReadFileToStrArr returned FALSE" << endl;
    return false;
  }
  D_A2_Out.resize(CS_A2_Arr.rows(), CS_A2_Arr.cols());
  for (int i_row=0; i_row<CS_A2_Arr.rows(); i_row++){
    for (int i_col=0; i_col<CS_A2_Arr.cols(); i_col++){
      D_A2_Out(i_row, i_col) = (CS_A2_Arr(i_row, i_col)).AToD();
    }
  }
  return true;
  */
}

/** *******************************************************/

bool CFits::ReadFileLinesToStrArr(const CString &CS_FileName_In,
                                  Array<CString, 1> &CS_A1_Out) const{
  CString CS("");
  return CS.ReadFileLinesToStrArr(CS_FileName_In, CS_A1_Out);
/**
  if (!this->FileAccess(CS_FileName_In)){
    cout << "CFits::ReadFileLinesToStrArr: ERROR: Access(CS_FileName_In) returned FALSE" << endl;
    return false;
  }
  int I_NLines = this->CountLines(CS_FileName_In);
  cout << "CFits::ReadFileLinesToStrArr: I_NLines = " << I_NLines << endl;
  CString templine(" ");
  FILE *ffile;
  long nelements;
  char oneword[255];
  char fname[255];
  char *line;
  strcpy(fname, CS_FileName_In.Get());
  CString CS_Line;

  CS_A1_Out.resize(I_NLines);

  #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
  cout << "CFits::ReadFileLinesToStrArr: function started" << endl;;
  #endif
  ffile = fopen(fname, "r");
  if (ffile == NULL)
  {
    cout << "CFits::ReadFileLinesToStrArr: Failed to open file fname (=<" << fname << ">)" << endl;
    #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
      (*P_OFS_Log) << "CFits::ReadFileLinesToStrArr: Failed to open file fname (=<" << fname << ">)" << endl;
    #endif
    return false;
    //return 0;
  }
  #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
    cout << "CFits::ReadFileLinesToStrArr: File fname(=<" << fname << ">) opened" << endl;
    cout << "CFits::ReadFileLinesToStrArr: 1. Starting do loop" << endl;
  #endif

  int I_Row = 0;
  int I_Pos;
  CString *P_CS_Temp;
  char *chr_cstring;
  cout << "CFits::ReadFileLinesToStrArr: 2. Starting do loop" << endl;
  do
  {
    line = fgets(oneword, 255, ffile);
    if (line != NULL)
    {
      #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
      cout << "CFits::ReadFileLinesToStrArr: I_Row = " << I_Row << ": line set to " << line << endl;
      #endif
      if (!CS_Line.Set(line)){
        cout << "CFits::ReadFileLinesToStrArr: ERROR: CS_Line.Set(line) returned FALSE." << endl;
        return false;
      }
      I_Pos = CS_Line.CharPos('\n');
      #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
        cout << "CFits::ReadFileLinesToStrArr: I_Row = " << I_Row << ": CS_Line=" << CS_Line << ": I_Pos('\n') set to " << I_Pos << endl;
      #endif
      if (I_Pos >= 0){
        chr_cstring = CS_Line.Get();
        chr_cstring[I_Pos] = '\0';
        CS_Line = CString(chr_cstring);
        #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
          cout << "CFits::ReadFileLinesToStrArr: I_Row = " << I_Row << ": CS_Line set to " << CS_Line << endl;
        #endif
      }
      I_Pos = CS_Line.StrPos(CString("#"));
      if (I_Pos != 0){
        CS_A1_Out(I_Row) = CS_Line;//)){
        #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
          cout << "CFits::ReadFileLinesToStrArr: CS_A1_Out(I_Row=" << I_Row << ") set to '" << CS_A1_Out(I_Row) << "'" << endl;
        #endif
      }
      I_Row++;
    }
  }while (line != NULL);
  #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
    cout << "CFits::ReadFileLinesToStrArr: File fname(=<" << fname << ">) contains " << I_Row << " data lines" << endl;
  #endif
  // --- close input file
  fclose(ffile);
  #ifdef __DEBUG_FITS_READFILELINESTOSTRARR__
    cout << "CFits::ReadFileLinesToStrArr: File fname (=<" << fname << ">) closed";
  #endif
  CS_A1_Out.resizeAndPreserve(I_Row);
  return true;
  **/
}

bool CFits::CalculateScatteredLight(int I_FittingOrder_In, int I_BoxCarWidth_In){
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::CalculateScatteredLight: ERROR: Trace functions not calculated => Returning FALSE" << endl;
    return false;
  }

  /// Set apertures to zero
  for (int i_ap = 0; i_ap < this->I_NApertures; i_ap++){
    #ifdef __DEBUG_FITS_CALCSCATTER__
      cout << "CFits::CalculateScatteredLight: i_ap = " << i_ap << ": P_D_A1_YCenter(" << i_ap << ") = " << (*this->P_D_A1_YCenter)(i_ap) << endl;
      cout << "CFits::CalculateScatteredLight: i_ap = " << i_ap << ": P_D_A1_YLow(" << i_ap << ") = " << (*this->P_D_A1_YLow)(i_ap) << endl;
      cout << "CFits::CalculateScatteredLight: i_ap = " << i_ap << ": P_D_A1_YHigh(" << i_ap << ") = " << (*this->P_D_A1_YHigh)(i_ap) << endl;
    #endif
    for (int i_row = int((*this->P_D_A1_YCenter)(i_ap)+(*this->P_D_A1_YLow)(i_ap)); i_row <= int((*this->P_D_A1_YCenter)(i_ap)+(*this->P_D_A1_YHigh)(i_ap)); i_row++){
      #ifdef __DEBUG_FITS_CALCSCATTER__
        cout << "CFits::CalculateScatteredLight: i_ap = " << i_ap << ": P_D_A2_XCenters(" << i_ap << ", " << i_row << ") = " << (*this->P_D_A2_XCenters)(i_ap, i_row) << endl;
        cout << "CFits::CalculateScatteredLight: i_ap = " << i_ap << ": P_D_A1_XMin(" << i_ap << ") = " << (*this->P_D_A1_XMin)(i_ap) << endl;
        cout << "CFits::CalculateScatteredLight: i_ap = " << i_ap << ": P_D_A1_XMax(" << i_ap << ") = " << (*this->P_D_A1_XMax)(i_ap) << endl;
      #endif
      for (int i_col = int((*this->P_D_A2_XCenters)(i_ap, i_row)+(*this->P_D_A1_XMin)(i_ap)); i_col <= int((*this->P_D_A2_XCenters)(i_ap, i_row)+(*this->P_D_A1_XMax)(i_ap)); i_col++){
        if (i_row >=0 && i_row < this->NRows && i_col >= 0 && i_col < this->NCols){
          (*this->P_D_A2_PixArray)(i_row, i_col) = 0.;
          #ifdef __DEBUG_FITS_CALCSCATTER__
            cout << "CFits::CalculateScatteredLight: i_ap = " << i_ap << ": P_D_A2_PixArray(" << i_row << ", " << i_col << ") set to zero" << endl;
          #endif
        }
      }
    }
//    if (i_ap == 2)
//      return false;
  }
//  #ifdef __DEBUG_FITS_CALCSCATTER__
    CString *P_TempString = this->P_CS_FileName->SubString(0,this->P_CS_FileName->LastStrPos(CString("."))-1);
    (*P_TempString) = (*P_TempString)+CString("-aps.fits");
    this->SetFileName(*P_TempString);
    this->WriteArray();
    delete(P_TempString);
//  #endif

  /// Fit scattered light for each row
  Array<int, 1> I_A1_Where(this->NCols);
  Array<int, 1> I_A1_IndArr(1);
  Array<double, 1> D_A1_IndArr(1);
  Array<double, 1> D_A1_NonZero(1);
  Array<double, 1> *P_D_A1_DInd;// = this->DIndGenArr(this->NCols);
  Array<double, 1> D_A1_MeasureErrors(1);
  Array<double, 1> *P_D_A1_Coeffs = new Array<double, 1>(I_FittingOrder_In+1);
  Array<double, 2> D_A2_Fit_Rows(this->NRows, this->NCols);
  D_A2_Fit_Rows = 0.;
  Array<double, 2> D_A2_Fit_Cols(this->NRows, this->NCols);
  D_A2_Fit_Cols = 0.;
  Array<double, 2> D_A2_Fit_Rows_Cols(this->NRows, this->NCols);
  D_A2_Fit_Rows_Cols = 0.;
  Array<double, 2> D_A2_Fit_Cols_Rows(this->NRows, this->NCols);
  D_A2_Fit_Cols_Rows = 0.;
  Array<double, 2> D_A2_Fit(this->NRows, this->NCols);
  Array<double, 1> *P_D_A1_Fit = new Array<double, 1>(this->NCols);
  int I_NInd_Out;
  int I_FittingOrder = 4;
  int I_LoopEnd;

  /**        CHISQ=chisq, $
  COVAR=covar, $
  DOUBLE=double, $
  MEASURE_ERRORS=measure_errors, $
  SIGMA=sigma, $
  STATUS=status, $
  YBAND=yband, $
  YERROR=yerror, $
  YFIT=yfit
  ;**/
//  Array<CString, 1> CS_A1_KeyWords_Fit(1);
//  void **PP_Args_Fit = (void**)malloc(sizeof(void*) * 1);
//  CS_A1_KeyWords_Fit(0) = CString("MEASURE_ERRORS");

  Array<double, 1> D_A1_Y(1);

  /// Fist run for rows, 2nd run for columns
  for (int i=0; i<4; i++){
    if (i==0){
      I_LoopEnd = this->NRows;
      P_D_A1_DInd = this->DIndGenArr(this->NCols);
    }
    else if (i == 1){
      I_LoopEnd = this->NCols;
      delete P_D_A1_DInd;
      P_D_A1_DInd = this->DIndGenArr(this->NRows);
    }
    else if (i == 2){
      I_LoopEnd = this->NRows;
      delete P_D_A1_DInd;
      P_D_A1_DInd = this->DIndGenArr(this->NCols);
    }
    else{
      I_LoopEnd = this->NCols;
      delete P_D_A1_DInd;
      P_D_A1_DInd = this->DIndGenArr(this->NRows);
    }
    for (int i_row=0; i_row < I_LoopEnd; i_row++){
      #ifdef __DEBUG_FITS_CALCSCATTER__
        cout << "CFits::CalculateScatteredLight: i = " << i << ": running i_row = " << i_row << endl;
      #endif
      D_A1_Y.resize(I_LoopEnd);
      if (i==0){
        D_A1_Y = (*this->P_D_A2_PixArray)(i_row, Range::all());
      }
      else if (i == 1){
        D_A1_Y = (*this->P_D_A2_PixArray)(Range::all(), i_row);
      }
      else if (i == 2){
        D_A1_Y = D_A2_Fit_Cols(i_row, Range::all());
      }
      else{
        D_A1_Y = D_A2_Fit_Rows(Range::all(), i_row);
      }
      /// Find pixels with non-zero values
      I_A1_Where = where(fabs(D_A1_Y) < 0.00001, 0, 1);
      #ifdef __DEBUG_FITS_CALCSCATTER__
        cout << "CFits::CalculateScatteredLight: I_A1_Where = " << I_A1_Where << endl;
      #endif
      if (!this->GetIndex(I_A1_Where, I_NInd_Out, I_A1_IndArr)){
        cout << "CFits::CalculateScatteredLight: ERROR: this->GetIndex returned FALSE => Returning FALSE";
        return false;
      }
      #ifdef __DEBUG_FITS_CALCSCATTER__
        cout << "CFits::CalculateScatteredLight: I_A1_IndArr = " << I_A1_IndArr << endl;
      #endif
      D_A1_IndArr.resize(I_A1_IndArr.size());
      for (int jj=0; jj<I_A1_IndArr.size(); jj++)
        D_A1_IndArr(jj) = double(I_A1_IndArr(jj));
      if (I_NInd_Out > I_FittingOrder){
        #ifdef __DEBUG_FITS_CALCSCATTER__
          cout << "CFits::CalculateScatteredLight: I_NInd_Out = " << I_NInd_Out << endl;
          cout << "CFits::CalculateScatteredLight: D_A1_IndArr = " << D_A1_IndArr << endl;
        #endif
        D_A1_NonZero.resize(I_NInd_Out);
        if (!this->GetSubArrCopy(D_A1_Y,
                                 I_A1_IndArr,
                                 D_A1_NonZero)){
          cout << "CFits::CalculateScatteredLight: ERROR: this->GetSubArrCopy returned FALSE => Returning FALSE";
          return false;
        }
//        D_A1_MeasureErrors.resize(I_NInd_Out);
//        D_A1_MeasureErrors = sqrt(D_A1_NonZero);
        //PP_Args_Fit[0] = &D_A1_MeasureErrors;
        #ifdef __DEBUG_FITS_CALCSCATTER__
          cout << "CFits::CalculateScatteredLight: D_A1_IndArr = " << D_A1_IndArr << ", D_A1_NonZero = " << D_A1_NonZero << endl;
          //cout << "CFits::CalculateScatteredLight: D_A1_MeasureErrors = " << D_A1_MeasureErrors << endl;
        #endif
        if (!this->PolyFit(D_A1_IndArr,
                           D_A1_NonZero,
                           I_FittingOrder,
//                           CS_A1_KeyWords_Fit,
//                           PP_Args_Fit,
                           P_D_A1_Coeffs)){
          cout << "CFits::CalculateScatteredLight: ERROR: this->PolyFit returned FALSE => Returning FALSE";
          return false;
        }

        /// Fit row/column and populate fit array
        P_D_A1_Fit = this->Poly(*P_D_A1_DInd, *P_D_A1_Coeffs);
        if (i==0){
          D_A2_Fit_Rows(i_row, Range::all()) = (*P_D_A1_Fit);
        }
        else if (i == 1){
          D_A2_Fit_Cols(Range::all(), i_row) = (*P_D_A1_Fit);
        }
        else if (i == 2){
          D_A2_Fit_Cols_Rows(i_row, Range::all()) = (*P_D_A1_Fit);
        }
        else{
          D_A2_Fit_Rows_Cols(Range::all(), i_row) = (*P_D_A1_Fit);
        }
      }
    }
//    #ifdef __DEBUG_FITS_CALCSCATTER__
    if (i==0)
      this->WriteFits(&D_A2_Fit_Rows, CString("test/ScatteredLight_Rows.fits"));
    if (i==1)
      this->WriteFits(&D_A2_Fit_Cols, CString("test/ScatteredLight_Cols.fits"));
    if (i==2)
      this->WriteFits(&D_A2_Fit_Cols_Rows, CString("test/ScatteredLight_Cols_Rows.fits"));
    if (i==3)
      this->WriteFits(&D_A2_Fit_Rows_Cols, CString("test/ScatteredLight_Rows_Cols.fits"));
//    #endif

    /// Box-car filter Fit array
    #ifdef __DEBUG_FITS_CALCSCATTER__
      cout << "CFits::CalculateScatteredLight: i = " << i << ": Starting box-car smoothing" << endl;
    #endif
    if (i==0){
      D_A2_Fit = D_A2_Fit_Rows;
    }
    else if (i == 1){
      D_A2_Fit = D_A2_Fit_Cols;
    }
    else if (i == 2){
      D_A2_Fit = D_A2_Fit_Cols_Rows;
    }
    else{
      D_A2_Fit = D_A2_Fit_Rows_Cols;
    }
    if (!this->BoxCarFilter(D_A2_Fit, I_BoxCarWidth_In, true)){
      cout << "CFits::CalculateScatteredLight: i = " << i << ": Error: this->BoxCarFilter returned FALSE => Returning FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_CALCSCATTER__
      cout << "CFits::CalculateScatteredLight: D_A2_Fit(10,10) = " << D_A2_Fit(10,10) << endl;
//      return false;
    #endif
    if (i == 0){
      D_A2_Fit_Rows = D_A2_Fit;
    }
    else if (i == 1){
      D_A2_Fit_Cols = D_A2_Fit;
    }
    else if (i == 2){
      D_A2_Fit_Cols_Rows = D_A2_Fit;
    }
    else{
      D_A2_Fit_Rows_Cols = D_A2_Fit;
    }
//    #ifdef __DEBUG_FITS_CALCSCATTER__
      if (i==0)
        this->WriteFits(&D_A2_Fit_Rows, CString("test/ScatteredLight_Rows_Box.fits"));
      if (i==1)
        this->WriteFits(&D_A2_Fit_Cols, CString("test/ScatteredLight_Cols_Box.fits"));
      if (i==2)
        this->WriteFits(&D_A2_Fit_Cols_Rows, CString("test/ScatteredLight_Cols_Rows_Box.fits"));
      if (i==3)
        this->WriteFits(&D_A2_Fit_Rows_Cols, CString("test/ScatteredLight_Rows_Cols_Box.fits"));
//    #endif
//    if (i == 2)
//      return false;
  }

  /// take median of all scattered light images as real scattered light, use another box-car filter, and subtract from this->P_D_A2_PixArray
  Array<double, 2> D_A2_ScatteredLight(this->NRows, this->NCols);
  Array<double, 1> D_A1_PixScatter(4);
  for (int i_row=0; i_row < this->NRows; i_row++){
    for (int i_col=0; i_col < this->NCols; i_col++){
      D_A1_PixScatter(0) = D_A2_Fit_Rows(i_row, i_col);
      D_A1_PixScatter(1) = D_A2_Fit_Cols(i_row, i_col);
      D_A1_PixScatter(2) = D_A2_Fit_Rows_Cols(i_row, i_col);
      D_A1_PixScatter(3) = D_A2_Fit_Cols_Rows(i_row, i_col);
      D_A2_ScatteredLight(i_row, i_col) = this->Median(D_A1_PixScatter);
    }
  }
  #ifdef __DEBUG_FITS_CALCSCATTER__
    this->WriteFits(&D_A2_ScatteredLight, CString("test/ScatteredLight_out.fits"));
  #endif
  for (int i=0; i<2; i++){
    if (!this->BoxCarFilter(D_A2_ScatteredLight, I_BoxCarWidth_In, true)){
      cout << "CFits::CalculateScatteredLight: Error: this->BoxCarFilter returned FALSE => Returning FALSE" << endl;
      return false;
    }
  }
//  #ifdef __DEBUG_FITS_CALCSCATTER__
    this->WriteFits(&D_A2_ScatteredLight, CString("test/ScatteredLight_out_box.fits"));
//  #endif

  (*this->P_D_A2_PixArray) = (*this->P_D_A2_PixArray) - D_A2_ScatteredLight;

  delete(P_D_A1_DInd);
  delete(P_D_A1_Coeffs);
  delete(P_D_A1_Fit);

  return true;
}

bool CFits::BoxCarFilter(Array<double, 2> D_A2_Data_InOut,
                         int I_BoxCarWidth_In,
                         bool B_IgnoreZeros) const{
  #ifdef __DEBUG_FITS_BOXCARFILTER__
    cout << "CFits::BoxCarFilter: I_BoxCarWidth_In = " << I_BoxCarWidth_In << endl;
  #endif
  if ((double(I_BoxCarWidth_In)/2.) - (int(I_BoxCarWidth_In/2.)) < 0.4)
    I_BoxCarWidth_In++;
  int I_NRows = D_A2_Data_InOut.rows();
  int I_NCols = D_A2_Data_InOut.cols();
  int I_Row_Start, I_Row_End, I_Col_Start, I_Col_End;
  Array<double, 2> D_A2_Smoothed(I_NRows, I_NCols);
  Array<double, 2> D_A2_ToSmooth(1,1);
  int I_Width_Half = int(I_BoxCarWidth_In/2.);
  for (int i_row=0; i_row<I_NRows; i_row++){
    #ifdef __DEBUG_FITS_BOXCARFILTER__
      cout << "CFits::BoxCarFilter: i_row = " << i_row << ": I_Width_Half = " << I_Width_Half << endl;
    #endif
    for (int i_col=0; i_col<I_NCols; i_col++){
      if (i_row < int(I_BoxCarWidth_In/2.)){
        I_Row_Start = 0;
        I_Row_End = i_row + I_Width_Half;
      }
      else if (i_row > I_NRows-I_Width_Half-1){
        I_Row_Start = i_row - I_Width_Half;
        I_Row_End = I_NRows - 1;
      }
      else{
        I_Row_Start = i_row - I_Width_Half;
        I_Row_End = i_row + I_Width_Half;
      }
      if (i_col < int(I_BoxCarWidth_In/2.)){
        I_Col_Start = 0;
        I_Col_End = i_col + I_Width_Half;
      }
      else if (i_col > I_NCols-I_Width_Half-1){
        I_Col_Start = i_col - I_Width_Half;
        I_Col_End = I_NCols - 1;
      }
      else{
        I_Col_Start = i_col - I_Width_Half;
        I_Col_End = i_col + I_Width_Half;
      }
      #ifdef __DEBUG_FITS_BOXCARFILTER__
        cout << "CFits::BoxCarFilter: i_row = " << i_row << ": i_col = " << i_col << ": I_Row_Start = " << I_Row_Start << ", I_Row_End = " << I_Row_End << ", I_Col_Start = " << I_Col_Start << ", I_Col_End = " << I_Col_End << endl;
//        if (i_row > 3)
//          return false;
      #endif
      D_A2_ToSmooth.resize(I_Row_End-I_Row_Start+1, I_Col_End-I_Col_Start+1);
      D_A2_ToSmooth = D_A2_Data_InOut(Range(I_Row_Start, I_Row_End), Range(I_Col_Start, I_Col_End));
      #ifdef __DEBUG_FITS_BOXCARFILTER__
        cout << "CFits::BoxCarFilter: D_A2_ToSmooth = " << D_A2_ToSmooth << endl;
      #endif
      D_A2_Smoothed(i_row, i_col) = this->Median(D_A2_ToSmooth, B_IgnoreZeros);
//      #ifdef __DEBUG_FITS_BOXCARFILTER__
        cout << "CFits::BoxCarFilter: D_A2_Smoothed(" << i_row << ", " << i_col << ") = " << D_A2_Smoothed(i_row, i_col) << endl;
//      #endif
    }
    #ifdef __DEBUG_FITS_BOXCARFILTER__
      cout << "CFits::BoxCarFilter: End: I_BoxCarWidth_In = " << I_BoxCarWidth_In << endl;
//      return false;
    #endif
  }
  #ifdef __DEBUG_FITS_BOXCARFILTER__
    cout << "CFits::BoxCarFilter: End: I_BoxCarWidth_In = " << I_BoxCarWidth_In << endl;
    cout << "CFits::BoxCarFilter: End: D_A2_Data_InOut(10,10) = " << D_A2_Data_InOut(10,10) << endl;
    cout << "CFits::BoxCarFilter: End: D_A2_Smoothed(10,10) = " << D_A2_Smoothed(10,10) << endl;
    //    return false;
  #endif
  D_A2_Data_InOut = D_A2_Smoothed;
  #ifdef __DEBUG_FITS_BOXCARFILTER__
    cout << "CFits::BoxCarFilter: End: D_A2_Data_InOut(10,10) = " << D_A2_Data_InOut(10,10) << endl;
  #endif
  return true;
}

bool CFits::Set_ApertureDataToZero(const int I_PlusNPixels_X, const int I_PlusNPixels_Y){
  return this->Set_ApertureDataToZero((*this->P_D_A2_PixArray), I_PlusNPixels_X, I_PlusNPixels_Y);
}

bool CFits::Set_ApertureDataToZero(Array<double, 2> &D_A2_InOut, const int I_PlusNPixels_X, const int I_PlusNPixels_Y) const{
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::Set_ApertureDataToZero: ERROR: Trace functions not calculated!" << endl;
    return false;
  }
  int i_row_start, i_row_end, i_col_start, i_col_end;
  /// Set apertures to zero
  for (int i_ap = 0; i_ap < this->I_NApertures; i_ap++){
    #ifdef __DEBUG_FITS_CALCSCATTER__
      cout << "CFits::Set_ApertureDataToZero: i_ap = " << i_ap << ": P_D_A1_YCenter(" << i_ap << ") = " << (*this->P_D_A1_YCenter)(i_ap) << endl;
      cout << "CFits::Set_ApertureDataToZero: i_ap = " << i_ap << ": P_D_A1_YLow(" << i_ap << ") = " << (*this->P_D_A1_YLow)(i_ap) << endl;
      cout << "CFits::Set_ApertureDataToZero: i_ap = " << i_ap << ": P_D_A1_YHigh(" << i_ap << ") = " << (*this->P_D_A1_YHigh)(i_ap) << endl;
    #endif
    i_row_start = int((*this->P_D_A1_YCenter)(i_ap)+(*this->P_D_A1_YLow)(i_ap)) - I_PlusNPixels_Y;
    i_row_end = int((*this->P_D_A1_YCenter)(i_ap)+(*this->P_D_A1_YHigh)(i_ap)) + I_PlusNPixels_Y;
    if (i_row_start < 0)
      i_row_start = 0;
    if (i_row_end >= this->NRows)
      i_row_end = this->NRows-1;
    for (int i_row = i_row_start; i_row <= i_row_end; i_row++){
      #ifdef __DEBUG_FITS_CALCSCATTER__
        cout << "CFits::Set_ApertureDataToZero: i_ap = " << i_ap << ": P_D_A2_XCenters(" << i_ap << ", " << i_row << ") = " << (*this->P_D_A2_XCenters)(i_ap, i_row) << endl;
        cout << "CFits::CalculateScatteredYight: i_ap = " << i_ap << ": P_D_A1_XMin(" << i_ap << ") = " << (*this->P_D_A1_XMin)(i_ap) << endl;
        cout << "CFits::Set_ApertureDataToZero: i_ap = " << i_ap << ": P_D_A1_XMax(" << i_ap << ") = " << (*this->P_D_A1_XMax)(i_ap) << endl;
      #endif
      i_col_start = int((*this->P_D_A2_XCenters)(i_ap, i_row)+(*this->P_D_A1_XMin)(i_ap)) - I_PlusNPixels_X;
      i_col_end = int((*this->P_D_A2_XCenters)(i_ap, i_row)+(*this->P_D_A1_XMax)(i_ap)) + I_PlusNPixels_X;
      if (i_col_start < 0)
	i_col_start = 0;
      if (i_col_end >= this->NCols)
	i_col_end = this->NCols-1;
      for (int i_col = i_col_start; i_col <= i_col_end; i_col++){
//        if (i_row >=0 && i_row < this->NRows && i_col >= 0 && i_col < this->NCols){
          D_A2_InOut(i_row, i_col) = 0.;
          #ifdef __DEBUG_FITS_CALCSCATTER__
            cout << "CFits::Set_ApertureDataToZero: i_ap = " << i_ap << ": D_A2_PixArray(" << i_row << ", " << i_col << ") set to zero" << endl;
          #endif
//        }
      }
    }
  }
  return true;
}

///Mode: 0: Median
///      1: Mean
///      2: Mininum
bool CFits::FindNonZeroClusters(Array<double, 2> &D_A2_InOut_PixArray, int I_In_BoxSize_X, int I_In_BoxSize_Y, int I_In_Mode, Array<double, 2> &D_A2_Out) const{
//  this->WriteFits(&D_A2_InOut_PixArray, CString("/home/azuri/spectra/SEDIFU/SEDM-deep-sim-flat-2012-05-14_ScatterOnly_apZero3.fits"));
  cout << "CFits::FindNonZeroClusters: I_In_BoxSize_X = " << I_In_BoxSize_X << ", I_In_BoxSize_Y = " << I_In_BoxSize_Y << endl;

  ///resize out array and set to zero
  D_A2_Out.resize(D_A2_InOut_PixArray.rows(), D_A2_InOut_PixArray.cols());
  D_A2_Out = 0.;

  ///find clusters, starting at [0,0]
  int i_x, i_y, sum_where, boxel, I_NClusters;
  Array<double, 2> D_A2_Box(I_In_BoxSize_X, I_In_BoxSize_Y);
  Array<int, 2> I_A2_Box_Where(I_In_BoxSize_X, I_In_BoxSize_Y);
  boxel = I_In_BoxSize_X * I_In_BoxSize_Y;
  I_NClusters = 0;
  for (int i_row = 0; i_row <= D_A2_InOut_PixArray.rows() - I_In_BoxSize_Y; i_row++){
    for (int i_col = 0; i_col <= D_A2_InOut_PixArray.cols() - I_In_BoxSize_X; i_col++){
      if (fabs(D_A2_InOut_PixArray(i_row, i_col)) >= 0.000001){
        D_A2_Box = D_A2_InOut_PixArray(Range(i_row, i_row + I_In_BoxSize_Y - 1),Range(i_col, i_col + I_In_BoxSize_X - 1));
        //cout << "CFits::FindNonZeroClusters: i_row = " << i_row << ", i_col = " << i_col << ": D_A2_Box.size() = " << D_A2_Box.size() << endl;
//      cout << "CFits::FindNonZeroClusters: i_row = " << i_row << ", i_col = " << i_col << ": D_A2_Box = " << D_A2_Box << endl;
        I_A2_Box_Where = where(fabs(D_A2_Box) >= 0.0000001, 1, 0);
//      cout << "CFits::FindNonZeroClusters: i_row = " << i_row << ", i_col = " << i_col << ": I_A2_Box_Where = " << I_A2_Box_Where << endl;
        sum_where = sum(I_A2_Box_Where);
        //cout << "CFits::FindNonZeroClusters: sum_where = " << sum_where << ", boxel = " << boxel << endl;
        if (sum_where == boxel){
          i_x = i_row + static_cast<int>(I_In_BoxSize_Y/2.);
          i_y = i_col + static_cast<int>(I_In_BoxSize_X/2.);
          cout << "CFits::FindNonZeroClusters: I_In_BoxSize_X = " << I_In_BoxSize_X << ", I_In_BoxSize_Y = " << I_In_BoxSize_Y << ": Cluster found at [" << i_x << ", " << i_y << "]" << endl;
          I_NClusters++;
          if (I_In_Mode == 0)///Median
            D_A2_Out(i_x, i_y) = this->Median(D_A2_Box, true);
          else if (I_In_Mode == 1)
            D_A2_Out(i_x, i_y) = mean(D_A2_Box);
	  else
            D_A2_Out(i_x, i_y) = min(D_A2_Box);

          D_A2_InOut_PixArray(Range(i_row, i_row + I_In_BoxSize_Y - 1),Range(i_col, i_col + I_In_BoxSize_X - 1)) = 0.;
          i_col += I_In_BoxSize_X;
        }
      }
    }
  }
  cout << "CFits::FindNonZeroClusters: I_NClusters found = " << I_NClusters << endl;
  if (I_NClusters == 0)
    return false;
  return true;
}


/// Sets Pixel values to zero and the centers of the Rectangles to the mean value of the Rectangle
bool CFits::FindMeanValuesOfRectangles(int I_In_WidthX, int I_In_WidthY){
  int i_row_center = I_In_WidthY / 2;
  int i_col_center = I_In_WidthX / 2;
  int i_row_start = 0;
  int i_col_start = 0;
  int i_row_end = I_In_WidthY - 1;
  int i_col_end = I_In_WidthX - 1;
  double D_Mean;
  if (I_In_WidthX >= this->NCols)
    return false;
  if (I_In_WidthY >= this->NRows)
    return false;
  Array<double, 2> D_A2_MeanArray(2,2);
  Array<int, 2> I_A2_Where(2,2);
  Array<int, 2> I_A2_IndArr(2,2);
  Array<double, 1> D_A1_GoodPix(2);
  int I_NGoodPix;
  while (i_row_start < this->NRows){
    while (i_col_start < this->NCols){
      cout << "CFits::FindMeanValuesOfRectangles: i_col_start = " << i_col_start << ", i_col_end = " << i_col_end << ", i_row_start = " << i_row_start << ", i_row_end = " << i_row_end << endl;
      D_A2_MeanArray.resize(i_row_end - i_row_start + 1, i_col_end - i_col_start + 1);
      I_A2_Where.resize(i_row_end - i_row_start + 1, i_col_end - i_col_start + 1);
      D_A2_MeanArray = (*this->P_D_A2_PixArray)(Range(i_row_start, i_row_end), Range(i_col_start, i_col_end));
      I_A2_Where = where(D_A2_MeanArray >= 0.000001, 1, 0);
      if (!this->GetIndex(I_A2_Where, I_NGoodPix, I_A2_IndArr)){
        cout << "CFits::FindMeanValuesOfRectangles: Error: GetIndex returned FALSE -> Returning FALSE" << endl;
        return false;
      }
//      cout << "CFits::FindMeanValuesOfRectangles: I_NGoodPix = " << I_NGoodPix << ": I_A2_IndArr = " << I_A2_IndArr << endl;
      (*this->P_D_A2_PixArray)(Range(i_row_start, i_row_end), Range(i_col_start, i_col_end)) = 0.;
      if (I_NGoodPix > 0){
        if (!this->GetSubArrCopy(D_A2_MeanArray, I_A2_IndArr, D_A1_GoodPix)){
          cout << "CFits::FindMeanValuesOfRectangles: Error: GetSubArrCopy returned FALSE -> Returning FALSE" << endl;
          return false;
        }
        D_Mean = mean(D_A1_GoodPix);
        (*this->P_D_A2_PixArray)(i_row_center, i_col_center) = D_Mean;
//        cout << "CFits::FindMeanValuesOfRectangles: PixArray(" << i_row_center << ", " << i_col_center << ") set to " << D_Mean << endl;
      }
      i_col_start += I_In_WidthX;
      if (i_col_start >= this->NCols)
        break;
      i_col_end += I_In_WidthX;
      if (i_col_end >= this->NCols){
        i_col_end = this->NCols - 1;
	i_col_start = i_col_end - I_In_WidthX + 1;
      }
      i_col_center += I_In_WidthX;
      if (i_col_center >= this->NCols)
        i_col_center = (i_col_end - i_col_start) / 2;
    }
    i_row_start += I_In_WidthY;
    if (i_row_start >= this->NRows){
      cout << "CFits::FindMeanValuesOfRectangles: i_row_start >= this->NRows => Aborting" << endl;
      break;
    }
    i_row_end += I_In_WidthY;
    if (i_row_end >= this->NRows){
      i_row_end = this->NRows - 1;
      i_row_start = i_row_end - I_In_WidthY + 1;
    }
    i_row_center += I_In_WidthY;
    if (i_row_center >= this->NRows)
      i_row_center = (i_row_end - i_row_start) / 2;
    i_col_start = 0;
    i_col_end = I_In_WidthX - 1;
    i_col_center = I_In_WidthX / 2;
  }
  return true;
}

bool CFits::ScaleImageToFitBackground(const Array<double, 2> &D_A2_Scatter_In, double &D_Fact_Out) const{
  return this->ScaleImageToFitBackground(*P_D_A2_PixArray, D_A2_Scatter_In, D_Fact_Out);
}

bool CFits::ScaleImageToFitBackground(const Array<double, 2> &D_A2_Image,
                                      const Array<double, 2> &D_A2_Scatter_In,
                                      double &D_Fact_Out) const{
  if (D_A2_Scatter_In.rows() != D_A2_Image.rows()){
    cout << "CFits::ScaleImageToFitBackground: ERROR: Number of rows of input scattered-light image (=" << D_A2_Scatter_In.rows() << ") does not agree with input image (= " << D_A2_Image.rows() << ") => Returning FALSE" << endl;
  }
  if (D_A2_Scatter_In.cols() != D_A2_Image.cols()){
    cout << "CFits::ScaleImageToFitBackground: ERROR: Number of columns of input scattered-light image (=" << D_A2_Scatter_In.cols() << ") does not agree with input image (= " << D_A2_Image.cols() << ") => Returning FALSE" << endl;
  }
  Array<double, 2> D_A2_Div(D_A2_Image.rows(), D_A2_Image.cols());
  D_A2_Div = D_A2_Image / D_A2_Scatter_In;
  Array<double, 1> *P_D_A1_Div = this->MakeVector(D_A2_Div);
  Array<double, 1> *P_D_A1_Div_Sort = this->BubbleSort(*P_D_A1_Div);
  D_Fact_Out = mean((*P_D_A1_Div_Sort)(Range(0, int(P_D_A1_Div->size()/10))));
  delete(P_D_A1_Div);
  delete(P_D_A1_Div_Sort);
  return true;
}

Array<double, 1> *CFits::MakeVector(const Array<double, 2> &D_A2_In) const{
  Array<double, 1> *P_D_A1_Out = new Array<double, 1>(D_A2_In.rows() * D_A2_In.cols());
  int i_start, i_end;
  i_start = 0;
  for (int i_row=0; i_row<D_A2_In.rows(); i_row++){
    i_end = i_start + D_A2_In.cols() - 1;
    (*P_D_A1_Out)(Range(i_start, i_end)) = D_A2_In(i_row, Range::all());
    i_start += D_A2_In.cols();
  }
  return P_D_A1_Out;
}


/// Calculate Scattered Light using Kriging Algorithm
/// IntArr_ClusterSizes_X_Y_In: Array(NClusterRuns, 2)
/// I_AddNPixToAp_X: number of pixels to add to aperture_width in X
/// I_AddNPixToAp_X: number of pixels to add to aperture_width in Y
/// I_NRectangles_X: number of rectangles in X direction
/// I_NRectangles_Y: number of rectangles in Y direction
/// FileName_ApZero_Out=<CString>
/// FileName_Clustered_Out=<CString>
/// FileName_ScatterFit_Out=<CString>
bool CFits::CalcScatterKriging(const Array<int, 2> &IntArr_ClusterSizes_X_Y_In,
                               const int I_AddNPixToAp_X,
                               const int I_AddNPixToAp_Y,
                               const int I_NRectangles_X,
                               const int I_NRectangles_Y,
                               Array<double, 2> &D_A2_ScatteredLight_Out,
                               Array<CString, 1> &CS_A1_Args_In,
                               void *PP_Args_In[]) const{
  if (IntArr_ClusterSizes_X_Y_In.cols() != 2){
    cout << "CFits::CalcScatterKriging: ERROR: IntArr_ClusterSizes_X_Y_In.cols() != 2 => Returning FALSE" << endl;
    return false;
  }
  D_A2_ScatteredLight_Out.resize(this->NRows, this->NCols);
  cout << "CFits::CalcScatterKriging: D_A2_ScatteredLight_Out resized" << endl;

  double tmp, pred, var;
  const size_t dim_cspace = 2;
  Array<double, 2> D_A2_PixArrayBak(this->NRows, this->NCols);
  D_A2_PixArrayBak = (*this->P_D_A2_PixArray);

  cout << "CFits::CalcScatterKriging: Starting Set_ApertureDataToZero()" << endl;
  const_cast<CFits*>(this)->Set_ApertureDataToZero(I_AddNPixToAp_X, I_AddNPixToAp_Y);
  cout << "CFits::CalcScatterKriging: Set_ApertureDataToZero() finished" << endl;
  cout << "CFits::CalcScatterKriging: CS_A1_Args_In = " << CS_A1_Args_In << endl;
  CString CS_Test(" ");
  CS_Test.Set("FileName_ApZero_Out");
  int I_Pos;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_Test)) >= 0){
    cout << "CFits::CalcScatterKriging: I_Pos = " << I_Pos << endl;
    CString *P_CS_FileName = (CString*)PP_Args_In[I_Pos];
    cout << "CFits::CalcScatterKriging: *P_CS_FileName = " << *P_CS_FileName << endl;
    this->WriteFits(this->P_D_A2_PixArray, *P_CS_FileName);
//    return false;
//    delete(P_CS_FileName);
  }

  Array<double, 2> D_A2_Clustered(2,2);
  Array<double, 2> D_A2_ToCluster(this->NRows, this->NCols);
  D_A2_ToCluster = const_cast<CFits*>(this)->GetPixArray();
  Array<int, 2> I_A2_ClusterCoords(2,2);
  Array<int, 2> I_A2_WhereCluster(this->NRows, this->NCols);
  Array<double, 2> D_A2_WhereClusterFAbs(this->NRows, this->NCols);
  Array<double, 2> D_A2_Clustered_Final(this->NRows, this->NCols);
  D_A2_Clustered_Final = 0.;
  int I_NClusters, I_ClusterSize_X, I_ClusterSize_Y;

  for (int i = 0; i < IntArr_ClusterSizes_X_Y_In.rows(); i++){
    I_ClusterSize_X = IntArr_ClusterSizes_X_Y_In(i, 0);
    I_ClusterSize_Y = IntArr_ClusterSizes_X_Y_In(i, 1);
    cout << "CFits::CalcScatterKriging: i = " << i << ": Starting FindNonZeroClusters()" << endl;
    if (this->FindNonZeroClusters(D_A2_ToCluster, I_ClusterSize_X, I_ClusterSize_Y, 2, D_A2_Clustered)){
//      cout << "CFits::CalcScatterKriging: No big clusters found" << endl;
//      return 0;
//    }

      D_A2_WhereClusterFAbs = fabs(D_A2_Clustered);
      I_A2_WhereCluster = where(D_A2_WhereClusterFAbs >= 0.000001, 1, 0);
      this->GetIndex(I_A2_WhereCluster, I_NClusters, I_A2_ClusterCoords);
      for (int i_cl=0; i_cl < I_NClusters; i_cl++){
        D_A2_Clustered_Final(I_A2_ClusterCoords(i_cl, 0), I_A2_ClusterCoords(i_cl, 1)) = D_A2_Clustered(I_A2_ClusterCoords(i_cl, 0), I_A2_ClusterCoords(i_cl, 1));
      }
    }
  }
  *this->P_D_A2_PixArray = D_A2_Clustered_Final;
  CS_Test.Set("FileName_Clustered_Out");
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_Test)) >= 0){
    CString *P_CS_FileName = (CString*)PP_Args_In[I_Pos];
    this->WriteFits(this->P_D_A2_PixArray, *P_CS_FileName);
//    delete(P_CS_FileName);
  }

  int I_RectangleSize_X = this->NCols / I_NRectangles_X;
  int I_RectangleSize_Y = this->NRows / I_NRectangles_Y;
  cout << "CFits::CalcScatterKriging: I_RectangleSize_X set to " << I_RectangleSize_X << endl;
  cout << "CFits::CalcScatterKriging: I_RectangleSize_Y set to " << I_RectangleSize_Y << endl;
  if (!const_cast<CFits*>(this)->FindMeanValuesOfRectangles(I_RectangleSize_X,I_RectangleSize_Y))
    return false;
  Array<int, 2> I_A2_WhereZero(this->NRows, this->NCols);
  cout << "CFits::CalcScatterKriging: starting where2" << endl;
  I_A2_WhereZero = where(fabs(const_cast<CFits*>(this)->GetPixArray()) > 0.000001, 1, 0);

  Array<int, 2> I_A2_IndZero(2,2);

  int I_NGood;
  this->GetIndex(I_A2_WhereZero, I_NGood, I_A2_IndZero);
  cout << "CFits::CalcScatterKriging: I_NGood = " << I_NGood << endl;
  const size_t num_samples = I_NGood;

  // kriging predictor
  CGeostat krig;

  // initialize kriging predictor
  cout << "CFits::CalcScatterKriging: starting kriging initialize: num_samples = " << num_samples << ", dim_cspace = " << dim_cspace << endl;
  krig.initialize(num_samples, dim_cspace);


  //
  // define a doCFits::CalcScatterKriging of control space
  //
  cout << "CFits::CalcScatterKriging: starting gsl_vector_alloc" << endl;
  gsl_vector *lower = gsl_vector_alloc(dim_cspace);
  gsl_vector *upper = gsl_vector_alloc(dim_cspace);
  //
  //control parameter c1 : 0 <= c1 <= 4.0
  gsl_vector_set(lower, 0, 0.0);
  gsl_vector_set(upper, 0, this->NRows-1);
  //
  // control parameter c2 : 0 <= c2 <= 5.0
  gsl_vector_set(lower, 1, 0.0);
  gsl_vector_set(upper, 1, this->NCols-1);
  //
  // set doCFits::CalcScatterKriging
  cout << "CFits::CalcScatterKriging: starting kriging setDoCFits::CalcScatterKriging" << endl;
  krig.setDomain(lower, upper);
  //
  gsl_vector_free(lower);
  gsl_vector_free(upper);

  //
  // sample data
  //
  cout << "CFits::CalcScatterKriging: starting gsl_vector_alloc *c" << endl;
  gsl_vector *c = gsl_vector_alloc(dim_cspace);

  cout << "CFits::CalcScatterKriging: starting kriging setData for loop" << endl;
  double i_a, i_b;
  for (int i = 0; i < num_samples; i++){
    i_a = static_cast<double>(I_A2_IndZero(i,0));
    i_b = static_cast<double>(I_A2_IndZero(i,1));
    cout << "i_a = " << i_a << ", i_b = " << i_b << endl;
    gsl_vector_set(c, 0, i_a);
    gsl_vector_set(c, 1, i_b);
    //
    // coordinate of i-th sample
    krig.setCoordinate(i, c);
    krig.setData(i, (*this->P_D_A2_PixArray)(I_A2_IndZero(i,0), I_A2_IndZero(i,1)));
  }

  //
  // precomputation of statistical analysis
  //
  //  using Spherical variogram model
  //  power coefficient = 0 (only use for stable variogram model)
  //  step width (h_step = 0.1)
  //krig.estimate(CVariogram::VARIO_SPH, 0, 0.1);
  cout << "CFits::CalcScatterKriging: starting kriging estimate" << endl;
  krig.estimate(CVariogram::VARIO_SPH, 0, 1.);


  //
  // output file stream
  std::ofstream ofkrig;
  ofkrig.open("krig.csv");

  //
  // prediction: 100x100 sample point
  //
  cout << "CFits::CalcScatterKriging: starting kriging prediction" << endl;
  for (size_t i = 0;i < this->NRows;i++)
  {
    cout << "CFits::CalcScatterKriging: row i = " << i << endl;
    // target parameter c1
    gsl_vector_set(c, 0, i);
    for (size_t j = 0;j < this->NCols;j++)
    {
      // target parameter c2
      gsl_vector_set(c, 1, j);

      // predictive value and estimate variance at parameter c
      krig.getPredictData(pred, var, c);
      ofkrig << pred << ", ";
      D_A2_ScatteredLight_Out(static_cast<int>(i), static_cast<int>(j)) = pred;
    }
    ofkrig << std::endl;
  }
  ofkrig.close();
  cout << "CFits::CalcScatterKriging: D_A2_ScatteredLight_Out.rows() = " << D_A2_ScatteredLight_Out.rows() << endl;
  cout << "CFits::CalcScatterKriging: D_A2_ScatteredLight_Out.cols() = " << D_A2_ScatteredLight_Out.cols() << endl;

  gsl_vector_free(c);

  CS_Test.Set("FileName_ScatterFit_Out");
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CS_Test);

  cout << "CFits::CalcScatterKriging: I_Pos = " << I_Pos << endl;
  if (I_Pos >= 0){
    CString *P_CS_FileName = (CString*)PP_Args_In[I_Pos];
    this->WriteFits(&D_A2_ScatteredLight_Out, *P_CS_FileName);
//    return false;
//    delete(P_CS_FileName);
  }
//  return false;
  *(const_cast<CFits*>(this)->P_D_A2_PixArray) = D_A2_PixArrayBak;
  return true;
}

/// Estimate Scattered Light using Kriging Algorithm by taking the minimum value per rectangle
/// plus 1 ReadOutNoise as input value for the fit
/// I_NRectangles_X: number of rectangles in X direction
/// I_NRectangles_Y: number of rectangles in Y direction
bool CFits::EstScatterKriging(const int I_NRectangles_X,
                              const int I_NRectangles_Y,
                              Array<double, 2> &D_A2_ScatteredLight_Out){
  Array<double, 2> D_A2_PixArray(this->NRows, this->NCols);
  D_A2_PixArray = this->GetPixArray();
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args(0) = CString(" ");
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  return this->EstScatterKriging(D_A2_PixArray, I_NRectangles_X, I_NRectangles_Y, D_A2_ScatteredLight_Out, CS_A1_Args, PP_Args);
}

bool CFits::EstScatterKriging(const int I_NRectangles_X,
                              const int I_NRectangles_Y,
                              Array<double, 2> &D_A2_ScatteredLight_Out,
                              Array<CString, 1> &CS_A1_Args_In,
                              void *PP_Args_In[]) const{
  Array<double, 2> D_A2_PixArray(this->NRows, this->NCols);
  D_A2_PixArray = (*(this->P_D_A2_PixArray));
  return this->EstScatterKriging(D_A2_PixArray, I_NRectangles_X, I_NRectangles_Y, D_A2_ScatteredLight_Out, CS_A1_Args_In, PP_Args_In);
}

bool CFits::EstScatterKriging(const Array<double, 2> &D_A2_PixArray_In,
                              const int I_NRectangles_X,
                              const int I_NRectangles_Y,
                              Array<double, 2> &D_A2_ScatteredLight_Out,
                              Array<CString, 1> &CS_A1_Args_In,
                              void *PP_Args_In[]) const{
  return this->EstimateScatteredLight(D_A2_PixArray_In,
                                      I_NRectangles_X,
                                      I_NRectangles_Y,
                                      D_A2_ScatteredLight_Out,
                                      CS_A1_Args_In,
                                      PP_Args_In);
}

bool CFits::EstimateScatteredLight(const Array<double, 2> &D_A2_PixArray_In,
                                   const int I_NRectangles_X,
                                   const int I_NRectangles_Y,
                                   Array<double, 2> &D_A2_ScatteredLight_Out,
                                   Array<CString, 1> &CS_A1_Args_In,
                                   void *PP_Args_In[]) const{
  int I_Pos = 0;
  int I_XMin = 0;
  int I_XMax = D_A2_PixArray_In.cols()-1;
  int I_YMin = 0;
  int I_YMax = D_A2_PixArray_In.rows()-1;
  bool B_Median = false;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("MEDIAN"))) >= 0){
    B_Median = true;
    cout << "CFits::EstimateScatteredLight: KeyWord_Set(MEDIAN): B_Median set to TRUE" << endl;
  }
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("AREA"))) >= 0){
    Array<int, 1> I_A1_Area(4);
    I_A1_Area = *(Array<int, 1>*)PP_Args_In[I_Pos];
    //#ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::EstimateScatteredLight: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
      //(*P_OFS_Log) << "CFits::MkProfIm: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
    //#endif
    I_XMin = I_A1_Area(0);
    I_XMax = I_A1_Area(1);
    I_YMin = I_A1_Area(2);
    I_YMax = I_A1_Area(3);
    #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
      cout << "CFits::EstimateScatteredLight: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
      //(*P_OFS_Log) << "CFits::MkProfIm: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
    #endif
//      return false;
  }
  cout << "CFits::EstimateScatteredLight: I_XMin = " << I_XMin << endl;
  cout << "CFits::EstimateScatteredLight: I_XMax = " << I_XMax << endl;
  cout << "CFits::EstimateScatteredLight: I_YMin = " << I_YMin << endl;
  cout << "CFits::EstimateScatteredLight: I_YMax = " << I_YMax << endl;

  CString CS_Method("Kriging");
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("METHOD"))) >= 0){
    CS_Method = *(CString*)PP_Args_In[I_Pos];
    cout << "CFits::EstimateScatteredLight: KeyWord_Set(METHOD): CS_Method set to " << CS_Method << endl;
  }
  
  float F_Smooth = 1e-16;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("SMOOTH"))) >= 0){
    F_Smooth = float(*(double*)PP_Args_In[I_Pos]);
    cout << "CFits::EstimateScatteredLight: KeyWord_Set(SMOOTH): F_Smooth set to " << F_Smooth << endl;
  }
  
  int I_Opt = -1;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("IOPT"))) >= 0){
    I_Opt = *(int*)PP_Args_In[I_Pos];
    cout << "CFits::EstimateScatteredLight: KeyWord_Set(IOPT): I_Opt set to " << I_Opt << endl;
  }
  
//  return false;
  Array<double, 2> D_A2_PixArray_Temp(I_YMax - I_YMin + 1, I_XMax - I_XMin + 1);
  D_A2_PixArray_Temp = D_A2_PixArray_In(Range(I_YMin, I_YMax), Range(I_XMin, I_XMax));

  cout << "CFits::EstimateScatteredLight: I_NRectangles_X = " << I_NRectangles_X << endl;
  int I_ClusterSizeX = D_A2_PixArray_Temp.cols() / I_NRectangles_X;
  cout << "CFits::EstimateScatteredLight: I_ClusterSizeX = " << I_ClusterSizeX << endl;

  cout << "CFits::EstimateScatteredLight: I_NRectangles_Y = " << I_NRectangles_Y << endl;
  int I_ClusterSizeY = D_A2_PixArray_Temp.rows() / I_NRectangles_Y;
  cout << "CFits::EstimateScatteredLight: I_ClusterSizeY = " << I_ClusterSizeY << endl;

  int I_StartX=0;
  int I_EndX=(I_ClusterSizeX)-1;
  int I_StartY=0;
  int I_EndY=(I_ClusterSizeY)-1;
  Array<double, 2> D_A2_Scatter(I_NRectangles_Y, I_NRectangles_X);
  Array<int, 3> I_A3_ClusterCenter(I_NRectangles_Y, I_NRectangles_X, 2);
  D_A2_Scatter = 0.;
  D_A2_ScatteredLight_Out.resize(D_A2_PixArray_Temp.rows(), D_A2_PixArray_Temp.cols());
  for (int i_x=0; i_x<I_NRectangles_X; i_x++){
    I_StartY=0;
    I_EndY=(I_ClusterSizeY)-1;

    for (int i_y=0; i_y<I_NRectangles_Y; i_y++){
      #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
        cout << "CFits::EstimateScatteredLight: i_x = " << i_x << ", i_y = " << i_y << ": I_StartX = " << I_StartX << ", I_EndX = " << I_EndX << ", I_StartY = " << I_StartY << ", I_EndY = " << I_EndY << endl;
      #endif
      if (B_Median){
        D_A2_Scatter(i_y, i_x) = this->Median(D_A2_PixArray_Temp(Range(I_StartY, I_EndY), Range(I_StartX, I_EndX)), false); 
      }
      else{
        #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
          cout << "CFits::EstimateScatteredLight: min(D_A2_PixArray_Temp(Range(I_StartY=" << I_StartY << ", I_EndY=" << I_EndY << "), Range(I_StartX=" << I_StartX << ", I_EndX=" << I_EndX << "))) = " << min(D_A2_PixArray_Temp(Range(I_StartY, I_EndY), Range(I_StartX, I_EndX))) << endl;
          cout << "CFits::EstimateScatteredLight: D_ReadOutNoise = " << this->D_ReadOutNoise << endl;
        #endif
        D_A2_Scatter(i_y, i_x) = min(D_A2_PixArray_Temp(Range(I_StartY, I_EndY), Range(I_StartX, I_EndX))) + (3. * this->D_ReadOutNoise);
      }
      #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
        cout << "CFits::EstimateScatteredLight: D_A2_Scatter(i_y = " << i_y << ", i_x = " << i_x << ") = " << D_A2_Scatter(i_y, i_x) << endl;
      #endif
      I_A3_ClusterCenter(i_y, i_x, 0) = I_StartX + (I_EndX - I_StartX)/2;
      I_A3_ClusterCenter(i_y, i_x, 1) = I_StartY + (I_EndY - I_StartY)/2;
      #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
        cout << "CFits::EstimateScatteredLight: I_A3_ClusterCenter(i_y = " << i_y << ", i_x = " << i_x << ", *) = " << I_A3_ClusterCenter(i_y, i_x, Range::all()) << endl;
      #endif
      I_StartY += I_ClusterSizeY;
      I_EndY += I_ClusterSizeY;
    }
    I_StartX += I_ClusterSizeX;
    I_EndX += I_ClusterSizeX;
  }

  if (CS_Method.EqualValue(CString("Kriging"))){  
    const size_t dim_cspace = 2;
    const size_t num_samples = I_NRectangles_X * I_NRectangles_Y;
    
    // kriging predictor
    CGeostat krig;
    
    // initialize kriging predictor
    cout << "CFits::EstimateScatteredLight: starting kriging initialize: num_samples = " << num_samples << ", dim_cspace = " << dim_cspace << endl;
    krig.initialize(num_samples, dim_cspace);
    
    //
    // define a doCFits::CalcScatterKriging of control space
    //
    #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
      cout << "CFits::EstimateScatteredLight: starting gsl_vector_alloc" << endl;
    #endif
    gsl_vector *lower = gsl_vector_alloc(dim_cspace);
    gsl_vector *upper = gsl_vector_alloc(dim_cspace);
    //
    //control parameter c1 : 0 <= c1 <= 4.0
    gsl_vector_set(lower, 0, 0.0);
    gsl_vector_set(upper, 0, D_A2_PixArray_Temp.rows()-1);
    //
    // control parameter c2 : 0 <= c2 <= 5.0
    gsl_vector_set(lower, 1, 0.0);
    gsl_vector_set(upper, 1, D_A2_PixArray_Temp.cols()-1);
    //
    // set doCFits::CalcScatterKriging
    #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
      cout << "CFits::EstimateScatteredLight: starting kriging setDoCFits::CalcScatterKriging" << endl;
    #endif
    krig.setDomain(lower, upper);
    //
    gsl_vector_free(lower);
    gsl_vector_free(upper);
    
    //
    // sample data
    //
    #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
      cout << "CFits::EstimateScatteredLight: starting gsl_vector_alloc *c" << endl;
    #endif
    gsl_vector *c = gsl_vector_alloc(dim_cspace);
    
    #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
      cout << "CFits::EstimateScatteredLight: starting kriging setData for loop" << endl;
    #endif
    double d_a, d_b, pred, var;
    size_t i = 0;

    for (int i_x = 0; i_x < I_NRectangles_X; i_x++){
      I_StartY=0;
      I_EndY=(I_ClusterSizeY)-1;
      
      for (int i_y = 0; i_y < I_NRectangles_Y; i_y++){
        
        d_a = static_cast<double>(I_A3_ClusterCenter(i_y, i_x, 0));
        d_b = static_cast<double>(I_A3_ClusterCenter(i_y, i_x, 1));
        cout << "d_a = " << d_a << ", d_b = " << d_b << endl;
        gsl_vector_set(c, 0, d_a);
        gsl_vector_set(c, 1, d_b);
        //
        // coordinate of i-th sample
        krig.setCoordinate(i, c);
        krig.setData(i, D_A2_Scatter(i_y, i_x));
        
        i++;
      }
    }
    //
    // precomputation of statistical analysis
    //
    //  using Spherical variogram model
    //  power coefficient = 0 (only use for stable variogram model)
    //  step width (h_step = 0.1)
    //krig.estimate(CVariogram::VARIO_SPH, 0, 0.1);
    cout << "CFits::EstimateScatteredLight: starting kriging estimate" << endl;
    krig.estimate(CVariogram::VARIO_SPH, 0, 1.);


    //
    // output file stream
  //  std::ofstream ofkrig;
  //  ofkrig.open("krig.csv");

    //
    // prediction: 100x100 sample point
    //
    cout << "CFits::EstimateScatteredLight: starting kriging prediction" << endl;
    for (size_t i = 0; i < D_A2_PixArray_Temp.rows(); i++)
    {
      cout << "CFits::EstimateScatteredLight: row i = " << i << endl;
      // target parameter c1
      gsl_vector_set(c, 0, i);
      for (size_t j = 0; j < D_A2_PixArray_Temp.cols(); j++)
      {
        // target parameter c2
        gsl_vector_set(c, 1, j);

        // predictive value and estimate variance at parameter c
        krig.getPredictData(pred, var, c);
  //      ofkrig << pred << ", ";
        D_A2_ScatteredLight_Out(static_cast<int>(i), static_cast<int>(j)) = pred;
      }
  //    ofkrig << std::endl;
    }
  //  ofkrig.close();

    gsl_vector_free(c);
  }
  else{/// bidirectional spline fitting
    std::vector<float> XVec(0);
    std::vector<float> YVec(0);
    std::vector<float> ZVec(0);
    std::vector<float> WVec(0);
    std::vector<float> ZFitVec(0);
    for (int i_x=0; i_x<I_NRectangles_X; i_x++){
      for (int i_y=0; i_y<I_NRectangles_Y; i_y++){
        #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
          cout << "CFits::EstimateScatteredLight: D_A2_Scatter(i_y=" << i_y << ", i_x=" << i_x << ") = " << D_A2_Scatter(i_y, i_x) << endl;
        #endif
        if (fabs(D_A2_Scatter(i_y, i_x)) > 0.0000001){
          XVec.push_back(I_A3_ClusterCenter(i_y, i_x, 0));
          YVec.push_back(I_A3_ClusterCenter(i_y, i_x, 1));
          ZVec.push_back(float(D_A2_Scatter(i_y, i_x)));
          WVec.push_back(float(1. / fabs(D_A2_Scatter(i_y, i_x))));
          #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
            cout << "CFits::EstimateScatteredLight: ZVec[" << ZVec.size()-1 << "] = " << ZVec[ZVec.size()-1] << endl;
          #endif
        }
      }
    }
    SurfaceFit surfaceFit;
    cout << "CFits::EstimateScatteredLight: starting surfaceFit.doFit" << endl;
    if (!surfaceFit.doFit(XVec, YVec, ZVec, WVec, I_NRectangles_X, I_NRectangles_Y, F_Smooth, I_Opt)){
      cout << "CFits::EstimateScatteredLight: ERROR: doFit returned FALSE" << endl;
      return false;
    }
    cout << "CFits::EstimateScatteredLight: surfaceFit.doFit finished" << endl;
    
    XVec.resize(0);
    XVec.reserve((I_YMax - I_YMin + 1) * (I_XMax - I_XMin + 1));
    YVec.resize(0);
    YVec.reserve((I_YMax - I_YMin + 1) * (I_XMax - I_XMin + 1));
    for (int i_row = I_YMin; i_row <= I_YMax; i_row++){
      for (int i_col = I_XMin; i_col <= I_XMax; i_col++){
        XVec.push_back(i_col);
        YVec.push_back(i_row);
      }
    }
    
    ZFitVec.resize(XVec.size());
    cout << "CFits::EstimateScatteredLight: starting surfaceFit.estimate" << endl;
    if (!surfaceFit.estimate(XVec, YVec, ZFitVec)){
      cout << "CFits::EstimateScatteredLight: ERROR: surfaceFit.estimate returned FALSE" << endl;
      return false;
    }
    cout << "CFits::EstimateScatteredLight: surfaceFit.estimateFit finished" << endl;
    D_A2_ScatteredLight_Out.resize(I_YMax - I_YMin + 1, I_XMax - I_XMin + 1);
    int i_pos = 0;
    for (int i_row = I_YMin; i_row <= I_YMax; i_row++){
      for (int i_col = I_XMin; i_col <= I_XMax; i_col++){
        D_A2_ScatteredLight_Out(i_row, i_col) = ZFitVec[i_pos];
        ++i_pos;
      }
    }
    
  }
  #ifdef __DEBUG_FITS_ESTIMATESCATTEREDLIGHT__
    cout << "CFits::EstimateScatteredLight: D_A2_ScatteredLight_Out.rows() = " << D_A2_ScatteredLight_Out.rows() << endl;
    cout << "CFits::EstimateScatteredLight: D_A2_ScatteredLight_Out.cols() = " << D_A2_ScatteredLight_Out.cols() << endl;
    cout << "CFits::EstimateScatteredLight: D_A2_ScatteredLight_Out = " << D_A2_ScatteredLight_Out << endl;
  #endif
  return true;
}


bool CFits::Set_ProfArray(const Array<double, 2> &D_A2_ProfArray_In){
  if (D_A2_ProfArray_In.rows() != this->NRows){
    cout << "CFits::Set_ProfArray: ERROR: D_A2_ProfArray_In.rows()=" << D_A2_ProfArray_In.rows() << " != this->NRows=" << this->NRows << endl;
    return false;
  }
  if (D_A2_ProfArray_In.cols() != this->NCols){
    cout << "CFits::Set_ProfArray: ERROR: D_A2_ProfArray_In.cols()=" << D_A2_ProfArray_In.cols() << " != this->NCols=" << this->NCols << endl;
    return false;
  }
  (*this->P_D_A2_ProfArray) = D_A2_ProfArray_In;
  this->ProfileCalculated = true;
  return true;
}

bool CFits::Read_ProfArray(const CString &CS_FitsFileName_In){
  CFits CF_Prof;
  if (!CF_Prof.SetFileName(CS_FitsFileName_In)){
    cout << "CFits::Read_ProfArray: ERROR: CF_Prof.SetFileName(" << CS_FitsFileName_In << ") returned FALSE => Returning FALSE" << endl;
    return false;
  }
  if (!CF_Prof.ReadArray()){
    cout << "CFits::Read_ProfArray: ERROR: CF_Prof.ReadArray() returned FALSE => Returning FALSE" << endl;
    return false;
  }
  return (this->Set_ProfArray(CF_Prof.GetPixArray()));
}






/**
  MkSlitFunc old version
  Make Slit Function
 **/
bool CFits::MkSlitFunc_Old(Array<double, 1> &D_A1_ScatterBelow,  //: in
                       Array<double, 1> &D_A1_XScatterBelow, //: in
                       Array<double, 1> &D_A1_ScatterAbove,  //: in
                       Array<double, 1> &D_A1_XScatterAbove, //: in
                       //                       Array<double, 1> &D_A1_XCenters,      ///: in //
                       //                       double &D_XLeftLim,                      ///: in //
                       //                       double &D_XRightLim,                     ///: in //
                       Array<double, 1> &D_A1_XSlitF,        //: out
                       Array<double, 2> &D_A2_SlitF,         //: out
                       Array<double, 1> &D_A1_BinCen,        //: out
                       int I_IAperture_In,                   //: in
                       //                       int I_NArgs,                          //: in
                       const Array<CString, 1> &CS_A1_Args,           //: in
                       void *ArgV[])                  //: in
/*                     //PLOT        =
                       Y_LOWER_LIM = int             : in
                       Y_UPPER_LIM = int             : in
                       LAMBDA_SF   = double          : in
                       LAMBDA_SP   = int             : out
                       SWATH_WIDTH = int             : in
                       BLZ         = Array<double, 1>: out
                       MASK        = Array<double, 2>: in
                       CCD_GAIN    = double          : in
                       CCD_READN   = double          : in
                       NO_SCATTER  = void
                       TELLURIC    = void
                       FILENAME    = CString         : in
*/
{
  /*
  pro mkslitf, m (array(ncol,nrow)), // image containing echelle spectrum
               scatter_below,
               yscatter_below,
               scatter_above,
               yscatter_above,
               ycen, // (vector(ncol)), row numbers of zero point for slit function
               y_lower_lim,
               y_upper_lim,
               yslitf, // (vector(nslitf)) subpixel row offsets for slitf,
               sflit, // (array(nslitf,nbin)), subpixel slit functions,
               bincen, // (vector(nbin)), column of bin centers,
               ord_num,
               PLOT=iplot,
               X_LEFT_LIM=x_left_lim,
               X_RIGHT_LIM=x_right_lim,
               LAMBDA_SF=lam_sf,
               LAMBDA_SP=lam_sp,
               SWATH_WIDTH=swath_width,
               BLZ=blz,
               OSAMPLE=osample,
               MASK=mask,
               GAIN=gain,
               READN=readn,
               NO_SCATTER=no_scatter,
               TELLURIC=telluric,
               FILENAME=filename
  ;Determines slit function along echelle order
  ;Input:
  ; im (array(ncol,nrow)) image containing echelle spectrum
  ; back (vector(ncol) vector containing background under the current order
  ; ymin (vector(ncol)) row numbers along bottom of region to map
  ; ycen (vector(ncol)) row numbers of zero point for slit function
  ; ymax (vector(ncol)) row numbers along top of region to map
  ;Output:
  ; yslitf (vector(nslitf)) subpixel row offsets for slitf
  ; sflit (array(nslitf,nbin)) subpixel slit functions
  ; bincen (vector(nbin)) column of bin centers
  ;History:
  ;18-Nov-96 Valenti  Wrote.
  ;21-Nov-97 Valenti  Adapted phx_slitf for use in echelle reduction package
  ;30-Mar-98 Valenti  Don't use polynomials to fit slit function. Instead
  ;                    median filter, then bin, then Gaussian smooth.
  ;05-May-98 CMJ      Back to using polynomials to fit slit function.  Seems
  ;                    to work OK with 18th order on the binned, median filtered
  ;                    slit function.
  ;13-Aug-98 CMJ      Put in logic to calculate both the smoothed medianed
  ;                    slit function and the polynomial one and choose between
  ;                    them based on standard deviations, giving the fit
  ;                    a little extra room for messiness.  I also force
  ;                    whatever method is chosen on the first time through to
  ;                    use throughout.  I have also increased the smoothing
  ;                    size for high resolution data.
  ;29-Nov-98 JAV      Check for rspec exactly zero and fudge it to be one,
  ;                    so as to avoid divide by zero and subsequent badness.
  ;08-Dec-98 JAV      Added an inital filtering of bad pixels in the oversampled
  ;                    slit function *before* binning. The rejection threshold
  ;                    is 3 times the mean absolute value of the difference
  ;                    between the oversampled (sf) and median filtered (medsf)
  ;                    slit functions. Indices of the good pixels are contained
  ;                    in "igd".
  ;09-Dec-98 CMJ      Added the conditional on binning the slit function back
  ;                    in to aviod inappropriate referencing of the variables.
  ;                    The result is some SF bins have no points in them, so
  ;                    added a later check which interpolates over these bins.
  ;06-Jun-99 JAV      Increased trace level of slit function type message from
  ;                    10 to 20 (suppressing the messages by default).
  ;30-Mar-01 NP       I will write down what I have done. I promise.
  */
  /**
    Array<double, 1> bincen   => Array<double, 1> D_A1_BinCen
  ! Array<double, 1> BLZ=blz = fltarr(ncol)  => Array<double, 1> *P_D_A1_BLZ
    FILENAME=filename
  ! double GAIN=gain=CCD_gain       => double D_CCDGain       ; Gain
    Array<long, 1>/int i      => Array<int, 1> I_A1_I / int I_I ;Points of row crossing
  ! long ib                   => int I_IB
  ! long ie                   => int I_IE
  ! Array<long, 1> ibeg      => Array<int, 1> I_A1_IBeg
  ! Array<double, 1> ibound  => Array<double, 1> D_A1_IBound
  ! int icen = yc(ib+j)     => int I_ICen
  ! Array<long, 1> iend      => Array<int, 1> I_A1_IEnd
  ! Array<double, 2> im              => CFits P_CF_Im
  ! int imask = 0                    => int I_IMask
  ! Array<long, 1> imax      => Array<int, 1> I_A1_IMax
  ! Array<long, 1> imin      => Array<int, 1> I_A1_IMin
    Array<double, 1> irow    => Array<double, 1> D_A1_ICol
  ! Array<long, 1> j0        => Array<int, 1> I_A1_J0
  ! Array<long, 1> j1        => Array<ing, 1> I_A1_J1
   ! Array<int, 1> jbad      => Array<int, 1> I_A1_JBad
    int jgood               => int I_JGood
  ! long k0                 => int I_K0
  ! long k1                 => int I_K1
  ! double LAMBDA_SF=lam_sf              => double D_LambdaSF
  ! int LAMBDA_SP=lam_sp                 => int I_LambdaSP
  ! Array<double, 2> MASK=mask            => Array<double, 2> D_A2_Mask
  ! bytarr msk(nc,nysf) / = 0  => Array<double, 2> D_A2_Msk
  ! int nbad                 => int I_NBad
  ! int nbin                 => int I_NBin
  ! long nc                  => int I_NR
  ! int ncol                 => int P_CF_Im->NRows
  ! int ni                   => int I_NI    ;This is how many times this order crosses to the next column
  NO_SCATTER=no_scatter
  ! int nrow                        => int P_CF_Im->NCols
  ! long nsf                        => int I_NSF
  ! int nslitf                     => int I_NSlitF
  ! long nysf                       => int I_NXSF
  ! int ord_num                             => int IOrdNum
  PLOT=iplot
  ! double READN=readn=CCD_readn=0. => double D_CCDReadN      ; Readout noise
  ! int OSAMPLE=osample                  => int I_OverSample
  Array<double, 1> dy_scatter         => Array<double, 1> D_A1_DXScatter
  Array<double, 1> yscatter_below     => Array<double, 1> D_A1_XScatterBelow
  Array<double, 1> yscatter_above     => Array<double, 1> D_A1_XScatterAbove
  Array<double, 1> scatter            => Array<double, 1> D_A1_Scatter
  Array<double, 1> scatter_above      => Array<double, 1> D_A1_ScatterAbove
  Array<double, 1> scatter_below      => Array<double, 1> D_A1_ScatterBelow
  ! Array<double, 2> sf(nc,nysf)      => Array<double, 2> D_A2_SF
  ! Array<double, 2> sfbin            => Array<double, 2> D_A2_SFBin;
  ! Array<double, 1> sfpnt(nsf)       => Array<double, 1> D_A1_SFPnt
  ! Array<double, 1> sfsm             => Array<double, 1> D_A1_SFSM
  Array<double, 2> slitf
  ! Array<double, 1> ssf               => Array<double, 1> D_A1_SSF
  ! int SWATH_WIDTH=swath_width       => int I_SwathWidth
  Array<double, 1> tel                => Array<double, 1> D_A1_Tel
  TELLURIC=telluric
  ! long X_LEFT_LIM=x_left_lim        => int (int)((*this->P_D_A1_XMin)(I_IAperture_In))
  ! long X_RIGHT_LIM=x_right_lim       => int (int)((*this->P_D_A1_XMax)(I_IAperture_In))
  ! Array<int, 1> yc                   => Array<int, 1> I_A1_XC
  yscatter_below
  yscatter_above
  ! Array<double, 1> ysfpnt(nsf)      => Array<double, 1> D_A1_XSFPnt
  ! Array<double, 1> ycen(ncol)        => Array<double, 1> this->P_D_A2_XCenters(I_IAperture_In)
  ! Array<double, 1> ycene             => Array<double, 1> D_A1_XCentersE
  ! long y_lower_lim                   => int 0. -
  (*this->P_D_A1_XLow)(I_IAperture_In), this->P_D_A1_XLow(I_IAperture_In)
  ! long y_upper_lim                   => int (*this->P_D_A1_XHigh)(I_IAperture_In), this->P_D_A1_XHigh(I_IAperture_In)
  Array<double, 1> yslitf
  ! long yslitf0 = -y_lower_lim        => int I_XSlitFunc0
  ! long yslitf1 =  y_upper_lim        => int I_XSlitFunc1
   **/

  (*P_OFS_Log) << "CFits::MkSlitFunc: Started: CS_A1_Args = " << CS_A1_Args << endl;

  //  (*this->P_D_A1_XLow)(I_IAperture_In) = 0. - D_XLeftLim;
  //  (*this->P_D_A1_XHigh)(I_IAperture_In) = 0. + (*this->P_D_A1_XHigh)(I_IAperture_In);
  //  (*this->P_D_A2_PixArray)()



  //  CFits *P_CF_Im = new CFits(*this);
  //  Array<double, 1> D_A1_BinCen;

  //  Array<double, 1> D_A1_ScatterBelow(this->GetNRows(), this->GetNCols());  //: in
  //  Array<double, 1> D_A1_XScatterBelow(this->GetNRows(), this->GetNCols()); //: in
  //  Array<double, 1> D_A1_ScatterAbove(this->GetNRows(), this->GetNCols());  //: in
  //  Array<double, 1> D_A1_XScatterAbove(this->GetNRows(), this->GetNCols()); //: in

  //  D_A1_ScatterBelow = 0.;
  //  D_A1_XScatterBelow = 0.;
  //  D_A1_ScatterAbove = 0.;
  //  D_A1_XScatterAbove = 0.;

  Array<double, 1> *P_D_A1_BLZ = new Array<double, 1>(1);
  (*P_D_A1_BLZ) = 0.;

  Array<double, 1> D_A1_DXScatter(1);
  D_A1_DXScatter = 0.;

  Array<double, 1> D_A1_IBound(1);
  D_A1_IBound = 0.;

  Array<double, 1> D_A1_ICol(1);
  D_A1_ICol = 0.;

  Array<double, 1> D_A1_IR0(1);
  D_A1_IR0 = 0.;

  Array<double, 1> D_A1_IR1(1);
  D_A1_IR1 = 0.;

  Array<double, 2> D_A2_Mask(1, 1);
  D_A2_Mask = 0.;

  Array<double, 2> D_A2_Msk(1, 1);
  D_A2_Msk = 0.;

  Array<double, 1> D_A1_SC(1);
  D_A1_SC = 0.;

  Array<double, 1> D_A1_Scatter(1);
  D_A1_Scatter = 0.;

  Array<double, 2> D_A2_SFBin(1, 1);
  D_A2_SFBin = 0.;

  Array<double, 1> D_A1_SF(1);
  D_A1_SF = 0.;

  Array<double, 2> D_A2_SF(1, 1);
  D_A2_SF = 0.;

  Array<double, 1> D_A1_SFPnt(1);
  D_A1_SFPnt = 0.;

  Array<double, 1> D_A1_SFSM(1);
  D_A1_SFSM = 0.;

  Array<double, 1> D_A1_SFSM2(1);
  D_A1_SFSM2 = 0.;

  Array<double, 1> D_A1_SFSM2Temp(1);
  D_A1_SFSM2Temp = 0.;

  Array<double, 2> D_A2_SlitFTemp(1,1);
  D_A2_SlitFTemp = 0.;

  Array<double, 1> D_A1_SP(1);
  D_A1_SP = 0.;

  Array<double, 1> D_A1_SSF(1);
  D_A1_SSF = 0.;

  Array<double, 1> D_A1_Tel(1);
  D_A1_Tel = 0.;

  Array<double, 2> D_A2_Tel(1,1);
  D_A2_Tel = 0.;

  Array<double, 1> D_A1_Temp(1);
  D_A1_Temp = 0.;

  Array<double, 1> D_A1_TempArr(1);
  D_A1_TempArr = 0.;

  Array<double, 1> D_A1_TempArrA(1);
  D_A1_TempArrA = 0.;

  Array<double, 1> D_A1_TempArrB(1);
  D_A1_TempArrB = 0.;

  Array<double, 1> D_A1_TempArrC(1);
  D_A1_TempArrC = 0.;

  Array<double, 1> D_A1_TempArrD(1);
  D_A1_TempArrD = 0.;

  Array<double, 1> D_A1_XCenMXC(1);
  D_A1_XCenMXC = 0.;

  Array<double, 1> D_A1_XCentersE(1);
  D_A1_XCentersE = 0.;

  Array<double, 1> D_A1_XInt(1);
  D_A1_XInt = 0.;

  Array<double, 1> D_A1_XSFPnt(1);
  D_A1_XSFPnt = 0.;

  Array<double, 1> D_A1_XSlitFTemp(1);
  D_A1_XSlitFTemp = 0.;

  Array<int, 1> I_A1_I(1);
  I_A1_I = 0;

  Array<int, 1> I_A1_IBeg(1);
  I_A1_IBeg = 0;

  Array<int, 1> I_A1_IEnd(1);
  I_A1_IEnd = 0;

  Array<int, 1> I_A1_IMax(1);
  I_A1_IMax = 0;

  Array<int, 1> I_A1_IMin(1);
  I_A1_IMin = 0;

  Array<int, 1> I_A1_ISort(1);
  I_A1_ISort = 0;

  Array<int, 1> I_A1_ITel(1);
  I_A1_ITel = 0;

  Array<int, 1> I_A1_IX(1);
  I_A1_IX = 0;

  Array<int, 1> I_A1_J0(1);
  I_A1_J0 = 0;

  Array<int, 1> I_A1_J1(1);
  I_A1_J1 = 0;

  Array<int, 1> I_A1_JBad(1);
  I_A1_JBad = 0;

  Array<int, 1> I_A1_Temp(1);
  I_A1_Temp = 0;

  Array<int, 1> I_A1_TempA(1);
  I_A1_TempA = 0;

  Array<int, 1> *P_I_A1_XC;

  char* tmpstr = new char[4];

  int I_I = 0;
  int I_IB = 0;// = I_A1_IBeg(m);    /// Lower row
  int I_IE = 0;// = I_A1_IEnd(m);    /// Upper row
  int I_NR = 0;// = I_IE - I_IB + 1; /// Number of rows
  int I_ICen = 0;
  int I_JGood = 0;
  int I_K0 = 0;
  int I_K1 = 0;
  int I_IMask = 0;
  int I_LambdaSP = 0;
  int I_NBad = 0;
  int I_NBin = 0;
  int I_NI = 0;
  int I_NSF = 0;
  int I_NSlitF = 0;
  int I_NTrim = 0;
  int I_NXSF = 0;
  //  int I_OverSample = 0;
  int I_Pos = 0;
  int I_SwathWidth = 0;
  int I_X0 = 0;
  int I_X1 = 0;
  int I_XSlitFunc0 = 0;
  int I_XSlitFunc1 = 0;
  //  int I_YLowerLim = 0;
  //  int I_YUpperLim = this->NRows - 1;
  int irow = 0;
  int pos = 0;
  int pppos = 0;
  int I_NArgs = CS_A1_Args.size();
  double D_BR0 = 0.;
  double D_BR1 = this->NRows - 1.;
  double D_CCDGain = 1.;
  double D_CCDReadN = 0.;
  double D_DXSF = 0.;
  double D_LambdaSF = 1.;
  double D_XSFMax = 0.;
  double D_XSFMin = 0.;
  //  double D_YLeftLim = 1.;
  //  double D_YRightLim = 1.;
  double d_tmp = 0.;

  CString CS_Temp("Y_LOWER_LIM");
  Array<CString, 1> cs_a1(8);

  void **args = (void**)malloc(sizeof(void*) * 8);

  cs_a1(pppos) = CString("NOISE");
  pppos++;

  //  cs_a1(pppos) = CString("OVERSAMPLE");
  //  pppos++;

  cs_a1(pppos) = CString("IM_OUT");
  pppos++;

  cs_a1(pppos) = CString("LAMBDA_SF");
  pppos++;

  cs_a1(pppos) = CString("LAMBDA_SP");
  pppos++;

  cs_a1(pppos) = CString("USE_ROW");
  pppos++;

  cs_a1(pppos) = CString("BAD");
  pppos++;

  cs_a1(pppos) = CString("MASK");

  firstIndex i;
  secondIndex j;

  /// Trace Functions
  if (!this->TraceFunctionsCalculated)
  {
    if (!this->CalcTraceFunctions())
    {
      cout << "CFits::MkSlitFunc: ERROR: this->CalcTraceFunctions() returned FALSE" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: this->CalcTraceFunctions() returned FALSE" << endl;
      return false;
    }
  }

  //  (*this->P_D_A2_XCenters)(I_IAperture_In, Range::all()) = D_A1_XCenters(Range::all());

  //  (*P_OFS_Log) << "CFits::MkSlitFunc: 1. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

  /**
  if n_params() lt 8 then begin
    print, 'syntax: mkslitf, im, back, ymin, ycen, ymax, yslitf, slitf,bincen $'
    print,'               [, ord_num, [,/PLOT [,Y_LOW_LIM=y_low_lim, Y_UPPER_LIM=y_upper_lim $'
    print,'               [, X_LEFT_LIM=x_left_lim, X_RIGHT_LIM=x_right_lim $'
    print,'               [, OSAMPLE=osample [,SWATH_WIDTH=swath_width]]]]]]'
    retall
  endif

  ;Get image size.
  sz = size(im)                              ;variable info
  ncol = sz(1)                               ;number of columns
  nrow = sz(2)                               ;number of rows

  if(not keyword_set(x_left_lim) ) then $
    x_left_lim  = 0
  */
  ///first column to extract
  //  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  //  {
  //    I_YLowerLim = *(int*)ArgV[I_Pos];
  //#ifdef __DEBUG_FITS_PISKUNOV__
  //    cout << "CFits::MkSlitFunc: KeyWord_Set(Y_LOWER_LIM): I_YLowerLim set to " << I_YLowerLim << endl;
  //    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(Y_LOWER_LIM): I_YLowerLim set to " << I_YLowerLim << endl;
  //#endif
  //  }

  /**
  if(not keyword_set(x_right_lim)) then $
    x_right_lim = ncol-1L
  */
  ///last column to extract
  //  CS_Temp.Set("Y_UPPER_LIM");
  //  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  //  {
  //    I_YUpperLim = *(int*)ArgV[I_Pos];
  //#ifdef __DEBUG_FITS_PISKUNOV__
  //    cout << "CFits::MkSlitFunc: KeyWord_Set(Y_UPPER_LIM): I_YUpperLim set to " << I_YUpperLim << endl;
  //    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(Y_UPPER_LIM): I_YUpperLim set to " << I_YUpperLim << endl;
  //#endif
  //  }

  /**
  if(keyword_set(gain))  then $
    CCD_gain  = gain $
  else $
    CCD_gain=1.
  */
  ///CCD gain
  CS_Temp.Set("CCD_GAIN");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  {
    D_CCDGain = *(double*)ArgV[I_Pos];
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: KeyWord_Set(CCD_GAIN): D_CCDGain set to " << D_CCDGain << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(CCD_GAIN): D_CCDGain set to " << D_CCDGain << endl;
#endif

  }

  /**
  if(keyword_set(readn)) then $
    CCD_readn = readn $
  else $
    CCD_readn=0.
  */
  ///Readout noise
  CS_Temp.Set("CCD_READN");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  {
    D_CCDReadN = *(double*)ArgV[I_Pos];
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: KeyWord_Set(CCD_READN): D_CCDReadN set to " << D_CCDReadN << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(CCD_READN): D_CCDReadN set to " << D_CCDReadN << endl;
#endif

  }

  /**
  msk = 0
  imask = 0
  if(keyword_set(mask)) then begin
    sz = size(mask)
    if(sz(0) eq 2 and sz(1) eq ncol and sz(2) eq nrow) then $
      imask = 1 $
    else begin
      print,'MKSLITF: Your mask is defined but does not match your image'
      stop
    endelse
  endif
  */
  ///Mask
  CS_Temp.Set("MASK");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  {
    D_A2_Mask = *(Array<double, 2>*)ArgV[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(MASK): D_A2_Mask set to " << D_A2_Mask << endl;//.transpose(secondDim, firstDim) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(MASK): D_A2_Mask set to " << D_A2_Mask << endl;//.transpose(secondDim, firstDim) << endl;
    if (D_A2_Mask.rows() != 1 && D_A2_Mask.cols() != 1 && D_A2_Mask(0,0) != 0)
    {
      if (D_A2_Mask.rows() != this->NRows ||
          D_A2_Mask.cols() != this->NCols)
      {
        cout << "CFits::MkSlitFunc: ERROR: Im(" << this->NRows << " x " << this->NCols << ") and Mask(" << D_A2_Mask.rows() << " x " << D_A2_Mask.cols() << ") don't have the same sizes!!!" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: Im(" << this->NRows << " x " << this->NCols << ") and Mask(" << D_A2_Mask.rows() << " x " << D_A2_Mask.cols() << ") don't have the same sizes!!!" << endl;
        return false;
      }
      I_IMask = 1;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(MASK): I_IMask set to " << I_IMask << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(MASK): I_IMask set to " << I_IMask << endl;
#endif

    }
  }
  ///Internal program parameters.
  CS_Temp.Set("SWATH_WIDTH");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  {
    /// If swath width is preset
    I_SwathWidth = *(int*)ArgV[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_SwathWidth set to " << I_SwathWidth << endl;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_SwathWidth set to " << I_SwathWidth << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_SwathWidth set to " << I_SwathWidth << endl;
#endif
    if (I_SwathWidth != 0)
    {
      ///nbin = round((x_right_lim - x_left_lim + 1.) / swath_width)>1
      I_NBin = Round(((*this->P_D_A1_XMax)(I_IAperture_In) - (*this->P_D_A1_XMin)(I_IAperture_In) + 1.)
                     / I_SwathWidth);
      if (I_NBin < 1)
        I_NBin = 1;
      cout << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBin << endl;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBin << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBin << endl;
#endif

    }
  }
  if (I_Pos < 0 || (I_Pos >= 0 && I_SwathWidth == 0))
    //  else///  if(not keyword_set(swath_width)) then begin
  { /// Estimate the Points of column crossing
    ///    i = uniq(long(ycen))                        ;Points of row crossing
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): this->P_D_A2_XCenters(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) << endl;
    cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): this->P_D_A2_XCenters(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): this->P_D_A2_XCenters(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) << endl;
#endif
    Array<int, 1> *p_tempIntArrA = Fix((*this->P_D_A2_XCenters)(I_IAperture_In, Range::all()));
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): p_tempIntArrA = " << *p_tempIntArrA << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): p_tempIntArrA = " << *p_tempIntArrA << endl;
#endif
    this->Uniq(*p_tempIntArrA, I_A1_I);
    delete p_tempIntArrA;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_A1_I set to " << I_A1_I << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_A1_I set to " << I_A1_I << endl;
#endif

    ///This is how many times this order crosses to the next column
    ///    ni = n_elements(i)                          ;This is how many times this order crosses to the next row
    I_NI = I_A1_I.size();
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NI set to " << I_NI << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NI set to " << I_NI << endl;
#endif

    /**
      if(ni gt 1) then begin                      ;Curved order crosses rows
        i = total(i(1:ni-1)-i(0:ni-2))/(ni-1)
        nbin = ((round(ncol/i) / 3)  > 3) < 20    ;number of swaths along the order
      endif else begin                            ;Perfectly aligned orders
        nbin = (ncol/400) > 3                     ;Still follow the changes in PSF
      endelse
    */
    ///Curved order crosses columns
    if (I_NI > 1)
    {
      I_I = sum(I_A1_I(Range(1, I_NI-1)) - I_A1_I(Range(0, I_NI - 2))) / (I_NI - 1);
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_I set to " << I_I << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_I set to " << I_I << endl;
#endif

      /// number of swaths along the order
      I_NBin = Round((double)this->NRows / (double)I_I) / 3;
//#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_NBin set to " << I_NBin << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_NBin set to " << I_NBin << endl;
//#endif
      if (I_NBin < 3)
        I_NBin = 3;






//        if (I_NBin > 20)
//        I_NBin = 20;





//#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_NBin set to " << I_NBin << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") > 1): I_NBin set to " << I_NBin << endl;
//#endif

    }
    else
    { /// Perfectly aligned orders
      /// Still follow the changes in PSF
      I_NBin = this->NRows / 400;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") <= 1): I_NBin set to " << I_NBin << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") <= 1): I_NBin set to " << I_NBin << endl;
#endif
      if (I_NBin < 3)
        I_NBin = 3;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") <= 1): I_NBin set to " << I_NBin << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): if(I_NI(=" << I_NI << ") <= 1): I_NBin set to " << I_NBin << endl;
#endif

    }

    /**
      nbin = nbin * (x_right_lim $                ;Adjust for the true order length
             - x_left_lim + 1) / ncol
    endif else $                                  ;If swath width is preset
      nbin = round((x_right_lim - x_left_lim + 1.) / swath_width)>1
    yc = fix(ycen)
    */
    /// Adjust for the true order length
    I_NBin = I_NBin * ((int)((*this->P_D_A1_XMax)(I_IAperture_In)) - (int)((*this->P_D_A1_XMin)(I_IAperture_In)) + 1) / this->NRows;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBin << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(SWATH_WIDTH): I_NBin set to " << I_NBin << endl;
#endif
  } /// if (!(I_Pos = this->KeyWord_Set(const_cast<const CString**>(PP_CS_Args), I_NArgs, CS_Temp)))

  //I_A1_XC.resize(D_A1_XCenters.size());
  P_I_A1_XC = Fix((*P_D_A2_XCenters)(I_IAperture_In, Range::all()));
//#ifdef __DEBUG_FITS_PISKUNOV__
cout << "CFits::MkSlitFunc: (*P_D_A2_XCenters)(I_IAperture_In=" << I_IAperture_In << ", Range::all()) set to " << (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) << endl;
  cout << "CFits::MkSlitFunc: P_I_A1_XC set to " << *P_I_A1_XC << endl;
//#endif

  /// Find columns that contain spectrum.
  ///  imin = yc - y_lower_lim                       ;bottom row of order
  I_A1_IMin.resize(P_I_A1_XC->size());

#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: this->P_D_A2_XCenters(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: this->P_D_A2_XCenters(I_IAperture_In=" << I_IAperture_In << ") = " << (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) << endl;
  cout << "CFits::MkSlitFunc: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
#endif




  /// TODO TODO TODO CHECK
  I_A1_IMin = (*P_I_A1_XC) + (*this->P_D_A1_XLow)(I_IAperture_In); /// Left row of order
  //      D_XLeftLim;
//#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_A1_IMin set to " << I_A1_IMin << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IMin set to " << I_A1_IMin << endl;
//#endif

  ///  imax = yc + y_upper_lim                       ;top row of order
  I_A1_IMax.resize(P_I_A1_XC->size());




  /// TODO TODO TODO CHECK
  I_A1_IMax = (*P_I_A1_XC) + (*this->P_D_A1_XHigh)(I_IAperture_In); /// Right row of order
//#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_A1_IMax set to " << I_A1_IMax << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IMax set to " << I_A1_IMax << endl;
//#endif
//return false;
  /// Calculate boundaries of distinct slitf regions.






  /// TODO TODO TODO CHECK: row or column
  /// Boundaries of bins
  ///  ibound = (x_right_lim - x_left_lim) * $
  ///           findgen(nbin+1) / nbin + x_left_lim  ;boundaries of bins
  D_A1_IBound.resize(I_NBin + 1);
  D_A1_IBound = i;
  D_A1_IBound *= ((*this->P_D_A1_XMax)(I_IAperture_In) -
                  (*this->P_D_A1_XMin)(I_IAperture_In))
                 / (double)I_NBin;
  D_A1_IBound += (*this->P_D_A1_XMin)(I_IAperture_In);
//#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_A1_IBound set to " << D_A1_IBound << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_IBound set to " << D_A1_IBound << endl;
//#endif

  /// Beginning of each bin
  ///  ibeg = ceil(ibound(0:nbin-1))                 ;beginning of each bin
  I_A1_IBeg.resize(I_NBin);
  D_A1_Temp.resize(I_NBin);
  if (D_A1_IBound.size() <= I_NBin)
  {
    cout << "CFits::MkSlitFunc: ERROR: D_A1_IBound.size(=" << D_A1_IBound.size() << ") < I_NBin(=" << I_NBin << ")" << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_IBound.size(=" << D_A1_IBound.size() << ") < I_NBin(=" << I_NBin << ")" << endl;
    return false;
  }
  D_A1_Temp = D_A1_IBound(Range(0, I_NBin-1));
  Array<long, 1> *p_ceil = this->Ceil(D_A1_Temp);
  Array<int, 1> *p_iceil = FixLI(*p_ceil);
  I_A1_IBeg = (*p_iceil);
  delete p_iceil;
  delete p_ceil;
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_A1_IBeg set to " << I_A1_IBeg << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IBeg set to " << I_A1_IBeg << endl;
  cout << "CFits::MkSlitFunc: P_D_A1_XMin = " << *P_D_A1_XMin << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XMin = " << *P_D_A1_XMin << endl;
#endif
  ///  ibeg(0) = x_left_lim
  I_A1_IBeg(0) = (int)((*this->P_D_A1_XMin)(I_IAperture_In));
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_A1_IBeg(0) set to " << I_A1_IBeg(0) << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IBeg(0) set to " << I_A1_IBeg(0) << endl;
#endif

  /// End of each bin
  ///  iend = floor(ibound(1:nbin))                  ;end of each bin
  I_A1_IEnd.resize(I_NBin);
  Array<int, 1> *p_tempIntArrB = Fix(D_A1_IBound(Range(1, I_NBin)));
  I_A1_IEnd = (*p_tempIntArrB);
  delete p_tempIntArrB;
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_A1_IEnd set to " << I_A1_IEnd << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IEnd set to " << I_A1_IEnd << endl;
#endif
  ///  iend(nbin-1) = x_right_lim
  I_A1_IEnd(I_NBin - 1) = (int)((*this->P_D_A1_XMax)(I_IAperture_In));
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_A1_IEnd(I_NBin - 1 = " << I_NBin - 1 << ") set to " << I_A1_IEnd(I_NBin - 1) << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_IEnd(I_NBin - 1 = " << I_NBin - 1 << ") set to " << I_A1_IEnd(I_NBin - 1) << endl;
#endif

  /// Center of each bin
  ///  bincen = 0.5*(ibeg + iend)                    ;center of each bin
  D_A1_BinCen.resize(I_NBin);
  D_A1_BinCen = 0.5 * (I_A1_IBeg + I_A1_IEnd);
//#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_A1_BinCen set to " << D_A1_BinCen << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_BinCen set to " << D_A1_BinCen << endl;
//#endif

  /**
  ;Initialize default parameters and arrays.
  if(keyword_set(osample)) then osamp=osample $ ;slitf pixels / real pixel
  else osamp = 14
  */
  /// Initialize default parameters and arrays.
  /*  CS_Temp.Set("OVERSAMPLE");
    if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
    {
      /// SlitF pixels / real pixel
      I_OverSample = *(int*)ArgV[I_Pos];
  #ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
  #endif
    }
    if (I_Pos < 0 || (I_Pos >= 0 && I_OverSample == 0))
    {
      I_OverSample = 14;
  #ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: !KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(OVERSAMPLE): I_OverSample set to " << I_OverSample << endl;
  #endif
  }*/

  CS_Temp.Set("BLZ");
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args, CString("BLZ"))) >= 0)
  {
    if (P_D_A1_BLZ != NULL)
      delete P_D_A1_BLZ;
    P_D_A1_BLZ = (Array<double, 1>*)ArgV[I_Pos];
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: KeyWord_Set(BLZ): P_D_A1_BLZ set to " << *P_D_A1_BLZ << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(BLZ): P_D_A1_BLZ set to " << *P_D_A1_BLZ << endl;
#endif

  }
  if (I_Pos < 0 || (I_Pos >= 0 && P_D_A1_BLZ->size() == 1 && abs((*P_D_A1_BLZ)(0)) < 0.000001))
  {
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: !KeyWord_Set(BLZ): P_D_A1_BLZ initialized " << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: !KeyWord_Set(BLZ): P_D_A1_BLZ initialized " << endl;
#endif

  }

  /**
  if(not keyword_set(lam_sf)) then $
    lambda_sf=1.$
  else $
    lambda_sf=lam_sf
  */
  CS_Temp.Set("LAMBDA_SF");
  cout << "CFits::MkSlitFunc: CS_A1_Args = " << CS_A1_Args << endl;
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  {
    cout << "CFits::MkSlitFunc: I_Pos = " << I_Pos << endl;
    D_LambdaSF = *(double*)ArgV[I_Pos];
    cout << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SF): D_LambdaSF set to " << D_LambdaSF << endl;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SF): D_LambdaSF set to " << D_LambdaSF << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SF): D_LambdaSF set to " << D_LambdaSF << endl;
#endif

  }

  /**
  if(not keyword_set(lam_sp)) then $
    lambda_sp=0  $
  else $
    lambda_sp=lam_sp
  */
  CS_Temp.Set("LAMBDA_SP");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  {
    I_LambdaSP = *(int*)ArgV[I_Pos];
    //#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SP): I_LambdaSP set to " << I_LambdaSP << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(LAMBDA_SP): I_LambdaSP set to " << I_LambdaSP << endl;
    //#endif
  }

  //  (*P_OFS_Log) << "CFits::MkSlitFunc: 2. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

  ///  irow = findgen(nrow)                          ;indices of all rows
  /// Indices of all columns
  D_A1_ICol.resize(this->NCols);
  D_A1_ICol = i;
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_A1_ICol set to " << D_A1_ICol << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_ICol set to " << D_A1_ICol << endl;
#endif

  ///  ycene = ycen(x_left_lim:x_right_lim)
  D_A1_XCentersE.resize((int)((*this->P_D_A1_XMax)(I_IAperture_In)) - (int)((*this->P_D_A1_XMin)(I_IAperture_In)) + 1);
  D_A1_XCentersE = (*P_D_A2_XCenters)(I_IAperture_In, Range((int)((*this->P_D_A1_XMin)(I_IAperture_In)), (int)((*this->P_D_A1_XMax)(I_IAperture_In))));
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_A1_XCentersE set to " << D_A1_XCentersE << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XCentersE set to " << D_A1_XCentersE << endl;
#endif

  ///  nysf = y_upper_lim + y_lower_lim + 1L         ;subpixel range required
  /// subpixel range required
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
#endif

  I_NXSF = (int)((*this->P_D_A1_XHigh)(I_IAperture_In)) - (int)((*this->P_D_A1_XLow)(I_IAperture_In)) + 1;
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_NXSF set to " << I_NXSF << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_NXSF set to " << I_NXSF << endl;
#endif

  ///  yslitf0 = -y_lower_lim                        ;minimum value for yslitf
  /// Minimum value for I_A1_XSlitFunc
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: Setting I_XSlitFunc0: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: Setting I_XSlitFunc0: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
#endif

  I_XSlitFunc0 = (int)((*this->P_D_A1_XLow)(I_IAperture_In));
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_XSlitFunc0 set to " << I_XSlitFunc0 << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_XSlitFunc0 set to " << I_XSlitFunc0 << endl;
#endif

  //  I_A1_IMin = (*P_D_A2_XCenters)(I_IAperture_In, Range::all()) + (*this->P_D_A1_XLow)(I_IAperture_In); /// Left row of order

  ///  yslitf1 =  y_upper_lim                        ;maximum value for yslitf
  /// Maximum value for I_A1_XSlitFunc
  I_XSlitFunc1 = (int)(*this->P_D_A1_XHigh)(I_IAperture_In);
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_XSlitFunc1 set to " << I_XSlitFunc1 << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_XSlitFunc1 set to " << I_XSlitFunc1 << endl;
#endif

  ///  blz = fltarr(ncol)
  P_D_A1_BLZ->resize(this->NRows);
  (*P_D_A1_BLZ) = 0.;
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: P_D_A1_BLZ set to " << (*P_D_A1_BLZ) << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_BLZ set to " << (*P_D_A1_BLZ) << endl;
#endif

  ///  for i=0, nbin-1 do begin                 ;loop thru sf regions
  /// Calculate slit functions within each bin

  //  (*P_OFS_Log) << "CFits::MkSlitFunc: 3. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

  for (int m = 0; m < I_NBin; m++) /// Loop thru sf regions
  {
    ///    ib = ibeg(i)                           ;left column
    if (m >= I_A1_IBeg.size())
    {
      cout << "CFits::MkSlitFunc: ERROR: m(=" << m << ") >= I_A1_IBeg.size(=" << I_A1_IBeg.size() << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: m(=" << m << ") >= I_A1_IBeg.size(=" << I_A1_IBeg.size() << ")" << endl;
      return false;
    }
    I_IB = I_A1_IBeg(m);    /// Lower row
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): Resizing D_A2_SF: I_IB set to " << I_IB << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): I_IB set to " << I_IB << endl;
#endif
    ///    ie = iend(i)                           ;right column
    I_IE = I_A1_IEnd(m);    /// Upper row
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): Resizing D_A2_SF: I_IE set to " << I_IE << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): I_IE set to " << I_IE << endl;
#endif
    ///    nc = ie - ib + 1                       ;number of columns
    I_NR = I_IE - I_IB + 1; /// Number of rows (Y-Direction)
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): Resizing D_A2_SF: I_NR set to " << I_NR << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): I_NR set to " << I_NR << endl;
#endif

    /// Load slit function data into vectors
    ///    nsf = nc * nysf                                          ;# slit func points
    I_NSF = I_NR * I_NXSF;    /// # slit func points
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): I_NSF = " << I_NSF << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): I_NSF = " << I_NSF << endl;
#endif
    ///    j0 = lonarr(nc)
    I_A1_J0.resize(I_NR);
    I_A1_J0 = 0;
    ///    j1 = lonarr(nc)
    I_A1_J1.resize(I_NR);
    I_A1_J1 = 0;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: I_A1_J0 and I_A1_J1 initialized to " << I_A1_J0.size() << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: I_A1_J0 and I_A1_J1 initialized to " << I_A1_J0.size() << endl;
#endif
    /*#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): Resizing D_A2_SF: I_NR = " << I_NR << ", I_NXSF = " << I_NXSF << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): Resizing D_A2_SF: I_NR = " << I_NR << ", I_NXSF = " << I_NXSF << endl;
    #endif
    */
    /*    if (I_NR < 1)
          I_NR = 1;
        if (I_NXSF < 1)
          I_NXSF = 1;
    */
    ///    sf = fltarr(nc,nysf)
    D_A2_SF.resize(I_NR, I_NXSF);
    D_A2_SF = 0.;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: D_A2_SF initialized to " << D_A2_SF.rows() << " x " << D_A2_SF.cols() << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A2_SF initialized to " << D_A2_SF.rows() << " x " << D_A2_SF.cols() << endl;
#endif

    ///    sfpnt = fltarr(nsf)
    D_A1_SFPnt.resize(I_NSF);
    D_A1_SFPnt = 0.;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: D_A1_SFPnt initialized to " << D_A1_SFPnt.size() << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_SFPnt initialized to " << D_A1_SFPnt.size() << endl;
#endif

    ///    ysfpnt = fltarr(nsf)
    D_A1_XSFPnt.resize(I_NSF);
    D_A1_XSFPnt = 0.;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: D_A1_XSFPnt initialized to " << D_A1_XSFPnt.size() << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XSFPnt initialized to " << D_A1_XSFPnt.size() << endl;
#endif

    ///    if(imask) then msk = bytarr(nc,nysf)
    if (I_IMask)
      D_A2_Msk.resize(I_NR, I_NXSF);
    else
      D_A2_Msk.resize(1, 1);

    D_A2_Msk = 0.;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): D_A2_Msk initialized to " << D_A2_Msk.rows() << " x " << D_A2_Msk.cols() << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): D_A2_Msk initialized to " << D_A2_Msk.rows() << " x " << D_A2_Msk.cols() << endl;
#endif

    /// loop thru columns in region
    ///    for j=0, nc-1 do begin              ;loop thru rows in region
    for (int n = 0; n < I_NR; n++)
    {

      //      (*P_OFS_Log) << "CFits::MkSlitFunc: 4. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

      /// column closest to peak
      ///      icen = yc(ib+j)                   ;row closest to peak
      if (I_IB + n >= P_I_A1_XC->size())
      {
        cout << "CFits::MkSlitFunc: ERROR: I_IB(=" << I_IB << ") + n(=" << n << ") >= P_I_A1_XC->size(=" << P_I_A1_XC->size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_IB(=" << I_IB << ") + n(=" << n << ") >= P_I_A1_XC.size(=" << P_I_A1_XC->size() << ")" << endl;
        return false;
      }
      I_ICen = (*P_I_A1_XC)(I_IB + n);
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_ICen set to " << I_ICen << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_ICen set to " << I_ICen << endl;
#endif

      /// lowest column to consider
      ///      k0 = icen + yslitf0               ;lowest row to consider
      I_K0 = I_ICen + I_XSlitFunc0;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_K0 set to " << I_K0 << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_K0 set to " << I_K0 << endl;
#endif

      /// highest column to consider
      ///      k1 = icen + yslitf1               ;highest row to consider
      I_K1 = I_ICen + I_XSlitFunc1;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_K1 set to " << I_K1 << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_K1 set to " << I_K1 << endl;
#endif

      /// beginning of storage area
      ///      j0(j) = j*nysf                    ;begining of storage area
      if (n >= I_A1_J0.size())
      {
        cout << "CFits::MkSlitFunc: ERROR: n(=" << n << ") != I_A1_J0.size(=" << I_A1_J0.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: n(=" << n << ") != I_A1_J0.size(=" << I_A1_J0.size() << ")" << endl;
        return false;
      }
      I_A1_J0(n) = n * I_NXSF;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A1_J0(n) set to " << I_A1_J0(n) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A1_J0(n) set to " << I_A1_J0(n) << endl;
#endif

      /// new logic (works at edge)
      ///      j1(j) = j0(j) + k1 - k0           ;new logic (works at edge)
      I_A1_J1(n) = I_A1_J0(n) + I_K1 - I_K0;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A1_J1(n) set to " << I_A1_J1(n) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): I_A1_J1(n) set to " << I_A1_J1(n) << endl;
#endif
      D_A1_SSF.resize(I_K1 - I_K0 + 1);
      ///      if(keyword_set(no_scatter)) then begin
      CS_Temp.Set("NO_SCATTER");
      if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0 && *(int*)ArgV[I_Pos] != 0)
      {
        ///        ssf = im(ib+j,k0:k1)
        D_A1_SSF = (*(const_cast<CFits*>(this)->P_D_A2_PixArray))(I_IB + n, Range(I_K0, I_K1));
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc:  for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): KeyWord_Set(NO_SCATTER): D_A1_SSF set to " << D_A1_SSF << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): KeyWord_Set(NO_SCATTER): D_A1_SSF set to " << D_A1_SSF << endl;
#endif

      }///      endif else begin
      else
      {
        /// Interpolate background
        ///        dy_scatter =   (dindgen(nysf) + k0 - yscatter_below(ib+j)) $
        D_A1_DXScatter.resize(I_NXSF);
        D_A1_DXScatter = i;

        if (I_IB + n >= D_A1_XScatterBelow.size())
        {
          cout << "CFits::MkSlitFunc: ERROR: I_IB(=" << I_IB << ") + n(=" << n << ") >= D_A1_XScatterBelow.size(=" << D_A1_XScatterBelow.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_IB(=" << I_IB << ") + n(=" << n << ") >= D_A1_XScatterBelow.size(=" << D_A1_XScatterBelow.size() << ")" << endl;
          return false;
        }
        if (I_IB + n >= D_A1_XScatterAbove.size())
        {
          cout << "CFits::MkSlitFunc: ERROR: I_IB(=" << I_IB << ") + n(=" << n << ") >= D_A1_XScatterAbove.size(=" << D_A1_XScatterAbove.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_IB(=" << I_IB << ") + n(=" << n << ") >= D_A1_XScatterAbove.size(=" << D_A1_XScatterAbove.size() << ")" << endl;
          return false;
        }
        D_A1_DXScatter += (double)I_K0 - D_A1_XScatterBelow(I_IB + n);
        ///                     / (yscatter_above(ib+j) - yscatter_below(ib+j))
        D_A1_DXScatter /= (D_A1_XScatterAbove(I_IB + n)
                           - D_A1_XScatterBelow(I_IB + n));
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_DXScatter set to " << D_A1_DXScatter << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_DXScatter set to " << D_A1_DXScatter << endl;
#endif
        ///        scatter = (scatter_above(ib+j)-scatter_below(ib+j))* $
        D_A1_Scatter.resize(I_NXSF);
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_ScatterAbove(I_IB+n) = " << D_A1_ScatterAbove(I_IB+n) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_ScatterAbove(I_IB+n) = " << D_A1_ScatterAbove(I_IB+n) << endl;
#endif
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_ScatterBelow(I_IB+n) = " << D_A1_ScatterBelow(I_IB+n) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_ScatterBelow(I_IB+n) = " << D_A1_ScatterBelow(I_IB+n) << endl;
#endif

        D_A1_Scatter = D_A1_ScatterAbove(I_IB + n) - D_A1_ScatterBelow(I_IB + n);
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
#endif
        ///                  * dy_scatter+scatter_below(ib+j)
        if (D_A1_Scatter.size() != D_A1_DXScatter.size())
        {
          cout << "CFits::MkSlitFunc: ERROR: D_A1_Scatter.size(=" << D_A1_Scatter.size() << ") != D_A1_DXScatter.size(=" << D_A1_DXScatter.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_Scatter.size(=" << D_A1_Scatter.size() << ") != D_A1_DXScatter.size(=" << D_A1_DXScatter.size() << ")" << endl;
          return false;
        }
        D_A1_Scatter *= D_A1_DXScatter;
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
#endif
        D_A1_Scatter += D_A1_ScatterBelow(I_IB + n);
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_Scatter set to " << D_A1_Scatter << endl;
#endif
        /// compute normalized slit func
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: this->P_D_A2_PixArray(I_IB(=" << I_IB << ") + n(=" << n << ") = " << I_IB + n << ", Range(I_K0(=" << I_K0 << "), I_K1(=" << I_K1 << ") = " << Range(I_K0, I_K1) << ") = " << (*this->P_D_A2_PixArray)(I_IB + n, Range(I_K0, I_K1)) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: this->P_D_A2_PixArray(I_IB(=" << I_IB << ") + n(=" << n << ") = " << I_IB + n << ", Range(I_K0(=" << I_K0 << "), I_K1(=" << I_K1 << ") = " << Range(I_K0, I_K1) << ") = " << (*this->P_D_A2_PixArray)(I_IB + n, Range(I_K0, I_K1)) << endl;
#endif
        /// compute normalized slit func
        ///        ssf = (im(ib+j,k0:k1) - scatter)
        if (D_A1_Scatter.size() != D_A1_SSF.size())
        {
          cout << "CFits::MkSlitFunc: ERROR: D_A1_Scatter.size(=" << D_A1_Scatter << ") != D_A1_SSF.size(=" << D_A1_SSF.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_Scatter.size(=" << D_A1_Scatter << ") != D_A1_SSF.size(=" << D_A1_SSF.size() << ")" << endl;
          return false;
        }
        if (D_A1_SSF.size() != I_K1 - I_K0 + 1)
        {
          cout << "CFits::MkSlitFunc: ERROR: D_A1_SSF.size(=" << D_A1_SSF.size() << ") != I_K1(=" << I_K1 << ") - I_K0(=" << I_K0 << ") + 1" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_SSF.size(=" << D_A1_SSF.size() << ") != I_K1(=" << I_K1 << ") - I_K0(=" << I_K0 << ") + 1" << endl;
          return false;
        }
        if (this->P_D_A2_PixArray->rows() <= I_IB + n)
        {
          cout << "CFits::MkSlitFunc: ERROR: this->P_D_A2_PixArray.rows(=" << P_D_A2_PixArray->rows() << ") <= I_IB(=" << I_IB << ") + n(=" << n << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: this->P_D_A2_PixArray.rows(=" << P_D_A2_PixArray->rows() << ") <= I_IB(=" << I_IB << ") + n(=" << n << ")" << endl;
          return false;
        }
        if (this->P_D_A2_PixArray->cols() <= I_K1)
        {
          cout << "CFits::MkSlitFunc: ERROR: this->P_D_A2_PixArray->cols(=" << this->P_D_A2_PixArray->cols() << ") <= I_K1(=" << I_K1 << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: this->P_D_A2_PixArray->cols(=" << this->P_D_A2_PixArray->cols() << ") <= I_K1(=" << I_K1 << ")" << endl;
          return false;
        }
        D_A1_SSF = (*(const_cast<CFits*>(this)->P_D_A2_PixArray))(I_IB + n, Range(I_K0, I_K1)) - D_A1_Scatter;
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_SSF set to " << D_A1_SSF << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): Scatter+: D_A1_SSF set to " << D_A1_SSF << endl;
#endif
        ///      endelse
      }/// end if (SCATTER)

      ///      sf(j,*) = ssf
      if (D_A2_SF.cols() != D_A1_SSF.size())
      {
        cout << "CFits::MkSlitFunc: ERROR: D_A2_SF.cols(=" << D_A2_SF.cols() << ") != D_A1_SSF.size(=" << D_A1_SSF.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A2_SF.cols(=" << D_A2_SF.cols() << ") != D_A1_SSF.size(=" << D_A1_SSF.size() << ")" << endl;
        return false;
      }
      D_A2_SF(n, Range::all()) = D_A1_SSF;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SF(n, *) set to " << D_A2_SF(n, Range::all()) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SF(n, *) set to " << D_A2_SF(n, Range::all()) << endl;
#endif
      ///      sfpnt(j0(j):j1(j)) = ssf
      if (D_A1_SFPnt.size() <= I_A1_J1(n))
      {
        cout << "CFits::MkSlitFunc: ERROR: D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ") <= I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ") <= I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << endl;
        return false;
      }
      D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) = D_A1_SSF;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_SFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_SFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
#endif

      ///      ysfpnt(j0(j):j1(j)) = irow(k0:k1) - ycen(ib+j)
      if (D_A1_XSFPnt.size() <= I_A1_J1(n))
      {
        cout << "CFits::MkSlitFunc: ERROR: D_A1_XSFPnt.size(=" << D_A1_XSFPnt.size() << ") <= I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_XSFPnt.size(=" << D_A1_XSFPnt.size() << ") <= I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << endl;
        return false;
      }
      if (D_A1_ICol.size() <= I_K1)
      {
        cout << "CFits::MkSlitFunc: ERROR: D_A1_ICol.size(=" << D_A1_ICol.size() << ") <= I_K1(=" << I_K1 << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_ICol.size(=" << D_A1_ICol.size() << ") <= I_K1(=" << I_K1 << ")" << endl;
        return false;
      }
      if (I_K1 - I_K0 != I_A1_J1(n) - I_A1_J0(n))
      {
        cout << "CFits::MkSlitFunc: ERROR: I_K1 - I_K0 (=" << I_K1 - I_K0 << ") != I_A1_J1(n) - I_A1_J0(n) = " << I_A1_J1(n) - I_A1_J0(n) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_K1 - I_K0 (=" << I_K1 - I_K0 << ") != I_A1_J1(n) - I_A1_J0(n) = " << I_A1_J1(n) - I_A1_J0(n) << endl;
        return false;
      }
      D_A1_XSFPnt(Range(I_A1_J0(n), I_A1_J1(n))) = D_A1_ICol(Range(I_K0, I_K1)) - (*P_D_A2_XCenters)(I_IAperture_In, I_IB + n);
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_XSFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_XSFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_XSFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_XSFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
#endif
      ///      if(imask) then msk(j,*) = mask(ib+j,k0:k1)
      if (I_IMask)
      {
        if (D_A2_Msk.cols() != I_K1-I_K0+1)
        {
          cout << "CFits::MkSlitFunc: ERROR: D_A2_Msk.cols(=" << D_A2_Msk.cols() << ") != I_K1-I_K0+1(=" << I_K1-I_K0+1 << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A2_Msk.cols(=" << D_A2_Msk.cols() << ") != I_K1-I_K0+1(=" << I_K1-I_K0+1 << ")" << endl;
          return false;
        }
        if (n >= D_A2_Msk.rows())
        {
          cout << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A2_Msk.rows(=" << D_A2_Msk.rows() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A2_Msk.rows(=" << D_A2_Msk.rows() << ")" << endl;
          return false;
        }
        if (D_A2_Mask.cols() <= I_K1)
        {
          cout << "CFits::MkSlitFunc: ERROR: D_A2_Mask.cols(=" << D_A2_Mask.cols() << ") <= I_K1(=" << I_K1 << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A2_Mask.cols(=" << D_A2_Mask.cols() << ") <= I_K1(=" << I_K1 << ")" << endl;
          return false;
        }
        if (I_IB+n >= D_A2_Mask.rows())
        {
          cout << "CFits::MkSlitFunc: ERROR: I_IB+n(=" << I_IB+n << ") >= D_A2_Mask.rows(=" << D_A2_Mask.rows() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_IB+n(=" << I_IB+n << ") >= D_A2_Mask.rows(=" << D_A2_Mask.rows() << ")" << endl;
          return false;
        }
        D_A2_Msk(n, Range::all()) = D_A2_Mask(I_IB + n, Range(I_K0, I_K1));
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): if (I_IMask): D_A2_Msk(n, Range::all()) set to " << D_A2_Msk(n, Range::all()) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): if (I_IMask): D_A2_Msk(n, Range::all()) set to " << D_A2_Msk(n, Range::all()) << endl;
#endif

      }
      ///    endfor
    } /// for (int n = 0; n < I_NR; n++)
    if (max(D_A2_Msk) > 1.){
      cout << "CFits::MkSlitFunc: ERROR: max(D_A2_Msk=" << D_A2_Msk << ") = " << max(D_A2_Msk) << " > 1 => Returning FALSE" << endl;
      return false;
    }
    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 5. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    ///      if(keyword_set(telluric)) then begin
    CS_Temp.Set("TELLURIC");
    if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
    {

      ///      tel=total(sf,1)
      D_A1_Tel.resize(D_A2_SF.cols());
      D_A1_Tel = sum(D_A2_SF(j, i), j);
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A1_Tel set to " << D_A1_Tel << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A1_Tel set to " << D_A1_Tel << endl;
#endif
      ///      itel=where(tel le (max(tel)-min(tel))/100.+min(tel),ntel)
      I_A1_ITel.resize(D_A1_Tel.size());
      I_A1_ITel = where(D_A1_Tel <= (max(D_A1_Tel) - min(D_A1_Tel))
                        / 100. + min(D_A1_Tel), 1, 0);
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): I_A1_ITel set to " << I_A1_ITel << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): I_A1_ITel set to " << I_A1_ITel << endl;
#endif
      ///      tel=sf(*,itel)
      D_A2_Tel.resize(D_A2_SF.rows(), sum(I_A1_ITel));
      pos = 0;
      for (int o = 0; o < I_A1_ITel.size(); o++)
      {
        if (I_A1_ITel(o) == 1)
        {
          D_A2_Tel(Range::all(), pos) = D_A2_SF(Range::all(), o);
          pos++;
        }
      }
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A2_Tel set to " << D_A2_Tel << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A2_Tel set to " << D_A2_Tel << endl;//.transpose(secondDim, firstDim) << endl;
#endif
      /// ???????????????????????????????
      /// reform(transpose(array) => array) => row vector   ?????????????????????
      /// ???????????????????????????????

      ///      sc=dblarr(nc)
      D_A1_SC.resize(I_NR);
      D_A1_SC = 0.;


      ///      for itel=0,nc-1 do $
      for (int o = 0; o < I_NR; o++)
      {
        ///        sc(itel)=median(reform(tel(itel,*)))
        if (o >= D_A2_Tel.rows())
        {
          cout << "CFits::MkSlitFunc: ERROR: o(=" << o << ") >= D_A2_Tel.rows(=" << D_A2_Tel.rows() << ")" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: o(=" << o << ") >= D_A2_Tel.rows(=" << D_A2_Tel.rows() << ")" << endl;
          return false;
        }
        D_A1_SC(o) = Median(D_A2_Tel(o, Range::all()));
      }
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A1_SC set to " << D_A1_SC << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A1_SC set to " << D_A1_SC << endl;
#endif
      /*      if (D_A2_SF.cols() == 0)
            {
              cout << "CFits::MkSlitFunc: D_A2_SF.cols(=" << D_A2_SF << ") == 0!!!" << endl;
              (*P_OFS_Log) << "CFits::MkSlitFunc: D_A2_SF.cols(=" << D_A2_SF << ") == 0!!!" << endl;
              D_A2_SF.resizeAndPreserve(1, 1);
          }*/
      ///      sf = sf - sc#replicate(1,yslitf1-yslitf0+1)
      I_A1_Temp.resize(I_XSlitFunc1 - I_XSlitFunc0 + 1);
      I_A1_Temp = 1;
      D_A2_SF.resizeAndPreserve(I_NR, I_A1_Temp.size());

      Array<double, 1> *p_tempDblVecArr = FixD(I_A1_Temp);
      Array<double, 2> *p_d2mata = VecArrACrossB(D_A1_SC, *p_tempDblVecArr);
      delete p_tempDblVecArr;

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): I_NR = " << I_NR << ", I_A1_Temp.size() = " << I_A1_Temp.size() << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): I_NR = " << I_NR << ", I_A1_Temp.size() = " << I_A1_Temp.size() << endl;
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A1_SC = " << D_A1_SC << ", VecArrACrossB(D_A1_SC, FixD(I_A1_Temp)) = " << *p_d2mata << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A1_SC = " << D_A1_SC << ", VecArrACrossB(D_A1_SC, FixD(I_A1_Temp)) = " << *p_d2mata << endl;
#endif
      if (D_A2_SF.rows() != D_A1_SC.size())
      {
        cout << "CFits::MkSlitFunc: ERROR: D_A2_SF.rows(=" << D_A2_SF.rows() << ") != D_A1_SC.size(=" << D_A1_SC.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A2_SF.rows(=" << D_A2_SF.rows() << ") != D_A1_SC.size(=" << D_A1_SC.size() << ")" << endl;
        return false;
      }
      if (D_A2_SF.cols() != I_A1_Temp.size())
      {
        cout << "CFits::MkSlitFunc: ERROR: D_A2_SF.cols(=" << D_A2_SF.cols() << ") != I_A1_Temp.size(=" << I_A1_Temp.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A2_SF.cols(=" << D_A2_SF.cols() << ") != I_A1_Temp.size(=" << I_A1_Temp.size() << ")" << endl;
        return false;
      }
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): p_d2mata = " << *p_d2mata << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): p_d2mata = " << *p_d2mata << endl;//.transpose(secondDim, firstDim) << endl;
#endif
      D_A2_SF -= (*p_d2mata);
      delete p_d2mata;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A2_SF set to " << D_A2_SF << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): D_A2_SF set to " << D_A2_SF << endl;//.transpose(secondDim, firstDim) << endl;
#endif

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: I_NR(=" << I_NR << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: I_NR(=" << I_NR << endl;

      cout << "CFits::MkSlitFunc: I_NR(=" << I_NR << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: I_NR(=" << I_NR << endl;
#endif
      /// replicate(1, yslitf1 - yslitf0 + 1) => dblarr(yslitf1 - yslitf0 + 1)
      /// sc#replicate(...) => dblarr(nc, yslitf1 - yslitf0 + 1)
      /// sf - sc#replicate(...) => dblarr(nc, yslitf1 - yslitf0 + 1)

      ///      sfpnt = reform(transpose(sf),n_elements(sfpnt))
      //      D_A1_SFPnt.resize(I_NR * I_A1_Temp.size());
      if (D_A1_SFPnt.size() != D_A2_SF.size())
      {
        cout << "CFits::MkSlitFunc: ERROR: D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ") != D_A2_SF.size(=" << D_A2_SF.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ") != D_A2_SF.size(=" << D_A2_SF.size() << ")" << endl;
        return false;
      }
      Array<double, 1> *p_D_A1_SFPnt = this->Reform(D_A2_SF);
      D_A1_SFPnt.resize(p_D_A1_SFPnt->size());
      D_A1_SFPnt = (*p_D_A1_SFPnt);
      delete p_D_A1_SFPnt;

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): MARK: D_A1_SFPnt set to " << D_A1_SFPnt << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(TELLURIC): MARK: D_A1_SFPnt set to " << D_A1_SFPnt << endl;
#endif

    } /// end if (I_Pos = this->KeyWord_Set(const_cast<const CString**>(PP_CS_Args), I_NArgs, CS_Temp))
    /**
    jgood=0
    slit_func,sf,ycen(ib:ie)-yc(ib:ie),sp,sfsm,
              NOISE=noise,
              OVERSAMPLE=osamp,
              IM_OUT=sfbin,
              LAMBDA_SF=lambda_sf,
              LAMBDA_SP=lambda_sp,
              USE_COL=jgood,
              BAD=jbad,
              MASK=msk
    */
    I_JGood = 0;
    I_A1_JBad = 0;
    double d_noise = 0.;
    int I_UseRow = 0;
    D_A2_SFBin.resize(this->NRows, this->NCols);
    D_A2_SFBin = 0.;
    //    CString **pp_cstr = (CString**)malloc(sizeof(CString*) * 8);
    pppos = 0;

    args[pppos] = &d_noise;
    pppos++;

    //    args[pppos] = &I_OverSample;
    //    pppos++;

    args[pppos] = &D_A2_SFBin;
    pppos++;

    args[pppos] = &D_LambdaSF;
    pppos++;

    args[pppos] = &I_LambdaSP;
    pppos++;

    args[pppos] = &I_UseRow;
    pppos++;

    args[pppos] = &I_A1_JBad;
    pppos++;

    args[pppos] = &D_A2_Msk;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: D_A2_Mask = " << D_A2_Mask << endl;//.transpose(secondDim, firstDim) << endl;
    cout << "CFits::MkSlitFunc: args[" << pppos << "] set to " << *(Array<double, 2>*)args[pppos] << endl;
#endif
    pppos++;

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 6. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    ///slit_func,sf,
    ///          ycen(ib:ie)-yc(ib:ie),
    ///          sp,
    ///          sfsm,
    ///          NOISE=noise,
    ///          OVERSAMPLE=osamp,
    ///          IM_OUT=sfbin,
    ///          LAMBDA_SF=lambda_sf,
    ///          LAMBDA_SP=lambda_sp,
    ///          USE_COL=jgood,
    ///          BAD=jbad,
    ///          MASK=msk
    //    Array<double, 1> D_A1_SF(D_A2_SF.cols());
    //    D_A1_SF = D_A2_SF(0,Range::all());

    D_A1_XCenMXC.resize(I_IE - I_IB + 1);
    if (I_IE >= P_D_A2_XCenters->cols())
    {
      cout << "CFits::MkSlitFunc: ERROR: I_IE(=" << I_IE << ") >= P_D_A2_XCenters->cols(=" << P_D_A2_XCenters->cols() << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_IE(=" << I_IE << ") >= P_D_A2_XCenters->cols(=" << P_D_A2_XCenters->cols() << ")" << endl;
      return false;
    }
    if (I_IE >= P_I_A1_XC->size())
    {
      cout << "CFits::MkSlitFunc: ERROR: I_IE(=" << I_IE << ") >= P_I_A1_XC.size(=" << P_I_A1_XC->size() << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_IE(=" << I_IE << ") >= P_I_A1_XC.size(=" << P_I_A1_XC->size() << ")" << endl;
      return false;
    }







    ///  TODO TODO TODO
    D_A1_XCenMXC = (*P_D_A2_XCenters)(I_IAperture_In, Range(I_IB, I_IE)) - (*P_I_A1_XC)(Range(I_IB, I_IE));

#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): Starting SlitFunc: D_A2_SF = Im_In = " << D_A2_SF << endl;//.transpose(secondDim, firstDim) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): Starting SlitFunc: D_A2_SF = Im_In = " << D_A2_SF << endl;//.transpose(secondDim, firstDim) << endl;
#endif

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 6.A this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    cout << "CFits::MkSlitFunc: " << *P_CS_FileName << ": for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): I_IAperture_In = " << I_IAperture_In << ": Starting SlitFunc" << endl;//.transpose(secondDim, firstDim) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: " << *P_CS_FileName << ": for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): I_IAperture_In = " << I_IAperture_In << ": Starting SlitFunc" << endl;//.transpose(secondDim, firstDim) << endl;

#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): I_IAperture_In = " << I_IAperture_In << ": D_A2_SF = " << D_A2_SF << endl;//.transpose(secondDim, firstDim) << endl;
#endif

    if (!this->SlitFunc_Old(D_A2_SF,
                        I_IAperture_In,
                        D_A1_XCenMXC,
                        D_A1_SP,
                        D_A1_SFSM,
                        //                        pppos,
                        *(const_cast<const Array<CString, 1>*>(&cs_a1)),
                        args))
    {
      /*      for (int ipos = 0; ipos < pppos; ipos++)
            {
              delete pp_cstr[ipos];
      //        delete args[ipos];
          }*/
      //      delete pp_cstr;
      //      delete(args);
      cout << "CFits::MkSlitFunc: ERROR: SlitFunc returned FALSE!" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: SlitFunc returned FALSE!" << endl;
      return false;
    }
    cout << "CFits::MkSlitFunc: SlitFunc ready" << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: SlitFunc ready" << endl;

#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: After SlitFunc: D_A1_SP =  " << D_A1_SP << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: After SlitFunc: D_A1_SP = " << D_A1_SP << endl;

    cout << "CFits::MkSlitFunc: After SlitFunc: D_A1_SFSM =  " << D_A1_SFSM << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: After SlitFunc: D_A1_SFSM = " << D_A1_SFSM << endl;

    cout << "CFits::MkSlitFunc: After SlitFunc: D_A2_SFBin = Im_Out = " << D_A2_SFBin << endl;//.transpose(secondDim, firstDim) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: After SlitFunc: D_A2_SFBin = Im_Out = " << D_A2_SFBin << endl;//.transpose(secondDim, firstDim) << endl;

    int tempppos = 0;
    if (m < 100)
    {
      tmpstr[tempppos] = 0;
      tempppos++;
    }
    else if (m < 10)
    {
      tmpstr[tempppos] = 0;
      tempppos++;
    }
    if (m > 10)
    {
      int tempm = m / 10;
      switch(tempm)
      {
      case 1: tmpstr[tempppos] = '1';
      case 2: tmpstr[tempppos] = '2';
      case 3: tmpstr[tempppos] = '3';
      case 4: tmpstr[tempppos] = '4';
      case 5: tmpstr[tempppos] = '5';
      case 6: tmpstr[tempppos] = '6';
      case 7: tmpstr[tempppos] = '7';
      case 8: tmpstr[tempppos] = '8';
      case 9: tmpstr[tempppos] = '9';
      }
      tempppos++;
      m -= 10 * tempm;
    }
    switch(m)
    {
    case 1: tmpstr[tempppos] = '1';
    case 2: tmpstr[tempppos] = '2';
    case 3: tmpstr[tempppos] = '3';
    case 4: tmpstr[tempppos] = '4';
    case 5: tmpstr[tempppos] = '5';
    case 6: tmpstr[tempppos] = '6';
    case 7: tmpstr[tempppos] = '7';
    case 8: tmpstr[tempppos] = '8';
    case 9: tmpstr[tempppos] = '9';
    }

    tmpstr[tempppos+1] = '\0';
    this->WriteArrayToFile(D_A2_SFBin, CString("/home/azuri/entwicklung/c/fitsutil/cfits/test/SlitFunc_SFBin_out") + CString(tmpstr) + CString(".dat"), CString("ascii"));
    cout << "CFits::MkSlitFunc: After SlitFunc: I_A1_JBad =  " << I_A1_JBad << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: After SlitFunc: I_A1_JBad = " << I_A1_JBad << endl;
    cout << "CFits::MkSlitFunc: After SlitFunc: d_noise =  " << d_noise << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: After SlitFunc: d_noise = " << d_noise << endl;
#endif

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 7. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    /**
    nbad=n_elements(jbad)
    if(nbad eq 1) then $
      if(jbad eq -1) then $
        nbad=0
    */
    I_NBad = I_A1_JBad.size();
    if (I_NBad == 1)
    {
      if (I_A1_JBad.size() == 1 && I_A1_JBad(0) == -1)
        I_NBad = 0;
    }
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: After SlitFunc: I_NBad =  " << I_NBad << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: After SlitFunc: I_NBad = " << I_NBad << endl;
#endif
    /// Normalize sfpnt for the plot
    ///    for j=0,nc-1 do begin          ; Normalize sfpnt for the plot
    for (int n = 0; n < I_NR; n++)
    {

      //      (*P_OFS_Log) << "CFits::MkSlitFunc: 8. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

      ///      sfpnt(j0(j):j1(j)) = sfpnt(j0(j):j1(j)) / (sp(j)>1.)
      if (n >= D_A1_SP.size())
      {
        cout << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A1_SP.size(=" << D_A1_SP.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A1_SP.size(=" << D_A1_SP.size() << ")" << endl;
        return false;
      }
      d_tmp = D_A1_SP(n);
      if (d_tmp < 1.)
        d_tmp = 1.;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_SFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) was " << D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_SFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) was " << D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
#endif
      if (I_A1_J1(n) >= D_A1_SFPnt.size())
      {
        cout << "CFits::MkSlitFunc: ERROR: I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << " >= D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_A1_J1(n=" << n << ")=" << I_A1_J1(n) << " >= D_A1_SFPnt.size(=" << D_A1_SFPnt.size() << ")" << endl;
        return false;
      }
      D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) /= d_tmp;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_SFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A1_SFPnt(Range(I_A1_J0(n)=" << I_A1_J0(n) << ", I_A1_J1(n)=" << I_A1_J1(n) << ")) set to " << D_A1_SFPnt(Range(I_A1_J0(n), I_A1_J1(n))) << endl;
#endif

      ///      sfbin(j,*) = sfbin(j,*) / (sp(j)>1.)
      if (n >= D_A2_SFBin.rows())
      {
        cout << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A2_SFBin.rows(=" << D_A2_SFBin.rows() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: n(=" << n << ") >= D_A2_SFBin.rows(=" << D_A2_SFBin.rows() << ")" << endl;
        return false;
      }
      D_A2_SFBin(n, Range::all()) /= d_tmp;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SFBin(n, Range::all()) set to " << D_A2_SFBin(n, Range::all()) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int n(=" << n << ") = 0; n < I_NR(=" << I_NR << "); n++): D_A2_SFBin(n, Range::all()) set to " << D_A2_SFBin(n, Range::all()) << endl;
#endif
      ///    endfor
    }/// end for (int n = 0; n < I_NR; n++)
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFPnt =  " << D_A1_SFPnt << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFPnt = " << D_A1_SFPnt << endl;

    cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A2_SFBin =  " << D_A2_SFBin << endl;//.transpose(secondDim, firstDim) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A2_SFBin = " << D_A2_SFBin << endl;//.transpose(secondDim, firstDim) << endl;
#endif

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 9. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    ///    blz(ib:ie)=sp
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SP = " << D_A1_SP << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SP = " << D_A1_SP << endl;
#endif
    if (I_IE >= P_D_A1_BLZ->size())
    {
      cout << "CFits::MkSlitFunc: ERROR: I_IE(=" << I_IE << ") >= P_D_A1_BLZ->size(=" << P_D_A1_BLZ->size() << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_IE(=" << I_IE << ") >= P_D_A1_BLZ->size(=" << P_D_A1_BLZ->size() << ")" << endl;
      return false;
    }
    if (D_A1_SP.size() != I_IE - I_IB + 1)
    {
      cout << "CFits::MkSlitFunc: ERROR: D_A1_SP.size(=" << D_A1_SP.size() << ") != I_IE(=" << I_IE << ") - I_IB(=" << I_IB << ") + 1 = " << I_IE - I_IB + 1 << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A1_SP.size(=" << D_A1_SP.size() << ") != I_IE(=" << I_IE << ") - I_IB(=" << I_IB << ") + 1 = " << I_IE - I_IB + 1 << endl;
      return false;
    }
    (*P_D_A1_BLZ)(Range(I_IB, I_IE)) = D_A1_SP;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): P_D_A1_BLZ(Range(I_IB=" << I_IB << ", I_IE=" << I_IE << ")) set to " << (*P_D_A1_BLZ)(Range(I_IB, I_IE)) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): P_D_A1_BLZ(Range(I_IB=" << I_IB << ", I_IE=" << I_IE << ")) set to " << (*P_D_A1_BLZ)(Range(I_IB, I_IE)) << endl;
#endif
    ///    if(i eq 0) then begin
    if (m == 0)
    {
      ///      nslitf = n_elements(sfsm)
      I_NSlitF = D_A1_SFSM.size();
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): m == 0: I_NSlitF = " << I_NSlitF << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): m == 0: I_NSlitF = " << I_NSlitF << endl;
#endif
      ///      yslitf = yslitf0 + (findgen(nslitf)-0.5)/osamp-1.5 ;final subpixel scale
      D_A1_Temp.resize(I_NSlitF);
      D_A1_Temp = i;
      D_A1_Temp -= 0.5;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): m == 0: D_A1_Temp = " << D_A1_Temp << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): m == 0: D_A1_Temp = " << D_A1_Temp << endl;
#endif

      /// Final subpixel scale
      D_A1_XSlitF.resize(D_A1_Temp.size());
      D_A1_XSlitF = I_XSlitFunc0 + D_A1_Temp / this->I_OverSample - 1.5;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): m == 0: D_A1_XSlitF = " << D_A1_XSlitF << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): m == 0: D_A1_XSlitF = " << D_A1_XSlitF << endl;
#endif

      /// Init final slit function
      ///      slitf = fltarr(nslitf, nbin)                       ;init final slit function
      D_A2_SlitF.resize(I_NSlitF, I_NBin);
      D_A2_SlitF = 0.;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): m == 0: D_A2_SlitF initialized to " << D_A2_SlitF.rows() << " x " << D_A2_SlitF.cols() << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): m == 0: D_A2_SlitF initialized to " << D_A2_SlitF.rows() << " x " << D_A2_SlitF.cols() << endl;
#endif

    }/// end if (m == 0)
    ///    sfsm2 = reform(transpose(sfbin),nsf)
    D_A1_SFSM2Temp.resize(I_NSF);
    if (D_A2_SFBin.size() != I_NSF)
    {
      cout << "CFits::MkSlitFunc: ERROR: D_A2_SFBin.size(" << D_A2_SFBin.size() << ") != I_NSF(=" << I_NSF << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A2_SFBin.size(" << D_A2_SFBin.size() << ") != I_NSF(=" << I_NSF << ")" << endl;
      return false;
    }
    D_A1_SFSM2Temp.resize(0);
    Array<double, 1> *p_D_A1_SFSM2Temp = this->Reform(D_A2_SFBin);
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFSM2Temp set to " << *p_D_A1_SFSM2Temp<< endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFSM2Temp = " << *p_D_A1_SFSM2Temp << endl;
#endif

    ///    j = sort(ysfpnt)
    Array<int, 1> *p_I_A1_Temp = this->SortIndices(D_A1_XSFPnt);
    I_A1_Temp.resize(p_I_A1_Temp->size());//D_A1_XSFPnt.size());
    I_A1_Temp = (*p_I_A1_Temp);
    delete p_I_A1_Temp;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): I_A1_Temp = " << I_A1_Temp << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): I_A1_Temp = " << I_A1_Temp << endl;
#endif
    I_A1_TempA.resize(I_A1_JBad.size());
    ///    if(nbad gt 0) then $
    if (I_NBad > 0)
    {
      ///      jbad = (sort(j))(jbad)
      if (I_A1_Temp.size() < I_A1_JBad.size())
      {
        cout << "CFits::MkSlitFunc: ERROR: I_A1_Temp.size(=" << I_A1_Temp.size() << ") < I_A1_JBad.size(=" << I_A1_JBad.size() << ")" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: I_A1_Temp.size(=" << I_A1_Temp.size() << ") < I_A1_JBad.size(=" << I_A1_JBad.size() << ")" << endl;
        return false;
      }
      Array<double, 1> *p_da1tempfix = FixD(I_A1_Temp);
      Array<int, 1> *p_ia1temp = this->SortIndices(*p_da1tempfix);
      delete p_da1tempfix;
      this->GetSubArrCopy(*p_ia1temp, I_A1_JBad, I_A1_TempA);
      delete p_ia1temp;
      I_A1_JBad = I_A1_TempA;
#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): NBad > 0: I_A1_JBad = " << I_A1_JBad << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): NBad > 0: I_A1_JBad = " << I_A1_JBad << endl;
#endif

    }

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 10. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    ///    ysfpnt = ysfpnt(j)
    D_A1_Temp.resize(I_A1_Temp.size());
    this->GetSubArrCopy(D_A1_XSFPnt, I_A1_Temp, D_A1_Temp);
    #ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_Temp = " << D_A1_Temp << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_Temp = " << D_A1_Temp << endl;
    #endif
    D_A1_XSFPnt.resize(D_A1_Temp.size());
    D_A1_XSFPnt = D_A1_Temp;
    #ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFPnt = " << D_A1_XSFPnt << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_XSFPnt = " << D_A1_XSFPnt << endl;
    #endif
    ///    sfpnt = sfpnt(j)
    this->GetSubArrCopy(D_A1_SFPnt, I_A1_Temp, D_A1_Temp);
    D_A1_SFPnt.resize(D_A1_Temp.size());
    D_A1_SFPnt = D_A1_Temp;
    #ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFPnt = " << D_A1_SFPnt << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFPnt = " << D_A1_SFPnt << endl;
    #endif
    ///    sfsm2 = sfsm2(j)
    this->GetSubArrCopy(*p_D_A1_SFSM2Temp, I_A1_Temp, D_A1_Temp);
    delete p_D_A1_SFSM2Temp;
    D_A1_SFSM2.resize(I_A1_Temp.size());
    D_A1_SFSM2 = D_A1_Temp;
    #ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFSM2 set to " << D_A1_SFSM2<< endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A1_SFSM2 = " << D_A1_SFSM2 << endl;
    #endif

    /// Save slit function
    ///    slitf(*,i) = sfsm/total(sfsm)*osamp         ;save slit function
    if (abs(sum(D_A1_SFSM)) < 0.000000001)
    {
      cout << "CFits::MkSlitFunc: ERROR: sum(D_A1_SFSM) == 0" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: sum(D_A1_SFSM) == 0" << endl;
      return false;
    }
    if (D_A2_SlitF.rows() != D_A1_SFSM.size())
    {
      cout << "CFits::MkSlitFunc: ERROR: D_A2_SlitF.rows(=" << D_A2_SlitF.rows() << ") != D_A1_SFSM.size(=" << D_A1_SFSM.size() << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A2_SlitF.rows(=" << D_A2_SlitF.rows() << ") != D_A1_SFSM.size(=" << D_A1_SFSM.size() << ")" << endl;
      return false;
    }
    if (D_A2_SlitF.cols() <= m)
    {
      cout << "CFits::MkSlitFunc: ERROR: D_A2_SlitF.cols(=" << D_A2_SlitF.cols() << ") <= m(=" << m << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: D_A2_SlitF.cols(=" << D_A2_SlitF.cols() << ") <= m(=" << m << ")" << endl;
      return false;
    }
    if (abs(sum(D_A1_SFSM)) < 0.00000000000000001)
    {
      cout << "CFits::MkSlitFunc: ERROR: sum(D_A1_SFSM=" << D_A1_SFSM << ") == 0 => Returning FALSE" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: sum(D_A1_SFSM=" << D_A1_SFSM << ") == 0 => Returning FALSE" << endl;
      return false;
    }
    D_A2_SlitF(Range::all(), m) = D_A1_SFSM / sum(D_A1_SFSM) * this->I_OverSample;
    #ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A2_SlitF = " << D_A2_SlitF << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int m(=" << m << ") = 0; m < I_NBin(=" << I_NBin << "); m++): D_A2_SlitF = " << D_A2_SlitF << endl;//.transpose(secondDim, firstDim) << endl;
    #endif

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 11. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

  } /// end for (int m = 0; m < I_NBin; m++) /// Loop thru sf regions

  //  (*P_OFS_Log) << "CFits::MkSlitFunc: 12. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

  //  for (int m = 0; m < I_NBin; m++)
  //  {
  //    for (int n = 0; n < )
#ifdef __DEBUG_FITS_PISKUNOV__
  (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XLow = " << *P_D_A1_XLow << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: P_D_A1_XHigh = " << *P_D_A1_XHigh << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_BinCen = " << D_A1_BinCen << endl;
#endif

  /*  /// Write slit function to (profile) image this->PixArray
    Array<double, 2> D_A2_Profile;
    D_A2_Profile.resize(I_NXSF, I_NR);
    D_A2_Profile = 0.;

    /// Vector of Slit Function Points at BinCenters
    Array<double, 1> D_A1_Bins(2);

    /// Vector of y_start(==0) and y_end(==1)
    Array<double, 1> D_A1_YBin;
    D_A1_YBin.resize(2);

    int I_StartInd = 0;
    int I_EndInd = 0;
    int i_nrows;

    Array<double, 1> D_A1_SlitPixA;
    D_A1_SlitPixA.resize(D_A2_SlitF.rows());

    Array<double, 1> D_A1_SlitPixB;
    D_A1_SlitPixB.resize(D_A2_SlitF.rows());

    Array<double, 1> D_A1_SlitPixBinA;
    Array<double, 1> D_A1_SlitPixBinB;
    Array<double, 1> D_A1_Ind;

    int OffSet = 0;
    int npix;// = XLast - XFirst + 1;
    Array<int, 1> temp_ind_arr;//(D_A1_XSlitF.size());
    temp_ind_arr.resize(D_A1_XSlitF.size());

    Array<int, 1> ind_arr;
    double WeightFirst = 0.;// = (*this->P_D_A2_XCenters)(I_IAperture_In, m) + (double)((*this->P_D_A1_XLow)(I_IAperture_In));
    double WeightLast = 0.;// = (*this->P_D_A2_XCenters)(I_IAperture_In, m) + (*this->P_D_A1_XHigh)(I_IAperture_In);
    int XFirst = 0;// = (int)WeightFirst;
    int XLast = 0;// = (int)WeightLast;
  */
  ///Trim end pixels of slitf, since they are sometimes bad.
  ///  ysfmin = min(yslitf, max=ysfmax)                  ;range of yslitf
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_A1_XSlitF = to " << D_A1_XSlitF << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XSlitF = to " << D_A1_XSlitF << endl;
#endif
  D_XSFMin = min(D_A1_XSlitF);
  D_XSFMax = max(D_A1_XSlitF);

#ifdef __DEBUG_FITS_PISKUNOV__
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_XSFMin set to " << D_XSFMin << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_XSFMax set to " << D_XSFMax << endl;
#endif
  ///  nysf = n_elements(yslitf)                          ;number of subpixels
  I_NXSF = D_A1_XSlitF.size();

  ///  dysf = (ysfmax - ysfmin) / (nysf - 1)             ;subpixel size
  D_DXSF = (D_XSFMax - D_XSFMin) / (I_NXSF - 1);
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_DXSF set to " << D_DXSF << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_DXSF set to " << D_DXSF << endl;
#endif
  ///  ntrim = ceil(1.0 / dysf)                          ;subpixels to trim
  I_NTrim = (int)this->Ceil(1.0 / D_DXSF);
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_NTrim set to " << I_NTrim << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_NTrim set to " << I_NTrim << endl;
#endif
  ///  yslitf = yslitf(ntrim:nysf-ntrim-1)               ;trim subpixel indexes
  D_A1_XSlitFTemp.resize(I_NXSF - 1 * I_NTrim);
  D_A1_XSlitFTemp = D_A1_XSlitF(Range(I_NTrim, I_NXSF - I_NTrim - 1));
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_A1_XSlitFTemp set to " << D_A1_XSlitFTemp << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XSlitFTemp set to " << D_A1_XSlitFTemp << endl;
#endif
  ///  slitf = slitf(ntrim:nysf-ntrim-1,*)               ;trim slit functions
  D_A2_SlitFTemp.resize(I_NXSF - 2 * I_NTrim + 1, D_A2_SlitF.cols());
  D_A2_SlitFTemp = D_A2_SlitF(Range(I_NTrim, I_NXSF - I_NTrim - 1), Range::all());
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_A2_SlitFTemp set to " << D_A2_SlitFTemp << endl;
  cout << "CFits::MkSlitFunc: D_A1_XSlitFTemp = " << D_A1_XSlitFTemp << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A2_SlitFTemp set to " << D_A2_SlitFTemp << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_A1_XSlitFTemp = " << D_A1_XSlitFTemp << endl;
#endif

  ///  ysfmin = min(yslitf, max=ysfmax)                  ;range of yslitf
  D_XSFMin = min(D_A1_XSlitFTemp);
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_XSFMin set to " << D_XSFMin << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_XSFMin set to " << D_XSFMin << endl;
#endif
  D_XSFMax = max(D_A1_XSlitFTemp);
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: D_XSFMax set to " << D_XSFMax << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: D_XSFMax set to " << D_XSFMax << endl;
#endif
  ///  nysf = n_elements(yslitf)                         ;number of subpixels
  I_NXSF = D_A1_XSlitFTemp.size();
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkSlitFunc: I_NXSF set to " << I_NXSF << endl;
  (*P_OFS_Log) << "CFits::MkSlitFunc: I_NXSF set to " << I_NXSF << endl;
#endif
  ///Use slit function and fit to order to normalize flat.
  ///    if(cole0 gt 0) then begin                         ;skip the beginning of the order
  ///      for icol=0,cole0-1 do begin                     ;loop thru image columns
  ///        if(onum eq ofirst) then y0 = 0 $              ;starting row to change
  ///        else                    y0 = ((yprev(icol)+1)>0)<(nrow-1)
  ///        if(onum eq nord) then   y1 = nrow-1 $         ;ending row to change
  ///        else                    y1 = ((yc(icol) + y_upper_lim)<(nrow-1))>0
  ///        im(icol,y0:y1) = 1.0
  ///      endfor
  ///    endif

  ///    for icol=cole0,cole1 do begin                     ;loop thru image columns


  Array<double, 1> *P_D_A1_BLZSmooth;
  if (this->KeyWord_Set(CS_A1_Args, CString("FLAT")) >= 0)
  {
    P_D_A1_BLZSmooth = this->MedianVec(*P_D_A1_BLZ, I_LambdaSP);
  }
  else
  {
    P_D_A1_BLZSmooth = new Array<double, 1>(1);
    (*P_D_A1_BLZSmooth) = 0.;
  }
  for (irow = 0; irow < this->NRows; irow++)
  {

    //    (*P_OFS_Log) << "CFits::MkSlitFunc: 13. this->NRows = " << this->NRows << ", this->NCols = " << NCols << endl;

    /// exwd = 0.5 if not set by KeyWord
    ///      if(exwd(0,onum-1) gt 1.5) then begin            ;starting row to change
    ///        y0 = yc(icol) - exwd(0,onum-1)                ;exwd is in pixels
    ///      endif else begin                                ;or a fraction
    ///        y0 = yc(icol) - round(y_lower_lim*exwd(0,onum-1))
    ///      endelse
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): P_D_A2_XCenters(I_IAperture_In(=" << I_IAperture_In << "), irow) = " << (*P_D_A2_XCenters)(I_IAperture_In, irow) << ", 0. - (*this->P_D_A1_XLow)(I_IAperture_In) = " << 0. - (*this->P_D_A1_XLow)(I_IAperture_In) << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): P_D_A2_XCenters(I_IAperture_In(=" << I_IAperture_In << "), irow) = " << (*P_D_A2_XCenters)(I_IAperture_In, irow) << ", 0. - (*this->P_D_A1_XLow)(I_IAperture_In) = " << 0. - (*this->P_D_A1_XLow)(I_IAperture_In) << endl;
#endif
    I_X0 = (int)((*P_D_A2_XCenters)(I_IAperture_In, irow))
           - this->Round(0. - (*this->P_D_A1_XLow)(I_IAperture_In));

#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X0 set to "<< I_X0 << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X0 set to "<< I_X0 << endl;
#endif
    /*    if (I_X0 < 0)
          I_X0 = 0;
        if (I_X0 >= this->NCols)
          I_X0 = this->NCols - 1;
    //#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows; irow++): I_X0 set to "<< I_X0 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows; irow++): I_X0 set to "<< I_X0 << endl;
    //#endif
    */
    ///      if(exwd(1,onum-1) gt 1.5) then begin            ;ending row to change
    ///        y1 = yc(icol) + exwd(1,onum-1)               ;exwd is in pixels
    ///      endif else begin                                ;or a fraction
    ///        y1 = yc(icol) + round(y_lower_lim*exwd(1,onum-1))
    ///      endelse
    I_X1 = (int)((*P_D_A2_XCenters)(I_IAperture_In, irow)) + this->Round((*this->P_D_A1_XHigh)(I_IAperture_In));// * 0.5);

#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X1 set to "<< I_X1 << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X1 set to "<< I_X1 << endl;
#endif

    /*    if (I_X1 < 0)
          I_X1 = 0;
        if (I_X1 >= this->NCols)
          I_X1 = this->NCols - 1;

    //#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X1 set to "<< I_X1 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_X1 set to "<< I_X1 << endl;
    //#endif
        */
    if (I_X0 >= 0 && I_X0 < this->NCols && I_X1 >= 0 && I_X1 < this->NCols)
    {
      ///      iy = y0 + indgen(y1 - y0 + 1)                   ;list of rows to change
      I_A1_IX.resize(I_X1 - I_X0 + 1);
      I_A1_IX = i + I_X0;

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_A1_IX set to " << I_A1_IX << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_A1_IX set to " << I_A1_IX << endl;
#endif

      ///      yint = (iy - ycen(icol) - ysfmin) / dysf        ;interpolation grid
      D_A1_XInt.resize(I_A1_IX.size());
      D_A1_XInt = (I_A1_IX - (*P_D_A2_XCenters)(I_IAperture_In, irow) - D_XSFMin) / D_DXSF;

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_XInt set to " << D_A1_XInt << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_XInt set to " << D_A1_XInt << endl;
#endif

      ///Linearly interpolate slit functions onto desired rows in current column.
      ///      isort = sort(abs(binc - icol))                  ;sort by distance
      D_A1_TempArr.resize(D_A1_BinCen.size());
      D_A1_TempArr = abs(D_A1_BinCen - irow);
      Array<int, 1> *p_I_A1_ISort = this->SortIndices(D_A1_TempArr);
      //      cout << "CFits::MkSlitFunc: p_I_A1_ISort set to " << *p_I_A1_ISort << endl;
      I_A1_ISort.resize(p_I_A1_ISort->size());//.resize(D_A1_BinCen.size());
      I_A1_ISort = (*p_I_A1_ISort);
      delete p_I_A1_ISort;

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_A1_ISort set to " << I_A1_ISort << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): I_A1_ISort set to " << I_A1_ISort << endl;
#endif

      ///      if(n_elements(isort) le 1) then begin           ;For short partial orders
      if (I_A1_ISort.size() <= 1)
      {
        ///        ic0=isort                                     ;that may fit in one swath
        D_A1_IR0.resize(1);
        D_A1_IR0 = I_A1_ISort(0);

        ///        ic1=isort
        D_A1_IR1.resize(1);
        D_A1_IR1 = I_A1_ISort(0);

        ///        bc0=cole0

        ///        bc1=cole1
      }/// end if (I_A1_ISort.size() <= 1)
      ///      endif else begin
      else
      {
        ///        ic0 = isort(0)                                ;index of closest bin
        D_A1_IR0.resize(1);
        D_A1_IR0(0) = I_A1_ISort(0);

#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_IR0 set to " << D_A1_IR0 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_IR0 set to " << D_A1_IR0 << endl;
#endif

        ///        ic1 = isort(1)                                ;index of next closest bin
        D_A1_IR1.resize(1);
        D_A1_IR1(0) = I_A1_ISort(1);

#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_IR1 set to " << D_A1_IR1 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_IR1 set to " << D_A1_IR1 << endl;
#endif

        ///        bc0 = binc(ic0)                               ;closest bin center
        //        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_BinCen = " << D_A1_BinCen << ", D_A1_IR0 = " << D_A1_IR0 << endl;
        //        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_BinCen = " << D_A1_BinCen << ", D_A1_IR0 = " << D_A1_IR0 << endl;
        D_BR0 = D_A1_BinCen((int)(D_A1_IR0(0)));

#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_BR0 set to " << D_BR0 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_BR0 set to " << D_BR0 << endl;
#endif

        ///        bc1 = binc(ic1)                               ;next closest center
        D_BR1 = D_A1_BinCen((int)(D_A1_IR1(0)));

#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_BR1 set to " << D_BR1 << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_BR1 set to " << D_BR1 << endl;
#endif

        ///      endelse
      }/// end else if (I_A1_ISort.size() > 1)
      ///      sf0 = interpolate(slitf(*,ic0), yint)           ;interpolate onto rows

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): SF0: D_A1_XInt = " << D_A1_XInt << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): SF0: D_A1_XInt = " << D_A1_XInt << endl;
#endif

      D_A1_TempArrA.resize(D_A2_SlitFTemp.rows());
      D_A1_TempArrA = D_A2_SlitFTemp(Range::all(), (int)(D_A1_IR0(0)));

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_TempArrA = " << D_A1_TempArrA << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_TempArrA = " << D_A1_TempArrA << endl;
#endif

      Array<double, 1> *p_D_A1_SF0 = this->InterPolate(D_A1_TempArrA, D_A1_XInt);
      D_A1_TempArrA.resize(0);

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): p_D_A1_SF0 set to " << *p_D_A1_SF0 << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): p_D_A1_SF0 set to " << *p_D_A1_SF0 << endl;
#endif

      ///      sf1 = interpolate(slitf(*,ic1), yint)           ;interpolate onto rows

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): SF1: D_A1_XInt = " << D_A1_XInt << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): SF1: D_A1_XInt = " << D_A1_XInt << endl;
#endif

      D_A1_TempArrB.resize(D_A2_SlitFTemp.rows());
      D_A1_TempArrB = D_A2_SlitFTemp(Range::all(), (int)(D_A1_IR1(0)));

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_TempArrB = " << D_A1_TempArrB << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_TempArrB = " << D_A1_TempArrB << endl;
#endif

      Array<double, 1> *p_D_A1_SF1 = this->InterPolate(D_A1_TempArrB, D_A1_XInt);
      D_A1_TempArrB.resize(0);

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_SF1 set to " << *p_D_A1_SF1 << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_SF1 set to " << *p_D_A1_SF1 << endl;
#endif

      ///      sf = sf0 + (sf1-sf0)/(bc1-bc0) * (icol-bc0)     ;extra/interpolate icol
      D_A1_SF.resize(p_D_A1_SF0->size());
      D_A1_TempArrC.resize(p_D_A1_SF0->size());
      D_A1_TempArrC = (*p_D_A1_SF1) - (*p_D_A1_SF0);

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: Calculating D_A1_SF to D_A1_SF0(=" << *p_D_A1_SF0 << ") + (D_A1_SF1(=" << *p_D_A1_SF1 << ") - D_A1_SF0(=" << *p_D_A1_SF0 << ") = " << D_A1_TempArrC << ") /" << endl;
      cout << "CFits::MkSlitFunc:              (D_BR1(=" << D_BR1 << ") - D_BR0(=" << D_BR0 << ") = " << D_BR1 - D_BR0 << ") * (irow(=" << irow << ") - D_BR0(=" << D_BR0 << ") = " << irow - D_BR0 << ")" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: Calculating D_A1_SF to D_A1_SF0(=" << *p_D_A1_SF0 << ") + (D_A1_SF1(=" << *p_D_A1_SF1 << ") - D_A1_SF0(=" << *p_D_A1_SF0 << ") = " << D_A1_TempArrC << ") /" << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc:              (D_BR1(=" << D_BR1 << ") - D_BR0(=" << D_BR0 << ") = " << D_BR1 - D_BR0 << ") * (irow(=" << irow << ") - D_BR0(=" << D_BR0 << ") = " << irow - D_BR0 << ")" << endl;
#endif

      D_A1_TempArrC.resize(1);

      D_A1_SF = (*p_D_A1_SF0) + ((*p_D_A1_SF1) - (*p_D_A1_SF0)) / (D_BR1 - D_BR0) * ((double)irow - D_BR0);
      delete p_D_A1_SF0;
      delete p_D_A1_SF1;

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_SF set to " << D_A1_SF << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): D_A1_SF set to " << D_A1_SF << endl;
#endif

      if (abs(sum(D_A1_SF)) < 0.000000001)
      {
        cout << "CFits::MkSlitFunc: ERROR: sum(D_A1_SF) == 0" << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: ERROR: sum(D_A1_SF) == 0" << endl;
        return false;
      }
      D_A1_SF = where(D_A1_SF < 0., 0., D_A1_SF);
      double fac = 1. / sum(D_A1_SF);

#ifdef __DEBUG_FITS_PISKUNOV__
      cout << "CFits::MkSlitFunc: fac set to 1 / sum = " << fac << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: fac set to 1 / sum = " << fac << endl;
#endif

      if ((I_Pos = this->KeyWord_Set(CS_A1_Args, CString("FLAT"))) >= 0)
      {
        if (P_D_A1_BLZSmooth->size() < irow + 1)
        {
          cout << "CFits::MkSlitFunc: BLZ set: ERROR: P_D_A1_BLZSmooth->size(=" << P_D_A1_BLZSmooth->size() << ") < irow(=" << irow << ") + 1 => Returning" << endl;
          (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ set: ERROR: P_D_A1_BLZSmooth->size(=" << P_D_A1_BLZSmooth->size() << ") < irow(=" << irow << ") + 1 => Returning" << endl;
          return false;
        }
#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: BLZ set: P_D_A1_BLZSmooth(irow=" << irow << ") = " << (*P_D_A1_BLZSmooth)(irow) << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ set: P_D_A1_BLZSmooth(irow=" << irow << ") = " << (*P_D_A1_BLZSmooth)(irow) << endl;
#endif

        fac *= (*P_D_A1_BLZSmooth)(irow);

#ifdef __DEBUG_FITS_PISKUNOV__
        cout << "CFits::MkSlitFunc: BLZ set: fac set to 1 / sum = " << fac << endl;
        (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ set: fac set to 1 / sum = " << fac << endl;
#endif

      }/// end if ((I_Pos = this->KeyWord_Set(CS_A1_Args, CString("BLZ"))) >= 0)
      (*P_D_A2_ProfArray)(irow, Range(I_X0, I_X1)) = D_A1_SF * fac;

#ifdef __DEBUG_FITS_PISKUNOV__
      D_A1_TempArrD.resize(I_X1 - I_X0 + 1);
      D_A1_TempArrD = (*P_D_A2_ProfArray)(irow, Range(I_X0, I_X1));
      cout << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): P_D_A2_ProfArray(irow(=" << irow << "), Range(I_X0(=" << I_X0 << "), I_X1(=" << I_X1 << ")) set to " << D_A1_TempArrD << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (int irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++): P_D_A2_ProfArray(irow(=" << irow << "), Range(I_X0(=" << I_X0 << "), I_X1(=" << I_X1 << ")) set to " << D_A1_TempArrD << endl;
      D_A1_TempArrD.resize(0);
#endif

    }/// end if (I_X0 != I_X1)

#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: end for (irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++)" << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: end for (irow(=" << irow << ") = 0; irow < this->NRows(=" << this->NRows << "); irow++)" << endl;
#endif

  }/// end for (irow = 0; irow < this->NRows; irow++)


  //  /// Vector containing the interpolated column
  //  Array<double, 1> D_A1_InterPol(I_NXSF);
  /*  /// Fill Profile Array
    /// Loop through Bins
    for (int m = -1; m < I_NBin; m++)
    {
      /// First Bin
      if (m == -1)
      {
        /// Set first rows to first slit function
        I_StartInd = I_A1_IBeg(0);
        I_EndInd = (int)D_A1_BinCen(0);
        D_A1_SlitPixA = 2. * D_A2_SlitFTemp(Range::all(), 0) - D_A2_SlitFTemp(Range::all(), 1);
        D_A1_SlitPixB = D_A2_SlitFTemp(Range::all(), 0);

  //      i_nrows = (int)(D_A1_BinCen(1)) - (int)(D_A1_BinCen(0));
  /*      /// Loop through rows of Profile Array from beginning to BinCenter
            for (int n = I_A1_IBeg(0); n <= D_A1_BinCen(0); n++)
        {
          (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (n(=" << n << ") = I_A1_IBeg(0)=" << I_A1_IBeg(0) << "; n <= D_A1_BinCen(0)=" << D_A1_BinCen(0) << "): Setting PixArray(m, Range(XCenters(I_IAperture_In=" << I_IAperture_In << " + Low(I_IAperture_In)=" << (*P_D_A1_XLow)(I_IAperture_In) << "))=" << Range((int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)), (int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)) + I_NSlitF - 1) << " to D_A2_SlitFTemp(Range::all(), 0) = " << D_A2_SlitFTemp(Range::all(), m) << endl;


          D_A2_Profile(n,Range::all())
              = D_A2_SlitFTemp(Range::all(), m);
      }*/
  /*    }
      else if (m == I_NBin - 1)
      {
        /// Set last rows to last slit function
        I_StartInd = (int)D_A1_BinCen(m);
        I_EndInd = I_A1_IEnd(m);
        D_A1_SlitPixA = D_A2_SlitFTemp(Range::all(), m);
        D_A1_SlitPixB = 2 * D_A1_SlitPixA - D_A2_SlitFTemp(Range::all(), m-1);

  /*      for (int n = (int)(D_A1_BinCen(m)); n <= I_A1_IEnd(m); n++)
        {
          (*P_OFS_Log) << "CFits::MkSlitFunc: Setting D_A2_Profile(n=" << n << ", Range((int)((*P_D_A2_XCenters)(I_IAperture_In, n)(=" << (*P_D_A2_XCenters)(I_IAperture_In, n) << ") + (*P_D_A1_XLow)(I_IAperture_In)(=" << (*P_D_A1_XLow)(I_IAperture_In) << ")), (int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In) = " << (*P_D_A1_XLow)(I_IAperture_In) << ") + I_NSlitF(=" << I_NSlitF << ") - 1) = " << Range((int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)), (int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)) + I_NSlitF - 1) << ") to D_A2_SlitFTemp(Range::all(), m=" << m << ") = " << D_A2_SlitFTemp(Range::all(), m) << endl;

          D_A2_Profile(n, Range((int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)), (int)((*P_D_A2_XCenters)(I_IAperture_In, n) + (*P_D_A1_XLow)(I_IAperture_In)) + I_NSlitF - 1)) = D_A2_SlitFTemp(Range::all(), m);
      }*/
  /*    }
      else
      {
        /// Set last rows to last slit function
        I_StartInd = (int)D_A1_BinCen(m);
        I_EndInd = (int)D_A1_BinCen(m+1);
        D_A1_SlitPixA = D_A2_SlitFTemp(Range::all(), m);
        D_A1_SlitPixB = D_A2_SlitFTemp(Range::all(), m+1);

        /// Interpolate profile rows from bins
        /// Loop through columns of Slit Function
        /// NOTE: Columns of Slit Function belong to (Rows of PixArray + Offset)
      //if (m < I_NBin)
     // {
      }

      /// Sum SubPixels to real Pixels of Profile Array
      D_A1_SlitPixBinA.resize(I_NXSF);
      D_A1_SlitPixBinA = 0.;
      D_A1_SlitPixBinB.resize(I_NXSF);
      D_A1_SlitPixBinB = 0.;

  /*    WeightFirst = (*this->P_D_A2_XCenters)(I_IAperture_In, 0) +
          (double)((*this->P_D_A1_XLow)(I_IAperture_In));
      XFirst = (int)WeightFirst;
      WeightFirst -= (double)XFirst;
      WeightFirst = 1. - WeightFirst;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XFirst set to " << XFirst << ", WeightFirst set to " << WeightFirst << endl;

      WeightLast = (*this->P_D_A2_XCenters)(I_IAperture_In, 0) +
          (*this->P_D_A1_XHigh)(I_IAperture_In);
      XLast = (int)WeightLast;
      WeightLast -= (double)XLast;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XLast set to " << XLast << ", WeightLast set to " << WeightLast << endl;

      npix = XLast - XFirst + 1;
      if (npix != I_NXSF)
      {
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): ERROR: npix(=" << npix << ") != I_NXSF(=" << I_NXSF << ") => Returning FALSE!";
        return false;
      }
      for (int p = 0; p < I_NXSF; p++)
      {
        temp_ind_arr = where((*P_D_A1_XLow)(I_IAperture_In) + (*P_D_A2_XCenters)(I_IAperture_In, I_StartInd) >= p && D_A1_XSlitFTemp - (*P_D_A1_XLow)(I_IAperture_In) < p+1, 1, 0);
        ind_arr.resize(sum(temp_ind_arr));
        int temppos = 0;
        for (int o = 0; o < D_A1_XSlitFTemp.size(); o++)
        {
          if (temp_ind_arr(o) == 1)
          {
            ind_arr(temppos) = o;
            temppos++;
          }
        }
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): ind_arr set to " << ind_arr << endl;

        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): this->GetSubArr(D_A2_Profile(m, Range::all()), ind_arr) = " << this->GetSubArr(D_A2_SlitFTemp(m, Range::all()), ind_arr) << endl;

        D_A2_Profile(p, I_StartInd) = sum(this->GetSubArr(D_A1_SlitPixA, ind_arr));
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): D_A2_Profile(p, I_StartInd=" << I_StartInd << ") set to " << D_A2_Profile(p,I_StartInd) << endl;

        D_A2_Profile(p, I_EndInd) = sum(this->GetSubArr(D_A1_SlitPixA, ind_arr));
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): D_A2_Profile(p, I_EndInd=" << I_EndInd << ") set to " << D_A2_Profile(p,I_EndInd) << endl;
      }
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): D_A2_Profile(Range::all(), I_StartInd=" << I_StartInd << ") set to " << D_A2_Profile(Range::all(),I_StartInd) << endl;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin(=" << I_NBin << "); m++): for (int p(=" << p << ") = 0; p < I_NXSF(=" << I_NXSF << "); p++): D_A2_Profile(Range::all(), I_EndInd=" << I_EndInd << ") set to " << D_A2_Profile(Range::all(),I_EndInd) << endl;



      i_nrows = I_EndInd - I_StartInd + 1;
      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin=" << I_NBin << "; m++): i_nrows set to " << i_nrows << "; I_NXSF = " << I_NXSF << endl;

      D_A1_Ind.resize(i_nrows);
      D_A1_Ind = i / i_nrows;

      /// Vector of y_start(==0) and y_end(==1)
      D_A1_YBin(0) = 0.;
      D_A1_YBin(1) = 1.;

      /// Loop through Rows of Profile Array
      for (int n = 0; n < i_nrows; n++)
      {
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin=" << I_NBin << "; m++): for (int n = 0; n < i_nrows(=" << i_nrows << "); n++): Starting Interpolation" << endl;

  //      /// Pixels to interpolate between
  //      D_A1_Bins(0) = D_A1_SlitPixA(n);
  //      D_A1_Bins(1) = D_A1_SlitPixB(n);
  //      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (int n = 0; n < i_nrows(=" << i_nrows << "); n++): D_A1_Bins set to " << D_A1_Bins << endl;

  //      (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = 0; m < I_NBin=" << I_NBin << "; m++): for (int n = 0; n < i_nrows(=" << i_nrows << "); n++): Starting InterPol: D_A1_YBin = " << D_A1_YBin << ", D_A1_Bins = " << D_A1_Bins << ", D_A1_Ind = " << D_A1_Ind << endl;

        WeightFirst = (*this->P_D_A2_XCenters)(I_IAperture_In, m) +
                      (double)((*this->P_D_A1_XLow)(I_IAperture_In));
        XFirst = (int)WeightFirst;
        WeightFirst -= (double)XFirst;
        WeightFirst = 1. - WeightFirst;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XFirst set to " << XFirst << endl;

        WeightLast = (*this->P_D_A2_XCenters)(I_IAperture_In, m) +
                     (*this->P_D_A1_XHigh)(I_IAperture_In);
        XLast = (int)WeightLast;
        WeightLast -= (double)XLast;
        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): XLast set to " << XLast << endl;

        npix = XLast - XFirst + 1;
        for (int n = 0; n < npix; n++)
        {

          (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < NRows(=" << this->NRows << "); m++): for (int n(=" << n << ") = 0; n < npix(=" << npix << "); n++): PixArray(m=" << m << ", (XFirst + n)=" << XFirst + n << ") set to " << (*P_D_A2_PixArray)(m, XFirst + n) << endl;
        }
        D_A2_Profile(n, Range(I_StartInd, I_EndInd))
            = D_A1_SlitPixA + ((n / I_NXSF) * (D_A1_SlitPixB - D_A1_SlitPixA));

        (*P_OFS_Log) << "CFits::MkSlitFunc: for (m(=" << m << ") = -1; m < I_NBin=" << I_NBin << "; m++): for (int n = 0; n < I_NXSF(=" << I_NXSF << "); n++): D_A1_Bins = " << D_A1_Bins << endl;
      }
    }
    this->WriteArrayToFile(D_A2_Profile, *(new CString("/home/azuri/entwicklung/c/fitsutil/cfits/test/Profile_out.dat")));
    /// Fill PixArray with Profile
    (*this->P_D_A2_PixArray) = 0.;
    /// Loop through rows
    for (int m = (*this->P_D_A1_XMin)(I_IAperture_In); m <= (*this->P_D_A1_XMax)(I_IAperture_In); m++)
    {

      /// Loop through columns
    }*/

  /// FILENAME
  CS_Temp.Set("FILENAME");
  if ((I_Pos = this->KeyWord_Set(*(const_cast<const Array<CString, 1>*>(&CS_A1_Args)), CS_Temp)) >= 0)
  {
    CString CS_TempFileName(*(CString*)ArgV[I_Pos]);
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: KeyWord_Set(FILENAME): CS_TempFileName set to " << CS_TempFileName << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: KeyWord_Set(FILENAME): CS_TempFileName set to " << CS_TempFileName << endl;
#endif
    this->WriteArrayToFile(D_A2_SlitF, CS_TempFileName, CString("ascii"));
  }

  /*  cout << "CFits::MkSlitFunc: End: P_D_A1_BLZ = " << (*P_D_A1_BLZ) << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A1_BLZ->rows() = " << P_D_A1_BLZ->rows() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->rows() = " << P_D_A2_Blaze->rows() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->cols() = " << P_D_A2_Blaze->cols() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->size() = " << P_D_A2_Blaze->size() << endl;*/

  if ((I_Pos = this->KeyWord_Set(CS_A1_Args, CString("FLAT"))) >= 0)
  {
    (*P_D_A2_Blaze)(I_IAperture_In, Range::all()) = (*P_D_A1_BLZSmooth)(Range::all());
  }
  else
  {
    (*P_D_A2_Blaze)(I_IAperture_In, Range::all()) = (*P_D_A1_BLZ)(Range::all());
  }
  /*  cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->rows() = " << P_D_A2_Blaze->rows() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->cols() = " << P_D_A2_Blaze->cols() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_Blaze->size() = " << P_D_A2_Blaze->size() << endl;
    cout << "CFits::MkSlitFunc: End: P_D_A2_BLZ(" << I_IAperture_In << ", *) = " << (*P_D_A2_Blaze)(I_IAperture_In, Range::all()) << endl;
  */
  //delete[] tmpstr;

  D_A1_DXScatter.resize(0);
  D_A1_IBound.resize(0);
  D_A1_ICol.resize(0);
  D_A1_IR0.resize(0);
  D_A1_IR1.resize(0);
  D_A2_Mask.resize(0, 0);
  D_A2_Msk.resize(0, 0);
  D_A1_SC.resize(0);
  D_A1_Scatter.resize(0);
  D_A2_SFBin.resize(0, 0);
  D_A1_SF.resize(0);
  D_A2_SF.resize(0,0);
  D_A1_SFPnt.resize(0);
  D_A1_SFSM.resize(0);
  D_A1_SFSM2.resize(0);
  D_A2_SlitFTemp.resize(0,0);
  D_A1_SP.resize(0);
  D_A1_SSF.resize(0);
  D_A1_Tel.resize(0);
  D_A2_Tel.resize(0,0);
  D_A1_Temp.resize(0);
  D_A1_TempArr.resize(0);
  D_A1_TempArrA.resize(0);
  D_A1_TempArrB.resize(0);
  D_A1_TempArrC.resize(0);
  D_A1_TempArrD.resize(0);
  D_A1_XCenMXC.resize(0);
  D_A1_XCentersE.resize(0);
  D_A1_XInt.resize(0);
  D_A1_XSFPnt.resize(0);
  D_A1_XSlitFTemp.resize(0);
  I_A1_I.resize(0);
  I_A1_IBeg.resize(0);
  I_A1_IEnd.resize(0);
  I_A1_IMax.resize(0);
  I_A1_IMin.resize(0);
  I_A1_ISort.resize(0);
  I_A1_ITel.resize(0);
  I_A1_IX.resize(0);
  I_A1_J0.resize(0);
  I_A1_J1.resize(0);
  I_A1_JBad.resize(0);
  I_A1_Temp.resize(0);
  I_A1_TempA.resize(0);
  delete P_I_A1_XC;
  delete P_D_A1_BLZSmooth;

  /*  for (int ipos = 0; ipos < pppos; ipos++)
    {
      delete pp_cstr[ipos];
  //    delete args[ipos];
  }*/
  //    delete pp_cstr;
  //    delete(args);

  I_Pos = this->KeyWord_Set(CS_A1_Args, CString("BLZ"));
  if (I_Pos < 0)/// KeyWord not set
  {
    //#ifdef __DEBUG_FITS_PISKUNOV__
    //    cout << "CFits::MkSlitFunc: BLZ not set: writing P_D_A1_BLZ to file" << endl;
    //    (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ not set: writing P_D_A1_BLZ to file" << endl;
    //#endif
    //    ofstream *P_OFS_BLZ = new ofstream("blz_out.text");
    //    for (int iblz=0; iblz < P_D_A1_BLZ->size(); iblz++)
    //      (*P_OFS_BLZ) << (*P_D_A1_BLZ)(iblz) << endl;
    //    delete P_OFS_BLZ;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: BLZ not set: deleting P_D_A1_BLZ" << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ not set: deleting P_D_A1_BLZ" << endl;
#endif
    delete P_D_A1_BLZ;
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkSlitFunc: BLZ not set: P_D_A1_BLZ deleted" << endl;
    (*P_OFS_Log) << "CFits::MkSlitFunc: BLZ not set: P_D_A1_BLZ deleted" << endl;
#endif
  }

  //  CS_A1_Args.resize(0);

  return true;
}



/**
 SlitFunc old version
 SlitFunc
 **/
bool CFits::SlitFunc_Old(Array<double, 2> &D_A2_ImM,
                     int I_IAperture_In,
                     Array<double, 1> &D_A1_XCenters_In, //: in
                     Array<double, 1> &SPVecArr,   //: out
                     Array<double, 1> &SFVecArr,   //: out
                     //                     int NArgs,                //: in
                     const Array<CString, 1> &CS_A1_Args,   //: in
                     void *ArgV[])     //: in
/*            NOISE      = double          : in
              OVERSAMPLE = int             : in
              IM_OUT     = Array<double, 2>: out
              LAMBDA_SF  = double          : in
              LAMBDA_SP  = int             : in
              USE_ROW    = int             : in
              BAD        = Array<int, 1>   : out
              MASK       = Array<double, 2>: in
*/
{
  cout << "CFits::SlitFunc_Old: CS_A1_Args = " << CS_A1_Args << endl;
  /**
  USAGE: SlitFunc(XCenters, SP, SF, NArgs, (*(new CString("Mask")), *(new CString(JBadVecArr)), ...), (<CFits*>P_Mask, <long>JBadVecArr, ...)
  **/

  /**
  Pro slit_func,im,
                ycen,
                sp,
                sf,
                OVERSAMPLE=oversample,
                LAMBDA_SF=lamb_sf,
                LAMBDA_SP=lamb_sp,
                IM_OUT=im_out,
                USE_COL=use_col,
                MASK=mask,
                NOISE=noise,
                BAD=jbad
    common bandsolv,band_solv_name
  **/

  /**
  Array Akl                      -> Array<double, 2> AKLArr
  Array bkl (size=[N,2*OverSample+1])-> Array<double, 2> BKLArr
  Vector bklind (size=osample+1) -> Array<int, 1> BKLIndVecArr
  Vector Bl                      -> Array<double, 1> BLVecArr
  double dev                     -> double Dev
  int    i                       -> int m
  int/Vector i1                  -> int IFirst/Array<double, 1> IFirstVecArr
  int/Vector i2                  -> int ILast/Array<double, 1> ILastVecArr
  Array  im                      -> Array<double, 2> D_A2_ImM
  Vector(use_col set)/Array imm  -> Array<double, 2> D_A2_ImM->(UseRowVecArr)
  Array  im_out                  -> Array<double, 2> *P_D_A2_ImOut
  Vector ind                     -> Array<double, 1> IndVecArr
  int    iter                    -> int  Iter
  Vector/long   jbad             -> Array<int, 1> *P_I_A1_JBadVecArr / (*P_I_A1_JBadVecArr)(0)
  int    l                       -> int n
  double lamb_sf                 -> double Lamb_SF [: in]
  double lamb_sp                 -> double Lamb_SP [: in]
  double lambda                  -> double Lambda
  Array  mask, mmsk              -> Array<long, 2> P_Mask->PixArray: in
  Vector(use_col set)/Array msk  -> Array<double, 2> Mask(UseRowVecArr)
  int    n                       -> int N
  int    ncol                    -> ImM->cols, NColsOut -> OutArr->NCols
  int    nind                    -> int  NInd
  int    nrow                    -> ImM->rows
  Array/Vector  o                -> Array<double, 2> OArr
  Vector oo                      -> Array<double, 1> OOVecArr
  Vector oind                    -> Array<int, 1> OIndVecArr
  Vector olind  (size=osample+1) -> Array<int, 1> OLIndVecArr
  Vector omega                   -> Array<double, 1> OmegaVecArr
  long   osample                 -> int  OverSample [: in]
  int    oversample              -> int  OverSample [: in]
  Vector r                       -> Array<double, 1> RVecArr
  Vector sf                      -> Array<double, 1> SFVecArr: in
  Vector sp                      -> Array<double, 1> SPVecArr: out
  Vector sp_old                  -> Array<double, 1> SPOldVecArr
  Array  ssf                     -> Array<double, 2> SSFArr
  int    use_col                 -> Array<long, 1> UseRowVecArr: in
  double weight                  -> double Weight
  Vector y (size=n)              -> Array<double, 1> XVecArr
  Vector ycen                    -> Array<double, 1> XCenVecArr: in
  Vector yy (size=n)             -> Array<double, 1> XXVecArr
  int(use_col set)/Vector yycen  -> Array<double, 1> XCenVecArr(0) <- XCenter: in
  double yyy                     -> double XXX
  IDL:     array(Column, Row)
  BLITZ++: array(Row, Column) !!!!!!!!!!!!!!!!!!!
  reform(Array, NCols, NRows)  -> Array<double, 2>& Reform(Array<double, 1>, NRows, NCols) <NOTE: Dim1 <=> Dim2>
  replicate(Value, Dim)      -> Replicate(Value, Dim)
  Matrix#Matrix              -> MatrixBTimesA()
  Vector#Vector              -> VecArrACrossB()
  Matrix#Vector              -> VecArrTimesMatrix() <Result: rows == 1>
  Matrix##Matrix             -> MatrixATimesB()
  Vector##Vector             -> VecArrACrossB()
  Matrix##Vector             -> MatrixTimesVecArr() <Result: cols == 1>
  **/

  //  (*P_OFS_Log) << "CFits::SlitFunc: 0. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  int NArgs = CS_A1_Args.size();

  CString *P_Delimiter = new CString("/");
  CString *P_Prefix = P_CS_FileName->SubString(0, P_CS_FileName->LastStrPos(*P_Delimiter));
  CString *P_TempString = new CString();
  //  int OverSample = 1;
  int N, TempInt, TempIntA, Pos;
  int NRowsOut, TempIntB;
  int  IFirst, ILast, Iter, NInd;
  int tempcol;// = OLIndVecArr(n) / OArr.rows();
  int temprow;// = OLIndVecArr(n) - tempcol * OArr.rows();
  int tempint = 0;
  int i_tmp_sum;
  long TempLong;

  Array<int, 1> *P_I_A1_JBadVecArr = new Array<int, 1>(1);
  (*P_I_A1_JBadVecArr) = 0;

  Array<double, 1> a(1);
  a = 0.;

  Array<double, 2> AKLArr(1,1);
  AKLArr = 0.;

  Array<double, 1> b(1);
  b = 0.;

  Array<double, 2> BKLArr(1,1);
  BKLArr = 0.;

  Array<int, 1> BKLIndVecArr(1);
  BKLIndVecArr = 0;

  Array<double, 1> BLVecArr(1);
  BLVecArr = 0.;

  Array<double, 1> c(1);
  c = 0.;

  Array<double, 1> D_A1_Ind(1);
  D_A1_Ind = 0.;

  Array<double, 2> D_A2_AKLT(1,1);
  D_A2_AKLT = 0.;

  Array<double, 2> D_A2_OT(1,1);
  D_A2_OT = 0.;

  Array<double, 2> D_A2_SPVecTimesBKLArr(1, 1);
  D_A2_SPVecTimesBKLArr = 0.;

  Array<int, 1> IFirstVecArr(1);
  IFirstVecArr = 0;

  Array<int, 1> ILastVecArr(1);
  ILastVecArr = 0;

  //  (*P_OFS_Log) << "CFits::SlitFunc: 0A. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  Array<double, 2> *P_D_A2_ImOut = new Array<double, 2> (D_A2_ImM.rows(), D_A2_ImM.cols());
  (*P_D_A2_ImOut) = 0.;

  Array<int, 1> IndVecArr(1);
  IndVecArr = 0;

  Array<double, 2> Mask(1,1);
  Mask = 0.;

  Array<double, 2> OArr(1,1);
  OArr = 0.;

  Array<int, 1> OIndVecArr(1);
  OIndVecArr = 0;

  Array<int, 1> OLIndVecArr(1);
  OLIndVecArr = 0;

  Array<double, 1> OOVecArr(1);
  OOVecArr = 0.;

  Array<double, 1> OmegaVecArr(1);
  OmegaVecArr = 0.;

  Array<double, 2> OmegaArr(1,1);
  OmegaArr = 0.;

  Array<double, 2> D_A2_TempAA(1, 1);
  D_A2_TempAA = 0.;

  Array<double, 1> D_A1_TempDVecArr(1);
  D_A1_TempDVecArr = 0.;

  Array<double, 1> D_A1_TempDVecArrAA(1);
  D_A1_TempDVecArrAA = 0.;

  Array<double, 2> ProductArr(1,1);
  ProductArr = 0.;

  Array<double, 1> RVecArr(1);
  RVecArr = 0.;

  //  Array<double, 1> SFVecArr(SF.copy());
  Array<double, 1> SPOldVecArr(1);
  SPOldVecArr = 0.;
  //  Array<double, 1> SPVecArr(SP.copy());

  Array<double, 2> SSFArr(1,1);
  SSFArr = 0.;

  Array<double, 2> TempArray(1,1);
  TempArray = 0.;

  Array<double, 1> TempDVecArr(1);
  TempDVecArr = 0.;

  Array<double, 1> TempDVecArrA(1);
  TempDVecArrA = 0.;

  Array<double, 1> TempDVecArrB(1);
  TempDVecArrB = 0.;

  Array<double, 1> TempDVecArrC(1);
  TempDVecArrC = 0.;

  Array<double, 2> TempDArr(1,1);
  TempDArr = 0.;

  Array<int, 1> TempIVecArr(1);
  TempIVecArr = 0;

  Array<double, 2> *P_TempMask = new Array<double, 2>(1,1);
  (*P_TempMask) = 0.;

  Array<long, 1> UseRowVecArr(1);
  UseRowVecArr = 0;

  Array<int, 1> IVecArr(1);
  IVecArr = 0;

  Array<double, 1> XVecArr(1);
  XVecArr = 0.;

  Array<double, 1> XCenVecArr(1);
  XCenVecArr = 0.;

  Array<double, 1> XXVecArr(1);
  XXVecArr = 0.;

  double Weight, Norm, Dev, tmpdbl, Lambda, XXX;
  double Lamb_SF = 0.1;
  double Lamb_SP = 0.;
  double D_SPVecPow = 0.;
#ifdef __DEBUG_FITS_PISKUNOV__
  //  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": D_A2_ImM = " << D_A2_ImM << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: D_A2_ImM = " << D_A2_ImM << endl;//.transpose(secondDim, firstDim) << endl;
  //  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": D_A1_XCenters_In = " << D_A1_XCenters_In << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: D_A1_XCenters_In = " << D_A1_XCenters_In << endl;
#endif
  firstIndex i;
  secondIndex j;

  //  (*P_OFS_Log) << "CFits::SlitFunc: 1. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  XCenVecArr.resize(D_A1_XCenters_In.size());
  XCenVecArr = D_A1_XCenters_In;
#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": XCenVecArr = " << XCenVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: XCenVecArr = " << XCenVecArr << endl;
#endif

  /**
  if(not keyword_set(band_solv_name)) then begin
    help,calls=a
    a=strmid(a(0),strpos(a(0),'<')+1,strlen(a(0))-strpos(a(0),'<')-1)
    if(strpos(a,'/nfs') eq 0) then a=strmid(a,4)
    if(strpos(a,'/export') eq 0) then a=strmid(a,7)
    if(!VERSION.OS eq 'Win32') then delimiter='\' else delimiter='/'
    prefix=strmid(a,0,strpos(a,delimiter,/REVERSE_SEARCH))   ;slit_func directory
    if(strpos(a,delimiter) lt 0) then cd,CURRENT=prefix
    band_solv_name=prefix+delimiter+'bandsol.so.' $
    +!version.os+strtrim(!version.MEMORY_BITS,2)
  endif
  */
  // nothing to do

  /**
  if(not keyword_set(oversample)) then oversample=1
  if(oversample lt 1) then oversample=1
  if(not keyword_set(mask)) then begin
    mmsk=byte(im*0)+1B
  endif else begin
    if((size(mask))(0) ne (size(im))(0) or $
       (size(mask))(1) ne (size(im))(1) or $
       (size(mask))(2) ne (size(im))(2)) then begin
      print,'SLIT_FUNC: Mask must have the same size as the image'
      stop
    endif
    mmsk=mask
  endelse
  osample=long(oversample)
  oind=lindgen(osample+1L)*(osample+2L)
  weight=1./float(osample)
  if(not keyword_set(lamb_sf)) then lamb_sf=0.1
  */
  /*  P_TempString->Set("OVERSAMPLE");
    if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0)
    {
      OverSample = *(int*)ArgV[Pos];
  #ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(OVERSAMPLE): OverSample set to " << OverSample << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(OVERSAMPLE): OverSample set to " << OverSample << endl;
  #endif
  }*/
  //  OverSample = this->I_OverSample;
  if (this->I_OverSample < 1)
    this->I_OverSample = 1;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": this->I_OverSample = " << this->I_OverSample << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: this->I_OverSample = " << this->I_OverSample << endl;
#endif
  P_TempString->Set("MASK");
  if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0)
  {
    if (P_TempMask != NULL)
      delete P_TempMask;
    P_TempMask = (Array<double, 2>*)ArgV[Pos];
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(MASK): P_TempMask read = " << *P_TempMask << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(MASK): P_TempMask read = " << *P_TempMask << endl;
#endif
    if (P_TempMask->size() != 1)
    {
      if (P_TempMask->rows() != D_A2_ImM.rows() ||
          P_TempMask->cols() != D_A2_ImM.cols())
      {
        cout << "SLIT_FUNC: Mask must have the same size as the image" << endl;
        (*P_OFS_Log) << "SLIT_FUNC: Mask must have the same size as the image" << endl;
        return false;
      }
      Mask.resize(P_TempMask->rows(), P_TempMask->cols());
      Mask = P_TempMask->copy();
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(MASK): Mask set to " << Mask << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(MASK): Mask set to " << Mask << endl;
#endif

    }
  }
  ///else
  if (Pos < 0 || (Pos >= 0 && P_TempMask->size() == 1))
  {
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": !KeyWord_Set(MASK): D_A2_ImM.rows = " << D_A2_ImM.rows() << ", D_A2_ImM.cols = " << D_A2_ImM.cols() << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(MASK): D_A2_ImM.rows = " << D_A2_ImM.rows() << ", D_A2_ImM.rows = " << D_A2_ImM.cols() << endl;
#endif
    if (D_A2_ImM.cols() < 0)
    {
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": !KeyWord_Set(MASK): D_A2_ImM = " << D_A2_ImM << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(MASK): D_A2_ImM = " << D_A2_ImM << endl;
    }
    Mask.resize(D_A2_ImM.rows(), D_A2_ImM.cols());
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": !KeyWord_Set(MASK): Mask set to " << Mask << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(MASK): Mask set to " << Mask << endl;
#endif

  }
  Mask = 1.;
  cout << "CFits::SlitFunc_Old: Mask = " << Mask << endl;
  //  (*P_OFS_Log) << "CFits::SlitFunc: 1.A this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;
  Weight = 1. / (double)this->I_OverSample;
  OIndVecArr.resize(this->I_OverSample + 1);
  OIndVecArr = 0;
  UseRowVecArr = i;//Range(0, D_A2_ImM.cols()-1);
  OIndVecArr = i;//this->LIndGen(this->I_OverSample + 1);
  OIndVecArr *= (this->I_OverSample + 2);
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Weight = " << Weight << endl;
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": UseRowVecArr = " << UseRowVecArr << endl;
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": OIndVecArr = " << OIndVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: Weight = " << Weight << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: UseRowVecArr = " << UseRowVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: OIndVecArr = " << OIndVecArr << endl;
#endif

  P_TempString->Set("LAMBDA_SF");
  if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0)
  {
    Lamb_SF = *(double*)ArgV[Pos];
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SF): Lamb_SF set to " << Lamb_SF << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SF): Lamb_SF set to " << Lamb_SF << endl;
#endif

  }
  if (Pos < 0 || (Pos >= 0 && abs(Lamb_SF) < 0.0000001))
  {
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": !KeyWord_Set(LAMBDA_SF): Lamb_SF = " << Lamb_SF << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(LAMBDA_SF): Lamb_SF = " << Lamb_SF << endl;
#endif

  }

  P_TempString->Set("BAD");
  if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0)
  {
    if (P_I_A1_JBadVecArr != NULL)
      delete P_I_A1_JBadVecArr;
    P_I_A1_JBadVecArr = (Array<int, 1>*)ArgV[Pos];
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(BAD): P_I_A1_JBadVecArr set to " << *P_I_A1_JBadVecArr << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(BAD): P_I_A1_JBadVecArr set to " << *P_I_A1_JBadVecArr << endl;
#endif

  }
  //  (*P_OFS_Log) << "CFits::SlitFunc: 1.B this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  /**
  for reject=1,1 do begin
    if(keyword_set(use_col)) then begin
      imm=im(use_col,*)
      yycen=ycen(use_col)
      msk=mmsk(use_col,*)
  */
  //  while(true)
  //  {
  P_TempString->Set("USE_ROW");
  if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0)
  {
    TempIntB = *(int*)ArgV[Pos];
    if (TempIntB != 0)
    {
      UseRowVecArr.resize(1);
      UseRowVecArr(0) = TempIntB;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(USE_ROW): ArgV[Pos=" << Pos << "]=" << *(int*)(ArgV[Pos]) << " => UseRowVecArr set to " << UseRowVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(USE_ROW): ArgV[Pos=" << Pos << "]=" << *(int*)(ArgV[Pos]) << " => UseRowVecArr set to " << UseRowVecArr << endl;
#endif
      D_A2_ImM(0, Range::all()) = D_A2_ImM(UseRowVecArr(0), Range::all());
      D_A2_ImM.resizeAndPreserve(1, D_A2_ImM.cols());
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": D_A2_ImM = " << D_A2_ImM << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: D_A2_ImM = " << D_A2_ImM << endl;//.transpose(secondDim, firstDim) << endl;
#endif

      XCenVecArr(0) = XCenVecArr(UseRowVecArr(0));
      XCenVecArr.resizeAndPreserve(1);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": XCenVecArr = " << XCenVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: XCenVecArr = " << XCenVecArr << endl;
#endif

      Mask(0, Range::all()) = Mask(UseRowVecArr(0), Range::all());
      Mask.resizeAndPreserve(1, Mask.cols());
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Mask = " << Mask << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: Mask = " << Mask << endl;
#endif

    }
  }
  /**
      endif else begin
        use_col=indgen(n_elements(im(*,0)))
        imm=im
        yycen=ycen
        msk=mmsk
      endelse
  */
  if (Pos < 0 || (Pos >= 0 && TempIntB == 0))
  {
    UseRowVecArr.resize(D_A2_ImM.rows());
    UseRowVecArr = i;
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": !KeyWord_Set(USE_ROW): UseRowVecArr set to " << UseRowVecArr << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(USE_ROW): UseRowVecArr set to " << UseRowVecArr << endl;
#endif

  }

  //    (*P_OFS_Log) << "CFits::SlitFunc: 2. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;
  /**
      sz=size(imm)
      ncol=sz(1)
      nrow=sz(2)
      n=(nrow+1L)*osample+1L
      norm=n_elements(msk)/total(long(msk))
      sf=total(imm*msk,1)
      sf=median(sf,5)                                    ; the spectrum
      sf=sf/total(sf)                                    ; slit function
  */
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": D_A2_ImM.cols(=" << D_A2_ImM.cols() << ") + 1 * this->I_OverSample(=" << this->I_OverSample << ") + 1 = " << ((D_A2_ImM.cols() + 1) * this->I_OverSample) + 1 << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: D_A2_ImM.cols(=" << D_A2_ImM.cols() << ") + 1 * this->I_OverSample(=" << this->I_OverSample << ") + 1 = " << ((D_A2_ImM.cols() + 1) * this->I_OverSample) + 1 << endl;
#endif
  N    = ((D_A2_ImM.cols() + 1) * this->I_OverSample) + 1;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": N set to " << N << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: N set to " << N << endl;
#endif
  if (abs(sum(Mask)) < 0.00000000000001)
  {
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: sum(Mask=" << Mask << ") == 0" << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: ERROR: sum(Mask=" << Mask << ") == 0" << endl;
    return false;
  }
  Norm = (D_A2_ImM.rows() * D_A2_ImM.cols()) / sum(Mask);
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Norm set to " << Norm << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: Norm set to " << Norm << endl;
#endif
  ProductArr.resize(D_A2_ImM.rows(), D_A2_ImM.cols());
  ProductArr = D_A2_ImM;
  ProductArr *= Mask;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ProductArr = " << ProductArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: ProductArr = " << ProductArr << endl;
#endif
  SFVecArr.resize(ProductArr.cols());
  SFVecArr = sum(ProductArr(j, i), j); /** Initial guess for the **/
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": SFVecArr = " << SFVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: SFVecArr = " << SFVecArr << endl;
#endif
  Array<double, 1> *p_d1temp = MedianVec(SFVecArr, 5, (CString("NORMAL")));
  SFVecArr = (*p_d1temp);             /** Spectrum **/
  delete p_d1temp;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": MedianVec(SFVecArr) = " << SFVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: MedianVec(SFVecArr) = " << SFVecArr << endl;
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": sum(SFVecArr) = " << sum(SFVecArr) << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: sum(SFVecArr) = " << sum(SFVecArr) << endl;
#endif
  if (abs(sum(SFVecArr)) < 0.000000001)
  {
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": WARNING: sum(SFVecArr=" << SFVecArr << ") == 0" << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: WARNING: sum(SFVecArr=" << SFVecArr << ") == 0" << endl;
    SFVecArr = 1.;
    //return false;
  }
  SFVecArr /= sum(SFVecArr);           /** Slit Function **/
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Slit Function SFVecArr = SFVecArr / (sum(SFVecArr) = " << sum(SFVecArr) << ") = " << SFVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: Slit Function SFVecArr = SFVecArr / (sum(SFVecArr) = " << sum(SFVecArr) << ") = " << SFVecArr << endl;
#endif

  /**
  sp=total((imm*msk)*(replicate(1.,ncol)#sf),2)*norm ; Initial guess for
  sp=median(sp,5)                                    ; the spectrum
  sp=sp/total(sp)*total(imm*msk)
  */
  /** Initial guess for the spectrum **/
  TempArray.resize(D_A2_ImM.rows(), D_A2_ImM.cols());
  TempArray = D_A2_ImM;
  TempArray *= Mask;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": TempArray = ImM*Mask = " << TempArray << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: TempArray = ImM*Mask = " << TempArray << endl;
#endif
  Array<double, 1> *p_d1rep = this->Replicate(1., D_A2_ImM.rows());
  Array<double, 2> *p_d2mat = this->VecArrACrossB(*p_d1rep, SFVecArr);
  TempArray *= (*p_d2mat);
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": TempArray = TempArray*(VecArrACrossB(Replicate(1.,D_A2_ImM.rows(=" << D_A2_ImM.rows() << "))=" << *p_d1rep << ", SFVecArr(=" << SFVecArr << "))=" << *p_d2mat << ") = " << TempArray << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: TempArray = TempArray*(VecArrACrossB(Replicate(1.,D_A2_ImM.rows(=" << D_A2_ImM.rows() << "))=" << *p_d1rep << ", SFVecArr(=" << SFVecArr << "))=" << *p_d2mat << ") = " << TempArray << endl;
#endif
  delete p_d1rep;
  delete p_d2mat;
  SPVecArr.resize(TempArray.rows());
  SPVecArr = sum(TempArray, j);
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": SPVecArr (set to sum) = " << SPVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (set to sum) = " << SPVecArr << endl;
#endif
  SPVecArr *= Norm;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": SPVecArr (*Norm=" << Norm << ") = " << SPVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (*Norm=" << Norm << ") = " << SPVecArr << endl;
#endif
  Array<double, 1> *p_d1sptemp = (MedianVec(SPVecArr, 5, (CString("NORMAL"))));
  SPVecArr = (*p_d1sptemp);
  delete p_d1sptemp;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": SPVecArr (set to MedianVec) = " << SPVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (set to MedianVec) = " << SPVecArr << endl;
#endif
  if (abs(sum(SPVecArr)) < 0.000000001)
  {
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": WARNING: sum(SPVecArr=" << SPVecArr << ") == 0" << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: WARNING: sum(SPVecArr=" << SPVecArr << ") == 0" << endl;
    SPVecArr = 1.;
    //      return false;
  }
  SPVecArr /= sum(SPVecArr);
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": SPVecArr (set to /=sum(=" << sum(SPVecArr) << ")) = " << SPVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (set to /=sum(=" << sum(SPVecArr) << ")) = " << SPVecArr << endl;
#endif
  SPVecArr *= sum(D_A2_ImM * Mask);
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": SPVecArr (set to *=sum(=" << sum(D_A2_ImM * Mask) << ")) = " << SPVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: SPVecArr (set to *=sum(=" << sum(D_A2_ImM * Mask) << ")) = " << SPVecArr << endl;
#endif
  /**
  if(keyword_set(noise)) then $
    dev=noise $
  else $
    dev=sqrt(total(msk*(imm-sp#sf)^2)/total(msk))
  j=where(abs(imm-sp#sf) gt 3.*dev,nj)
  if(nj gt 0) then begin
    msk(j)=0B
  endif
  */
  /** Add too noisy pixels to bad-pixel mask **/
  P_TempString->Set("NOISE");
  if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0)
  {
    Dev = *(double*)ArgV[Pos];
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(NOISE): Dev set to " << Dev << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(NOISE): Dev set to " << Dev << endl;
#endif

  }
  if (Pos < 0 || (Pos >= 0 && abs(Dev) < 0.0000001))
  {
    if (abs(sum(Mask)) < 0.00000000000000001)
    {
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: sum(Mask=" << Mask << ") == 0" << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: ERROR: sum(Mask=" << Mask << ") == 0" << endl;
      return false;
    }
    Array<double, 2> *p_tempMat = this->VecArrACrossB(SPVecArr, SFVecArr);
    Dev = sqrt(sum(Mask * pow2(D_A2_ImM - (*p_tempMat))) / sum(Mask));
    delete p_tempMat;
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": !KeyWord_Set(NOISE): Dev set to " << Dev << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: !KeyWord_Set(NOISE): Dev set to " << Dev << endl;
#endif

  }

  //    (*P_OFS_Log) << "CFits::SlitFunc: 3. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  TempArray.resize(D_A2_ImM.rows(), D_A2_ImM.cols());
  Array<double, 2> *p_tempMatA = this->VecArrACrossB(SPVecArr, SFVecArr);
  TempArray = where(fabs(D_A2_ImM - (*p_tempMatA)) > (3. * Dev), 0, 1);
  delete p_tempMatA;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": sum(TempArray(where)) = " << sum(TempArray) << ", TempArray.size() = " << TempArray.size() << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: sum(TempArray(where)) = " << sum(TempArray) << ", TempArray.size() = " << TempArray.size() << endl;
#endif

  if (sum(TempArray) < TempArray.size())
  {
    Mask *= TempArray;
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": sum(TempArray(where)) = " << sum(TempArray) << " < TempArray.size() = " << TempArray.size() << ": Mask set to " << Mask << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: sum(TempArray(where)) = " << sum(TempArray) << " < TempArray.size() = " << TempArray.size() << ": Mask set to " << Mask << endl;
#endif

  }

  /**
  y=(dindgen(n)+0.5d0)/float(osample)-1.d0

  bklind=lindgen(osample+1)+n*osample
  olind=oind(0:osample)
  */
  XVecArr.resize(N);
  XVecArr = ((i + 0.5) / this->I_OverSample) - 1.;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": XVecArr = " << XVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: XVecArr = " << XVecArr << endl;
#endif
  BKLIndVecArr.resize(this->I_OverSample + 1);
  BKLIndVecArr = i;
  BKLIndVecArr += (N * this->I_OverSample);
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": BKLIndVecArr = " << BKLIndVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: BKLIndVecArr = " << BKLIndVecArr << endl;
#endif
  OLIndVecArr.resize(this->I_OverSample + 1);
  if (OIndVecArr.size() < this->I_OverSample+1)
  {
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: size of OIndVecArr(=" << OIndVecArr.size() << " < this->I_OverSample + 1(=" << this->I_OverSample + 1 << ")" << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: ERROR: size of OIndVecArr(=" << OIndVecArr.size() << " < this->I_OverSample + 1(=" << this->I_OverSample + 1 << ")" << endl;
    return false;
  }
  OLIndVecArr = OIndVecArr(Range(0, this->I_OverSample));
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": OLIndVecArr = " << OLIndVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: OLIndVecArr = " << OLIndVecArr << endl;
#endif

  ///    for m=osample+1L,2L*osample do begin
  ///    endfor
  for (long m=this->I_OverSample + 1; m <= (2 * this->I_OverSample); m++)
  {
    ///      mm=m-osample
    long mm = m - this->I_OverSample;
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m=" << m << "): mm = " << mm << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): mm = " << mm << endl;
#endif

    ///      bklind=[bklind,lindgen(osample+1-mm)+n*m]
    TempIVecArr.resize(this->I_OverSample + 1 - mm);
    TempIVecArr = i + (N * m);
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m=" << m << "): TempIVecArr = " << TempIVecArr << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): TempIVecArr = " << TempIVecArr << endl;
#endif

    int oldsize = BKLIndVecArr.size();
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m=" << m << "): oldsize(BKLIndVecArr) = " << oldsize << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): oldsize(BKLIndVecArr) = " << oldsize << endl;
#endif
    BKLIndVecArr.resizeAndPreserve(oldsize + this->I_OverSample + 1 - mm);
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m=" << m << "): BKLIndVecArr = " << BKLIndVecArr << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): BKLIndVecArr = " << BKLIndVecArr << endl;
#endif
    BKLIndVecArr(Range(oldsize, toEnd))//oldsize + 1 + this->I_OverSample - mm))
    = TempIVecArr(Range::all());
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m=" << m << "): BKLIndVecArr = " << BKLIndVecArr << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): BKLIndVecArr = " << BKLIndVecArr << endl;
#endif

    ///      olind=[olind,oind(0:osample-mm)+mm]
    oldsize = OLIndVecArr.size();
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m=" << m << "): oldsize(OLIndVecArr) = " << oldsize << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): oldsize(OLIndVecArr) = " << oldsize << endl;
#endif
    OLIndVecArr.resizeAndPreserve(OLIndVecArr.size() + this->I_OverSample + 1 - mm);
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m=" << m << "): OLIndVecArr = " << OLIndVecArr << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): OLIndVecArr = " << OLIndVecArr << endl;
#endif
    if (OIndVecArr.size() < this->I_OverSample - mm + 1)
    {
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: size of OIndVecArr(=" << OIndVecArr.size() << ") < this->I_OverSample - mm + 1(=" << this->I_OverSample - mm + 1 << ")" << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: ERROR: size of OIndVecArr(=" << OIndVecArr.size() << ") < this->I_OverSample - mm + 1(=" << this->I_OverSample - mm + 1 << ")" << endl;
      return false;
    }
    OLIndVecArr(Range(oldsize, toEnd))
    = OIndVecArr(Range(0, this->I_OverSample - mm)) + mm;
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m=" << m << "): OLIndVecArr = " << OLIndVecArr << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: for(m=" << m << "): OLIndVecArr = " << OLIndVecArr << endl;
#endif

  }/// end for (long m=this->I_OverSample + 1; m <= (2 * this->I_OverSample); m++)

  ///    Bl=dblarr(n)                               ; and RHS
  ///    omega=replicate(weight,osample+1L)         ; Replicate constant weights

  /** Goto Label here!!!!!!!!! **/
  SPOldVecArr.resize(SPVecArr.size());
  SPOldVecArr = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": SPOldVecArr = " << SPOldVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: SPOldVecArr = " << SPOldVecArr << endl;
#endif
  ///    iter=0
  Iter = 0;
  ///    next:
  while(Iter < 8)   /** Iteration counter **/
  {

    //      (*P_OFS_Log) << "CFits::SlitFunc: 4. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

    ///    iter=iter+1                                ; Iteration counter
    Iter++;
    //#ifdef __DEBUG_FITS_SLITFUNC__
    //      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Iter = " << Iter << ": (max(abs(SPVecArr=" << SPVecArr << " - SPOldVecArr=" << SPOldVecArr << ") / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << endl;
    //      (*P_OFS_Log) << "CFits::SlitFunc: Iter = " << Iter << ": (max(abs(SPVecArr=" << SPVecArr << " - SPOldVecArr=" << SPOldVecArr << ") / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << endl;
    //#endif

    if (Iter == 1 || max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) > 0.00001)
    {

      ///    Akl=dblarr(n,2*osample+1)                  ; Initialize matrix
      AKLArr.resize(N, (2*this->I_OverSample) + 1); /** Initialize Matrix **/
      AKLArr = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": if(max...): AKLArr initialized to 0.: size(AKLArr) = (" << AKLArr.rows() << "," << AKLArr.cols() << ")" << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: if(max...): AKLArr initialized to 0.: size(AKLArr) = (" << AKLArr.rows() << "," << AKLArr.cols() << ")" << endl;
#endif
      BLVecArr.resize(N);                      /** and RHS **/
      BLVecArr = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": if(max...): BLVecArr = " << BLVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: if(max...): BLVecArr = " << BLVecArr << endl;
#endif
      OmegaVecArr.resize(this->I_OverSample + 1);
      OmegaVecArr = Weight;                    /** Replicate constant Weights **/
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": if(max...): OmegaVecArr = " << OmegaVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: if(max...): OmegaVecArr = " << OmegaVecArr << endl;
#endif

#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": (max(abs(SPVecArr=" << SPVecArr << " - SPOldVecArr=" << SPOldVecArr << ") / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001: Resizing XXVecArr to N=" << N << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: (max(abs(SPVecArr=" << SPVecArr << " - SPOldVecArr=" << SPOldVecArr << ") / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001: Resizing XXVecArr to N=" << N << endl;
#endif
      XXVecArr.resize(N);
      XXVecArr = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": starting for(m=0; m<D_A2_ImM.rows(=" << D_A2_ImM.rows() << "); m++)" << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: starting for(m=0; m<D_A2_ImM.rows(=" << D_A2_ImM.rows() << "); m++)" << endl;
#endif
      ///    for i=0,ncol-1 do begin  */ /** i => m **/   /*               ; Fill up matrix and RHS
      for (int m = 0; m < D_A2_ImM.rows(); m++)  /** Fill up matrix and RHS **/
      {

        //          (*P_OFS_Log) << "CFits::SlitFunc: 5. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Begin for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++)" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: Begin for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++)" << endl;
#endif
        ///      yy=y+yycen(i)                            ; Offset SFVecArr
        if (XXVecArr.size() != XVecArr.size())
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: size of XXVecArr(=" << XXVecArr.size() << ") != size of XVecArr(=" << XVecArr.size() << ")" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: ERROR: size of XXVecArr(=" << XXVecArr.size() << ") != size of XVecArr(=" << XVecArr.size() << ")" << endl;
          return false;
        }
        XXVecArr = XVecArr + XCenVecArr(m);    /** Offset SFVecArr **/
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): XXVecArr set to " << XXVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): XXVecArr set to " << XXVecArr << endl;
#endif

        ///      ind=where(yy ge 0 and yy lt 1, nind)     ; Weights are the same within pixel except
        /** Weights are the same for all pixels except for the first and the last subpixels **/
        TempIVecArr.resize(XXVecArr.size());
        TempIVecArr = where((XXVecArr > 0) && (XXVecArr < 1), 1, 0);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): TempIVecArr set to " << TempIVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): TempIVecArr set to " << TempIVecArr << endl;
#endif
        NInd = sum(TempIVecArr);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): NInd = " << NInd << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): NInd = " << NInd << endl;
#endif
        IndVecArr.resize(NInd);
        IndVecArr = 0;
        int pos = 0;
        for (int n = 0; n < TempIVecArr.size(); n++)
        {
          if (TempIVecArr(n) == 1)
          {
            IndVecArr(pos) = n;
            pos++;
          }
        }
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): IndVecArr set to " << IndVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): IndVecArr set to " << IndVecArr << endl;
#endif
        ///      i1=ind(0) & i2=ind(nind-1)               ; for the first and the last subpixels.
        IFirst = IndVecArr(0);

#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): IFirst = " << IFirst << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): IFirst set to " << IFirst << endl;
#endif
        ILast  = IndVecArr(NInd - 1);
        IndVecArr.resize(1);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): ILast = " << ILast << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): ILast set to " << ILast << endl;
#endif

        ///      omega(0)=yy(i1)                          ; Fix the first and the last subpixel, here

        /** Fix the first and the last subpixels, here the weight is split between the two subpixels **/
        OmegaVecArr(0) = XXVecArr(IFirst);

#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
#endif

        ///      omega(osample)=1.-yy(i2)                 ; the weight is split between the two subpixels
        OmegaVecArr(this->I_OverSample) = 1. - XXVecArr(ILast);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OmegaVecArr(this->I_OverSample=" << this->I_OverSample << ") set to " << OmegaVecArr(this->I_OverSample) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OmegaVecArr(this->I_OverSample=" << this->I_OverSample << ") set to " << OmegaVecArr(this->I_OverSample) << endl;
#endif

        ///      bkl=dblarr(n,2*osample+1)                ; Band-diagonal part that will contain omega#omega
        /** Band-diagonal part that will contain omega#omega **/
        BKLArr.resize(N, (2 * this->I_OverSample) + 1);
        BKLArr = 0.;

        ///      o=omega#omega
        Array<double, 2> *p_OArr = VecArrACrossB(OmegaVecArr, OmegaVecArr);
        OArr.resize(p_OArr->rows(),p_OArr->cols());//OmegaVecArr.size(), OmegaVecArr.size());
        OArr = (*p_OArr);
        delete p_OArr;
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): 5. OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): 5. OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif

        ///      o(osample,osample)=o(osample,osample)+o(0,0)
        tmpdbl = OArr(this->I_OverSample, this->I_OverSample);
        tmpdbl += OArr(0, 0);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): tmpdbl set to " << tmpdbl << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): tmpdbl set to " << tmpdbl << endl;
#endif
        OArr(this->I_OverSample, this->I_OverSample) = tmpdbl;
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr(this->I_OverSample=" << this->I_OverSample << ", this->I_OverSample) set to " << OArr(this->I_OverSample, this->I_OverSample) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr(this->I_OverSample=" << this->I_OverSample << ", this->I_OverSample) set to " << OArr(this->I_OverSample, this->I_OverSample) << endl;
#endif

        ///      oo=o(olind)
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OLIndVecArr = " << OLIndVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OLIndVecArr = " << OLIndVecArr << endl;
#endif
        OOVecArr.resize(OLIndVecArr.size());
        OOVecArr = 0.;
        for (int n = 0; n < OLIndVecArr.size(); n++)
        {
          tempcol = this->GetColFromIndex(OLIndVecArr(n), OArr.rows());
          temprow = this->GetRowFromIndex(OLIndVecArr(n), OArr.rows());
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for (int n(=" << n << ") = 0; n < OLIndVecArr.size(=" << OLIndVecArr.size() << "); n++): setting OOVecArr to OArr(OLIndVecArr(temprow(=" << temprow << "), tempcol(=" << tempcol << "))=" << OArr(temprow, tempcol) << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for (int n(=" << n << ") = 0; n < OLIndVecArr.size(=" << OLIndVecArr.size() << "); n++): setting OOVecArr(n) to OArr(OLIndVecArr(temprow(=" << temprow << "), tempcol(=" << tempcol << "))=" << OArr(temprow, tempcol) << endl;
#endif
          if (temprow >= OArr.rows())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: temprow(=" << temprow << ") >= OArr.rows(=" << OArr.rows() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: temprow(=" << temprow << ") >= OArr.rows(=" << OArr.rows() << ")" << endl;
            return false;
          }
          if (tempcol >= OArr.cols())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: tempcol(=" << tempcol << ") >= OArr.cols(=" << OArr.cols() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: tempcol(=" << tempcol << ") >= OArr.cols(=" << OArr.cols() << ")" << endl;
            return false;
          }
          OOVecArr(n) = OArr(temprow, tempcol);
        }
        //          OLIndVecArr.resize(1);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OOVecArr set to " << OOVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OOVecArr set to " << OOVecArr << endl;
#endif

        ///      for l=0,nrow-1 do begin
        for (int n = 0; n < D_A2_ImM.cols(); n++)
        {
          ///        bkl(l*osample+i1+bklind)=oo*msk(i,l)

          //            (*P_OFS_Log) << "CFits::SlitFunc: 6. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

          for (int o = 0; o < BKLIndVecArr.size(); o++)
          {
            //              (*P_OFS_Log) << "CFits::SlitFunc: 6. for(o(= " << o << "); o < BKLIndVecArr.size(=" << BKLIndVecArr.size() << "); o++)" << endl;
#ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": n(=" << n << ") * this->I_OverSample(=" << this->I_OverSample << ") + IFirst(=" << IFirst << ") + BKLIndVecArr(o=" << o << ")=" << BKLIndVecArr(o) << " = " << (n * this->I_OverSample) + IFirst + BKLIndVecArr(o) << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": BKLIndVecArr = " << BKLIndVecArr << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": OOVecArr = " << OOVecArr << endl;
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": BKLArr = " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: n(=" << n << ") * this->I_OverSample(=" << this->I_OverSample << ") + IFirst(=" << IFirst << ") + BKLIndVecArr(o=" << o << ")=" << BKLIndVecArr(o) << " = " << (n * this->I_OverSample) + IFirst + BKLIndVecArr(o) << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: BKLIndVecArr = " << BKLIndVecArr << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: OOVecArr = " << OOVecArr << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: BKLArr = " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif

            tempcol = this->GetColFromIndex((n * this->I_OverSample) + IFirst + BKLIndVecArr(o), BKLArr.rows());
            temprow = this->GetRowFromIndex((n * this->I_OverSample) + IFirst + BKLIndVecArr(o), BKLArr.rows());

            if (temprow >= BKLArr.rows())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: temprow(=" << temprow << ") >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: ERROR: temprow(=" << temprow << ") >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
              return false;
            }

            if (tempcol >= BKLArr.cols())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: tempcol(=" << tempcol << ") >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: ERROR: tempcol(=" << tempcol << ") >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
              return false;
            }

            if (o >= OOVecArr.size())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: o(=" << o << ") >= OOVecArr.size(=" << OOVecArr.size() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: ERROR: o(=" << o << ") >= OOVecArr.size(=" << OOVecArr.size() << ")" << endl;
              return false;
            }
            if (m >= Mask.rows())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: m(=" << m << ") >= Mask.rows(=" << Mask.rows() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: ERROR: m(=" << m << ") >= Mask.rows(=" << Mask.rows() << ")" << endl;
              return false;
            }
            if (n >= Mask.cols())
            {
              cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: n(=" << n << ") >= Mask.cols(=" << Mask.cols() << ")" << endl;
              (*P_OFS_Log) << "CFits::SlitFunc: ERROR: n(=" << n << ") >= Mask.cols(=" << Mask.cols() << ")" << endl;
              return false;
            }
            BKLArr(temprow, tempcol) = OOVecArr(o) * Mask(m,n);
#ifdef __DEBUG_FITS_SLITFUNC__
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=0; n<NCols(=" << D_A2_ImM.cols() << "); n++): for(o(=" << o << ")=0; o<BKLIndVecArr(=" << BKLIndVecArr.size() << "); o++): BKLArr(((n * this->I_OverSample) + IFirst + BKLIndVecArr(o) = " << (n * this->I_OverSample) + IFirst + BKLIndVecArr(o) << ")(=^ temprow=" << temprow << ", tempcol=" << tempcol << ")) set to " << BKLArr(temprow, tempcol) << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=0; n<NCols(=" << D_A2_ImM.cols() << "); n++): for(o(=" << o << ")=0; o<BKLIndVecArr(=" << BKLIndVecArr.size() << "); o++): BKLArr(((n * this->I_OverSample) + IFirst + BKLIndVecArr(o) = " << (n * this->I_OverSample) + IFirst + BKLIndVecArr(o) << ")(=^ temprow=" << temprow << ", tempcol=" << tempcol << ") set to " << BKLArr(temprow, tempcol) << endl;
#endif
            //              }
          }/// end for (int o = 0; o < BKLIndVecArr.size(); o++)
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=0; n<NRows(=" << D_A2_ImM.rows() << "); n++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=0; n<NRows(=" << D_A2_ImM.rows() << "); n++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif
          //            CString bklfile("bkl");
          //            bklfile+=n;
          //            bklfile+=".dat";
          //            ofstream *ofs_bkl = new ofstream(bklfile.Get());
          //            (*ofs_bkl) << BKLArr << endl;
          ///      endfor
        }/// end for (int n = 0; n < D_A2_ImM.cols(); n++)

        //          (*P_OFS_Log) << "CFits::SlitFunc: 7. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OOVecArr set to " << OOVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OOVecArr set to " << OOVecArr << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif

        ///      oo=o(osample,osample)
        OOVecArr.resize(1);
        OOVecArr(0) = OArr(this->I_OverSample, this->I_OverSample);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OOVecArr set to " << OOVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OOVecArr set to " << OOVecArr << endl;
#endif

        ///      for l=1,nrow-1 do $
        for (int n = 1; n < D_A2_ImM.cols(); n++)
        {
          ///        bkl(l*osample+i1,osample)=oo*msk(i,l)
          if ((n*this->I_OverSample) + IFirst >= BKLArr.rows())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: (n*this->I_OverSample) + IFirst = " << (n*this->I_OverSample) + IFirst << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: (n*this->I_OverSample) + IFirst = " << (n*this->I_OverSample) + IFirst << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
            return false;
          }
          BKLArr((n * this->I_OverSample) + IFirst, this->I_OverSample) = OOVecArr(0) * Mask(m, n);
        }/// end for (int n = 1; n < D_A2_ImM.cols(); n++)
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif

        ///      bkl(nrow*osample+i1,osample)=omega(osample)^2*msk(i,nrow-1)
        if (D_A2_ImM.cols() * this->I_OverSample + IFirst >= BKLArr.rows())
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: D_A2_ImM.cols() * this->I_OverSample + IFirst = " << D_A2_ImM.cols() * this->I_OverSample + IFirst << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: ERROR: D_A2_ImM.cols() * this->I_OverSample + IFirst = " << D_A2_ImM.cols() * this->I_OverSample + IFirst << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
          return false;
        }
        BKLArr((D_A2_ImM.cols() * this->I_OverSample) + IFirst, this->I_OverSample) = pow(OmegaVecArr(this->I_OverSample),2) * Mask(m, D_A2_ImM.cols() - 1);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BKLArr((D_A2_ImM.cols() * this->I_OverSample) + IFirst=" << (D_A2_ImM.cols() * this->I_OverSample) + IFirst << ", this->I_OverSample=" << this->I_OverSample << ") set to " << BKLArr((D_A2_ImM.cols() * this->I_OverSample) + IFirst, this->I_OverSample) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BKLArr((D_A2_ImM.cols() * this->I_OverSample) + IFirst=" << (D_A2_ImM.cols() * this->I_OverSample) + IFirst << ", this->I_OverSample=" << this->I_OverSample << ") set to " << BKLArr((D_A2_ImM.cols() * this->I_OverSample) + IFirst, this->I_OverSample) << endl;
#endif
        ///      for m=0L,osample-1L do $
        for (int o = 0; o < this->I_OverSample; o++)
        {
          ///        bkl(osample-m:n-1L,m)=bkl(0L:n-1L-osample+m,2L*osample-m)
          if (N-1 >= BKLArr.rows())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: N-1 = " << N-1 << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: N-1 = " << N-1 << " >= BKLArr.rows(=" << BKLArr.rows() << ")" << endl;
            return false;
          }
          if (o >= BKLArr.cols())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: o = " << o << " >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: o = " << o << " >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
            return false;
          }
          if (2*this->I_OverSample-o >= BKLArr.cols())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: 2*this->I_OverSample-o = " << 2*this->I_OverSample-o << " >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: 2*this->I_OverSample-o = " << 2*this->I_OverSample-o << " >= BKLArr.cols(=" << BKLArr.cols() << ")" << endl;
            return false;
          }
          BKLArr(Range(this->I_OverSample-o, N - 1), o) = BKLArr(Range(0, N - 1 - this->I_OverSample + o), 2 * this->I_OverSample - o);
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(o(=" << o << ")=0; o<this->I_OverSample(=" << this->I_OverSample << "); o++): BKLArr(Range(this->I_OverSample-o=" << this->I_OverSample-o << ", N-1=" << N-1 << "),o=" << o << ") set to " << BKLArr(Range(this->I_OverSample-o, N - 1), o) << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(o(=" << o << ")=0; o<this->I_OverSample(=" << this->I_OverSample << "); o++): BKLArr(Range(this->I_OverSample-o=" << this->I_OverSample-o << ", N-1=" << N-1 << "),o=" << o << ") set to " << BKLArr(Range(this->I_OverSample-o, N - 1), o) << endl;
#endif

        }/// end for (int o = 0; o < this->I_OverSample; o++)
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BKLArr set to " << BKLArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif
        ///      Akl=Akl+sp(i)^2*bkl
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): AKLArr = " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): AKLArr = " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif
#ifdef __DEBUG_FITS_SLITFUNC__
        D_SPVecPow = pow(SPVecArr(m), 2);
        D_A2_SPVecTimesBKLArr.resize(BKLArr.rows(), BKLArr.cols());
        D_A2_SPVecTimesBKLArr = 0.;
        D_A2_SPVecTimesBKLArr = D_SPVecPow * BKLArr;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): D_SPVecPow = " << D_SPVecPow << " * BKLArr(= " << BKLArr << ") = " << D_A2_SPVecTimesBKLArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): D_SPVecPow = " << D_SPVecPow << " * BKLArr(= " << BKLArr << ") = " << D_A2_SPVecTimesBKLArr << endl;
#endif
        if (AKLArr.size() != BKLArr.size())
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: size of AKLArr(=" << AKLArr.size() << ") != size of BKLArr(=" << BKLArr.size() << ")";
          (*P_OFS_Log) << "CFits::SlitFunc: ERROR: size of AKLArr(=" << AKLArr.size() << ") != size of BKLArr(=" << BKLArr.size() << ")";
          return false;
        }
        AKLArr += (pow(SPVecArr(m), 2) * BKLArr);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): AKLArr set to " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): AKLArr set to " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif
        ///      o=dblarr(n)
        OArr.resize(N, 1);
        OArr = 0.;
        ///      for l=0,nrow-1 do $
        for (int n = 0; n < D_A2_ImM.cols(); n++)
        {
          ///        o(l*osample+i1:l*osample+i1+osample)= $
          ///        imm(i,l)*weight*msk(i,l)
          OArr(Range((n * this->I_OverSample) + IFirst, n * this->I_OverSample + IFirst + this->I_OverSample), 0) = D_A2_ImM(m, n) * Weight * Mask(m, n);
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr(Range(n * this->I_OverSample) + IFirst=" << (n * this->I_OverSample) + IFirst << ", n * this->I_OverSample + IFirst + this->I_OverSample=" << n * this->I_OverSample + IFirst + this->I_OverSample << "), 0) set to " << OArr(Range((n * this->I_OverSample) + IFirst, n * this->I_OverSample + IFirst + this->I_OverSample), 0) << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr(Range(n * this->I_OverSample) + IFirst=" << (n * this->I_OverSample) + IFirst << ", n * this->I_OverSample + IFirst + this->I_OverSample=" << n * this->I_OverSample + IFirst + this->I_OverSample << "), 0) set to " << OArr(Range((n * this->I_OverSample) + IFirst, n * this->I_OverSample + IFirst + this->I_OverSample), 0) << endl;
#endif

        }
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif
        ///      for l=1,nrow-1 do $

        //          (*P_OFS_Log) << "CFits::SlitFunc: 8. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

        for (int n = 1; n < D_A2_ImM.cols(); n++)
        {
          ///        o(l*osample+i1)=imm(i,l-1)*omega(osample)*msk(i,l-1) $
          ///        +imm(i,l)*omega(0)*msk(i,l)
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (D_A2_ImM(m,n-1)=" << D_A2_ImM(m, n-1) << ")" << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (Mask(m,n-1)=" << Mask(m, n-1) << ")" << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): OmegaVecArr(this->I_OverSample)=" << OmegaVecArr(this->I_OverSample) << ")" << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (D_A2_ImM(m,n)=" << D_A2_ImM(m, n) << ")" << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (Mask(m,n)=" << Mask(m, n) << ")" << endl;
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (OmegaVecArr(0)=" << OmegaVecArr(0) << ")" << endl;

          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (D_A2_ImM(m,n-1)=" << D_A2_ImM(m, n-1) << ")" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (Mask(m,n-1)=" << Mask(m, n-1) << ")" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (OmegaVecArr(this->I_OverSample)=" << OmegaVecArr(this->I_OverSample) << ")" << endl;

          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (D_A2_ImM(m,n)=" << D_A2_ImM(m, n) << ")" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (Mask(m,n)=" << Mask(m, n) << ")" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): (OmegaVecArr(0)=" << OmegaVecArr(0) << ")" << endl;
#endif
          OArr((n * this->I_OverSample) + IFirst, 0) = (D_A2_ImM(m, n-1) * OmegaVecArr(this->I_OverSample) * Mask(m, n-1)) + (D_A2_ImM(m, n) * OmegaVecArr(0) * Mask(m, n));
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): OArr((n * this->I_OverSample) + IFirst=" << (n * this->I_OverSample) + IFirst << ", 0) set to " << OArr((n * this->I_OverSample) + IFirst, 0) << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): for(n(=" << n << ")=1; n<NCols(=" << D_A2_ImM.cols() << "); n++): OArr((n * this->I_OverSample) + IFirst=" << (n * this->I_OverSample) + IFirst << ", 0) set to " << OArr((n * this->I_OverSample) + IFirst, 0) << endl;
#endif

        }/// end for (int n = 1; n < D_A2_ImM.cols(); n++)
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif
        ///      o(i1)=imm(i,0)*omega(0)*msk(i,0)
        OArr(IFirst, 0) = D_A2_ImM(m, 0) * OmegaVecArr(0) * Mask(m, 0);
        ///      o(nrow*osample+i1)=imm(i,nrow-1)*omega(osample)*msk(i,nrow-1)
        OArr((D_A2_ImM.cols() * this->I_OverSample) + IFirst, 0) = D_A2_ImM(m, D_A2_ImM.cols() - 1) * OmegaVecArr(this->I_OverSample) * Mask(m, D_A2_ImM.cols() - 1);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif
        ///      Bl=Bl+sp(i)*o
        BLVecArr(Range::all()) += ((SPVecArr(m) * OArr(Range::all(), 0)));
#ifdef __DEBUG_FITS_SLITFUNC1__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": end for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BLVecArr set to " << BLVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: end for(m(=" << m << ")=0; m<NRows(=" << D_A2_ImM.rows() << "); m++): BLVecArr set to " << BLVecArr << endl;
#endif
      } /** end for (int m = 0; m < D_A2_ImM.cols(); m++) **/

      //        (*P_OFS_Log) << "CFits::SlitFunc: 9. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": end for(m=0; m<NRows; m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: end for(m=0; m<NRows; m++): OArr set to " << OArr << endl;//.transpose(secondDim,firstDim) << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": end for(m=0; m<NRows; m++): BLVecArr set to " << BLVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: end for(m=0; m<NRows; m++): BLVecArr set to " << BLVecArr << endl;
#endif

      ///    lambda = lamb_sf*total(Akl(*,osample))/n
      Lambda = Lamb_SF * sum(AKLArr(Range::all(), this->I_OverSample)) / N;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Lambda set to Lamb_SF(=" << Lamb_SF << ")*total(AKLArr(*,this->I_OverSample)=" << AKLArr(Range::all(), this->I_OverSample) << ")=" << sum(AKLArr(Range::all(), this->I_OverSample)) << " =>  =  " << Lambda << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: Lambda set to Lamb_SF(=" << Lamb_SF << ")*total(AKLArr(*,this->I_OverSample)=" << AKLArr(Range::all(), this->I_OverSample) << ")=" << sum(AKLArr(Range::all(), this->I_OverSample)) << " =>  =  " << Lambda << endl;
#endif

      /**
       1st order Tikhonov regularization (minimum 1st derivatives)
       Add the following 3-diagonal matrix * lambda:
        1 -1  0  0  0  0
       -1  2 -1  0  0  0
        0 -1  2 -1  0  0
        0  0 -1  2 -1  0
            .  .  .
       **/
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Start 1st order Tikhonov: AKLArr = " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: Start 1st order Tikhonov: AKLArr = " << AKLArr << endl;//.transpose(secondDim,firstDim) << endl;
#endif

      ///    Akl(  0,osample)=Akl(  0,osample)+lambda   ; +lambda to the upper-left element
      AKLArr(0, this->I_OverSample) += Lambda; /** + Lambda to the upper-left element **/
#ifdef __DEBUG_FITS_SLITFUNC1__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 1st order Tikhonov: AKLArr(0,this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(0,this->I_OverSample) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 1st order Tikhonov: AKLArr(0,this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(0,this->I_OverSample) << endl;
#endif

      ///    Akl(n-1,osample)=Akl(n-1,osample)+lambda   ; and to the lower-right
      AKLArr(N-1,this->I_OverSample) += Lambda; /** and to the lower-right **/
#ifdef __DEBUG_FITS_SLITFUNC1__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 1st order Tikhonov: AKLArr(N-1=" << N-1 << ",this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(N-1,this->I_OverSample) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 1st order Tikhonov: AKLArr(N-1=" << N-1 << ",this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(N-1,this->I_OverSample) << endl;
#endif

      ///    Akl(1L:n-2L,osample)=Akl(1L:n-2L,osample)+2.*lambda    ; +2*lambda to the rest of the main diagonal
      AKLArr(Range(1,N-2), this->I_OverSample) += 2. * Lambda; /** +2*Lambda to the rest of the main diagonal **/
#ifdef __DEBUG_FITS_SLITFUNC1__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 1st order Tikhonov: AKLArr(Range(1,N-2=" << N-2 << "),this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(Range(1,N-2),this->I_OverSample) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 1st order Tikhonov: AKLArr(Range(1,N-2=" << N-2 << "),this->I_OverSample=" << this->I_OverSample << ") set to " << AKLArr(Range(1,N-2),this->I_OverSample) << endl;
#endif

      ///    Akl(0L:n-2L,osample+1L)=Akl(0L:n-2L,osample+1L)-lambda ; -lambda to the upper sub-diagonal
      AKLArr(Range(0, N - 2), this->I_OverSample + 1) -= Lambda; /** -Lambda to the upper sub-diagonal **/
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 1st order Tikhonov: AKLArr(Range(0,N-2=" << N-2 << "),this->I_OverSample+1=" << this->I_OverSample+1 << ") set to " << AKLArr(Range(0,N-2),this->I_OverSample+1) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 1st order Tikhonov: AKLArr(Range(0,N-2=" << N-2 << "),this->I_OverSample+1=" << this->I_OverSample+1 << ") set to " << AKLArr(Range(0,N-2),this->I_OverSample+1) << endl;
#endif

      ///    Akl(1L:n-1L,osample-1L)=Akl(1L:n-1L,osample-1L)-lambda ; -lambda to the lower sub-diagonal
      AKLArr(Range(1, N - 1), this->I_OverSample - 1) -= Lambda; /** -Lambda to the lower sub-diagonal **/
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 1st order Tikhonov: AKLArr(Range(1,N-1=" << N-1 << "),this->I_OverSample-1=" << this->I_OverSample-1 << ") set to " << AKLArr(Range(1,N-1),this->I_OverSample-1) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 1st order Tikhonov: AKLArr(Range(1,N-1=" << N-1 << "),this->I_OverSample-1=" << this->I_OverSample-1 << ") set to " << AKLArr(Range(1,N-1),this->I_OverSample-1) << endl;
#endif

#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Start. 1st order Tikhonov: AKLArr = " << AKLArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 1st order Tikhonov: AKLArr = " << AKLArr << endl;
#endif

      /**
       2nd order Tikhonov regularization (minimum 2nd derivative)
       Add the following 5-diagonal matrix * lambda:
        1 -2  1  0  0  0
       -2  5 -4  1  0  0
        1 -4  6 -4  1  0
        0  1 -4  6 -4  1
            .  .  .
       **/
      ///    m = CALL_EXTERNAL(band_solv_name, 'bandsol', $
      ///    Akl, Bl, n, 2*osample+1L)
      void **PP_Void = (void**)malloc(sizeof(void*) * 4);
      D_A2_AKLT.resize(AKLArr.cols(), AKLArr.rows());
      D_A2_AKLT = AKLArr.transpose(secondDim, firstDim);
#ifdef __DEBUG_FITS_SLITFUNC1__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Start. 2nd order Tikhonov: AKLArr = " << AKLArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: AKLArr = " << AKLArr << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Start. 2nd order Tikhonov: D_A2_AKLT = " << D_A2_AKLT << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: D_A2_AKLT = " << D_A2_AKLT << endl;
#endif
      PP_Void[0] = D_A2_AKLT.data();
      PP_Void[1] = BLVecArr.data();
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Start. 2nd order Tikhonov: BLVecArr = " << BLVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: BLVecArr = " << BLVecArr << endl;
#endif
      PP_Void[2] = &N;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Start. 2nd order Tikhonov: N = " << N << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: N = " << N << endl;
#endif
      TempInt = (2 * this->I_OverSample) + 1;
      PP_Void[3] = &TempInt;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: TempInt = " << TempInt << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: TempInt = " << TempInt << endl;
#endif
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: Starting BandSol(D_A2_AKLT=" << D_A2_AKLT << ", BLVecArr=" << BLVecArr << ", N=" << N << ", TempInt=" << TempInt << ")" << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: Starting BandSol(D_A2_AKLT=" << D_A2_AKLT << ", BLVecArr=" << BLVecArr << ", N=" << N << ", TempInt=" << TempInt << ")" << endl;
#endif
      int M = this->BandSol(4, PP_Void);
      AKLArr = D_A2_AKLT.transpose(secondDim, firstDim);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: After BandSol: D_A2_AKLT=" << D_A2_AKLT << ", AKLArr=" << AKLArr << ", BLVecArr=" << BLVecArr << ", N=" << N << ", TempInt=" << TempInt << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: After BandSol: D_A2_AKLT=" << D_A2_AKLT << ", AKLArr=" << AKLArr << ", BLVecArr=" << BLVecArr << ", N=" << N << ", TempInt=" << TempInt << endl;
#endif
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: M(BandSol) = " << M << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: M(BandSol) = " << M << endl;
#endif

      //        (*P_OFS_Log) << "CFits::SlitFunc: 10. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

      ///    sf=Bl/total(Bl)*osample
      SFVecArr.resize(BLVecArr.size());
      if (abs(sum(BLVecArr)) < 0.000000001)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": WARNING: sum(BLVecArr) == 0" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: WARNING: sum(BLVecArr) == 0" << endl;
        BLVecArr = 1.;
        //          return false;
      }
      SFVecArr = BLVecArr / sum(BLVecArr) * this->I_OverSample;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: SFVecArr = " << SFVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: SFVecArr = " << SFVecArr << endl;
#endif

      ///    sp_old=sp
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: SPVecArr = " << SPVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: SPVecArr = " << SPVecArr << endl;
#endif
      SPOldVecArr.resize(SPVecArr.size());
      SPOldVecArr = SPVecArr;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: SPOldVecArr = " << SPOldVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: SPOldVecArr = " << SPOldVecArr << endl;
#endif

      ///    r=sp
      RVecArr.resize(SPVecArr.size());
      RVecArr = SPVecArr;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: RVecArr = " << RVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: RVecArr = " << RVecArr << endl;
#endif

      ///    omega=replicate(weight,osample)
      OmegaVecArr.resize(this->I_OverSample);
      OmegaVecArr = Weight;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": 2nd order Tikhonov: OmegaVecArr = " << OmegaVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: 2nd order Tikhonov: OmegaVecArr = " << OmegaVecArr << endl;
#endif

      /** Evaluate the new Spectrum **/
      ///    for i=0,ncol-1 do begin                    ; Evaluate the new spectrum
      for (int m = 0; m < D_A2_ImM.rows(); m++)
      {
        ///      yy=y+yycen(i)                            ; Offset SF
        XXVecArr = XVecArr;
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): XXVecArr set to " << XXVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): XXVecArr set to = " << XXVecArr << endl;
#endif
        XXVecArr += XCenVecArr(m);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): XXVecArr = " << XXVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): XXVecArr = " << XXVecArr << endl;
#endif
        ///      i1=where(yy ge 0 and yy lt nrow, nind)
        TempIVecArr.resize(XXVecArr.size());
        TempIVecArr = where(XXVecArr >= 0. && XXVecArr < (double)(D_A2_ImM.cols()), 1, 0);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): TempIVecArr(where) = " << TempIVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): TempIVecArr(where) = " << TempIVecArr << endl;
#endif
        int i_temp_sum = sum(TempIVecArr);
        if (i_temp_sum == 0)
        {
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": sum(TempIVecArr=" << TempIVecArr << ") = 0!!!!!!!!!!!!!!!!!!!!!!!111!!!!!!";
          (*P_OFS_Log) << "CFits::SlitFunc: sum(TempIVecArr=" << TempIVecArr << ") = 0!!!!!!!!!!!!!!!!!!!!!!!111!!!!!!";
#endif

        }
        IFirstVecArr.resize(sum(TempIVecArr));
        IFirstVecArr = 0;
        TempInt = 0;
        for (int n = 0; n < TempIVecArr.size(); n++)
        {
          if (TempIVecArr(n) > 0)
          {
            IFirstVecArr(TempInt) = n;
            TempInt++;
          }
        }
        TempIVecArr.resize(1);
        ///      i2=i1(nind-1)
        ILast = IFirstVecArr(IFirstVecArr.size()-1);
        ///      i1=i1(0)
        IFirst = IFirstVecArr(0);
        IFirstVecArr.resize(1);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): IFirst = " << IFirst << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): IFirst = " << IFirst << endl;
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): ILast = " << ILast << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): ILast = " << ILast << endl;
#endif

        ///      omega(0)=yy(i1)
        OmegaVecArr(0) = XXVecArr(IFirst);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
#endif

        ///      ssf=reform(sf(i1:i2),osample,nrow)
        //          SSFTArr.resize(D_A2_ImM.cols(), this->I_OverSample);
        //          SSFTArr = 0.;

        TempDVecArr.resize(ILast - IFirst + 1);
        TempDVecArr = SFVecArr(Range(IFirst, ILast));
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): TempDVecArr set to " << TempDVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): TempDVecArr set to " << TempDVecArr << endl;
#endif
        Array<double, 2> *p_SSFTArr = this->Reform(TempDVecArr, (int)D_A2_ImM.cols(), this->I_OverSample);
        SSFArr.resize(this->I_OverSample, (int)D_A2_ImM.cols());
        SSFArr = p_SSFTArr->transpose(secondDim, firstDim);
        delete p_SSFTArr;
        TempDVecArr.resize(0);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): SSFArr set to " << SSFArr << endl;//.transpose(secondDim, firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): SSFArr set to " << SSFArr << endl;//.transpose(secondDim, firstDim) << endl;
#endif

        ///      o=reform(ssf##omega)
        tempint = SSFArr.cols();

        D_A2_TempAA.resize(SSFArr.cols(), SSFArr.rows());
        D_A2_TempAA =
          SSFArr.transpose(secondDim,firstDim);

        //TempDVecArr.resize(tempint);
        Array<double, 1> *p_TempDVecArrBB = this->MatrixTimesVecArr(D_A2_TempAA,
                                            OmegaVecArr);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): TempDVecArr set to " << *p_TempDVecArrBB << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): TempDVecArr set to " << *p_TempDVecArrBB << endl;
#endif
        OArr.resize(tempint, 1);
        //          for (int n = 0; n < SSFArr.rows(); n++)
        OArr(Range(0,tempint-1), 0) = (*p_TempDVecArrBB)(Range(0,tempint-1));
        delete p_TempDVecArrBB;
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): OArr set to " << OArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
#endif

        ///      yyy=nrow-yy(i2)
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): D_A2_ImM.cols(=" << D_A2_ImM.cols() << ") - XXVecArr(ILast=" << ILast << ")(=" << XXVecArr(ILast) << ") = " << D_A2_ImM.cols() - XXVecArr(ILast) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): D_A2_ImM.cols(=" << D_A2_ImM.cols() << ") - XXVecArr(ILast=" << ILast << ")(=" << XXVecArr(ILast) << ") = " << D_A2_ImM.cols() - XXVecArr(ILast) << endl;
#endif
        XXX = D_A2_ImM.cols() - XXVecArr(ILast);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): XXX set to " << XXX << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): XXX set to " << XXX << endl;
#endif

        ///      o(0:nrow-2)=o(0:nrow-2)+reform(ssf(0,1:nrow-1))*yyy
        TempDVecArr.resize(D_A2_ImM.cols()-1);
        TempDVecArr = SSFArr(0, Range(1, D_A2_ImM.cols()-1));
        TempDVecArr *= XXX;
        OArr(Range(0, D_A2_ImM.cols() - 2), 0) += TempDVecArr;
        ///      o(nrow-1)=o(nrow-1)+sf(i2+1)*yyy
        OArr(D_A2_ImM.cols() - 1, 0) += SFVecArr(ILast + 1) * XXX;
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
#endif

        //        (*P_OFS_Log) << "CFits::SlitFunc: 11. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

        ///      r(i)  = ((imm(i,*)*msk(i,*))#o)
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): D_A2_ImM(m, all()) = " << D_A2_ImM(m, Range::all()) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): D_A2_ImM(m, all()) = " << D_A2_ImM(m, Range::all()) << endl;
#endif

        ///      r(i)  = ((imm(i,*)*msk(i,*))#o)
        D_A1_TempDVecArr.resize(D_A2_ImM.cols());
        D_A1_TempDVecArr = D_A2_ImM(m, Range::all());
        D_A1_TempDVecArr *= Mask(m, Range::all());
        D_A1_TempDVecArrAA.resize(OArr.rows());
        D_A1_TempDVecArrAA = OArr(Range::all(), 0);

        if (D_A1_TempDVecArr.size() != D_A1_TempDVecArrAA.size())
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: D_A1_TempDVecArr.size(=" << D_A1_TempDVecArr.size() << ")=(" << D_A1_TempDVecArr << ") != D_A1_TempDVecArrAA.size(=" << D_A1_TempDVecArrAA.size() << ") = (" << D_A1_TempDVecArrAA << ")" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: ERROR: D_A1_TempDVecArr.size(=" << D_A1_TempDVecArr.size() << ")=(" << D_A1_TempDVecArr << ") != D_A1_TempDVecArrAA.size(=" << D_A1_TempDVecArrAA.size() << ") = (" << D_A1_TempDVecArrAA << ")" << endl;
          return false;
        }

        RVecArr(m) = this->VecArrAScalarB(D_A1_TempDVecArr, D_A1_TempDVecArrAA);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): RVecArr(m) set to " << RVecArr(m) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): RVecArr(m) set to " << RVecArr(m) << endl;
#endif
        ///      sp(i) = total(o^2*msk(i,*))
        TempDVecArr.resize(OArr.rows());
        TempDVecArr = (pow2(OArr(Range::all(), 0)));
        TempDVecArr(Range::all()) *= Mask(m, Range::all());
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): TempDVecArrA set to " << TempDVecArrA << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): TempDVecArrA set to " << TempDVecArrA << endl;
#endif
        SPVecArr(m) = sum(TempDVecArr);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): SPVecArr(m=" << m << ") set to " << SPVecArr(m) << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): SPVecArr(m=" << m << ") set to " << SPVecArr(m) << endl;
#endif
        ///      if(sp(i) eq 0.d0) then $
        ///        sp(i)=total(o^2)
        if (fabs(SPVecArr(m)) < 0.000001)
        {
          SPVecArr(m) = sum(pow2(OArr));
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): was == 0: SPVecArr(m=" << m << ") set to " << SPVecArr << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): was == 0: SPVecArr(m=" << m << ") set to " << SPVecArr(m) << endl;
#endif

        }
        /*
        if(iter gt 1) then begin
          j=where(abs((imm(i,*)-r(i)/sp(i)*o)) gt 3.*dev,nj,COMPLEMENT=b)
          if(nj gt 0) then begin
            msk(i,j)=0B
          endif
          if(nj lt nrow) then msk(i,b)=1B
        endif
        endfor
        */
        ///Locate and mask outliers
        if (Iter > 1)
        {
          TempDVecArr.resize(D_A2_ImM.cols());
          TempDVecArr = 0.;
          TempDVecArrA.resize(D_A2_ImM.cols());
          TempDVecArrA = 0.;
          TempDVecArrB.resize(OArr.rows());
          TempDVecArrB = 0.;
          TempDVecArr = D_A2_ImM(m, Range::all());
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): Iter(=" << Iter << ") > 1: TempDVecArr set to " << TempDVecArr << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): Iter(=" << Iter << ") > 1: TempDVecArr set to " << TempDVecArr << endl;
#endif
          TempDVecArrB = OArr(Range::all(), 0);
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): Iter(=" << Iter << ") > 1: TempDVecArrB set to " << TempDVecArrB << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): Iter(=" << Iter << ") > 1: TempDVecArrB set to " << TempDVecArrB << endl;
#endif
          TempDVecArrA = where(fabs(TempDVecArr - (TempDVecArrB * (RVecArr(m)/SPVecArr(m)))) > 3. * Dev, 1, 0);
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): Iter(=" << Iter << ") > 1: TempDVecArrA set to " << TempDVecArrA << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): Iter(=" << Iter << ") > 1: TempDVecArrA set to " << TempDVecArrA << endl;
#endif
          if (sum(TempDVecArrA) > 0)
          {
            for (int n = 0; n < TempDVecArrA.size(); n++)
            {
              if (TempDVecArrA(n) == 1)
              {
                Mask(m, n) = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): Iter(=" << Iter << ") > 1: Mask(m=" << m << ", n=" << n << ") set to " << Mask(m,n) << endl;
                (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): Iter(=" << Iter << ") > 1: Mask(m=" << m << ", n=" << n << ") set to " << Mask(m,n) << endl;
#endif

              }
            } /// end for (int n = 0; n < TempDVecArrA.size(); n++)
          } /// end if (sum(TempDVecArrA) > 0)
          if (sum(TempDVecArrA) < D_A2_ImM.cols())
          {
            for (int n = 0; n < TempDVecArrA.size(); n++)
            {
              if (TempDVecArrA(n) == 0)
              {
                Mask(m, n) = 1.;
#ifdef __DEBUG_FITS_SLITFUNC__
                cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": for(m==" << m << "): Iter(=" << Iter << ") > 1: Mask(m=" << m << ", n=" << n << ") set to " << Mask(m,n) << endl;
                (*P_OFS_Log) << "CFits::SlitFunc: for(m==" << m << "): Iter(=" << Iter << ") > 1: Mask(m=" << m << ", n=" << n << ") set to " << Mask(m,n) << endl;
#endif

              }
            } /// end for (int n = 0; n < TempDVecArrA.size(); n++)
          }
        } /// end if (Iter > 1)
      } ///end for (int m = 0; m < D_A2_ImM.rows(); m++)

      //        (*P_OFS_Log) << "CFits::SlitFunc: 12. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

      ///    if(keyword_set(lamb_sp)) then begin
      ///    endif else sp=r/sp
      P_TempString->Set("LAMBDA_SP");
      if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0)
      {
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SP): Pos = " << Pos << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SP): Pos = " << Pos << endl;
#endif
        Lamb_SP = (*(double*)ArgV[Pos]);
        //atof(this->GetKeyWordValueFromCStringArray(const_cast<const CString**>(Args), NArgs, (*(new CString("Lamb_SP"))))->Get());
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SP): Lamb_SP set to " << Lamb_SP << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SP): Lamb_SP set to " << Lamb_SP << endl;
#endif
        if (abs(Lamb_SP) > 0.0000001)
        {
          ///      lambda = lamb_sp*total(sp)/ncol
          Lambda = Lamb_SP * sum(SPVecArr) / D_A2_ImM.rows();
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SP): Lambda set to " << Lambda << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SP): Lambda set to " << Lambda << endl;
#endif
          ///      a =[0.,replicate(-lambda,ncol-1)]
          a.resize(D_A2_ImM.rows());
          a = 0. - Lambda;
          a(0) = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SP): a set to " << a << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SP): a set to " << a << endl;
#endif
          ///      b =[lambda+1.,replicate(2.*lambda+1.,ncol-2),lambda+1.]
          b.resize(D_A2_ImM.rows());
          b = (2. * Lambda) + 1.;
          b(0) = Lambda + 1.;
          b(D_A2_ImM.rows() - 1) = Lambda + 1.;
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SP): b set to " << b << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SP): b set to " << b << endl;
#endif
          ///      c =[replicate(-lambda,ncol-1),0.]
          c.resize(D_A2_ImM.rows());
          c = 0. - Lambda;
          c(D_A2_ImM.rows() - 1) = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SP): c set to " << c << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SP): c set to " << c << endl;
#endif

          ///      sp=trisol(a,b,c,r/sp)
          //          SPVecArr.resize(D_A2_ImM.rows());
          //          SPVecArr = 0.;
          if (D_A2_ImM.rows() != SPVecArr.size())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: D_A2_ImM.rows(=" << D_A2_ImM.rows() << ") != SPVecArr.size(=" << SPVecArr.size() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: D_A2_ImM.rows(=" << D_A2_ImM.rows() << ") != SPVecArr.size(=" << SPVecArr.size() << ")" << endl;
            return false;
          }
          TempDVecArr.resize(D_A2_ImM.rows());
          TempDVecArr = RVecArr / SPVecArr;
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SP): TempDVecArr set to " << TempDVecArr << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SP): TempDVecArr set to " << TempDVecArr << endl;
#endif
          this->TriDag(a, b, c, TempDVecArr, SPVecArr);
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(LAMBDA_SP): after TriDag: SPVecArr set to " << SPVecArr << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(LAMBDA_SP): after TriDag: SPVecArr set to " << SPVecArr << endl;
#endif

        }
      }
      ///else
      if (Pos < 0 || (Pos >= 0 && abs(Lamb_SP) < 0.0000001))
      {
        SPVecArr = RVecArr / SPVecArr;
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": Not KeyWord_Set(LAMBDA_SP): SPVecArr set to " << SPVecArr << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: Not KeyWord_Set(LAMBDA_SP): SPVecArr set to " << SPVecArr << endl;
#endif

      } /// end else if ((Pos = this->KeyWord_Set(const_cast<const CString**>(Args), NArgs, *P_TempString)) < 0)
      /*
      if(iter lt 8 and max(abs(sp-sp_old)/max(sp)) gt 1.d-5) then goto,next
      */
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": end if (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001)" << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: end if (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001)" << endl;
#endif

    } /// end if (Iter == 1 || max(abs(SPVecArr-SPOldVecArr)/max(SPVecArr)) > 0.00001)
    else
    {
      if (Iter != 1)
      {
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": !if (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001) => breaking while loop" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: !if (max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)=" << max(SPVecArr) << ")=" << max(fabs(SPVecArr - SPOldVecArr) / max(SPVecArr)) << " > 0.00001) => breaking while loop" << endl;
#endif
        break;
      }/// end if (Iter != 1)
    }/// end else if (Iter != 1 && max(abs(SPVecArr-SPOldVecArr)/max(SPVecArr)) <= 0.00001)
  } /// end while(Iter < 8)

  //    (*P_OFS_Log) << "CFits::SlitFunc: 13. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

  /*
  jbad=0L
  if(arg_present(im_out)) then begin
    ncol=n_elements(ycen)
  */
  (*P_I_A1_JBadVecArr)(0) = 0;
  P_TempString->Set("IM_OUT");
  if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0)
  {
    if (P_D_A2_ImOut != NULL)
      delete P_D_A2_ImOut;
    P_D_A2_ImOut = (Array<double, 2>*)ArgV[Pos];
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): P_D_A2_ImOut read " << endl;// to " << *P_D_A2_ImOut << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): P_D_A2_ImOut read" << endl;// to " << *P_D_A2_ImOut << endl;
#endif
    P_D_A2_ImOut->resize(D_A2_ImM.rows(), D_A2_ImM.cols());
    (*P_D_A2_ImOut) = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): P_D_A2_ImOut initialized to size " << P_D_A2_ImOut->rows() << "x" << P_D_A2_ImOut->cols() << endl;// to " << *P_D_A2_ImOut << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): P_D_A2_ImOut initialized to size " << P_D_A2_ImOut->rows() << "x" << P_D_A2_ImOut->cols() << endl;// to " << *P_D_A2_ImOut << endl;
#endif

    NRowsOut = XCenVecArr.size();
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): NRowsOut set to " << NRowsOut << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): NRowsOut set to " << NRowsOut << endl;
#endif
    /**
    if(keyword_set(use_col)) then $
      sp=interpol(sp,use_col,findgen(ncol))
    */
    P_TempString->Set("USE_ROW");
    if ((Pos = this->KeyWord_Set(CS_A1_Args, *P_TempString)) >= 0 && TempIntB != 0)
    {
      /// Interpolate SPVecArr
      D_A1_Ind.resize(D_A2_ImM.rows());
      D_A1_Ind = i;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): KeyWord_Set(USE_ROW): MARK: INTERPOL: SPVecArr = " << SPVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: MARK: INTERPOL: KeyWord_Set(IM_OUT): KeyWord_Set(USE_ROW): SPVecArr = " << SPVecArr << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): KeyWord_Set(USE_ROW): MARK: INTERPOL: D_A1_Ind = " << D_A1_Ind << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: MARK: INTERPOL: KeyWord_Set(IM_OUT): KeyWord_Set(USE_ROW): D_A1_Ind = " << D_A1_Ind << endl;
      //        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): KeyWord_Set(USE_ROW): MARK: INTERPOL: FixD(UseRowVecArr) = " << FixD(UseRowVecArr) << endl;
      //        (*P_OFS_Log) << "CFits::SlitFunc: MARK: INTERPOL: KeyWord_Set(IM_OUT): KeyWord_Set(USE_ROW): FixD(UseRowVecArr) = " << FixD(UseRowVecArr) << endl;
#endif
      Array<double, 1> *p_tempDblVecArrA = FixD(UseRowVecArr);
      Array<double, 1> tempDblVecArrB(3);
      this->InterPol(SPVecArr, *p_tempDblVecArrA, D_A1_Ind, tempDblVecArrB);
      SPVecArr = tempDblVecArrB;
      delete p_tempDblVecArrA;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): KeyWord_Set(USE_ROW): MARK: INTERPOL: SPVecArr set to " << SPVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: MARK: INTERPOL: KeyWord_Set(IM_OUT): KeyWord_Set(USE_ROW): SPVecArr set to " << SPVecArr << endl;
#endif

    }

    //      (*P_OFS_Log) << "CFits::SlitFunc: 13. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

    ///      im_out=fltarr(ncol,nrow)
    P_D_A2_ImOut->resize(NRowsOut, D_A2_ImM.cols());
    (*P_D_A2_ImOut) = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): P_D_A2_ImOut resized to (" << NRowsOut << ", " << D_A2_ImM.cols() << ")" << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): P_D_A2_ImOut resized to (" << NRowsOut << ", " << D_A2_ImM.cols() << ")" << endl;
#endif

    ///      omega=replicate(weight,osample)
    OmegaVecArr.resize(this->I_OverSample);
    OmegaVecArr = Weight;
#ifdef __DEBUG_FITS_SLITFUNC__
    cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): OmegaVecArr set to " << OmegaVecArr << endl;
    (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): OmegaVecArr set to " << OmegaVecArr << endl;
#endif

    /*
    for i=0,ncol-1 do begin                    ; Evaluate the new spectrum
      yy=y+ycen(i)                             ; Offset SF
      i1=where(yy ge 0 and yy lt nrow, nind)
      i2=i1(nind-1)
      i1=i1(0)
    */
    for (int m = 0; m < NRowsOut; m++)  /// Evaluate the new spectrum
    {
      //        (*P_OFS_Log) << "CFits::SlitFunc: for(m(=" << m << "); m < NRowsOut(=" << NRowsOut << "); m++): MARK MARK MARK" << endl;
      XXVecArr = XVecArr + XCenVecArr(m);
      TempIVecArr.resize(XXVecArr.size());
      TempIVecArr = 0;

#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): XXVecArr = " << XXVecArr << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): D_A2_ImM->cols = " << D_A2_ImM.cols() << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): XXVecArr = " << XXVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): D_A2_ImM->cols = " << D_A2_ImM.cols() << endl;
#endif

      TempIVecArr = where(XXVecArr > 0. && XXVecArr < (double)(D_A2_ImM.cols()), 1, 0);

#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): TempIVecArr(where) = " << TempIVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): TempIVecArr(where) = " << TempIVecArr << endl;
#endif

      i_tmp_sum = sum(TempIVecArr);
      if (i_tmp_sum == 0)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): ERROR: i_tmp_sum == 0!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): ERROR: i_tmp_sum == 0!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
        return false;
      }
      IFirstVecArr.resize(i_tmp_sum);
      IFirstVecArr = 0;
      TempInt = 0;
      for (int n = 0; n < TempIVecArr.size(); n++)
      {
        if (TempIVecArr(n) > 0)
        {
          IFirstVecArr(TempInt) = n;
          TempInt++;
        }
      }
      IFirst = IFirstVecArr(0);
      ILast = IFirstVecArr(IFirstVecArr.size() - 1);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): IFirst set to " << IFirst << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): IFirst set to " << IFirst << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): ILast set to " << ILast << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): ILast set to " << ILast << endl;
#endif

      ///        omega(0)=yy(i1)
      OmegaVecArr(0) = XXVecArr(IFirst);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OmegaVecArr(0) set to " << OmegaVecArr(0) << endl;
#endif

      ///        ssf=reform(sf(i1:i2),osample,nrow) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      SSFArr.resize(this->I_OverSample, D_A2_ImM.cols());
      SSFArr = 0.;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): SFVecArr = " << SFVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): SFVecArr = " << SFVecArr << endl;
#endif
      TempDVecArr.resize(ILast - IFirst + 1);
      TempDVecArr = SFVecArr(Range(IFirst, ILast));
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): TempDVecArr set to " << TempDVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): TempDVecArr set to " << TempDVecArr << endl;
#endif
      if (TempDVecArr.size() != D_A2_ImM.cols() * this->I_OverSample)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: size of TempDVecArr(=" << TempDVecArr.size() << ") != D_A2_ImM.cols(=" << D_A2_ImM.cols() << ") * this->I_OverSample(=" << this->I_OverSample << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: size of TempDVecArr(=" << TempDVecArr.size() << ") != D_A2_ImM.cols(=" << D_A2_ImM.cols() << ") * this->I_OverSample(=" << this->I_OverSample << ")" << endl;
        return false;
      }
      Array<double, 2> *p_D_A2_SSFT = Reform(TempDVecArr, D_A2_ImM.cols(), this->I_OverSample);
      TempDVecArr.resize(0);
      SSFArr = p_D_A2_SSFT->transpose(secondDim, firstDim);
      delete p_D_A2_SSFT;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): SSFArr set to " << SSFArr << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): SSFArr set to " << SSFArr << endl;//.transpose(secondDim, firstDim) << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OmegaVecArr set to " << OmegaVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OmegaVecArr set to " << OmegaVecArr << endl;
#endif

      ///        o=reform(reform(ssf##omega))
      OArr.resize(SSFArr.cols(), 1);
      D_A2_OT.resize(SSFArr.cols(), SSFArr.rows());
      D_A2_OT = SSFArr.transpose(secondDim, firstDim);
      if (OArr.rows() != D_A2_OT.rows())
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: OArr.rows(=" << OArr.rows() << ") != D_A2_OT.rows(=" << D_A2_OT.rows() << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: OArr.rows(=" << OArr.rows() << ") != D_A2_OT.rows(=" << D_A2_OT.rows() << ")" << endl;
        return false;
      }
      Array<double, 1> *p_TempDVecArrAA = this->MatrixTimesVecArr(D_A2_OT, OmegaVecArr);
      OArr(Range::all(), 0) = (*p_TempDVecArrAA);
      delete p_TempDVecArrAA;
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
#endif

      ///        yyy=nrow-yy(i2)
      XXX = D_A2_ImM.cols() - XXVecArr(ILast);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): XXX set to " << XXX << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): XXX set to " << XXX << endl;
#endif

      if (OArr.rows() < D_A2_ImM.cols())
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: OArr.rows(=" << OArr.rows() << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: OArr.rows(=" << OArr.rows() << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << ")" << endl;
        return false;
      }
      if (SSFArr.cols() < D_A2_ImM.cols())
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: SSFArr.cols(=" << SSFArr.cols() << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: SSFArr.cols(=" << SSFArr.cols() << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << ")" << endl;
        return false;
      }
      if (SFVecArr.size() < ILast + 2)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: SFVecArr.size(=" << SFVecArr.size() << ") < ILast(=" << ILast << ")+2" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: SFVecArr.size(=" << SFVecArr.size() << ") < ILast(=" << ILast << ") + 2" << endl;
        return false;
      }
      ///        o(0:nrow-2)=o(0:nrow-2)+reform(ssf(0,1:nrow-1))*yyy
      OArr(Range(0, D_A2_ImM.cols() - 2), 0) += (SSFArr(0, Range(1, D_A2_ImM.cols() - 1)) * XXX);
      ///        o(nrow-1)=o(nrow-1)+sf(i2+1)*yyy
      OArr(D_A2_ImM.cols() - 1, 0) += (SFVecArr(ILast + 1) * XXX);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OArr set to " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
#endif

      ///        j=where(abs(im(i,*)-sp(i)*o) lt 3*dev,nj,COMPLEMENT=b)
      /** i => m, j => IFirstVecArr, b => TempIVecArr, nj => NInd **/
      if (OArr.rows() != D_A2_ImM.cols())
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: OArr.row(=" << OArr.rows() << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: OArr.rows(=" << OArr.rows() << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << ")" << endl;
        return false;
      }
      IVecArr.resize(D_A2_ImM.cols());
      IVecArr = where(abs(D_A2_ImM(m, Range::all()) - SPVecArr(m) * OArr(Range::all(), 0)) < 3. * Dev, 1, 0);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): IVecArr(where) set to " << IVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): IVecArr(where) set to " << IVecArr << endl;
#endif
      ///        j=where(abs(im(i,*)-sp(i)*o) lt 3*dev,nj,COMPLEMENT=b)
      /** i => m, j => IFirstVecArr, b => TempIVecArr, nj => NInd **/
      NInd = sum(IVecArr);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): NInd set to " << NInd << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): NInd set to " << NInd << endl;
#endif
      TempIVecArr.resize(IVecArr.size() - NInd);
      TempIVecArr = 0;
      if (IVecArr.size() < NInd)
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: IVecArr.size(=" << IVecArr.size() << ") < NInd(=" << NInd << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: IVecArr.size(=" << IVecArr.size() << ") < NInd(=" << NInd << ")" << endl;
        return false;
      }
      IFirstVecArr.resize(NInd);//IVecArr.size() - NInd);
      IFirstVecArr = 0;
      TempInt = 0;
      TempIntA = 0;



      /// MARK MARK MARK!!!
      /// Indices below are still to be checked





      for (int n = 0; n < IVecArr.size(); n++)
      {
        if (IVecArr(n) > 0)
        {
          if (TempInt >= IFirstVecArr.size())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: TempInt(=" << TempInt << ") >= IFirstVecArr.size(=" << IFirstVecArr.size() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: TempInt(=" << TempInt << ") >= IFirstVecArr.size(=" << IFirstVecArr.size() << ")" << endl;
            return false;
          }
          IFirstVecArr(TempInt) = n;
          TempInt++;
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): for(n(==" << n << ")=0; n< IVecArr.size(=" << IVecArr.size() << "; n++): IFirstVecArr(TempInt=" << TempInt << ") set to " << IFirstVecArr(TempInt) << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): for(n(==" << n << ")=0; n< IVecArr.size(=" << IVecArr.size() << "; n++): IFirstVecArr(TempInt=" << TempInt << ") set to " << IFirstVecArr(TempInt) << endl;
#endif

        }
        else
        {
          if (TempIntA >= TempIVecArr.size())
          {
            cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: TempIntA(=" << TempIntA << ") >= TempIVecArr.size(=" << IFirstVecArr.size() << ")" << endl;
            (*P_OFS_Log) << "CFits::SlitFunc: ERROR: TempIntA(=" << TempIntA << ") >= TempIVecArr.size(=" << TempIVecArr.size() << ")" << endl;
            return false;
          }
          TempIVecArr(TempIntA) = n;
          TempIntA++;
#ifdef __DEBUG_FITS_SLITFUNC__
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): for(n(==" << n << ")=0; n< IVecArr.size(=" << IVecArr.size() << "; n++): TempIVecArr(TempIntA=" << TempIntA << ") set to " << TempIVecArr(TempIntA) << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): for(n(==" << n << ")=0; n< IVecArr.size(=" << IVecArr.size() << "; n++): TempIVecArr(TempIntA=" << TempIntA << ") set to " << TempIVecArr(TempIntA) << endl;
#endif

        }
      }/// end for (int n = 0; n < IVecArr.size(); n++)

      //        (*P_OFS_Log) << "CFits::SlitFunc: 14. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;

      /*
      if(nj lt nrow) then $          ; Bad pixels in column i
        jbad=[jbad,long(nrow)*i+b]

      im_out(i,*)=sp(i)*o
      endfor
      endif
      */
      if (NInd < D_A2_ImM.cols())  /// Bad pixels in column m
      {
        TempLong = (*P_I_A1_JBadVecArr)(0);
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): NInd(=" << NInd << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << "): TempLong set to " << TempLong << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): NInd(=" << NInd << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << "): TempLong set to " << TempLong << endl;
#endif
        P_I_A1_JBadVecArr->resize(1 + TempIVecArr.size());
        (*P_I_A1_JBadVecArr)(0) = TempLong;
        if (TempIVecArr.size() != P_I_A1_JBadVecArr->size()-1)
        {
          cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: TempIVecArr.size(=" << TempIVecArr.size() << ") != P_I_A1_JBadVecArr->size(=" << P_I_A1_JBadVecArr->size() << ")-1" << endl;
          (*P_OFS_Log) << "CFits::SlitFunc: ERROR: TempIVecArr.size(=" << TempIVecArr.size() << ") != P_I_A1_JBadVecArr->size(=" << P_I_A1_JBadVecArr->size() << ")-1" << endl;
          return false;
        }
        (*P_I_A1_JBadVecArr)(Range(1, P_I_A1_JBadVecArr->size() - 1)) = TempIVecArr;
        (*P_I_A1_JBadVecArr)(Range(1, P_I_A1_JBadVecArr->size() - 1)) += (long)D_A2_ImM.cols() * m;
#ifdef __DEBUG_FITS_SLITFUNC__
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): NInd(=" << NInd << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << "): P_I_A1_JBadVecArr set to " << (*P_I_A1_JBadVecArr) << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): NInd(=" << NInd << ") < D_A2_ImM.cols(=" << D_A2_ImM.cols() << "): P_I_A1_JBadVecArr set to " << (*P_I_A1_JBadVecArr) << ")" << endl;
#endif
      }

#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): SPVecArr = " << SPVecArr << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): SPVecArr = " << SPVecArr << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): SPVecArr(m) = " << SPVecArr(m) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): SPVecArr(m) = " << SPVecArr(m) << endl;
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OArr = " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): OArr = " << OArr << endl;//.transpose(secondDim, firstDim) << endl;
#endif
      if (P_D_A2_ImOut->cols() != OArr.rows())
      {
        cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": ERROR: P_D_A2_ImOut->cols(=" << P_D_A2_ImOut->cols() << ") != OArr.rows(=" << OArr.rows() << ")" << endl;
        (*P_OFS_Log) << "CFits::SlitFunc: ERROR: P_D_A2_ImOut->cols(=" << P_D_A2_ImOut->cols() << ") != OArr.rows(=" << OArr.rows() << ")" << endl;
        return false;
      }
      (*P_D_A2_ImOut)(m, Range::all()) = SPVecArr(m) * OArr(Range::all(), 0);
#ifdef __DEBUG_FITS_SLITFUNC__
      cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): P_D_A2_ImOut(m=" << m << ", *) set to " << (*P_D_A2_ImOut)(m, Range::all()) << endl;
      (*P_OFS_Log) << "CFits::SlitFunc: KeyWord_Set(IM_OUT): for(m(==" << m << ")=0; m< NRowsOut(=" << NRowsOut << "; m++): P_D_A2_ImOut(m=" << m << ", *) set to " << (*P_D_A2_ImOut)(m, Range::all()) << endl;
#endif
    } /// end for (int m = 0; m < NRowsOut; m++)
  } /// end if (this->KeyWord_Set(const_cast<const CString**>(Args), NArgs, "IM_OUT"))
  else
  {
    delete P_D_A2_ImOut;
  }

  //    (*P_OFS_Log) << "CFits::SlitFunc: 15. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;
  //}/** end while(true) **/

  /*
  endfor
  if(n_elements(jbad) gt 1) then $
  jbad=jbad(1:n_elements(jbad)-1) $
  else $
  jbad=-1

  return
  end
  */
  if (P_I_A1_JBadVecArr->size() > 1)
  {
    //TempIVecArr.resize(P_I_A1_JBadVecArr->size());
    //TempIVecArr = FixLI(*P_I_A1_JBadVecArr);
    (*P_I_A1_JBadVecArr)(Range(0, P_I_A1_JBadVecArr->size() - 2)) = (*P_I_A1_JBadVecArr)(Range(1, P_I_A1_JBadVecArr->size() - 1));
    P_I_A1_JBadVecArr->resizeAndPreserve(P_I_A1_JBadVecArr->size() - 1);
  }
  else
  {
    P_I_A1_JBadVecArr->resize(1);
    (*P_I_A1_JBadVecArr) = -1;
  }
#ifdef __DEBUG_FITS_SLITFUNC__
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": READY: P_I_A1_JBadVecArr set to " << (*P_I_A1_JBadVecArr) << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: READY: P_I_A1_JBadVecArr set to " << (*P_I_A1_JBadVecArr) << endl;
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": READY: SFVecArr set to " << SFVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: READY: SFVecArr set to " << SFVecArr << endl;
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": READY: SPVecArr set to " << SPVecArr << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: READY: SPVecArr set to " << SPVecArr << endl;
  cout << "CFits::SlitFunc: I_IAperture_In = " << I_IAperture_In << ": READY: P_D_A2_ImOut set to " << *P_D_A2_ImOut << endl;//->transpose(secondDim, firstDim) << endl;
  (*P_OFS_Log) << "CFits::SlitFunc: READY: P_D_A2_ImOut set to " << *P_D_A2_ImOut << endl;//->transpose(secondDim, firstDim) << endl;
#endif

  //  (*P_OFS_Log) << "CFits::SlitFunc: End: 16. this->NRows = " << this->NRows << ", this->NCols = " << this->NCols << endl;
  delete P_Delimiter;
  delete P_Prefix;
  delete P_TempString;
  a.resize(0);
  AKLArr.resize(0,0);
  b.resize(0);
  BKLArr.resize(0,0);
  BKLIndVecArr.resize(0);
  BLVecArr.resize(0);
  c.resize(0);
  D_A1_Ind.resize(0);
  D_A2_AKLT.resize(0,0);
  D_A2_OT.resize(0,0);
  D_A2_SPVecTimesBKLArr.resize(0, 0);
  //  D_A2_SSFT.resize(0,0);
  IFirstVecArr.resize(0);
  ILastVecArr.resize(0);
  IndVecArr.resize(0);
  Mask.resize(0,0);
  OArr.resize(0,0);
  OIndVecArr.resize(0);
  OLIndVecArr.resize(0);
  OOVecArr.resize(0);
  OmegaVecArr.resize(0);
  OmegaArr.resize(0,0);
  D_A2_TempAA.resize(0,0);
  D_A1_TempDVecArr.resize(0);
  ProductArr.resize(0,0);
  RVecArr.resize(0);
  SPOldVecArr.resize(0);
  SSFArr.resize(0,0);
  TempArray.resize(0,0);
  TempDVecArr.resize(0);
  TempDVecArrA.resize(0);
  TempDVecArrB.resize(0);
  TempDVecArrC.resize(0);
  TempDArr.resize(0,0);
  TempIVecArr.resize(0);
  UseRowVecArr.resize(0);
  IVecArr.resize(0);
  XVecArr.resize(0);
  XCenVecArr.resize(0);
  XXVecArr.resize(0);

  return true;
}



/**
  MkProfIm Old version
  Make Profile Image
 **/
bool CFits::MkProfIm_Old()
{
  Array<CString, 1> CS_A1_Args(1);
  CS_A1_Args(0) = CString("");
  void **PP_Args;
  PP_Args = (void**)malloc(sizeof(void*) * 1);

  int I_temp = 1;
  PP_Args[0] = &I_temp;

  if (!this->MkProfIm_Old(CS_A1_Args, PP_Args))
  {
    cout << "CFits::MkProfIm_Old(): ERROR: MkProfIm(CS_A1_Args=" << CS_A1_Args << ") returned FALSE => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::MkProfIm_Old(): ERROR: MkProfIm(CS_A1_Args=" << CS_A1_Args << ") returned FALSE => Returning FALSE" << endl;
    return false;
  }
  return true;
}

/**
  MkProfIm Old version
  Make Profile Image
 **/
bool CFits::MkProfIm_Old(const Array<CString, 1> &CS_A1_Args_In,       ///: in
                     void *ArgV[])                                  ///: in
/** KeyWords and Values:   SWATH_WIDTH:              int: in
                           LAMBDA_SP  :              int: in (Smoothing along dispersion)
                           FLAT       :             bool: in
 **/
{
#ifdef __DEBUG_FITS_PISKUNOV__
  (*P_OFS_Log) << "CFits::MkProfIm: started: this = " << *this << endl;

  (*P_OFS_Log) << "CFits::MkProfIm: P_D_A1_XHigh = " << (*this->P_D_A1_XHigh) << endl;

  (*P_OFS_Log) << "CFits::MkProfIm: P_D_A1_XLow = " << (*this->P_D_A1_XLow) << endl;
#endif
  Array<double, 1> D_A1_ScatterBelow(this->NRows);
  D_A1_ScatterBelow = 0.;

  Array<double, 1> D_A1_XScatterBelow(this->NRows);
  D_A1_XScatterBelow = 0.;

  Array<double, 1> D_A1_ScatterAbove(this->NRows);
  D_A1_ScatterAbove = 0.;

  Array<double, 1> D_A1_XScatterAbove(this->NRows);
  D_A1_XScatterAbove = 0.;

  //  double D_XLeftLim;
  //  double D_XRightLim;
  //  double D_LambdaSF = 40.;
  //  double D_LambdaSP = 20.;

  //  int I_YLowerLim;
  //  int I_YUpperLim;

  //  int I_NArgs = 0;
  int I_Pos = 0;
  int I_NArgs = 0;

  Array<double, 1> D_A1_XSlitF(1);
  Array<double, 2> D_A2_SlitF(1,1);
  Array<double, 1> D_A1_BinCen(1);
  Array<double, 1> D_A1_BLZ(this->NRows);


  Array<CString, 1> CS_A1_Args(8);

  void **PP_Args;
  PP_Args = (void**)malloc(sizeof(void*) * 8);

  //  CS_A1_Args(0) = CString("Y_LOWER_LIM");
  //  PP_Args[0] = &I_YLowerLim;
  //  I_NArgs++;

  //  CS_A1_Args(1) = CString("Y_UPPER_LIM");
  //  PP_Args[1] = &I_YUpperLim;
  //  I_NArgs++;

  //  CS_A1_Args(0) = CString("OVERSAMPLE");
  //  PP_Args[0] = &I_OverSample;
  //  I_NArgs++;

  CS_A1_Args(I_NArgs) = CString("CCD_GAIN");
  PP_Args[I_NArgs] = &this->D_Gain;
  I_NArgs++;

  CS_A1_Args(I_NArgs) = CString("CCD_READN");
  PP_Args[I_NArgs] = &this->D_ReadOutNoise;
  I_NArgs++;

  CS_A1_Args(I_NArgs) = CString("NO_SCATTER");
  int noscat = 1;
  PP_Args[I_NArgs] = &noscat;
  I_NArgs++;

  int I_SwathWidth = 300;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("SWATH_WIDTH"))) >= 0)
  {
    CS_A1_Args(I_NArgs) = CString("SWATH_WIDTH");
    I_SwathWidth = *(int*)ArgV[I_Pos];
    PP_Args[I_NArgs] = &I_SwathWidth;
    I_NArgs++;
  }

  CS_A1_Args(I_NArgs) = CString("LAMBDA_SF");
  double D_SF_Smooth = 50.;
  PP_Args[I_NArgs] = &D_SF_Smooth;
  I_NArgs++;

  CS_A1_Args(I_NArgs) = CString("BLZ");
  PP_Args[I_NArgs] = &D_A1_BLZ;
  I_NArgs++;

  int I_SP_Smooth = 20;
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("LAMBDA_SP"))) >= 0)
  {
    I_SP_Smooth = *(int*)ArgV[I_Pos];
  }
  if (this->KeyWord_Set(CS_A1_Args_In, CString("FLAT")) >= 0)
  {
    CS_A1_Args(I_NArgs) = CString("FLAT");
    PP_Args[I_NArgs] = &D_A1_BLZ;
    I_NArgs++;

    CS_A1_Args(I_NArgs) = CString("LAMBDA_SP");
    PP_Args[I_NArgs] = &I_SP_Smooth;
    I_NArgs++;
  }
  else
  {
    while (I_NArgs < 8)
    {
      CS_A1_Args(I_NArgs) = CString("");
      PP_Args[I_NArgs] = &noscat;
      I_NArgs++;
    }
  }

#ifdef __DEBUG_FITS_PISKUNOV__
  cout << "CFits::MkProfIm: CS_A1_Args set to " << CS_A1_Args << endl;
  (*P_OFS_Log) << "CFits::MkProfIm: CS_A1_Args set to " << CS_A1_Args << endl;
#endif
  //  cout << "CFits::MkProfIm: I_NArgs set to " << I_NArgs << endl;
  //  CS_A1_Args.resizeAndPreserve(I_NArgs);

  int i_ord;
  for (i_ord = 0; i_ord < this->I_NApertures; i_ord++)//1; i_ord++)//
  {
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): this->P_CS_FileName = " << *this->P_CS_FileName << endl;
    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): this->P_CS_FileName = " << *this->P_CS_FileName << endl;
#endif
    //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): this->P_D_A2_XCenters = " << *this->P_D_A2_XCenters << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): this->P_D_A2_XCenters = " << *this->P_D_A2_XCenters << endl;
    //#endif
    //    Array<double, 1> D_A1_XCenters((*this->P_D_A2_XCenters)(i_ord, Range::all()));

    //#ifdef __DEBUG_FITS_PISKUNOV__
    //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_A1_XCenters set to " << D_A1_XCenters << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_A1_XCenters set to " << D_A1_XCenters << endl;

    //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XHigh = " << (*this->P_D_A1_XHigh) << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XHigh = " << (*this->P_D_A1_XHigh) << endl;

    //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XLow = " << (*this->P_D_A1_XLow) << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XLow = " << (*this->P_D_A1_XLow) << endl;
    //#endif
    //    D_XLeftLim = 0. - (*this->P_D_A1_XLow)(i_ord);

    //#ifdef __DEBUG_FITS_PISKUNOV__
    //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_XLeftLim set to " << D_XLeftLim << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_XLeftLim set to " << D_XLeftLim << endl;
    //#endif
    //    D_XRightLim = (*this->P_D_A1_XHigh)(i_ord);

    //#ifdef __DEBUG_FITS_PISKUNOV__
    //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_XRightLim set to " << D_XRightLim << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): D_XRightLim set to " << D_XRightLim << endl;
    //#endif
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_YCenter(i_ord) = " << (*P_D_A1_YCenter)(i_ord) << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XMin(i_ord) = " << (*P_D_A1_XMin)(i_ord) << endl;
    //    I_YLowerLim = (int)((*this->P_D_A1_XMin)(i_ord));

    //#ifdef __DEBUG_FITS_PISKUNOV__
    //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): I_YLowerLim set to " << I_YLowerLim << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): I_YLowerLim set to " << I_YLowerLim << endl;
    //#endif
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): P_D_A1_XMax(i_ord) = " << (*P_D_A1_XMax)(i_ord) << endl;
    //    I_YUpperLim = (int)((*this->P_D_A1_XMax)(i_ord));
    //#ifdef __DEBUG_FITS_PISKUNOV__
    //    cout << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): I_YUpperLim set to " << I_YUpperLim << endl;
    //    (*P_OFS_Log) << "CFits::MkProfIm: for (i_ord(=" << i_ord << ") = 0; i_ord < this->I_NApertures; i_ord++): I_YUpperLim set to " << I_YUpperLim << endl;
    //#endif
    if (!MkSlitFunc_Old(D_A1_ScatterBelow,  //: in
                    D_A1_XScatterBelow, //: in
                    D_A1_ScatterAbove,  //: in
                    D_A1_XScatterAbove, //: in
                    //                    D_A1_XCenters,      //: in
                    //                    D_XLeftLim,         //: in
                    //                    D_XRightLim,        //: in
                    D_A1_XSlitF,        //: out
                    D_A2_SlitF,         //: out
                    D_A1_BinCen,        //: out
                    i_ord,     //: in
                    //I_NArgs,            //: in
                    *(const_cast<const Array<CString, 1>*>(&CS_A1_Args)),  //: in
                    PP_Args))
    {
      //      delete PP_CString;
      //      delete PP_Args;
      cout << "CFits::MkProfIm: ERROR: MkSlitFunc returned FALSE => returning FALSE" << endl;
      (*P_OFS_Log) << "CFits::MkProfIm: ERROR: MkSlitFunc returned FALSE => returning FALSE" << endl;
      return false;
    }
    //#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkProfIm: MkSlitFunc returned TRUE" << endl;
    (*P_OFS_Log) << "CFits::MkProfIm: MkSlitFunc returned TRUE" << endl;
    //#endif
    //    cout << "CFits::MkProfIm: D_A1_BLZ = " << D_A1_BLZ;
    //    (*this->P_D_A2_Blaze)(i_ord, Range::all()) = D_A1_BLZ;

    /*                     //PLOT        =
    Y_LOWER_LIM = int             : in
    Y_UPPER_LIM = int             : in
    LAMBDA_SF   = double          : in
    LAMBDA_SP   = int             : in
    SWATH_WIDTH = int             : in
    BLZ         = Array<double, 1>: out
    OVERSAMPLE  = int             : in
    MASK        = Array<double, 2>: in
    CCD_GAIN    = double          : in
    CCD_READN   = double          : in
    NO_SCATTER  = void
    TELLURIC    = void
    FILENAME    = CString         : in
      */


    //    if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("BLZ"))) >= 0)
    //    {
#ifdef __DEBUG_FITS_PISKUNOV__
    cout << "CFits::MkProfIm: reinitializing D_A1_BLZ " << endl;
    (*P_OFS_Log) << "CFits::MkProfIm: reinitializing D_A1_BLZ " << endl;
#endif
    D_A1_BLZ = 0.;
    //      if (this->P_D_A2_Blaze->cols() != D_A1_BLZ.size())
    //      {
    //        cout << "CFits::MkProfIm: ERROR: BLZ set: this->P_D_A2_Blaze->cols(=" << P_D_A2_Blaze->cols() << ") != D_A1_BLZ.size(=" << D_A1_BLZ.size() << ") => Returning FALSE" << endl;
    //        (*P_OFS_Log) << "CFits::MkProfIm: ERROR: BLZ set: this->P_D_A2_Blaze->cols(=" << P_D_A2_Blaze->cols() << ") != D_A1_BLZ.size(=" << D_A1_BLZ.size() << ") => Returning FALSE" << endl;
    //        return false;
    //      }
    //      (*this->P_D_A2_Blaze)(i_ord, Range::all()) = D_A1_BLZ;
    //#ifdef __DEBUG_FITS_PISKUNOV__
    //      cout << "CFits::MkProfIm: this->P_D_A2_Blaze(i_ord(=" << i_ord << "), Range::all()) set to " << (*this->P_D_A2_Blaze)(i_ord, Range::all()) << endl;
    //      (*P_OFS_Log) << "CFits::MkProfIm: this->P_D_A2_Blaze(i_ord(=" << i_ord << "), Range::all()) set to " << (*this->P_D_A2_Blaze)(i_ord, Range::all()) << endl;
    //#endif
    //    }
  }/// end for (i_ord = 0; i_ord < this->I_NApertures; i_ord++)
  //  this->WriteArrayToFile((*P_D_A2_ProfArray), CString("/home/azuri/entwicklung/c/fitsutil/cfits/test/Profile_out.dat"));
  //#ifdef __DEBUG_FITS_PISKUNOV__
  //  cout << "CFits::MkProfIm: P_D_A2_ProfArray written to Profile_out.dat" << endl;
  //  (*P_OFS_Log) << "CFits::MkProfIm: P_D_A2_ProfArray written to Profile_out.dat" << endl;
  //#endif
  //#ifdef __DEBUG_FITS_PISKUNOV__
  //  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("BLZ"))) >= 0)
  //    this->WriteArrayToFile((*P_D_A2_Blaze), CString("/home/azuri/entwicklung/c/fitsutil/cfits/test/Blaze_out.dat"));
  //#endif
  /*  for (int ippos = 0; ippos < I_NArgs; ippos++)
    {
      delete PP_CString[ippos];
  }*/
  //  delete PP_CString;
  //  delete PP_Args;

  this->ProfileCalculated = true;

  return true;
}


/**
 * WriteApToFile
 * Writes aperture I_Aperture_In to fits file CS_FileNameOut
 **/
bool CFits::WriteApToFile(const Array<double, 2> &D_A2_Spectra_In,
                          const int I_Aperture_In,
                          const CString &CS_FitsFileName_Out) const{
  if (I_Aperture_In < 0 || I_Aperture_In >= this->I_NApertures){
    cout << "CFits::WriteApToFile: ERROR: I_Aperture_In = " << I_Aperture_In << " outside range => Returning FALSE" << endl;
    return false;
  }
  CFits CF;
  CF.SetFileName(CS_FitsFileName_Out);
  CF.SetNRows(1);
  int I_YMin = int((*(this->P_D_A1_YCenter))(I_Aperture_In) + (*(this->P_D_A1_YLow))(I_Aperture_In));
  int I_YMax = int((*(this->P_D_A1_YCenter))(I_Aperture_In) + (*(this->P_D_A1_YHigh))(I_Aperture_In));
  CF.SetNCols(I_YMax - I_YMin + 1);
//  Array<double, 1> D_A1_Temp(I_YMax-I_YMin+1);
  (CF.GetPixArray())(0,Range::all()) = D_A2_Spectra_In(I_Aperture_In, Range(I_YMin, I_YMax));
//  CF.GetPixArray() = D_A1_Temp;
  CF.WriteArray();
  return true;
}

/**
 * ShiftAndCrossCorrelate
 * + Splits D_A1_Spec_In and D_A1_SpecRef_In into I_NPieces_In and calculates shift and stretch to achieve minimum ChiSq in crosscorrelation
 * + fits polynomials to Stretches and Shifts with 3sigma rejection
 * + applies shifts and stretches to D_A2_LineList_WLenPix_In to calculate D_A2_LineList_WLenPix_Out
 **/
bool CFits::StretchAndCrossCorrelateSpec(const Array<double, 1> &D_A1_Spec_In,
                                         const Array<double, 1> &D_A1_SpecRef_In,
                                         const Array<double, 2> &D_A2_LineList_WLenPix_In,
                                         const int I_Radius_XCor_In,
                                         const int I_Stretch_Min_Length_In,
                                         const int I_Stretch_Max_Length_In,
                                         const int I_NStretches_In,
                                         const int I_LengthPieces_In,
                                         const int I_NCalcs_In,
                                         const int I_PolyFitOrder_Stretch_In,
                                         const int I_PolyFitOrder_Shift_In,
                                         const CString &CS_FName_In,
                                         Array<double, 2> &D_A2_LineList_WLenPix_Out) const{
  if (D_A1_Spec_In.size() != D_A1_SpecRef_In.size()){
    cout << "CFits::StretchAndCrossCorrelate: ERROR: D_A1_Spec_In.size(=" << D_A1_Spec_In.size() << " != D_A1_SpecRef_In.size(=" << D_A1_SpecRef_In.size() << ") => Returning FALSE" << endl;
    return false;
  }
  Array<double, 1> D_A1_ChiSqMin_Stretch(I_NCalcs_In);
  D_A1_ChiSqMin_Stretch = 0.;
  Array<double, 1> D_A1_ChiSqMin_Shift(I_NCalcs_In);
  D_A1_ChiSqMin_Shift = 0.;
  Array<double, 1> D_A1_XCenter(I_NCalcs_In);
  D_A1_XCenter = 0.;
  Array<double, 1> D_A1_SpecPiece(I_LengthPieces_In);
  Array<double, 1> D_A1_SpecRefPiece(I_LengthPieces_In);
  int I_Start = 0;
  int I_End = 0;
  Array<double, 2> D_A2_SpecPieceStretched_MinChiSq(2,2);

  /// create html file for the plots
  #ifdef __WITH_PLOTS__
    CString CS_HTML_FileName(CS_FName_In);
    CS_HTML_FileName.Add(CString("_plots.html"));
    ofstream *P_OFS_html = new ofstream(CS_HTML_FileName.Get());
    (*P_OFS_html) << "<html><body><center>" << endl;
    CString CS_PlotName("");
    CString *P_CS_Num;
//    CS_FName_In.MkDir(CString("plots"));
  #endif

  Array<double, 2> D_A2_LineList_Pixels_AllPieces(D_A2_LineList_WLenPix_In.rows(), I_NCalcs_In);
  D_A2_LineList_Pixels_AllPieces = 0.;
  Array<double, 1> *P_D_A1_X = this->DIndGenArr(D_A1_SpecRef_In.size());
  Array<double, 1> D_A1_XPiece(1);
  Array<double, 1> D_A1_XPieceStretched(1);

  for (int i_run = 0; i_run < I_NCalcs_In; i_run++){
    I_End = I_Start + I_LengthPieces_In;
    if (I_End >= D_A1_Spec_In.size())
      I_End = D_A1_Spec_In.size()-1;
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
      cout << "CFits::StretchAndCrossCorrelateSpec: i_run = " << i_run << ": I_Start = " << I_Start << ", I_End = " << I_End << endl;
    #endif
    if (I_End <= I_Start){
      cout << "CFits::StretchAndCrossCorrelateSpec: i_run = " << i_run << ": ERROR: I_End <= I_Start" << endl;
      return false;
    }
    D_A1_XCenter(i_run) = double(I_Start) + (double(I_End - I_Start) / 2.);

    D_A1_SpecPiece.resize(I_End - I_Start + 1);
    D_A1_SpecPiece = D_A1_Spec_In(Range(I_Start, I_End));
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
      cout << "CFits::StretchAndCrossCorrelateSpec: i_run = " << i_run << ": D_A1_SpecPiece = " << D_A1_SpecPiece << endl;
    #endif
    D_A1_SpecRefPiece.resize(I_End - I_Start + 1);
    D_A1_SpecRefPiece = D_A1_SpecRef_In(Range(I_Start, I_End));
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
      cout << "CFits::StretchAndCrossCorrelateSpec: i_run = " << i_run << ": D_A1_SpecRefPiece = " << D_A1_SpecRefPiece << endl;
    #endif
    /// stretch and crosscorrelate pieces
    if (!this->StretchAndCrossCorrelate(D_A1_SpecPiece,
                                        D_A1_SpecRefPiece,
                                        I_Radius_XCor_In,
                                        I_Stretch_Min_Length_In,
                                        I_Stretch_Max_Length_In,
                                        I_NStretches_In,
                                        D_A1_ChiSqMin_Stretch(i_run),
                                        D_A1_ChiSqMin_Shift(i_run),
                                        D_A2_SpecPieceStretched_MinChiSq)){
      cout << "CFits::StretchAndCrossCorrelateSpec: ERROR: StretchAndCrossCorrelate(D_A1_SpecPiece=" << D_A1_SpecPiece << "," << endl;
      cout << "D_A1_SpecRefPiece = " << D_A1_SpecRefPiece << "," << endl;
      cout << "I_Radius_XCor_In = " << I_Radius_XCor_In << "," << endl;
      cout << "I_Stretch_Min_Length_In = " << I_Stretch_Min_Length_In << "," << endl;
      cout << "I_Stretch_Max_Length_In = " << I_Stretch_Max_Length_In << "," << endl;
      cout << "I_NStretches_In = " << I_NStretches_In << ",...) returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
      cout << "CFits::StretchAndCrossCorrelateSpec: i_run=" << i_run << ": D_A1_ChiSqMin_Stretch(i_run) = " << D_A1_ChiSqMin_Stretch(i_run) << endl;
      cout << "CFits::StretchAndCrossCorrelateSpec: i_run=" << i_run << ": D_A1_ChiSqMin_Shift(i_run) = " << D_A1_ChiSqMin_Shift(i_run) << endl;
    #endif

    D_A1_XPiece.resize(I_End - I_Start + 1);
    D_A1_XPiece = (*P_D_A1_X)(Range(I_Start, I_End));

    D_A1_XPieceStretched.resize(D_A1_ChiSqMin_Stretch(i_run));
    D_A1_XPieceStretched(0) = I_Start;
    for (int i_pix=1; i_pix<D_A1_XPieceStretched.size(); i_pix++){
      D_A1_XPieceStretched(i_pix) = D_A1_XPieceStretched(i_pix-1) + (D_A1_XPiece.size() / D_A1_ChiSqMin_Stretch(i_run));
    }
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
      cout << "CFits::StretchAndCrossCorrelateSpec: i_run=" << i_run << ": D_A1_XPieceStretched = " << D_A1_XPieceStretched << endl;
    #endif

    Array<int, 1> *P_I_A1_ValueLocate;
    double D_WeightLeft = 0.;
    double D_WeightRight = 0.;
    P_I_A1_ValueLocate = this->ValueLocate(D_A1_XPieceStretched, D_A2_LineList_WLenPix_In(Range::all(), 1));
    for (int i_line = 0; i_line < D_A2_LineList_Pixels_AllPieces.rows(); i_line++){
      if (((*P_I_A1_ValueLocate)(i_line) >= 0) && ((*P_I_A1_ValueLocate)(i_line) < D_A1_XPieceStretched.size()-1)){
        D_WeightRight = (D_A1_XPieceStretched((*P_I_A1_ValueLocate)(i_line) + 1) - D_A1_XPieceStretched((*P_I_A1_ValueLocate)(i_line))) * (D_A2_LineList_WLenPix_In(i_line, 1) - D_A1_XPieceStretched((*P_I_A1_ValueLocate)(i_line)));
        #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
          cout << "CFits::StretchAndCrossCorrelateSpec: i_line = " << i_line << ": D_A1_XPieceStretched((*P_I_A1_ValueLocate)(i_line)=" << (*P_I_A1_ValueLocate)(i_line) << ") = " << D_A1_XPieceStretched((*P_I_A1_ValueLocate)(i_line)) << ", D_A1_XPieceStretched((*P_I_A1_ValueLocate)(i_line)+1=" << (*P_I_A1_ValueLocate)(i_line)+1 << ") = " << D_A1_XPieceStretched((*P_I_A1_ValueLocate)(i_line)+1) << ", D_WeightRight = " << D_WeightRight << endl;
        #endif
        D_WeightLeft = 1. - D_WeightRight;

        #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
          cout << "CFits::StretchAndCrossCorrelateSpec: i_line = " << i_line << ": D_WeightLeft = " << D_WeightLeft << endl;
        #endif
        D_A2_LineList_Pixels_AllPieces(i_line, i_run) = I_Start + ((*P_I_A1_ValueLocate)(i_line) * D_WeightLeft) + (((*P_I_A1_ValueLocate)(i_line) + 1) * D_WeightRight) - D_A1_ChiSqMin_Shift(i_run);
        #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
          cout << "CFits::StretchAndCrossCorrelateSpec: i_line = " << i_line << ": D_A2_LineList_Pixels_AllPieces(i_line, i_run) = " << D_A2_LineList_Pixels_AllPieces(i_line, i_run) << endl;
        #endif
      }
    }
    delete(P_I_A1_ValueLocate);

    #ifdef __WITH_PLOTS__
      mglGraph gr;
      P_CS_Num = CS_HTML_FileName.IToA(i_run);
      Array<double, 1> *P_D_A1_XPiece = this->DIndGenArr(D_A1_SpecPiece.size());
      *P_D_A1_XPiece += I_Start;
      mglData MGLData1_PieceX;
      MGLData1_PieceX.Link(P_D_A1_XPiece->data(), D_A1_SpecPiece.size(), 0, 0);
      mglData MGLData_SpecPiece;
      MGLData_SpecPiece.Link(D_A1_SpecPiece.data(), D_A1_SpecPiece.size(), 0, 0);
      mglData MGLData_SpecRefPiece;// = new mglData(2);
      MGLData_SpecRefPiece.Link(D_A1_SpecRefPiece.data(), D_A1_SpecRefPiece.size(), 0, 0);
      Array<double, 1> D_A1_X(D_A2_SpecPieceStretched_MinChiSq.rows());
      D_A1_X = D_A2_SpecPieceStretched_MinChiSq(Range::all(), 0) + D_A1_ChiSqMin_Shift(i_run);

      #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
        cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_SpecPieceStretched_MinChiSq = " << D_A2_SpecPieceStretched_MinChiSq << endl;
      #endif

      mglData MGLData1_X_Stretched, MGLData1_Y_Stretched;// = new mglData(2,2);
      mglData MGLData1_X_StretchedAndShifted, MGLData1_Y_StretchedAndShifted;// = new mglData(2,2);
      Array<double, 1> D_A1_Plot_Stretched_X(D_A1_X.size());
      Array<double, 1> D_A1_Plot_Stretched_Y(D_A1_X.size());
      Array<double, 1> D_A1_Plot_StretchedAndShifted_X(D_A1_X.size());
      Array<double, 1> D_A1_Plot_StretchedAndShifted_Y(D_A1_X.size());
      D_A1_Plot_Stretched_X(Range::all()) = D_A1_X + double(I_Start);
      D_A1_Plot_StretchedAndShifted_X(Range::all()) = D_A2_SpecPieceStretched_MinChiSq(Range::all(), 0) + double(I_Start);
      #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
        cout << "CFits::StretchAndCrossCorrelateSpec: D_A1_Plot_Stretched_X = " << D_A1_Plot_Stretched_X;
        cout << "CFits::StretchAndCrossCorrelateSpec: D_A1_Plot_StretchedAndShifted_X = " << D_A1_Plot_StretchedAndShifted_X;
      #endif
      D_A1_Plot_Stretched_Y(Range::all()) = D_A2_SpecPieceStretched_MinChiSq(Range::all(), 1);
      D_A1_Plot_StretchedAndShifted_Y(Range::all()) = D_A2_SpecPieceStretched_MinChiSq(Range::all(), 1);
      MGLData1_X_Stretched.Link(D_A1_Plot_Stretched_X.data(), long(D_A1_Plot_Stretched_X.size()), 0, 0);
      MGLData1_Y_Stretched.Link(D_A1_Plot_Stretched_Y.data(), long(D_A1_Plot_Stretched_Y.size()), 0, 0);

      MGLData1_X_StretchedAndShifted.Link(D_A1_Plot_StretchedAndShifted_X.data(), long(D_A1_Plot_Stretched_X.size()), 0, 0);
      MGLData1_Y_StretchedAndShifted.Link(D_A1_Plot_StretchedAndShifted_Y.data(), long(D_A1_Plot_Stretched_Y.size()), 0, 0);
      //      this->ArrayToMGLArray(D_A2_Plot, P_MGLData2_XY);
      #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
        cout << "CFits::ArrayToMGLArray: MGLData1_X_Stretched = " << MGLData1_X_Stretched.PrintInfo() << endl;
        cout << "CFits::ArrayToMGLArray: MGLData1_X_Stretched(0,0,0) = " << MGLData1_X_Stretched.GetVal(0,0,0) << endl;
        cout << "CFits::ArrayToMGLArray: MGLData1_X_StretchedAndShifted = " << MGLData1_X_StretchedAndShifted.PrintInfo() << endl;
        cout << "CFits::ArrayToMGLArray: MGLData1_X_StretchedAndShifted(0,0,0) = " << MGLData1_X_StretchedAndShifted.GetVal(0,0,0) << endl;
      #endif

      Array<double, 1> D_A1_MaxY(3);
      D_A1_MaxY(0) = max(D_A1_Plot_Stretched_Y);
      D_A1_MaxY(1) = max(D_A1_SpecRefPiece);
      D_A1_MaxY(2) = max(D_A1_SpecPiece);

      Array<double, 1> D_A1_MinX(3);
      D_A1_MinX(0) = min(D_A1_Plot_Stretched_X);
      D_A1_MinX(1) = min(D_A1_Plot_StretchedAndShifted_X);
      D_A1_MinX(2) = min(*P_D_A1_XPiece);

      Array<double, 1> D_A1_MaxX(3);
      D_A1_MaxX(0) = max(D_A1_Plot_Stretched_X);
      D_A1_MaxX(1) = max(D_A1_Plot_StretchedAndShifted_X);
      D_A1_MaxX(2) = max(*P_D_A1_XPiece);

      gr.SetRanges(min(D_A1_MinX),max(D_A1_MaxX),0,max(D_A1_MaxY));
      gr.Axis();
      gr.Label('y',"Counts",0);
      gr.Label('x',"Pixel Number",0);
      gr.Plot(MGLData1_X_Stretched, MGLData1_Y_Stretched, "r");
      gr.AddLegend("RefStretched", "r");

      gr.Plot(MGLData1_X_StretchedAndShifted, MGLData1_Y_StretchedAndShifted, "b");
      gr.AddLegend("Ref stretched and shifted", "b");

      gr.Plot(MGLData1_PieceX, MGLData_SpecRefPiece, "Y");
      gr.AddLegend("Reference", "Y");

      gr.Plot(MGLData1_PieceX, MGLData_SpecPiece, "g");
      gr.AddLegend("Spectrum", "g");
      gr.Box();
      gr.Legend();

      CS_PlotName.Set(CS_FName_In);
      CS_PlotName.Add(CString("_plot_spec_ref_stretched"));
      CS_PlotName.Add(*P_CS_Num);
      CS_PlotName.Add(".png");
      gr.WriteFrame(CS_PlotName.Get());

      int I_PathPos = CS_PlotName.LastStrPos(CString("/"));
      CString CS_PName(" ");
      if (I_PathPos < 0){
          CS_PName.Set(CS_PlotName);
      }
      else{
          CString *P_CS_PNTemp = CS_PlotName.SubString(I_PathPos+1);
          CS_PName.Set(*P_CS_PNTemp);
          delete(P_CS_PNTemp);
      }
      (*P_OFS_html) << "<img src=\"" << CS_PName << "\"><br>" << CS_PName << "<br>" << D_A1_ChiSqMin_Shift(i_run) << " pixels shift, " << D_A1_ChiSqMin_Stretch(i_run) << " pixels stretch<br><hr><br>" << endl;
      #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
        cout << "CFits::StretchAndCrossCorrelateSpec: CS_PlotName = <" << CS_PlotName << ">" << endl;
      #endif
      delete(P_CS_Num);
    #endif

    // for next run
    I_Start += (D_A1_Spec_In.size() - I_LengthPieces_In) / (I_NCalcs_In - 1);
  }/// end for (int i_run = 0; i_run < I_NStretches_In; i_run++){
  delete(P_D_A1_X);

  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: D_A1_ChiSqMin_Shift = " << D_A1_ChiSqMin_Shift << endl;
    cout << "CFits::StretchAndCrossCorrelateSpec: D_A1_ChiSqMin_Stretch = " << D_A1_ChiSqMin_Stretch << endl;
    cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_LineList_Pixels_AllPieces = " << D_A2_LineList_Pixels_AllPieces << endl;
  #endif

  Array<int, 1> I_A1_Where(D_A2_LineList_Pixels_AllPieces.cols());
  Array<int, 1> *P_I_A1_IndWhere;
  int I_NInd = 0;
  D_A2_LineList_WLenPix_Out.resize(D_A2_LineList_WLenPix_In.rows(), D_A2_LineList_WLenPix_In.cols());
  D_A2_LineList_WLenPix_Out = 0.;
  D_A2_LineList_WLenPix_Out(Range::all(), 0) = D_A2_LineList_WLenPix_In(Range::all(), 0);
  for (int i_line=0; i_line<D_A2_LineList_WLenPix_In.rows(); i_line++){
    I_A1_Where = where(fabs(D_A2_LineList_Pixels_AllPieces(i_line, Range::all())) > 0.001, 1, 0);
    P_I_A1_IndWhere = this->GetIndex(I_A1_Where, I_NInd);
    if (I_NInd == 1)
      D_A2_LineList_WLenPix_Out(i_line, 1) = D_A2_LineList_Pixels_AllPieces(i_line, (*P_I_A1_IndWhere)(0));
    else{
      for (int i_ind=0; i_ind<I_NInd; i_ind++){
        D_A2_LineList_WLenPix_Out(i_line, 1) += D_A2_LineList_Pixels_AllPieces(i_line, (*P_I_A1_IndWhere)(i_ind));
      }
      D_A2_LineList_WLenPix_Out(i_line, 1) = D_A2_LineList_WLenPix_Out(i_line, 1) / I_NInd;
    }
    if (D_A2_LineList_WLenPix_In.cols() == 3){
      D_A2_LineList_WLenPix_Out(i_line, 2) = D_A2_LineList_WLenPix_In(i_line, 2);
    }
    delete(P_I_A1_IndWhere);
  }
  cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_LineList_WLenPix_Out = " << D_A2_LineList_WLenPix_Out << endl;

  /// Check positions
  Array<double, 2> D_A2_Dist(D_A2_LineList_Pixels_AllPieces.rows(), D_A2_LineList_Pixels_AllPieces.cols());
  D_A2_Dist = 0.;
  for (int i_row=0; i_row<D_A2_LineList_Pixels_AllPieces.rows(); i_row++){
    for (int i_col = 0; i_col < D_A2_LineList_Pixels_AllPieces.cols(); i_col++){
      if (fabs(D_A2_LineList_Pixels_AllPieces(i_row, i_col)) > 0.00000000000001)
        D_A2_Dist(i_row, i_col) = D_A2_LineList_Pixels_AllPieces(i_row, i_col) - D_A2_LineList_WLenPix_In(i_row, 1);
    }
  }
  cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_Dist = " << D_A2_Dist << endl;
/*  Array<CString, 1> CS_A1_Args_LinFit(3);
  CS_A1_Args_LinFit(0).Set(CString("N_REJECTED"));
//  CS_A1_Args_LinFit(1).Set(CString("SIGMA"));
  CS_A1_Args_LinFit(1).Set(CString("YFIT"));
  CS_A1_Args_LinFit(2).Set(CString("REJECTED"));
//  CS_A1_Args_LinFit(4).Set(CString("ALLOW_SKY_LT_ZERO"));
  void **PP_Args_LinFit = (void**)malloc(sizeof(void*) * 3);
  double D_Reject = 4.5;
  int I_NRejected = 0;
  double D_Sigma_Fit = 0.;
  Array<double, 1> D_A1_FitOut(D_A1_Dist.size());
  Array<int, 1> I_A1_Rejected(1);
  I_A1_Rejected = -1;
  D_A1_FitOut = 0.;
  PP_Args_LinFit[0] = &I_NRejected;
//  PP_Args_LinFit[1] = &D_Sigma_Fit;
  PP_Args_LinFit[1] = &D_A1_FitOut;
  PP_Args_LinFit[2] = &I_A1_Rejected;
  Array<double, 1> D_A1_DistX(D_A1_Dist.size());
  D_A1_DistX = D_A2_LineList_WLenPix_In(Range::all(), 1);
  double D_A = 1.;
  double D_B = 1.;
  Array<double, 1> *P_D_A1_Coeffs = new Array<double, 1>(3);
  (*P_D_A1_Coeffs) = 0.;
  if (!this->PolyFit(D_A1_DistX,
                     D_A1_Dist,
                     1,
                     D_Reject,
                     CS_A1_Args_LinFit,
                     PP_Args_LinFit,
                     P_D_A1_Coeffs)){
    cout << "CFits::StretchAndCrossCorrelateSpec: ERROR: this->PolyFit returned FALSE" << endl;
    return false;
  }
  cout << "CFits::StretchAndCrossCorrelateSpec: D_A1_Dist = " << D_A1_Dist << endl;
  cout << "CFits::StretchAndCrossCorrelateSpec: D_A1_FitOut = " << D_A1_FitOut << endl;
  cout << "CFits::StretchAndCrossCorrelateSpec: *P_D_A1_Coeffs = " << *P_D_A1_Coeffs << endl;
  delete(P_D_A1_Coeffs);
**/
  Array<int, 2> I_A2_Where(D_A2_LineList_Pixels_AllPieces.rows(), D_A2_LineList_Pixels_AllPieces.cols());
  I_A2_Where = where(fabs(D_A2_LineList_Pixels_AllPieces) > 0.000001, 1, 0);
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: I_A2_Where = " << I_A2_Where << endl;
  #endif
  Array<int, 2> I_A2_IndWhere(2,2);
  if (!this->GetIndex(I_A2_Where, I_NInd, I_A2_IndWhere)){
    cout << "CFits::StretchAndCrossCorrelateSpec: ERROR: GetIndex returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: I_A2_IndWhere = " << I_A2_IndWhere << endl;
  #endif
  Array<double, 1> D_A1_Dist_SubArr(2);
  if (!this->GetSubArrCopy(D_A2_Dist, I_A2_IndWhere, D_A1_Dist_SubArr)){
    cout << "CFits::StretchAndCrossCorrelateSpec: ERROR: GetSubArrCopy returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: D_A1_Dist_SubArr = " << D_A1_Dist_SubArr << endl;
  #endif
  double D_MedianDiff = this->Median(D_A1_Dist_SubArr);
  Array<double, 1> *P_D_A1_Sort = this->BubbleSort(D_A1_Dist_SubArr);
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: D_MedianDiff = " << D_MedianDiff << endl;
    cout << "CFits::StretchAndCrossCorrelateSpec: *P_D_A1_Sort = " << *P_D_A1_Sort << endl;
  #endif
  Array<double, 1> D_A1_Dist_Temp(D_A1_Dist_SubArr.size()-4);
  D_A1_Dist_Temp = (*P_D_A1_Sort)(Range(2, D_A1_Dist_SubArr.size()-3));
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: D_A1_Dist_Temp = " << D_A1_Dist_Temp << endl;
  #endif
  double D_StdDev_Diff = this->StdDev(D_A1_Dist_Temp);
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: D_StdDev_Diff = " << D_StdDev_Diff << endl;
  #endif
  I_A1_Where.resize(D_A1_Dist_SubArr.size());
  I_A1_Where = where(fabs(D_A1_Dist_SubArr - D_MedianDiff) > (3. * D_StdDev_Diff), 1, 0);
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: I_A1_Where = " << I_A1_Where << endl;
  #endif
  Array<int, 1> I_A1_IndWhere(2);
  int I_NBad = 0;
  if (max(I_A1_Where) > 0){
    if (!this->GetIndex(I_A1_Where, I_NBad, I_A1_IndWhere)){
      cout << "CFits::StretchAndCrossCorrelateSpec: ERROR: 2. GetIndex returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
      cout << "CFits::StretchAndCrossCorrelateSpec: I_NBad = " << I_NBad << ": I_A1_IndWhere = " << I_A1_IndWhere << endl;
    #endif
    for (int i_bad=0; i_bad<I_NBad; i_bad++){
      D_A2_LineList_Pixels_AllPieces(I_A2_IndWhere(I_A1_IndWhere(i_bad), 0), I_A2_IndWhere(I_A1_IndWhere(i_bad), 1)) = 0.;
      #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
        cout << "CFits::StretchAndCrossCorrelateSpec: i_bad = " << i_bad << ": D_A2_LineList_Pixels_AllPieces(" << I_A2_IndWhere(I_A1_IndWhere(i_bad), 0) << ", " << I_A2_IndWhere(I_A1_IndWhere(i_bad), 1) << ") set to " << D_A2_LineList_Pixels_AllPieces(I_A2_IndWhere(I_A1_IndWhere(i_bad), 0), I_A2_IndWhere(I_A1_IndWhere(i_bad), 1)) << endl;
      #endif
    }
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
      cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_LineList_Pixels_AllPieces = " << D_A2_LineList_Pixels_AllPieces << endl;
    #endif

    I_A1_Where.resize(D_A2_LineList_Pixels_AllPieces.cols());
    D_A2_LineList_WLenPix_Out(Range::all(), 1) = 0.;
    for (int i_line=0; i_line<D_A2_LineList_WLenPix_In.rows(); i_line++){
      I_A1_Where = where(fabs(D_A2_LineList_Pixels_AllPieces(i_line, Range::all())) > 0.001, 1, 0);
      P_I_A1_IndWhere = this->GetIndex(I_A1_Where, I_NInd);
      #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
        cout << "CFits::StretchAndCrossCorrelateSpec: i_line = " << i_line << ": I_NInd = " << I_NInd << endl;
      #endif
      if (I_NInd == 0)
        D_A2_LineList_WLenPix_Out(i_line, 1) = D_A2_LineList_WLenPix_In(i_line, 1) + D_MedianDiff;
      else if (I_NInd == 1)
        D_A2_LineList_WLenPix_Out(i_line, 1) = D_A2_LineList_Pixels_AllPieces(i_line, (*P_I_A1_IndWhere)(0));
      else{
        for (int i_ind=0; i_ind<I_NInd; i_ind++){
          D_A2_LineList_WLenPix_Out(i_line, 1) += D_A2_LineList_Pixels_AllPieces(i_line, (*P_I_A1_IndWhere)(i_ind));
          #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
            cout << "CFits::StretchAndCrossCorrelateSpec: i_line = " << i_line << ": i_ind = " << i_ind << ": (*P_I_A1_IndWhere)(" << i_ind << ") = " << (*P_I_A1_IndWhere)(i_ind) << endl;
            cout << "CFits::StretchAndCrossCorrelateSpec: i_line = " << i_line << ": i_ind = " << i_ind << ": D_A2_LineList_WLenPix_Out(" << i_line << ", 1) set to " << D_A2_LineList_WLenPix_Out(i_line, 1) << endl;
          #endif
        }
        D_A2_LineList_WLenPix_Out(i_line, 1) = D_A2_LineList_WLenPix_Out(i_line, 1) / I_NInd;
      }
      #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
        cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_LineList_WLenPix_Out(" << i_line << ", 1) set to " << D_A2_LineList_WLenPix_Out(i_line, 1) << endl;
      #endif
      delete(P_I_A1_IndWhere);
    }
  }
//  if (I_NBad > 0)
//    return false;
/**  Array<int, 1>
  for (int i_line=0; i_line<I_NRejected; i_line++){
    cout << "CFits::StretchAndCrossCorrelateSpec: Position of line " << I_A1_Rejected(i_line) << " was " << D_A2_LineList_WLenPix_Out(I_A1_Rejected(i_line), 1) << endl;
    D_A2_LineList_WLenPix_Out(I_A1_Rejected(i_line), 1) = D_A2_LineList_WLenPix_In(I_A1_Rejected(i_line), 1) - D_A1_FitOut(I_A1_Rejected(i_line));
    cout << "CFits::StretchAndCrossCorrelateSpec: Position of line " << I_A1_Rejected(i_line) << " corrected to " << D_A2_LineList_WLenPix_Out(I_A1_Rejected(i_line), 1) << endl;
    return false;
  }
  **/

  ///plot whole spectra
  #ifdef __WITH_PLOTS__
    mglData MGLData1_SpecRef;// = new mglData(2);
    Array<double, 1> D_A1_SpecRef_Temp(D_A1_SpecRef_In.size());
    D_A1_SpecRef_Temp = D_A1_SpecRef_In;
    MGLData1_SpecRef.Link(D_A1_SpecRef_Temp.data(), D_A1_SpecRef_In.size());

    mglData MGLData1_Spec;// = new mglData(2);
    Array<double, 1> D_A1_Spec_Temp(D_A1_Spec_In.size());
    D_A1_Spec_Temp = D_A1_Spec_In;
    MGLData1_Spec.Link(D_A1_Spec_Temp.data(), D_A1_Spec_In.size());

    mglGraph gr;
    Array<double, 1> D_A1_Max(2);
    D_A1_Max(0) = max(D_A1_Spec_In);
    D_A1_Max(1) = max(D_A1_SpecRef_In);
    gr.SetRanges(0,D_A1_Spec_Temp.rows(),0,max(D_A1_Max));
    gr.Axis();
    gr.Label('y',"Counts",0);
    gr.Label('x',"Pixel Number",0);

    gr.Plot(MGLData1_SpecRef, "g");
    gr.AddLegend("RefSpec", "g");

    gr.Plot(MGLData1_Spec, "b");
    gr.AddLegend("Spec", "b");

    Array<double, 1> D_A1_Line_X(2);
    Array<double, 1> D_A1_Line_Y(2);
    mglData D_MGL1_X, D_MGL1_Y;// = new mglData(2,2);
    for (int i_ref=0; i_ref<2; i_ref++){
      for (int i_line=0; i_line<D_A2_LineList_WLenPix_In.rows(); i_line++){
        if (i_ref == 0)
          D_A1_Line_X = D_A2_LineList_WLenPix_In(i_line, 1);
        else
          D_A1_Line_X = D_A2_LineList_WLenPix_Out(i_line, 1);

        D_A1_Line_Y(0) = 0.;
        D_A1_Line_Y(1) = max(D_A1_Spec_In);
        D_MGL1_X.Link(D_A1_Line_X.data(), long(D_A1_Line_X.size()), 0, 0);
        D_MGL1_Y.Link(D_A1_Line_Y.data(), long(D_A1_Line_X.size()), 0, 0);

        if (i_ref == 0)
          gr.Plot(D_MGL1_X, D_MGL1_Y, "g");
        else
          gr.Plot(D_MGL1_X, D_MGL1_Y, "b");
      }
    }
//    delete(P_MGLData2);
    CS_PlotName.Set(CS_FName_In);
    CS_PlotName.Add(CString("_plot_spec_final.png"));
    gr.Box();
    gr.Legend();
    gr.WriteFrame(CS_PlotName.Get());

    int I_PathPos = CS_PlotName.LastStrPos(CString("/"));
    CString CS_PName(" ");
    if (I_PathPos < 0){
        CS_PName.Set(CS_PlotName);
    }
    else{
        CString *P_CS_PNTemp = CS_PlotName.SubString(I_PathPos+1);
        CS_PName.Set(*P_CS_PNTemp);
        delete(P_CS_PNTemp);
    }
    (*P_OFS_html) << "<img src=\"" << CS_PName << "\"><br>" << CS_PName << "<br><br><hr><br>" << endl;
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
      cout << "CFits::StretchAndCrossCorrelateSpec: CS_PlotName = <" << CS_PlotName << ">" << endl;
    #endif
    (*P_OFS_html) << "</center></body></html>" << endl;
    delete(P_OFS_html);
//    Py_Exit(0);
  #endif
    
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATESPEC__
    cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_LineList_Pixels_AllPieces = " << D_A2_LineList_Pixels_AllPieces << endl;
    cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_LineList_WLenPix_In = " << D_A2_LineList_WLenPix_In << endl;
    cout << "CFits::StretchAndCrossCorrelateSpec: D_A2_LineList_WLenPix_Out = " << D_A2_LineList_WLenPix_Out << endl;
  #endif
    
  return true;
}

bool CFits::StretchAndCrossCorrelate(const Array<double, 1> &D_A1_Spec_In,
                                     const Array<double, 1> &D_A1_SpecRef_In,
                                     const int I_Radius_XCor_In,
                                     const int I_Stretch_Min_Length_In,
                                     const int I_Stretch_Max_Length_In,
                                     const int I_N_Stretches_In,
                                     double &D_Stretch_Out,
                                     double &D_Shift_Out,
                                     Array<double, 2> &D_A2_SpecStretched_MinChiSq) const{
  /// Stretch Reference Spectrum
  Array<double, 1> *P_D_A1_Ref_X = this->DIndGenArr(D_A1_SpecRef_In.size());
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATE__
    cout << "CFits::StretchAndCrossCorrelate: *P_D_A1_Ref_X = " << *P_D_A1_Ref_X << endl;
    cout << "CFits::StretchAndCrossCorrelate: D_A1_SpecRef_In = " << D_A1_SpecRef_In << endl;
    #endif

  Array<double, 1> D_A1_SpecTemp(1);
  D_A1_SpecTemp = 0.;
  Array<double, 1> D_A1_SpecRefTemp(1);
  D_A1_SpecRefTemp = 0.;
  Array<double, 2> D_A2_SpecCalib_Out(2,2);
  D_A2_SpecCalib_Out = 0.;
  double D_RMS_Out = 0.;
//  int I_PixShift = 0;
  int I_LinePos = 0;
  int i_line_temp = 0;
  int i_nlines = 0;
  Array<double, 1> D_A1_Ref_Y(1);
  Array<double, 1> D_A1_Ref_X_Stretched(1);
  Array<double, 1> D_A1_XCorChiSq(I_N_Stretches_In);
  Array<int, 1> I_A1_RefStretchLength(I_N_Stretches_In);
  Array<int, 1> I_A1_PixShift(I_N_Stretches_In);
  I_A1_RefStretchLength = 0;
  D_A1_XCorChiSq = 0.;
  I_A1_RefStretchLength(0) = I_Stretch_Min_Length_In;
  double D_Temp = 0.;
  for (int i_stretch=0; i_stretch<I_N_Stretches_In; i_stretch++){

    D_A1_Ref_X_Stretched.resize(I_A1_RefStretchLength(i_stretch));
    D_A1_Ref_X_Stretched(0) = (*P_D_A1_Ref_X)(0);
    for (int i_x_stretch=1; i_x_stretch < I_A1_RefStretchLength(i_stretch); i_x_stretch++)
      D_A1_Ref_X_Stretched(i_x_stretch) = D_A1_Ref_X_Stretched(i_x_stretch-1) + (((*P_D_A1_Ref_X)(P_D_A1_Ref_X->size()-1) - (*P_D_A1_Ref_X)(0))/I_A1_RefStretchLength(i_stretch));
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATE__
      cout << "CFits::StretchAndCrossCorrelate: i_stretch = " << i_stretch << ": I_RefStretchLength = " << I_A1_RefStretchLength(i_stretch) << ": D_A1_Ref_X_Stretched = " << D_A1_Ref_X_Stretched << endl;
    #endif
    if (!this->InterPol(D_A1_SpecRef_In,
                        *P_D_A1_Ref_X,
                        D_A1_Ref_X_Stretched,
                        D_A1_Ref_Y)){
      cout << "CFits::StretchAndCrossCorrelate: i_stretch = " << i_stretch << ": I_RefStretchLength = " << I_A1_RefStretchLength(i_stretch) << ": ERROR: InterPol(D_A1_SpecRef=" << D_A1_SpecRef_In << ", *P_D_A1_Ref_X=" << *P_D_A1_Ref_X << ", D_A1_Ref_X_Stretched=" << D_A1_Ref_X_Stretched << ", D_A1_Ref_Y) returned FALSE" << endl;
      exit(EXIT_FAILURE);
    }

    /// Cross-correlate D_A1_Spec to reference spectrum
    D_A1_SpecTemp.resize(D_A1_Spec_In.size());
    D_A1_SpecTemp = D_A1_Spec_In;
    D_A1_SpecRefTemp.resize(D_A1_Ref_Y.size());
    D_A1_SpecRefTemp = D_A1_Ref_Y;
    if (D_A1_SpecTemp.size() < D_A1_SpecRefTemp.size())
      D_A1_SpecRefTemp.resizeAndPreserve(D_A1_SpecTemp.size());
    if (D_A1_SpecRefTemp.size() < D_A1_SpecTemp.size())
      D_A1_SpecTemp.resizeAndPreserve(D_A1_SpecRefTemp.size());

    if (!this->CrossCorrelate(D_A1_SpecRefTemp,
                              D_A1_SpecTemp,
                              I_Radius_XCor_In,
                              I_Radius_XCor_In,
                              I_A1_PixShift(i_stretch),
                              D_A1_XCorChiSq(i_stretch))){
      cout << "CFits::StretchAndCrossCorrelate: i_stretch = " << i_stretch << ": I_RefStretchLength = " << I_A1_RefStretchLength(i_stretch) << ": ERROR: CrossCorrelate returned FALSE" << endl;
      exit(EXIT_FAILURE);
    }
    #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATE__
      cout << "CFits::StretchAndCrossCorrelate: i_stretch = " << i_stretch << ": I_RefStretchLength = " << I_A1_RefStretchLength(i_stretch) << ": I_A1_PixShift(i_stretch) = " << I_A1_PixShift(i_stretch) << endl;
      cout << "CFits::StretchAndCrossCorrelate: i_stretch = " << i_stretch << ": I_RefStretchLength = " << I_A1_RefStretchLength(i_stretch) << ": D_A1_XCorChiSq(i_stretch) = " << D_A1_XCorChiSq(i_stretch) << endl;
    #endif
    if (i_stretch < I_N_Stretches_In - 1){
      D_Temp = double(I_Stretch_Max_Length_In - I_Stretch_Min_Length_In) / double(I_N_Stretches_In);
      I_A1_RefStretchLength(i_stretch+1) = I_A1_RefStretchLength(i_stretch) + int(D_Temp);
      #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATE__
        cout << "CFits::StretchAndCrossCorrelate: i_stretch = " << i_stretch << ": I_Stretch_Max_Length_In(=" << I_Stretch_Max_Length_In << ") - I_Stretch_Min_Length_In(=" << I_Stretch_Min_Length_In << ") / I_N_Stretches_In(=" << I_N_Stretches_In << ") = " << D_Temp << ", int(D_Temp) = " << int(D_Temp) << endl;
        cout << "CFits::StretchAndCrossCorrelate: i_stretch = " << i_stretch << ": I_RefStretchLength(i+1) = " << I_A1_RefStretchLength(i_stretch+1) << endl;
      #endif
    }
  }/// end for (int i_stretch=0; i_stretch<I_N_Stretches_In; i_stretch++){

  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATE__
    cout << "CFits::StretchAndCrossCorrelate: I_A1_RefStretchLength = " << I_A1_RefStretchLength << endl;
    cout << "CFits::StretchAndCrossCorrelate: D_A1_XCorChiSq = " << D_A1_XCorChiSq << endl;
    cout << "CFits::StretchAndCrossCorrelate: I_A1_PixShift = " << I_A1_PixShift << endl;
  #endif

  double D_MinXCorChiSq = max(D_A1_XCorChiSq);
  int I_MinXCorChiSqPos = 0;
  for (int i_stretch=0; i_stretch<I_N_Stretches_In; i_stretch++){
    if (D_A1_XCorChiSq(i_stretch) < D_MinXCorChiSq){
      D_MinXCorChiSq = D_A1_XCorChiSq(i_stretch);
      I_MinXCorChiSqPos = i_stretch;
    }
  }
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATE__
    cout << "CFits::StretchAndCrossCorrelate: I_MinXCorChiSqPos = " << I_MinXCorChiSqPos << endl;
  #endif
  D_Shift_Out = double(I_A1_PixShift(I_MinXCorChiSqPos));
  D_Stretch_Out = double(I_A1_RefStretchLength(I_MinXCorChiSqPos));

  D_A1_Ref_X_Stretched.resize(I_A1_RefStretchLength(I_MinXCorChiSqPos));
  D_A1_Ref_X_Stretched(0) = (*P_D_A1_Ref_X)(0);
  for (int i_x_stretch=1; i_x_stretch < I_A1_RefStretchLength(I_MinXCorChiSqPos); i_x_stretch++)
    D_A1_Ref_X_Stretched(i_x_stretch) = D_A1_Ref_X_Stretched(i_x_stretch-1) + (((*P_D_A1_Ref_X)(P_D_A1_Ref_X->size()-1) - (*P_D_A1_Ref_X)(0))/D_Stretch_Out);
  #ifdef __DEBUG_FITS_STRETCHANDCROSSCORRELATE__
    cout << "CFits::StretchAndCrossCorrelate: I_MinXCorChiSqPos = " << I_MinXCorChiSqPos << ": I_RefStretchLength = " << I_A1_RefStretchLength(I_MinXCorChiSqPos) << ": D_A1_Ref_X_Stretched = " << D_A1_Ref_X_Stretched << endl;
  #endif
  if (!this->InterPol(D_A1_SpecRef_In,
                      *P_D_A1_Ref_X,
                      D_A1_Ref_X_Stretched,
                      D_A1_Ref_Y)){
    cout << "CFits::StretchAndCrossCorrelate: I_MinXCorChiSqPos = " << I_MinXCorChiSqPos << ": I_RefStretchLength = " << I_A1_RefStretchLength(I_MinXCorChiSqPos) << ": ERROR: InterPol(D_A1_SpecRef=" << D_A1_SpecRef_In << ", *P_D_A1_Ref_X=" << *P_D_A1_Ref_X << ", D_A1_Ref_X_Stretched=" << D_A1_Ref_X_Stretched << ", D_A1_Ref_Y) returned FALSE" << endl;
    exit(EXIT_FAILURE);
  }
  Array<double, 1> *P_D_A1_Ref_X_Temp = this->DIndGenArr(D_A1_Ref_Y.size());
  D_A1_Ref_X_Stretched.resize(D_A1_Ref_Y.size());
  D_A1_Ref_X_Stretched = (*P_D_A1_Ref_X_Temp) - D_Shift_Out;
  delete(P_D_A1_Ref_X_Temp);

  D_A2_SpecStretched_MinChiSq.resize(D_A1_Ref_Y.size(), 2);
  D_A2_SpecStretched_MinChiSq(Range::all(), 0) = D_A1_Ref_X_Stretched;
  D_A2_SpecStretched_MinChiSq(Range::all(), 1) = D_A1_Ref_Y;

  delete(P_D_A1_Ref_X);

  return true;
}

/**
 * Identify
 * Identifies calibration lines, given in D_A2_LineList_In the format [wlen, approx_pixel] in
 * wavelength-calibration spectrum D_A2_Spec_In [pixel_number, flux]
 * within the given position plus/minus I_Radius_In,
 * fits Gaussians to each line, fits Polynomial of order I_PolyFitOrder_In, and
 * returns calibrated spectrum D_A2_CalibratedSpec_Out in the format
 * [WLen, flux] and PolyFit coefficients D_A1_PolyFitCoeffs_Out
 * 
 * If D_A2_LineList_In contains 3 columns, the 3rd column will be used to decide which line
 * to keep in case a weak line close to a strong line gets wrongly identified as the strong
 * line
 **/
bool CFits::Identify(const Array<double, 1> &D_A1_Spec_In,
                     const Array<double, 2> &D_A2_LineList_In,
                     const int I_Radius_In,
                     const double D_FWHM_In,
                     const int I_PolyFitOrder_In,
                     const CString &CS_FName_In,
                     Array<double, 2> &D_A2_CalibratedSpec_Out,
                     Array<double, 1> &D_A1_PolyFitCoeffs_Out,
                     double &D_RMS_Out,
		     Array<double, 2> &D_A2_PixWLen_Out) const{

  /// Initialise output parameters
  D_A1_PolyFitCoeffs_Out.resize(I_PolyFitOrder_In+1);
  D_A1_PolyFitCoeffs_Out = 0.;
  D_RMS_Out = -1.;
  D_A2_PixWLen_Out.resize(D_A2_LineList_In.rows(), 3);
  D_A2_PixWLen_Out = 0.;
  D_A2_CalibratedSpec_Out.resize(D_A1_Spec_In.size(), 2);
  D_A2_CalibratedSpec_Out = 0.;
                       
  ///for each line in line list, find maximum in spectrum and fit Gaussian
  int I_MaxPos = 0;
  int I_NInd = 0;
  int I_Start = 0;
  int I_End = 0;
  int I_NTerms = 4;
  double D_Max = 0.;
  double D_Min = 0.;
  Array<int, 1> I_A1_Index(2*I_Radius_In + 1);
  I_A1_Index = 0;
  Array<int, 1> I_A1_IndexPos(1);
  I_A1_IndexPos = 0;
  Array<double, 1> D_A1_GaussSpec(1);
  D_A1_GaussSpec = 0.;
  Array<double, 1> D_A1_GaussCoeffs(I_NTerms);
  D_A1_GaussCoeffs = 0.;
  Array<double, 1> D_A1_EGaussCoeffs(D_A1_GaussCoeffs.size());
  D_A1_EGaussCoeffs = 0.;
  Array<int, 2> I_A2_Limited(I_NTerms,2);
  I_A2_Limited = 1;
  Array<double, 2> D_A2_Limits(I_NTerms,2);
  D_A2_Limits = 0.;
  Array<double, 1> D_A1_Guess(I_NTerms);
//  Array<CString, 1> CS_A1_KeyWords(2);
//  CS_A1_KeyWords(0) = CString("MEASURE_ERRORS");
//  CS_A1_KeyWords(1) = CString("NTERMS");
//  CS_A1_KeyWords(2) = CString("ESTIMATES");
//  void **PP_Args = (void**)malloc(sizeof(void*) * 2);
  Array<double, 1> D_A1_MeasureErrors(2);
  D_A1_MeasureErrors = 0.;
//  PP_Args[0] = &D_A1_MeasureErrors;
//  PP_Args[1] = &I_NTerms;
//  Array<double, 1> D_A1_Estimates(I_NTerms);
//  PP_Args[2] = &D_A1_Estimates;
  Array<double, 1> *P_D_A1_Ind = this->DIndGenArr(D_A1_Spec_In.size());
  Array<double, 1> D_A1_X(1);
  D_A1_X = 0.;
  Array<double, 1> D_A1_GaussPos(D_A2_LineList_In.rows());
  D_A1_GaussPos = 0.;
  #ifdef __WITH_PLOTS__
    CString CS_PlotName("");
    CString *P_CS_Num;
//    CS_FName_In.MkDir(CString("plots"));
  #endif
  for (int i_line=0; i_line < D_A2_LineList_In.rows(); i_line++){
    I_Start = int(D_A2_LineList_In(i_line,1))-I_Radius_In;
    if (I_Start < 0)
      I_Start = 0;
    I_End = int(D_A2_LineList_In(i_line,1))+I_Radius_In;
    if (I_End >= D_A1_Spec_In.size())
      I_End = D_A1_Spec_In.size()-1;
    if (I_Start >= I_End){
      cout << "CFits::Identify: Warning: I_Start(=" << I_Start << ") >= I_End(=" << I_End << ") => Returning FALSE" << endl;
      cout << "CFits::Identify: D_A1_Spec_In = " << D_A1_Spec_In << endl;
      cout << "CFits::Identify: D_A2_LineList_In = " << D_A2_LineList_In << endl;
//      return false;
    }
    else{
      D_Max = max(D_A1_Spec_In(Range(I_Start, I_End)));
      D_Min = min(D_A1_Spec_In(Range(I_Start, I_End)));
//    D_A1_Estimates(0) = D_Max - D_Min;
      #ifdef __DEBUG_FITS_IDENTIFY__
        cout << "CFits::Identify: D_A1_Spec_In(" << I_Start << ":" << I_End << ") = " << D_A1_Spec_In(Range(I_Start, I_End)) << endl;
      #endif
      I_A1_Index.resize(I_End - I_Start + 1);
      I_A1_Index = where(fabs(D_A1_Spec_In(Range(I_Start, I_End)) - D_Max) < 0.00000001, 1, 0);
      #ifdef __DEBUG_FITS_IDENTIFY__
        cout << "CFits::Identify: i_line = " << i_line << ": I_A1_Index = " << I_A1_Index << endl;
      #endif
      if (!(this->GetIndex(I_A1_Index, I_NInd, I_A1_IndexPos))){
        cout << "CFits::Identify: ERROR: GetIndex returned FALSE" << endl;
        return false;
      }
//    D_A1_Estimates(1) = I_A1_IndexPos(0);
//    D_A1_Estimates(2) = D_FWHM_In;
//    D_A1_Estimates(3) = D_Min;
      #ifdef __DEBUG_FITS_IDENTIFY__
        cout << "CFits::Identify: I_A1_IndexPos = " << I_A1_IndexPos << endl;
      #endif
      if (I_NInd != 1){
        cout << "CFits::Identify: WARNING: I_NInd(=" << I_NInd << ") != 1" << endl;
//      return false;
      }
      I_MaxPos = I_A1_IndexPos(0) + I_Start;
//      I_MaxPos = this->Round(double(I_A1_IndexPos(0)) + D_A2_LineList_In(i_line,1) - double(I_Radius_In));
      #ifdef __DEBUG_FITS_IDENTIFY__
        cout << "CFits::Identify: I_MaxPos = " << I_MaxPos << endl;
      #endif
      I_Start = this->Round(double(I_MaxPos) - (1.5*D_FWHM_In));
      if (I_Start < 0)
        I_Start = 0;
      #ifdef __DEBUG_FITS_IDENTIFY__
        cout << "CFits::Identify: I_Start = " << I_Start << endl;
      #endif
      I_End = this->Round(double(I_MaxPos) + (1.5*D_FWHM_In));
      if (I_End >= D_A1_Spec_In.size())
        I_End = D_A1_Spec_In.size()-1;
      #ifdef __DEBUG_FITS_IDENTIFY__
        cout << "CFits::Identify: I_End = " << I_End << endl;
      #endif
      if (I_End < I_Start+4){
        cout << "CFits::Identify: WARNING: Line position outside spectrum" << endl;
      }
      else{
        D_A1_GaussSpec.resize(I_End - I_Start + 1);
        D_A1_MeasureErrors.resize(I_End - I_Start + 1);
        D_A1_X.resize(I_End - I_Start + 1);
        D_A1_GaussSpec = D_A1_Spec_In(Range(I_Start, I_End));
        #ifdef __DEBUG_FITS_IDENTIFY__
          cout << "CFits::Identify: D_A1_GaussSpec = " << D_A1_GaussSpec << endl;
        #endif
        D_A1_MeasureErrors = sqrt(fabs(D_A1_GaussSpec));
        #ifdef __DEBUG_FITS_IDENTIFY__
          cout << "CFits::Identify: D_A1_MeasureErrors = " << D_A1_MeasureErrors << endl;
        #endif
        D_A1_X = (*P_D_A1_Ind)(Range(I_Start, I_End));
        #ifdef __DEBUG_FITS_IDENTIFY__
          cout << "CFits::Identify: D_A1_X = " << D_A1_X << endl;
        #endif
//        if (!this->GaussFit(D_A1_X,
//                            D_A1_GaussSpec,
//                            D_A1_GaussCoeffs,
//                            CS_A1_KeyWords,
//                            PP_Args)){

        /*     p[0] = constant offset
         *     p[1] = peak y value
         *     p[2] = x centroid position
         *     p[3] = gaussian sigma width
         */
        D_A1_Guess(0) = min(D_A1_GaussSpec);
        D_A1_Guess(1) = max(D_A1_GaussSpec - D_A1_Guess(0));
        D_A1_Guess(2) = D_A1_X(0) + (D_A1_X(D_A1_X.size()-1) - D_A1_X(0)) / 2.;
        D_A1_Guess(3) = D_FWHM_In;
        D_A2_Limits(0,1) = fabs(1.5 * D_A1_Guess(0));
        D_A2_Limits(1,0) = 0.;
        D_A2_Limits(1,1) = fabs(1.5 * D_A1_Guess(1));
        D_A2_Limits(2,0) = D_A1_X(1);
        D_A2_Limits(2,1) = D_A1_X(D_A1_X.size()-2);
        D_A2_Limits(3,0) = D_A1_Guess(3) / 3.;
        D_A2_Limits(3,1) = 2. * D_A1_Guess(3);
        if (!MPFitGaussLim(D_A1_X,
                           D_A1_GaussSpec,
                           D_A1_MeasureErrors,
                           D_A1_Guess,
                           I_A2_Limited,
                           D_A2_Limits,
                           true,
                           false,
                           D_A1_GaussCoeffs,
                           D_A1_EGaussCoeffs)){
          cout << "CFits::Identify: WARNING: GaussFit returned FALSE" << endl;
        //        return false;
        }
        else{
          #ifdef __DEBUG_FITS_IDENTIFY__
            cout << "CFits::Identify: i_line = " << i_line << ": D_A1_GaussCoeffs = " << D_A1_GaussCoeffs << endl;
          #endif
          if (fabs(double(I_MaxPos) - D_A1_GaussCoeffs(2)) < 2.5){//D_FWHM_In){
            D_A1_GaussPos(i_line) = D_A1_GaussCoeffs(2);
            #ifdef __DEBUG_FITS_IDENTIFY__
              cout << "CFits::Identify: D_A1_GaussPos(" << i_line << ") = " << D_A1_GaussPos(i_line) << endl;
            #endif
            if (i_line > 0){
              if (fabs(D_A1_GaussPos(i_line) - D_A1_GaussPos(i_line-1)) < 1.5){/// wrong line identified!
                if (D_A2_LineList_In.cols() > 2){
                  if (D_A2_LineList_In(i_line, 2) < D_A2_LineList_In(i_line-1, 2)){
                    cout << "CFits::Identify: WARNING: i_line=" << i_line << ": line " << i_line << " at " << D_A1_GaussPos(i_line) << " has probably been misidentified (D_A1_GaussPos(" << i_line-1 << ")=" << D_A1_GaussPos(i_line-1) << ") => removing line from line list" << endl;
                    D_A1_GaussPos(i_line) = 0.;
                  }
                  else{
                    cout << "CFits::Identify: WARNING: i_line=" << i_line << ": line at D_A1_GaussPos(" << i_line-1 << ") = " << D_A1_GaussPos(i_line-1) << " has probably been misidentified (D_A1_GaussPos(" << i_line << ")=" << D_A1_GaussPos(i_line) << ") => removing line from line list" << endl;
                    D_A1_GaussPos(i_line-1) = 0.;
                  }
//                  exit(EXIT_FAILURE);
                }
              }
            }
          }
          else{
            cout << "CFits::Identify: WARNING: I_MaxPos=" << I_MaxPos << " - D_A1_GaussCoeffs(2)=" << D_A1_GaussCoeffs(2) << " >= 2.5 => Skipping line" << endl;
          }
        }
      }
    }
  }/// end for (int i_line=0; i_line < D_A2_LineList_In.rows(); i_line++){
  ///remove lines which could not be found from line list
  I_A1_Index.resize(D_A1_GaussPos.size());
  I_A1_Index = where(D_A1_GaussPos > 0., 1, 0);
  #ifdef __DEBUG_FITS_IDENTIFY__
    cout << "CFits::Identify: D_A1_GaussPos = " << D_A1_GaussPos << endl;
    cout << "CFits::Identify: I_A1_Index = " << I_A1_Index << endl;
  #endif
  if (!(this->GetIndex(I_A1_Index, I_NInd, I_A1_IndexPos))){
    cout << "CFits::Identify: ERROR: GetIndex returned FALSE" << endl;
    return false;
  }
  cout << "CFits::Identify: " << I_NInd << " lines identified" << endl;
  #ifdef __DEBUG_FITS_IDENTIFY__
    cout << "CFits::Identify: I_A1_IndexPos = " << I_A1_IndexPos << endl;
  #endif
  if (I_NInd < (this->Round(double(D_A2_LineList_In.rows())*0.66))){
    cout << "CFits::Identify: ERROR: less than " << this->Round(double(D_A2_LineList_In.rows())*0.66) << " lines identified" << endl;
    return false;
  }
  else{
    Array<double, 1> D_A1_FittedWLen(I_NInd);
    Array<double, 1> D_A1_WLen(D_A2_LineList_In.rows());
    Array<double, 1> D_A1_FittedPos(I_NInd);

    if (!this->GetSubArrCopy(D_A1_GaussPos, I_A1_IndexPos, D_A1_FittedPos)){
      cout << "CFits::Identify: ERROR: GetSubArr(" << D_A1_GaussPos << ", " << I_A1_IndexPos << ") returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_IDENTIFY__
      cout << "CFits::Identify: D_A1_FittedPos = " << D_A1_FittedPos << endl;
    #endif

    D_A1_WLen = D_A2_LineList_In(Range::all(),0);
    if (!this->GetSubArrCopy(D_A1_WLen, I_A1_IndexPos, D_A1_FittedWLen)){
      cout << "CFits::Identify: ERROR: GetSubArrCopy returned FALSE" << endl;
      return false;
    }
    cout << "CFits::Identify: found D_A1_WLen = " << D_A1_FittedWLen << endl;

    D_A2_PixWLen_Out.resize(D_A1_FittedPos.size(), 3);
    D_A2_PixWLen_Out(Range::all(), 0) = D_A1_FittedPos;
    D_A2_PixWLen_Out(Range::all(), 1) = D_A1_FittedWLen;

//  Array<CString, 1> CS_A1_PolyFit_KeyWords(1);
//  CS_A1_PolyFit_KeyWords(0) = CString("YFIT");
//  Array<double, 1> D_A1_YFit(D_A1_FittedPos.size());
//  void **PP_Args_PolyFit = (void**)malloc(sizeof(void*) * 1);
//  PP_Args_PolyFit[0] = &D_A1_YFit;
    if (!this->PolyFit(D_A1_FittedPos,
                       D_A1_FittedWLen,
                       I_PolyFitOrder_In,
//                       CS_A1_PolyFit_KeyWords,
//                       PP_Args_PolyFit,
                       &D_A1_PolyFitCoeffs_Out)){
      cout << "CFits::Identify: ERROR: PolyFit returned FALSE" << endl;
      return false;
    }
    Array<double, 1> *P_D_A1_WLen_Gauss = this->Poly(D_A1_FittedPos, D_A1_PolyFitCoeffs_Out);
    cout << "CFits::Identify: P_D_A1_WLen_PolyFit = " << *P_D_A1_WLen_Gauss << endl;
    D_A2_PixWLen_Out(Range::all(), 2) = *P_D_A1_WLen_Gauss;

    ///Calculate RMS
    Array<double, 1> D_A1_WLenMinusFit(P_D_A1_WLen_Gauss->size());
    D_A1_WLenMinusFit = D_A1_FittedWLen-(*P_D_A1_WLen_Gauss);
    cout << "CFits::Identify: D_A1_WLenMinusFit = " << D_A1_WLenMinusFit << endl;
    D_RMS_Out=sqrt(sum(pow2(D_A1_FittedWLen-(*P_D_A1_WLen_Gauss)))/D_A1_FittedPos.size());
    cout << "CFits::Identify: D_RMS_Out = " << D_RMS_Out << endl;
    cout << "======================================" << endl;

    ///calibrate spectrum
    Array<double, 1> *P_D_A1_WLen_Out;// = new Array<double, 1>(D_A1_Spec_In.size());
    #ifdef __DEBUG_FITS_IDENTIFY__
      cout << "CFits::Identify: *P_D_A1_Ind = " << *P_D_A1_Ind << endl;
    #endif
    P_D_A1_WLen_Out = this->Poly((*P_D_A1_Ind), D_A1_PolyFitCoeffs_Out);
    D_A2_CalibratedSpec_Out.resize(D_A1_Spec_In.size(),2);
    D_A2_CalibratedSpec_Out(Range::all(),0) = (*P_D_A1_WLen_Out);
    D_A2_CalibratedSpec_Out(Range::all(),1) = D_A1_Spec_In;
    #ifdef __DEBUG_FITS_IDENTIFY__
      cout << "CFits::Identify: D_A2_CalibratedSpec_Out = " << D_A2_CalibratedSpec_Out << endl;
    #endif

    /// Check for monotonic
    if (this->IsMonotonic(*P_D_A1_WLen_Out) == 0){
      cout << "CFits::Identify: WARNING: Wavelength solution is not monotonic => Setting D_RMS_Out to 1000" << endl;
      D_RMS_Out = 1000.;
      cout << "CFits::Identify: D_RMS_Out = " << D_RMS_Out << endl;
      cout << "======================================" << endl;
    }

    #ifdef __WITH_PLOTS__
      mglGraph gr;
      mglData MGLData_X;
      MGLData_X.Link(P_D_A1_Ind->data(), P_D_A1_Ind->size(), 0, 0);
      mglData MGLData_WLen_Fit;
      MGLData_WLen_Fit.Link(P_D_A1_WLen_Out->data(), P_D_A1_WLen_Out->size(), 0, 0);
      mglData MGLData_OrigPos;// = new mglData(2);
      MGLData_OrigPos.Link(D_A1_FittedPos.data(), D_A1_FittedPos.size(), 0, 0);
      mglData MGLData_OrigWLen;// = new mglData(2);
      MGLData_OrigWLen.Link(D_A1_FittedWLen.data(), D_A1_FittedWLen.size(), 0, 0);
      mglData MGLData_FittedPos;// = new mglData(2);
      MGLData_FittedPos.Link(D_A1_FittedPos.data(), D_A1_FittedPos.size(), 0, 0);
      mglData MGLData_FittedWLen;// = new mglData(2);
      MGLData_FittedWLen.Link(P_D_A1_WLen_Gauss->data(), P_D_A1_WLen_Gauss->size(), 0, 0);

      gr.SetSize(1900,1200);
      gr.SetRanges(min(*P_D_A1_Ind),max(*P_D_A1_Ind),min(*P_D_A1_WLen_Out),max(*P_D_A1_WLen_Out)+(max(*P_D_A1_WLen_Out) - min(*P_D_A1_WLen_Out)) / 4.5);
      gr.Axis();
      gr.Label('y',"Wavelength",0);
      gr.Label('x',"Pixel Number",0);
      gr.Plot(MGLData_X, MGLData_WLen_Fit, "r");
      gr.AddLegend("Fit", "r");

      gr.Plot(MGLData_OrigPos, MGLData_OrigWLen, "bo ");
      gr.AddLegend("Line List", "bo ");

      gr.Plot(MGLData_FittedPos, MGLData_FittedWLen, "Yx ");
      gr.AddLegend("Fitted Positions", "Yx ");

      gr.Box();
      gr.Legend();

      CS_PlotName.Set(CS_FName_In);
      CS_PlotName.Add(CString("_Pix_WLen.png"));
      gr.WriteFrame(CS_PlotName.Get());

    #endif



    /// clean up
    delete(P_D_A1_WLen_Gauss);
    delete(P_D_A1_WLen_Out);
  }
  /// clean up
  delete(P_D_A1_Ind);

  return true;
}

/**
 * Dispcor
 * Applies dispersion correction to spectrum and returns wavelength-calibrated
 * two-dimensional spectrum (D_A1_Spec_In.size(), 2) [WLen, Flux]
 **/
bool CFits::DispCor(const Array<double, 1> &D_A1_Spec_In,
                    const Array<double, 1> &D_A1_PolyFitCoeffs_In,
                    Array<double, 2> &D_A2_Spec_Out){
  return this->DispCor(D_A1_Spec_In, D_A1_PolyFitCoeffs_In, 0., D_A2_Spec_Out);
}

bool CFits::DispCor(const Array<double, 1> &D_A1_Spec_In,
                    const Array<double, 1> &D_A1_PolyFitCoeffs_In,
                    const double D_PixShift_In,
                    Array<double, 2> &D_A2_Spec_Out){
  D_A2_Spec_Out.resize(D_A1_Spec_In.size(), 2);
  Array<double, 1> *P_D_A1_PixNumber = this->DIndGenArr(D_A1_Spec_In.size());
  *P_D_A1_PixNumber = *P_D_A1_PixNumber + D_PixShift_In;
  #ifdef __DEBUG_FITS_DISPCOR__
    cout << "CFits::DispCor: *P_D_A1_PixNumber = " << *P_D_A1_PixNumber << endl;
  #endif
  Array<double, 1> *P_D_A1_WLen_Out = this->Poly((*P_D_A1_PixNumber), D_A1_PolyFitCoeffs_In);
  #ifdef __DEBUG_FITS_DISPCOR__
    cout << "CFits::DispCor: *P_D_A1_WLen_Out = " << *P_D_A1_WLen_Out << endl;
  #endif
  D_A2_Spec_Out(Range::all(),0) = *P_D_A1_WLen_Out;
  D_A2_Spec_Out(Range::all(),1) = D_A1_Spec_In;

  /// clean up
  delete(P_D_A1_PixNumber);
  delete(P_D_A1_WLen_Out);
  return true;
}

/**
 * bool WriteCube(Array<double, 3> D_A3_In, CString CS_FitsFileName_Out) const
 **/
bool CFits::WriteCube(Array<double, 3> &D_A3_In, CString &CS_FitsFileName_Out) const{
  fitsfile *fptr;       /* pointer to the FITS file, defined in fitsio.h */
  int status, ii, jj, kk;
  long  fpixel, nelements, exposure;
//  double array[D_A3_In.rows()][D_A3_In.cols()][D_A3_In.depth()];
  void *p_void;

  /* initialize FITS image parameters */
//  char filename[] = CS_FitsFileName_Out.GetPChar();             /* name for new FITS file */
  int bitpix   =  DOUBLE_IMG; /* 16-bit unsigned short pixel values       */
  long naxis    =   3;  /* 3-dimensional image                            */
  long naxes[3] = { D_A3_In.depth(), D_A3_In.cols(), D_A3_In.rows() };   /* image is 300 pixels wide by 200 rows */

  /* allocate memory for the whole image */
//  array[0] = (double *)malloc( naxes[0] * naxes[1] * naxes[2] * sizeof( double ));

  /* initialize pointers to the start of each row of the image *
  for( kk=0; kk<naxes[2]; kk++ ){
    for( jj=0; jj<naxes[1]; jj++ ){
      for( ii=0; ii<naxes[0]; ii++ ){
        array[kk, jj, ii] = D_A3_In(ii,jj,kk);
      }
    }
  }*/

  remove(CS_FitsFileName_Out.Get());               /* Delete old file if it already exists */

  status = 0;         /* initialize status before calling fitsio routines */

  fits_create_file(&fptr, CS_FitsFileName_Out.Get(), &status); /* create new FITS file */
  if (status !=0)
  {
    cout << "CFits::WriteArray: Error <" << status << "> while creating file " << CS_FitsFileName_Out.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteArray: Error <" << status << "> while creating file " << CS_FitsFileName_Out.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(status, P_ErrMsg);
    cout << "CFits::WriteArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }

  /* write the required keywords for the primary array image.     */
  /* Since bitpix = USHORT_IMG, this will cause cfitsio to create */
  /* a FITS image with BITPIX = 16 (signed short integers) with   */
  /* BSCALE = 1.0 and BZERO = 32768.  This is the convention that */
  /* FITS uses to store unsigned integers.  Note that the BSCALE  */
  /* and BZERO keywords will be automatically written by cfitsio  */
  /* in this case.                                                */

  fits_create_img(fptr,  bitpix, naxis, naxes, &status);
  if (status !=0)
  {
    cout << "CFits::WriteArray: Error <" << status << "> while creating image " << CS_FitsFileName_Out.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteArray: Error <" << status << "> while creating image " << CS_FitsFileName_Out.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(status, P_ErrMsg);
    cout << "CFits::WriteArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }

  fpixel = 1;                               /* first pixel to write      */
  nelements = naxes[0] * naxes[1] * naxes[2];          /* number of pixels to write */
  p_void = D_A3_In.data();// = new Array<double,2>(p_Array, shape(naxes[0],

  /* write the array of unsigned integers to the FITS file */
  fits_write_img(fptr, TDOUBLE, fpixel, nelements, p_void, &status);
  if (status !=0)
  {
    cout << "CFits::WriteArray: Error <" << status << "> while writing image " << CS_FitsFileName_Out.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteArray: Error <" << status << "> while writing image " << CS_FitsFileName_Out.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(status, P_ErrMsg);
    cout << "CFits::WriteArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }

//    free( array[0] );  /* free previously allocated memory */

  /* write another optional keyword to the header */
  /* Note that the ADDRESS of the value is passed in the routine *
  exposure = 1500.;
  if ( fits_update_key(fptr, TLONG, "EXPOSURE", &exposure,
    "Total Exposure Time", &status) )
    printerror( status );
  */

  fits_close_file(fptr, &status);                /* close the file */
  if (status !=0)
  {
    cout << "CFits::WriteArray: Error <" << status << "> while closing file" << CS_FitsFileName_Out.Get() << endl;
    (*P_OFS_Log) << "CFits::WriteArray: Error <" << status << "> while closing file" << CS_FitsFileName_Out.Get() << endl;
    char* P_ErrMsg = new char[255];
    ffgerr(status, P_ErrMsg);
    cout << "CFits::WriteArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    (*P_OFS_Log) << "CFits::WriteArray: <" << P_ErrMsg << "> => Returning FALSE" << endl;
    delete[] P_ErrMsg;
    return false;
  }

  return true;
}

/** find nearest neighbour to D_ReferencePoint_In in D_A1_ArrayToLookForNeighbour_In, and write position of nearest 
 * neighbour to I_Pos_Out
 * */
int CFits::FindNearestNeighbour(const double &D_ReferencePoint_In,
                                 const Array<double, 1> &D_A1_ArrayToLookForNeighbour_In) const{
  Array<double, 1> D_A1_Diff(D_A1_ArrayToLookForNeighbour_In.size());
  D_A1_Diff = D_A1_ArrayToLookForNeighbour_In - D_ReferencePoint_In;
  TinyVector<int, 1> TV_Index = minIndex(D_A1_Diff);
  return TV_Index(0);
}
                          
/**
 * find nearest neighbour to D_A1_ReferencePoint_In(x,y) in D_A2_ArrayToLookForNeighbour_In and write coordinates to D_A1_NearestNeighbour_Out
 **/
bool CFits::FindNearestNeighbour(const Array<double, 1> &D_A1_ReferencePoint_In,
                                 const Array<double, 2> &D_A2_ArrayToLookForNeighbour_In, Array<double, 1> &D_A1_NearestNeighbour_Out,
                                 int &I_Pos) const{
  Array<int, 1> I_A1_Area(4);
  I_A1_Area(0) = 0;
  I_A1_Area(1) = this->NCols;
  I_A1_Area(2) = 0;
  I_A1_Area(3) = this->NRows;
  return this->FindNearestNeighbour(D_A1_ReferencePoint_In,
                                    D_A2_ArrayToLookForNeighbour_In,
                                    I_A1_Area,
                                    D_A1_NearestNeighbour_Out,
                                    I_Pos);
}

bool CFits::FindNearestNeighbour(const Array<double, 1> &D_A1_ReferencePoint_In,
                                 const Array<double, 2> &D_A2_ArrayToLookForNeighbour_In,
                                 const Array<int, 1> &I_A1_Area,
                                 Array<double, 1> &D_A1_NearestNeighbour_Out,
                                 int &I_Pos) const{
//  cout << "CFits::FindNearestNeighbour: D_A1_Dist = " << D_A1_Dist << endl;
  Array<int, 1> I_A1_IndicesInArea_Where(D_A2_ArrayToLookForNeighbour_In.rows());
  I_A1_IndicesInArea_Where = where(D_A2_ArrayToLookForNeighbour_In(Range::all(), 0) >= I_A1_Area(0) && D_A2_ArrayToLookForNeighbour_In(Range::all(), 0) <= I_A1_Area(1) && D_A2_ArrayToLookForNeighbour_In(Range::all(), 1) >= I_A1_Area(2) && D_A2_ArrayToLookForNeighbour_In(Range::all(), 1) <= I_A1_Area(3), 1, 0);
  #ifdef __DEBUG_FITS_FINDNEARESTNEIGHBOUR__
    cout << "CFits::FindNearestNeighbour: D_A1_ReferencePoint_In = " << D_A1_ReferencePoint_In << endl;
    cout << "CFits::FindNearestNeighbour: D_A2_ArrayToLookForNeighbour_In = " << D_A2_ArrayToLookForNeighbour_In << endl;
    cout << "CFits::FindNearestNeighbour: I_A1_Area = " << I_A1_Area << endl;
    cout << "CFits::FindNearestNeighbour: I_A1_IndicesInArea_Where = " << I_A1_IndicesInArea_Where << endl;
  #endif
  int I_NIndicesInArea = 0;
  Array<int, 1> *P_I_A1_IndicesInArea = this->GetIndex(I_A1_IndicesInArea_Where, I_NIndicesInArea);
  Array<double, 2> D_A2_ArrayToLookForNeighbour_InArea(I_NIndicesInArea, D_A2_ArrayToLookForNeighbour_In.cols());
  for (int i_ind=0; i_ind< I_NIndicesInArea; i_ind++){
    if (((*P_I_A1_IndicesInArea)(i_ind) < 0) || ((*P_I_A1_IndicesInArea)(i_ind) >= D_A2_ArrayToLookForNeighbour_In.rows())){
      cout << "CFits::FindNearestNeighbour: ERROR: ((*P_I_A1_IndicesInArea)(i_ind=" << i_ind << ")=" << (*P_I_A1_IndicesInArea)(i_ind) << " < 0) || ((*P_I_A1_IndicesInArea)(i_ind) >= D_A2_ArrayToLookForNeighbour_In.rows()=" << D_A2_ArrayToLookForNeighbour_In.rows() << ")" << endl;
      return false;
    }
    D_A2_ArrayToLookForNeighbour_InArea(i_ind, Range::all()) = D_A2_ArrayToLookForNeighbour_In((*P_I_A1_IndicesInArea)(i_ind), Range::all());
  }
  Array<double, 2> D_A2_Temp(D_A2_ArrayToLookForNeighbour_InArea.rows(), D_A2_ArrayToLookForNeighbour_InArea.cols());
  D_A2_Temp(Range::all(),0) = D_A2_ArrayToLookForNeighbour_InArea(Range::all(),0) - D_A1_ReferencePoint_In(0);
  D_A2_Temp(Range::all(),1) = D_A2_ArrayToLookForNeighbour_InArea(Range::all(),1) - D_A1_ReferencePoint_In(1);
  Array<double, 1> D_A1_Dist(D_A2_Temp.rows());
  D_A1_Dist = sqrt(sqr(D_A2_Temp(Range::all(),0)) + sqr(D_A2_Temp(Range::all(),1)));
  Array<int, 1> I_A1_Where(D_A1_Dist.rows());
  I_A1_Where = where(fabs(D_A1_Dist - min(D_A1_Dist)) < 0.00001, 1, 0);
  Array<int, 1> I_A1_WherePos(sum(I_A1_Where));
  int I_NInd;
  if (!this->GetIndex(I_A1_Where, I_NInd, I_A1_WherePos)){
    cout << "CFits::FindNearestNeighbour: ERROR: GetIndex(I_A1_Where) returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_FINDNEARESTNEIGHBOUR__
    cout << "CFits::FindNearestNeighbour: I_NInd = " << I_NInd << ": I_A1_WherePos = " << I_A1_WherePos << endl;
  #endif
  D_A1_NearestNeighbour_Out.resize(2);
  D_A1_NearestNeighbour_Out(0) = D_A2_ArrayToLookForNeighbour_In((*P_I_A1_IndicesInArea)(I_A1_WherePos(0)),0);
  D_A1_NearestNeighbour_Out(1) = D_A2_ArrayToLookForNeighbour_In((*P_I_A1_IndicesInArea)(I_A1_WherePos(0)),1);
  #ifdef __DEBUG_FITS_FINDNEARESTNEIGHBOUR__
    cout << "CFits::FindNearestNeighbour: D_A1_NearestNeighbour_Out = " << D_A1_NearestNeighbour_Out << endl;
  #endif
  I_Pos = (*P_I_A1_IndicesInArea)(I_A1_WherePos(0));
  #ifdef __DEBUG_FITS_FINDNEARESTNEIGHBOUR__
    cout << "CFits::FindNearestNeighbour: I_Pos = " << I_Pos << endl;
  #endif
 
  delete(P_I_A1_IndicesInArea);
  return true;
}

/**
 * find I_N nearest neighbours to D_A1_ReferencePoint_In(x,y) in D_A2_ArrayToLookForNeighbour_In and write coordinates to D_A2_NearestNeighbour_Out
 **/
bool CFits::FindNearestNeighbours(const Array<double, 1> &D_A1_ReferencePoint_In,
                                  const Array<double, 2> &D_A2_ArrayToLookForNeighbour_In,
                                  const int I_N,
                                  Array<double, 2> &D_A2_NearestNeighbours_Out,
                                  Array<int, 1> &I_A1_Pos) const{
  Array<int, 1> I_A1_Area(4);
  I_A1_Area(0) = 0;
  I_A1_Area(1) = this->NCols-1;
  I_A1_Area(2) = 0;
  I_A1_Area(3) = this->NRows-1;
  return this->FindNearestNeighbours(D_A1_ReferencePoint_In,
                                     D_A2_ArrayToLookForNeighbour_In,
                                     I_N,
                                     I_A1_Area,
                                     D_A2_NearestNeighbours_Out,
                                     I_A1_Pos);
}

/**
 * find I_N nearest neighbours to D_A1_ReferencePoint_In(x,y) in D_A2_ArrayToLookForNeighbour_In and write coordinates to D_A2_NearestNeighbour_Out
 **/
bool CFits::FindNearestNeighbours(const Array<double, 1> &D_A1_ReferencePoint_In,
                                  const Array<double, 2> &D_A2_ArrayToLookForNeighbour_In,
                                  const int I_N,
                                  const Array<int, 1> &D_A1_Area_In,
                                  Array<double, 2> &D_A2_NearestNeighbours_Out,
                                  Array<int, 1> &I_A1_Pos) const{
                           
//  cout << "CFits::FindNearestNeighbours: D_A2_ArrayToLookForNeighbour_In = " << D_A2_ArrayToLookForNeighbour_In << endl;
  cout << "CFits::FindNearestNeighbours: I_N = " << I_N << endl;
  D_A2_NearestNeighbours_Out.resize(I_N,2);
  I_A1_Pos.resize(I_N);
  I_A1_Pos = -1;
  Array<double, 2> D_A2_ArrayToLookForNeighbour_Temp(D_A2_ArrayToLookForNeighbour_In.rows(), D_A2_ArrayToLookForNeighbour_In.cols());
  Array<double, 2> D_A2_Temp(2,2);
  Array<double, 1> D_A1_NearestNeighbour_Out(2);
  D_A2_ArrayToLookForNeighbour_Temp = D_A2_ArrayToLookForNeighbour_In;
  int I_Pos, I_NInd;
  Array<int, 1> I_A1_Ind(D_A2_ArrayToLookForNeighbour_In.rows());
  Array<int, 1> *P_I_A1_Ind;
  for (int i=0; i<I_N; i++){
    #ifdef __DEBUG_FITS_FINDNEARESTNEIGHBOUR__
      cout << "CFits::FindNearestNeighbour: i=" << i << ": D_A1_ReferencePoint_In = " << D_A1_ReferencePoint_In << endl;
      cout << "CFits::FindNearestNeighbour: i=" << i << ": D_A2_ArrayToLookForNeighbour_Temp = " << D_A2_ArrayToLookForNeighbour_Temp << endl;
    #endif
    if (!this->FindNearestNeighbour(D_A1_ReferencePoint_In,
                                    D_A2_ArrayToLookForNeighbour_Temp,
                                    D_A1_NearestNeighbour_Out,
                                    I_Pos)){
      cout << "CFits::FindNearestNeighbours: ERROR: " << i << "th nearest neighbour not found" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_FINDNEARESTNEIGHBOUR__
      cout << "CFits::FindNearestNeighbours: i=" << i << ": I_Pos = " << I_Pos << endl;
      cout << "CFits::FindNearestNeighbours: i=" << i << ": D_A1_NearestNeighbour_Out = " << D_A1_NearestNeighbour_Out << endl;
    #endif
    //    I_A1_Ind.resize(D_A2_ArrayToLookForNeighbour_In.rows());
    I_A1_Ind = where((fabs(D_A2_ArrayToLookForNeighbour_In(Range::all(), 0) - D_A1_NearestNeighbour_Out(0)) < 1.) && (fabs(D_A2_ArrayToLookForNeighbour_In(Range::all(), 1) - D_A1_NearestNeighbour_Out(1)) < 1.), 1, 0);
    P_I_A1_Ind = this->GetIndex(I_A1_Ind, I_NInd);
//    cout << "CFits::FindNearestNeighbours: i=" << i << ": *P_I_A1_Ind = " << *P_I_A1_Ind << ", I_NInd = " << I_NInd << endl;
    I_A1_Pos(i) = (*P_I_A1_Ind)(0);
    #ifdef __DEBUG_FITS_FINDNEARESTNEIGHBOUR__
      cout << "CFits::FindNearestNeighbours: i=" << i << ": I_A1_Pos(i) = " << I_A1_Pos(i) << endl;
    #endif
    delete(P_I_A1_Ind);
    D_A2_NearestNeighbours_Out(i,Range::all()) = D_A1_NearestNeighbour_Out;

    ///remove element at position I_Pos from D_A2_ArrayToLookForNeighbour_Temp
    if (!this->Remove_Ith_RowFromArray(D_A2_ArrayToLookForNeighbour_Temp, I_Pos)){
      cout << "CFits::FindNearestNeighbours: ERROR: Remove_Ith_RowFromArray(D_A2_ArrayToLookForNeighbour_Temp=" << D_A2_ArrayToLookForNeighbour_Temp << ", I_Pos=" << I_Pos << ") returned FALSE" << endl;
      return false;
    }
/*    D_A2_Temp.resize(D_A2_ArrayToLookForNeighbour_Temp.rows()-1, 2);
    if (I_Pos > 0){
      D_A2_Temp(Range(0,I_Pos-1),Range::all()) = D_A2_ArrayToLookForNeighbour_Temp(Range(0,I_Pos-1),Range::all());
    }
    if (I_Pos < D_A2_ArrayToLookForNeighbour_Temp.rows()-1){
      D_A2_Temp(Range(I_Pos,D_A2_Temp.rows()-1),Range::all()) = D_A2_ArrayToLookForNeighbour_Temp(Range(I_Pos+1,D_A2_ArrayToLookForNeighbour_Temp.rows()-1),Range::all());
    }
    D_A2_ArrayToLookForNeighbour_Temp.resize(D_A2_Temp.rows(), D_A2_Temp.cols());
    D_A2_ArrayToLookForNeighbour_Temp = D_A2_Temp;*/
  }
  return true;
}

/**
 * Calculate Integral under line between two points
 * **/
bool CFits::IntegralUnderLine(const Array<double, 2> &D_A2_Coords_In,
                              double &D_Integral_Out) const{
  if (D_A2_Coords_In(0,0) == D_A2_Coords_In(1,0)){
    D_Integral_Out = 0.;
    return true;
  }
  Array<double, 1> D_A1_X(2);
  Array<double, 1> D_A1_Y(2);
  if (D_A2_Coords_In(0,0) > D_A2_Coords_In(1,0)){
    D_A1_X(0) = D_A2_Coords_In(1,0);
    D_A1_Y(0) = D_A2_Coords_In(1,1);
    D_A1_X(1) = D_A2_Coords_In(0,0);
    D_A1_Y(1) = D_A2_Coords_In(0,1);
  }
  else{
    D_A1_X(0) = D_A2_Coords_In(0,0);
    D_A1_Y(0) = D_A2_Coords_In(0,1);
    D_A1_X(1) = D_A2_Coords_In(1,0);
    D_A1_Y(1) = D_A2_Coords_In(1,1);
  }
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderLine: D_A1_X = " << D_A1_X << endl;
    cout << "CFits::IntegralUnderLine: D_A1_Y = " << D_A1_Y << endl;
  #endif
  if (fabs((D_A1_X(0) - D_A1_X(1)) / D_A1_X(0)) < 5.e-8){
    D_Integral_Out = 0.;
    return true;
  }
  double D_BinStart_X, D_BinEnd_X, D_Bin_Ya, D_Bin_Yb;
  Array<double, 1> *P_D_A1_YFit;
  D_Integral_Out = 0.;

  D_BinStart_X = D_A1_X(0);
  D_BinEnd_X = D_A1_X(1);

  ///fit straight line to coordinates
  if (fabs(D_A1_X(0) - D_A1_X(1)) < 0.000002){
    return true;
  }
  Array<double, 1> *P_D_A1_Coeffs = new Array<double, 1>(2);
  if (!this->PolyFit(D_A1_X,
                     D_A1_Y,
                     1,
                     P_D_A1_Coeffs)){
    cout << "CFits::IntegralUnderLine: fabs(D_A1_X(0)(=" << D_A1_X(0) << ") - D_A1_X(1)(=" << D_A1_X(1) << ")) = " << fabs(D_A1_X(0) - D_A1_X(1)) << endl;
    cout << "CFits::IntegralUnderLine: ERROR: PolyFit(" << D_A1_X << ", " << D_A1_Y << ", 1, " << *P_D_A1_Coeffs << ") returned false" << endl;
    delete(P_D_A1_Coeffs);
    return false;
  }
  D_A1_X.resize(3,2);
  D_A1_X(0) = D_BinStart_X;
  D_A1_X(1) = D_BinStart_X + ((D_BinEnd_X - D_BinStart_X)/2.);
  D_A1_X(2) = D_BinEnd_X;
  P_D_A1_YFit = this->Poly(D_A1_X, *P_D_A1_Coeffs);
  D_Bin_Ya = (*P_D_A1_YFit)(0);
  D_Bin_Yb = (*P_D_A1_YFit)(2);

  /// Calculate Integral
  D_Integral_Out += (D_BinEnd_X - D_BinStart_X) * (*P_D_A1_YFit)(1);

  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderLine: D_Integral_Out = " << D_Integral_Out << endl;
  #endif

  /// clean up
  delete(P_D_A1_YFit);
  delete(P_D_A1_Coeffs);
  return true;
}

/**
 * Calculate Integral in Triangle
 * **/
bool CFits::IntegralInTriangle(const Array<double, 2> &D_A2_Coords_In,
                               double &D_Integral_Out) const{
  if (D_A2_Coords_In.rows() != 3){
    cout << "CFits::IntegralInTriangle: ERROR: D_A2_Coords_In does not contain 3 coordinates" << endl;
    D_Integral_Out = 0.;
    return false;
  }
/**  cout << "CFits::IntegralInTriangle: D_A2_Coords_In = " << D_A2_Coords_In << endl;
  Array<int, 1> I_A1_Where(3);
  I_A1_Where = where(fabs(D_A2_Coords_In(Range::all(), 1) - max(D_A2_Coords_In(Range::all(), 1))) < 0.0000000001, 1, 0);
  cout << "CFits::IntegralInTriangle: I_A1_Where = " << I_A1_Where << endl;
  double D_Integral = 0.;
  D_Integral_Out = 0.;
  Array<double, 2> D_A2_Line(2,2);
  int I_PosA, I_PosB;
  for (int i=0; i<3; i++){
    if (i == 0){
      I_PosA = 0;
      I_PosB = 1;
    }
    else if (i == 1){
      I_PosA = 1;
      I_PosB = 2;
    }
    else{
      I_PosA = 2;
      I_PosB = 0;
    }
    D_A2_Line(0, Range::all()) = D_A2_Coords_In(I_PosA, Range::all());
    D_A2_Line(1, Range::all()) = D_A2_Coords_In(I_PosB, Range::all());
    if (!this->IntegralUnderLine(D_A2_Line, D_Integral)){
      cout << "IntegralInTriangle: ERROR: IntegralUnderLine(D_A2_Line = " << D_A2_Line << ") returned FALSE" << endl;
      D_Integral_Out = 0.;
      return false;
    }
    if (sum(I_A1_Where) == 1){
      if (I_A1_Where(I_PosA) == 1 || I_A1_Where(I_PosB) == 1)
        D_Integral_Out += D_Integral;
      else
        D_Integral_Out -= D_Integral;
    }
    else{
      if (I_A1_Where(I_PosA) == 1 & I_A1_Where(I_PosB) == 1)
        D_Integral_Out += D_Integral;
      else
        D_Integral_Out -= D_Integral;
    }
    cout << "CFits::IntegralInTriangle: i=" << i << ": D_Integral_Out = " << D_Integral_Out << endl;
  }**/
  D_Integral_Out = fabs((D_A2_Coords_In(0,0) * (D_A2_Coords_In(1,1) -
                         D_A2_Coords_In(2,1))
                       + D_A2_Coords_In(1,0) * (D_A2_Coords_In(2,1) -
                         D_A2_Coords_In(0,1))
                       + D_A2_Coords_In(2,0) * (D_A2_Coords_In(0,1) -
                         D_A2_Coords_In(1,1)))
                     /2.);
  return true;
}

/**
 * Calculate Integral within closed structure
 * D_A2_Coords_In(0,0) = x0
 * D_A2_Coords_In(0,1) = y0
 * D_A2_Coords_In(1,0) = x1
 * D_A2_Coords_In(1,1) = y1
 *           *
 *           *
 *           *
 * NOTE: Coordinates must go either in clockwise or counterclockwise direction!
 * **/
bool CFits::IntegralInClosedStructure(const Array<double, 2> &D_A2_Coords_In,
                                      double &D_Integral_Out) const{
  D_Integral_Out = 0.;
  double D_IntegralInTriangle = 0.;
  Array<double, 2> D_A2_Coords_Triangle(3,2);
  D_A2_Coords_Triangle(0,Range::all()) = D_A2_Coords_In(0,Range::all());
  for (int i_triag=0; i_triag < D_A2_Coords_In.rows()-2; i_triag++){
    D_A2_Coords_Triangle(1,Range::all()) = D_A2_Coords_In(i_triag+1, Range::all());
    D_A2_Coords_Triangle(2,Range::all()) = D_A2_Coords_In(i_triag+2, Range::all());
    if (!this->IntegralInTriangle(D_A2_Coords_Triangle, D_IntegralInTriangle)){
      cout << "CFits::IntegralInClosedStructure: ERROR: IntegralInTriangle(" << D_A2_Coords_Triangle << ") returned FALSE" << endl;
      D_Integral_Out = 0.;
      return false;
    }
    D_Integral_Out += D_IntegralInTriangle;
  }
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralInClosedStructure: D_Integral_Out = " << D_Integral_Out << endl;
  #endif
  return true;
}


/**
 * Calculate Integral under curve from D_A1_XInt(0) to D_A1_XInt(1)
 **/
bool CFits::IntegralUnderCurve(const Array<double, 1> &D_A1_XIn,
                               const Array<double, 1> &D_A1_YIn,
                               const Array<double, 1> &D_A1_XInt,
			       double &D_Integral_Out) const{
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "DFits::IntegralUnderCurve: D_A1_XIn = " << D_A1_XIn << endl;
    cout << "DFits::IntegralUnderCurve: D_A1_YIn = " << D_A1_YIn << endl;
    cout << "DFits::IntegralUnderCurve: D_A1_XInt = " << D_A1_XInt << endl;
  #endif
  if (D_A1_XIn.size() < 2){
    cout << "CFits::IntegralUnderCurve: ERROR: D_A1_XIn.size() < 2 => Returning FALSE" << endl;
    return false;
  }
  if (D_A1_YIn.size() < 2){
    cout << "CFits::IntegralUnderCurve: ERROR: D_A1_YIn.size() < 2 => Returning FALSE" << endl;
    return false;
  }
  if (D_A1_XIn.size() != D_A1_YIn.size()){
    cout << "CFits::IntegralUnderCurve: ERROR: D_A1_XIn.size() != D_A1_YIn.size() => Returning FALSE" << endl;
    return false;
  }
  if (D_A1_XInt.size() != 2){
    cout << "CFits::IntegralUnderCurve: ERROR: D_A1_XInt.size() != 2 => Returning FALSE" << endl;
    return false;
  }

/**  if (D_A1_XInt(0) < D_A1_XIn(0)){
    cout << "CFits::IntegralUnderCurve: WARNING: D_A1_XInt(0)(=" << D_A1_XInt(0) << ") < D_A1_XIn(0)(=" << D_A1_XIn(0) << ")" << endl;
    D_Integral_Out = 0.;
    return true;
  }
  if (D_A1_XInt(1) > D_A1_XIn(D_A1_XIn.size()-1)){
    cout << "CFits::IntegralUnderCurve: WARNING: D_A1_XInt(1)(=" << D_A1_XInt(1) << ") > D_A1_XIn(D_A1_XIn.size()-1=" << D_A1_XIn.size()-1 << ")(=" << D_A1_XIn(D_A1_XIn.size()-1) << ")" << endl;
    D_Integral_Out = 0.;
    return true;
  }**/
  if (D_A1_XInt(0) > D_A1_XIn(D_A1_XIn.size()-1)){
    cout << "CFits::IntegralUnderCurve: WARNING: D_A1_XInt(0)(=" << D_A1_XInt(0) << ") > D_A1_XIn(" << D_A1_XIn.size()-1 << ")(=" << D_A1_XIn(D_A1_XIn.size()-1) << ")" << endl;
    D_Integral_Out = 0.;
    return true;
  }
  if (D_A1_XInt(1) < D_A1_XIn(0)){
    cout << "CFits::IntegralUnderCurve: WARNING: D_A1_XInt(1)(=" << D_A1_XInt(1) << ") > D_A1_XIn(0)(=" << D_A1_XIn(0) << ")" << endl;
    D_Integral_Out = 0.;
    return true;
  }

  Array<double, 1> D_A1_XTemp(D_A1_XIn.size() + 2);
  D_A1_XTemp = 0.;
  int I_IndXIn = 0;
  int I_IndX = 1;
  while ((D_A1_XIn(I_IndXIn) < D_A1_XInt(0)) && (I_IndXIn < D_A1_XIn.size())){
    #ifdef __DEBUG_FITS_INTEGRAL__
      cout << "CFits::IntegralUnderCurve: D_A1_XIn(I_IndXIn=" << I_IndXIn << ") = " << D_A1_XIn(I_IndXIn) << " < D_A1_XInt(0) = " << D_A1_XInt(0) << endl;
    #endif
    I_IndXIn++;
  }
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: I_IndXIn = " << I_IndXIn << endl;
  #endif
  D_A1_XTemp(0) = D_A1_XInt(0);
  if ((I_IndXIn < 0) || (I_IndXIn >= D_A1_XIn.size())){
    cout << "CFits::IntegralUnderCurve: ERROR: (I_IndXIn=" << I_IndXIn << " < 0) || (I_IndXIn >= D_A1_XIn.size()=" << D_A1_XIn.size() << ")" << endl;
    return false;
  }
  while (D_A1_XIn(I_IndXIn) < D_A1_XInt(1)){
    #ifdef __DEBUG_FITS_INTEGRAL__
      cout << "CFits::IntegralUnderCurve: D_A1_XIn(I_IndXIn=" << I_IndXIn << ") = " << D_A1_XIn(I_IndXIn) << " < D_A1_XInt(1) = " << D_A1_XInt(1) << endl;
    #endif
    D_A1_XTemp(I_IndX) = D_A1_XIn(I_IndXIn);
    I_IndX++;
    I_IndXIn++;
    if (I_IndXIn >= D_A1_XIn.size()){
      break;
    }
  }
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: D_A1_XTemp set to " << D_A1_XTemp << endl;
  #endif
  D_A1_XTemp(I_IndX) = D_A1_XInt(1);
  Array<double, 1> D_A1_X(I_IndX+1);
  D_A1_X = D_A1_XTemp(Range(0, I_IndX));
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: D_A1_X set to " << D_A1_X << endl;
  #endif


/**  Array<int, 1> I_A1_Where(D_A1_XIn.size());
  I_A1_Where = where(D_A1_XIn <= D_A1_XInt(0), 1, 0);
  int I_NIndA;
  Array<int, 1> I_A1_IndA(1);
  if (!this->GetIndex(I_A1_Where, I_NIndA, I_A1_IndA)){
    D_Integral_Out = 0.;
    cout << "CFits::IntegralUnderCurve: WARNING: D_A1_Xin = " << D_A1_XIn << ", D_A1_XInt = " << D_A1_XInt << ": GetIndex() returned FALSE" << endl;
    return true;
  }
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << endl << endl << endl << endl << "CFits::IntegralUnderCurve: D_A1_XIn = " << D_A1_XIn << endl;
    cout << "CFits::IntegralUnderCurve: D_A1_XInt = " << D_A1_XInt << endl;
    cout << "CFits::IntegralUnderCurve: I_A1_IndA = " << I_A1_IndA << endl;
  #endif
  int I_Index0 = 0;
  int I_Index1 = 0;
  if (I_A1_IndA(I_A1_IndA.size()-1) == 0)
    I_Index0 = 0;
  else
    I_Index0 = I_A1_IndA(I_A1_IndA.size()-1);
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: I_Index0 = " << I_Index0 << endl;
  #endif

  I_A1_Where = where(D_A1_XIn > D_A1_XInt(1), 1, 0);
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: I_A1_Where = " << I_A1_Where << endl;
  #endif
  int I_NIndB = 0;
  Array<int, 1> I_A1_IndB(1);
  this->GetIndex(I_A1_Where, I_NIndB, I_A1_IndB);
//    D_Integral_Out = 0.;
/    cout << "CFits::IntegralUnderCurve: WARNING: 2. GetIndex(I_A1_Where=" << I_A1_Where << ") returned FALSE" << endl;
//    return true;
//  }
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: I_A1_IndB = " << I_A1_IndB << endl;
  #endif
  if (I_NIndB < 1)
    I_Index1 = D_A1_XIn(D_A1_XIn.size()-1);
  else
    I_Index1 = I_A1_IndB(0);
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: I_Index1 = " << I_Index1 << endl;
  #endif

  if (I_Index1 - I_Index0 < 1){
    D_Integral_Out = 0.;
    cout << "CFits::IntegralUnderCurve: WARNING: I_Index1(=" << I_Index1 << ") - I_Index0(=" << I_Index0 << ") < 1" << endl;
    return true;
  }

  int I_XSize = I_Index1 - I_Index0 + 1;
  if (I_NIndA == 0)
    I_XSize--;
  if (I_NIndB == 0)
    I_XSize--;

  Array<double, 1> D_A1_X(I_Index1 - I_Index0 + 1);
  D_A1_X = D_A1_XIn(Range(I_Index0, I_Index1));
//  D_A1_X(Range(1,I_A1_IndB.size())) = D_A1_XIn(Range(I_A1_IndA(I_A1_IndB(0)), I_A1_IndA(I_A1_IndB(I_A1_IndB.size()-1))));
//  D_A1_X(D_A1_X.size()-1) = D_A1_XInt(1);
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: D_A1_X set to " << D_A1_X << endl;
  #endif */
  Array<double, 1> D_A1_Y(D_A1_X.size());
  if (!this->InterPol(D_A1_YIn, D_A1_XIn, D_A1_X, D_A1_Y)){
    cout << "CFits::IntegralUnderCurve: ERROR: InterPol returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralUnderCurve: D_A1_X = " << D_A1_X << endl;
    cout << "CFits::IntegralUnderCurve: D_A1_Y = " << D_A1_Y << endl;
  #endif
//  return false;
  D_Integral_Out = 0.;
  double D_Integral = 0.;
  Array<double, 2> D_A2_Coords(2,2);
  for (int i=1; i<D_A1_X.size(); i++){
    D_A2_Coords(0,0) = D_A1_X(i-1);
    D_A2_Coords(1,0) = D_A1_X(i);
    D_A2_Coords(0,1) = D_A1_Y(i-1);
    D_A2_Coords(1,1) = D_A1_Y(i);
    if (!this->IntegralUnderLine(D_A2_Coords, D_Integral)){
      cout << "CFits::IntegralUnderCurve: ERROR: this->IntegralUnderLine(" << D_A2_Coords << ", " << D_Integral << ") returned FALSE" << endl;
      return false;
    }
    D_Integral_Out += D_Integral;
    #ifdef __DEBUG_FITS_INTEGRAL__
      cout << "CFits::IntegralUnderCurve: i=" << i << ": D_Integral_Out = " << D_Integral_Out << endl;
    #endif
  }
  return true;
}

/**
 * Integral-normalise a function
 **/
bool CFits::IntegralNormalise(const Array<double, 1> &D_A1_XIn,
                              const Array<double, 1> &D_A1_YIn,
			      Array<double, 1> &D_A1_YOut) const{
  if (D_A1_XIn.size() < 2){
    cout << "CFits::IntegralNormalise: ERROR: D_A1_XIn.size() < 2" << endl;
    return false;
  }
  if (D_A1_XIn.size() != D_A1_YIn.size()){
    cout << "CFits::IntegralNormalise: ERROR: D_A1_XIn.size() != D_A1_YIn.size()" << endl;
    return false;
  }
  D_A1_YOut.resize(D_A1_YIn.size());
  double D_Integral;
  Array<double, 1> D_A1_XInt(2);
  D_A1_XInt(0) = D_A1_XIn(0);
  D_A1_XInt(1) = D_A1_XIn(D_A1_XIn.size()-1);
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralNormalise: D_A1_XIn = " << D_A1_XIn << endl;
    cout << "CFits::IntegralNormalise: D_A1_YIn = " << D_A1_YIn << endl;
    cout << "CFits::IntegralNormalise: D_A1_XInt = " << D_A1_XInt << endl;
  #endif
  if (!this->IntegralUnderCurve(D_A1_XIn, D_A1_YIn, D_A1_XInt, D_Integral)){
    cout << "CFits::IntegralNormalise: ERROR: IntegralUnderCurve returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralNormalise: D_Integral = " << D_Integral << endl;
  #endif
  D_A1_YOut = D_A1_YIn / D_Integral;
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralNormalise: D_A1_YIn = " << D_A1_YIn << endl;
    cout << "CFits::IntegralNormalise: D_A1_YOut = " << D_A1_YOut << endl;
  #endif
  return true;
}


/**
 * Integral-normalise a function
 **/
bool CFits::IntegralNormalise(const Array<double, 1> &D_A1_XIn,
	                      Array<double, 1> &D_A1_YInOut) const{
  Array<double, 1> D_A1_YTemp(D_A1_YInOut.size());
  #ifdef __DEBUG_FITS_INTEGRAL__
    cout << "CFits::IntegralNormalise: D_A1_XIn = " << D_A1_XIn << endl;
    cout << "CFits::IntegralNormalise: D_A1_YInOut = " << D_A1_YInOut << endl;
  #endif
  if (!this->IntegralNormalise(D_A1_XIn, D_A1_YInOut, D_A1_YTemp)){
    cout << "CFits::IntegralNormalise: ERROR: IntegralNormalise returned FALSE" << endl;
    return false;
  }
  D_A1_YInOut = D_A1_YTemp;
  D_A1_YTemp.resize(0);
  return true;
}


/**
 * Sort 6 coordinates to create hexagon
 * **/
bool CFits::SortCoordinatesToCreateHexagon(const Array<double, 2> &D_A2_Coords_In,
                                           Array<double, 2> &D_A2_Coords_Out) const{
  if (D_A2_Coords_In.rows() != 6 || D_A2_Coords_In.cols() != 2){
    cout << "CFits::SortCoordinatesToCreateHexagon: ERROR: D_A2_Coords_In(=" << D_A2_Coords_In << ") does not have 6x2 format" << endl;
    return false;
  }
  cout << "CFits::SortCoordinatesToCreateHexagon: D_A2_Coords_In = " << D_A2_Coords_In << endl;
/**  double D_XMin = min(D_A2_Coords_In(Range::all(),0));
  Array<double, 2> D_A2_Coords_Left(D_A2_Coords_In.rows(), 2);
  D_A2_Coords_Left = D_A2_Coords_In;
  Array<int, 1> I_A1_Where(D_A2_Coords_In.rows());
  I_A1_Where = where(fabs(D_A2_Coords_In(Range::all(),1) - D_YMin) < 0.000001, 1, 0);
  Array<int, 1> I_A1_Index(1);
  int I_NInd;
  if (!this->GetIndex(I_A1_Where, I_NInd, I_A1_Index)){
    cout << "CFits::SortCoordinatesToCreateHexagon: ERROR: GetIndex(I_A1_Where) returned FALSE" << endl;
    return false;
  }
  cout << "CFits::SortCoordinatesToCreateHexagon: I_A1_Index(minY) = " << I_A1_Index << endl;
  D_A2_Coords_Out.resize(D_A2_Coords_In.rows(),2);
  D_A2_Coords_Out = 0.;
  D_A2_Coords_Out(0,Range::all()) = D_A2_Coords_In(I_A1_Index(0),Range::all());
  cout << "CFits::SortCoordinatesToCreateHexagon: D_A2_Coords_Out = " << D_A2_Coords_Out << endl;
  if (!this->Remove_Ith_RowFromArray(D_A2_Coords_Left, I_A1_Index(0))){
    cout << "CFits::SortCoordinatesToCreateHexagon: ERROR: Remove_Ith_RowFromArray(D_A2_Coords_Left=" << D_A2_Coords_Left << ", " << I_A1_Index(0) << ") returned FALSE" << endl;
    return false;
  }
  cout << "CFits::SortCoordinatesToCreateHexagon: D_A2_Coords_Left = " << D_A2_Coords_Left << endl;

  Array<double, 1> D_A1_Next(2);
  Array<double, 1> D_A1_Ref(2);
  int I_Pos=0;

  for (int i=1; i<D_A2_Coords_In.rows()-1; i++){
    D_A1_Ref = D_A2_Coords_Out(i-1, Range::all());
    if (!this->FindNearestNeighbour(D_A1_Ref,
                                    D_A2_Coords_Left,
                                    D_A1_Next,
                                    I_Pos)){
      cout << "CFits::SortCoordinatesToCreateHexagon: i=" << i << ": ERROR: FindNearestNeighbour returned FALSE" << endl;
      return false;
    }
    cout << "CFits::SortCoordinatesToCreateHexagon: i=" << i << ": D_A1_Next = " << D_A1_Next << endl;
    D_A2_Coords_Out(i,Range::all()) = D_A1_Next;

    if (!this->Remove_Ith_RowFromArray(D_A2_Coords_Left, I_Pos)){
      cout << "CFits::SortCoordinatesToCreateHexagon: i=" << i << ": ERROR: Remove_Ith_RowFromArray(D_A2_Coords_Left=" << D_A2_Coords_Left << ", I_Row=" << I_Pos << ") returned FALSE" << endl;
      return false;
    }
    cout << "CFits::SortCoordinatesToCreateHexagon: D_A2_Coords_Left set to " << D_A2_Coords_Left << endl;
  }

  D_A2_Coords_Out(D_A2_Coords_Out.rows()-1, Range::all()) = D_A2_Coords_Left(0, Range::all());
  cout << "CFits::SortCoordinatesToCreateHexagon: D_A2_Coords_Out set to " << D_A2_Coords_Out << endl;
  return true;**/
  return this->SortCoordinatesCounterClockWise(D_A2_Coords_In, D_A2_Coords_Out);
}

bool CFits::SortCoordinatesCounterClockWise(const Array<double, 2> &D_A2_Corners_In,
                                            Array<double, 2> &D_A2_Corners_Out) const{
  if (D_A2_Corners_In.rows() < 3 || D_A2_Corners_In.cols() != 2){
    cout << "CFits::SortCoordinatesCounterClockWise: ERROR: D_A2_Corners_In(=" << D_A2_Corners_In << ") does not contain 2 columns or at least 2 rows" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_SORTCOORDSCCW__
    cout << "CFits::SortCoordinatesCounterClockWise: D_A2_Corners_In = " << D_A2_Corners_In << endl;
  #endif
  D_A2_Corners_Out.resize(D_A2_Corners_In.rows(),2);

  Array<double, 1> D_A1_Pix(2);

  /// Start with lower most left corner
  Array<int, 1> I_A1_Where_X(D_A2_Corners_In.rows());
  Array<int, 1> I_A1_Where_Y(D_A2_Corners_In.rows());
  Array<int, 1> I_A1_Ind_X(1);
  Array<int, 1> I_A1_Ind_Y(1);
  Array<double, 1> D_A1_Out(1);
  Array<double, 2> D_A2_Out(2,2);
  int I_NInd, I_Run;
  int I_NCorners_New = 0;
  int I_RightMostCorner = 0;
  int I_LeftMostCorner = 0;
  I_Run = 0;
  Array<double, 2> D_A2_Corners(D_A2_Corners_In.rows(),2);
  D_A2_Corners = 0.;
  Array<double, 2> D_A2_CornersTemp(D_A2_Corners_In.rows(),2);
  D_A2_CornersTemp = D_A2_Corners_In;

  I_A1_Where_X = where(fabs(D_A2_Corners_In(Range::all(),0) - min(D_A2_Corners_In(Range::all(), 0))) < 0.000000001, 1, 0);
  if (!this->GetIndex(I_A1_Where_X, I_NInd, I_A1_Ind_X)){
    cout << "CFits::SortCoordinatesCounterClockWise: ERROR: GetIndex(I_A1_Where_X=" << I_A1_Where_X << ") returned FALSE" << endl;
    return false;
  }
  if (I_NInd == 1){
    I_LeftMostCorner = I_A1_Ind_X(0);
    D_A1_Pix = D_A2_Corners_In(I_A1_Ind_X(0), Range::all());
    #ifdef __DEBUG_FITS_SORTCOORDSCCW__
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == 1: D_A1_Pix set to " << D_A1_Pix << endl;
    #endif
    if (!this->Remove_Ith_RowFromArray(D_A2_CornersTemp, I_A1_Ind_X(0))){
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == 1: ERROR: 1. Remove_Ith_ElementFromArray(D_A2_CornersTemp=" << D_A2_CornersTemp << ", " << I_A1_Ind_X(0) << ") returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_SORTCOORDSCCW__
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == 1: D_A2_CornersTemp set to " << D_A2_CornersTemp << endl;
    #endif
  }
  else{
    if (!this->GetSubArrCopy(D_A2_Corners_In(Range::all(), 1), I_A1_Ind_X, D_A1_Out)){
      cout << "CFits::SortCoordinatesCounterClockWise:: I_NInd != 1: ERROR: GetSubArrCopy(" << D_A2_Corners_In(Range::all(), 1) << ", " << I_A1_Ind_X << ") returned FALSE" << endl;
      return false;
    }
    I_A1_Where_Y.resize(I_NInd);
    I_A1_Where_Y = where(fabs(D_A1_Out - min(D_A1_Out)) < 0.00000001, 1, 0);
    if (!this->GetIndex(I_A1_Where_Y, I_NInd, I_A1_Ind_Y)){
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd != 1: ERROR: GetIndex(I_A1_Where_Y=" << I_A1_Where_Y << ") returned FALSE" << endl;
      return false;
    }
    I_LeftMostCorner = I_A1_Ind_X(I_A1_Ind_Y(0));
    D_A1_Pix = D_A2_Corners_In(I_A1_Ind_X(I_A1_Ind_Y(0)), Range::all());
    #ifdef __DEBUG_FITS_SORTCOORDSCCW__
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd != 1: D_A1_Pix set to " << D_A1_Pix << endl;
    #endif
    if (!this->Remove_Ith_RowFromArray(D_A2_CornersTemp, I_A1_Ind_X(I_A1_Ind_Y(0)))){
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd != 1: ERROR: 2. Remove_Ith_ElementFromArray(D_A2_CornersTemp=" << D_A2_CornersTemp << ", " << I_A1_Ind_X(I_A1_Ind_Y(0)) << ") returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_SORTCOORDSCCW__
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd != 1: D_A2_CornersTemp set to " << D_A2_CornersTemp << endl;
    #endif
  }
  D_A2_Corners(I_NCorners_New, Range::all()) = D_A1_Pix;
  I_NCorners_New++;

  /// Find rightmost corner
  I_A1_Where_X = where(fabs(D_A2_Corners_In(Range::all(),0) - max(D_A2_Corners_In(Range::all(), 0))) < 0.000000001, 1, 0);
  if (!this->GetIndex(I_A1_Where_X, I_NInd, I_A1_Ind_X)){
    cout << "CFits::SortCoordinatesCounterClockWise: ERROR: GetIndex(I_A1_Where_X=" << I_A1_Where_X << ") returned FALSE" << endl;
    return false;
  }
  if (I_NInd == 1){
    I_RightMostCorner = I_A1_Ind_X(0);
    #ifdef __DEBUG_FITS_SORTCOORDSCCW__
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == 1: I_RightMostCorner set to " << I_RightMostCorner << ": D_A2_Corners_In(I_RightMostCorner, *) = " << D_A2_Corners_In(I_RightMostCorner, Range::all()) << endl;
    #endif
  }
  else{
    if (!this->GetSubArrCopy(D_A2_Corners_In(Range::all(), 1), I_A1_Ind_X, D_A1_Out)){
      cout << "CFits::SortCoordinatesCounterClockWise:: I_NInd != 1: ERROR: GetSubArrCopy(" << D_A2_Corners_In(Range::all(), 1) << ", " << I_A1_Ind_X << ") returned FALSE" << endl;
      return false;
    }
    I_A1_Where_Y.resize(I_NInd);
    I_A1_Where_Y = where(fabs(D_A1_Out - min(D_A1_Out)) < 0.00000001, 1, 0);
    if (!this->GetIndex(I_A1_Where_Y, I_NInd, I_A1_Ind_Y)){
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd != 1: ERROR: GetIndex(I_A1_Where_Y=" << I_A1_Where_Y << ") returned FALSE" << endl;
      return false;
    }
    I_RightMostCorner = I_A1_Ind_X(I_A1_Ind_Y(0));
    #ifdef __DEBUG_FITS_SORTCOORDSCCW__
      cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == 1: I_RightMostCorner set to " << I_RightMostCorner << ": D_A2_Corners_In(I_RightMostCorner, *) = " << D_A2_Corners_In(I_RightMostCorner, Range::all()) << endl;
    #endif
  }

  bool B_GoRight = true;
  bool B_GoLeft = false;

//  for (int i_corner=0; i_corner < D_A2_CornersTemp.rows()-1; i_corner++){
  do {
    I_Run++;
    if (I_Run > 3 * D_A2_Corners_In.rows()){
      cout << "CFits::SortCoordinatesCounterClockWise: ERROR: I_Run(=" << I_Run << ") > 3 * D_A2_Corners_In.rows() = " << D_A2_Corners_In.rows() << " => Returning FALSE" << endl;
      return false;
    }
    I_A1_Where_X.resize(D_A2_CornersTemp.rows());
    if (B_GoRight){
      /// Take all points with x value >= last x value AND y value <= y of rightmost corner
      I_A1_Where_X = where((D_A2_CornersTemp(Range::all(),0) >= D_A2_Corners(I_NCorners_New-1,0))
                           && (D_A2_CornersTemp(Range::all(), 1) <= D_A2_Corners_In(I_RightMostCorner, 1)), 1, 0);
      #ifdef __DEBUG_FITS_SORTCOORDSCCW__
        cout << "CFits::SortCoordinatesCounterClockWise: B_GoRight: I_A1_Where_X set to " << I_A1_Where_X << endl;
      #endif
    }
    else{
      /// Take all points with x value <= last x value AND y value = y of LEFTmost corner
      I_A1_Where_X = where((D_A2_CornersTemp(Range::all(),0) <= D_A2_Corners(I_NCorners_New-1,0))
                           && (D_A2_CornersTemp(Range::all(), 1) >= D_A2_Corners_In(I_LeftMostCorner, 1)), 1, 0);
      #ifdef __DEBUG_FITS_SORTCOORDSCCW__
        cout << "CFits::SortCoordinatesCounterClockWise: B_GoLeft: I_A1_Where_X set to " << I_A1_Where_X << endl;
      #endif
    }
    if (sum(I_A1_Where_X) > 0){
      if (!this->GetIndex(I_A1_Where_X, I_NInd, I_A1_Ind_X)){
        cout << "CFits::SortCoordinatesCounterClockWise: ERROR: GetIndex(I_A1_Where_X=" << I_A1_Where_X << ") returned FALSE" << endl;
        return false;
      }
      #ifdef __DEBUG_FITS_SORTCOORDSCCW__
        cout << "CFits::SortCoordinatesCounterClockWise: I_A1_Ind_X set to " << I_A1_Ind_X << endl;
      #endif
      if (I_NInd == 1){
        D_A1_Pix = D_A2_CornersTemp(I_A1_Ind_X(0), Range::all());
        #ifdef __DEBUG_FITS_SORTCOORDSCCW__
          cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == 1: D_A1_Pix set to " << D_A1_Pix << endl;
        #endif
        if (!this->Remove_Ith_RowFromArray(D_A2_CornersTemp, I_A1_Ind_X(0))){
          cout << "CFits::SortCoordinatesCounterClockWise: ERROR: 3. Remove_Ith_ElementFromArray(D_A2_CornersTemp = " << D_A2_CornersTemp << ", " << I_A1_Ind_X(0) << ") returned FALSE" << endl;
          return false;
        }
        #ifdef __DEBUG_FITS_SORTCOORDSCCW__
          cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == 1: D_A2_CornersTemp set to " << D_A2_CornersTemp << endl;
          cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == 1: D_A2_Corners set to " << D_A2_Corners << endl;
        #endif
        D_A2_Corners(I_NCorners_New, Range::all()) = D_A1_Pix;
        I_NCorners_New++;
      }
      else{
        if (!this->GetSubArrCopy(D_A2_CornersTemp(Range::all(), 0), I_A1_Ind_X, D_A1_Out)){
          cout << "CFits::SortCoordinatesCounterClockWise:: ERROR: GetSubArrCopy(" << D_A2_CornersTemp(Range::all(), 0) << ", " << I_A1_Ind_X << ") returned FALSE" << endl;
          return false;
        }
        #ifdef __DEBUG_FITS_SORTCOORDSCCW__
          cout << "CFits::SortCoordinatesCounterClockWise: I_NInd == " << I_NInd << ": D_A1_Out set to " << D_A1_Out << endl;
        #endif
        I_A1_Where_Y.resize(I_A1_Ind_X.size());
        if (B_GoRight){
          I_A1_Where_Y = where(fabs(D_A1_Out - min(D_A1_Out)) < 0.000000001, 1, 0);
          #ifdef __DEBUG_FITS_SORTCOORDSCCW__
            cout << "CFits::SortCoordinatesCounterClockWise: B_GoRight: I_A1_Where_Y set to " << I_A1_Where_Y << endl;
          #endif
        }
        else{
          I_A1_Where_Y = where(fabs(D_A1_Out - max(D_A1_Out)) < 0.000000001, 1, 0);
          #ifdef __DEBUG_FITS_SORTCOORDSCCW__
            cout << "CFits::SortCoordinatesCounterClockWise: B_GoLeft: I_A1_Where_Y set to " << I_A1_Where_Y << endl;
          #endif
        }
        if (sum(I_A1_Where_Y) > 0){
          if (!this->GetIndex(I_A1_Where_Y, I_NInd, I_A1_Ind_Y)){
            cout << "CFits::SortCoordinatesCounterClockWise: ERROR: GetIndex(I_A1_Where_Y=" << I_A1_Where_Y << ") returned FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_SORTCOORDSCCW__
            cout << "CFits::SortCoordinatesCounterClockWise: sum(I_A1_Where_Y)=" << sum(I_A1_Where_Y) << ">0: I_A1_Ind_Y set to " << I_A1_Ind_Y << endl;
          #endif
          D_A1_Pix = D_A2_CornersTemp(I_A1_Ind_X(I_A1_Ind_Y(0)), Range::all());
          #ifdef __DEBUG_FITS_SORTCOORDSCCW__
            cout << "CFits::SortCoordinatesCounterClockWise: sum(I_A1_Where_Y)=" << sum(I_A1_Where_Y) << ">0: D_A1_Pix set to " << D_A1_Pix << endl;
          #endif
          if (!this->Remove_Ith_RowFromArray(D_A2_CornersTemp, I_A1_Ind_X(I_A1_Ind_Y(0)))){
            cout << "CFits::SortCoordinatesCounterClockWise: ERROR: 3. Remove_Ith_ElementFromArray(D_A2_CornersTemp = " << D_A2_CornersTemp << ", " << I_A1_Ind_X(I_A1_Ind_Y(0)) << ") returned FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_SORTCOORDSCCW__
            cout << "CFits::SortCoordinatesCounterClockWise: sum(I_A1_Where_Y)=" << sum(I_A1_Where_Y) << ">0: D_A2_CornersTemp set to " << D_A2_CornersTemp << endl;
          #endif
          D_A2_Corners(I_NCorners_New, Range::all()) = D_A1_Pix;
          I_NCorners_New++;
          #ifdef __DEBUG_FITS_SORTCOORDSCCW__
            cout << "CFits::SortCoordinatesCounterClockWise: sum(I_A1_Where_Y)=" << sum(I_A1_Where_Y) << ">0: D_A2_Corners set to " << D_A2_Corners << endl;
          #endif
        }
        else{
          if (B_GoRight){
            #ifdef __DEBUG_FITS_SORTCOORDSCCW__
              cout << "CFits::SortCoordinatesCounterClockWise: sum(I_A1_Where_Y)==0: B_GoRight: B_GoRight set to FALSE, B_GoLeft set to TRUE" << endl;
            #endif
            B_GoRight = false;
            B_GoLeft = true;
          }
          else{
            #ifdef __DEBUG_FITS_SORTCOORDSCCW__
              cout << "CFits::SortCoordinatesCounterClockWise: sum(I_A1_Where_Y)==0: B_GoLeft: B_GoRight set to TRUE, B_GoLeft set to FALSE" << endl;
            #endif
            B_GoRight = true;
            B_GoLeft = false;
          }
        }
      }
    }
    else{
      if (B_GoRight){
        #ifdef __DEBUG_FITS_SORTCOORDSCCW__
          cout << "CFits::SortCoordinatesCounterClockWise: sum(I_A1_Where_X)==0: B_GoRight: B_GoRight set to FALSE, B_GoLeft set to TRUE" << endl;
        #endif
        B_GoRight = false;
        B_GoLeft = true;
      }
      else{
        #ifdef __DEBUG_FITS_SORTCOORDSCCW__
          cout << "CFits::SortCoordinatesCounterClockWise: sum(I_A1_Where_X)==0: B_GoRight: B_GoRight set to TRUE, B_GoLeft set to FALSE" << endl;
        #endif
        B_GoRight = true;
        B_GoLeft = false;
      }
/**      I_A1_Where_X = where(D_A2_CornersTemp(Range::all(),0) < D_A2_Corners(I_NCorners_New-1,0), 1, 0);
      if (sum(I_A1_Where_X) > 0){
        if (!this->GetIndex(I_A1_Where_X, I_NInd, I_A1_Ind_X)){
          cout << "CFits::SortCoordinatesCounterClockWise: ERROR: GetIndex(I_A1_Where_X=" << I_A1_Where_X << ") returned FALSE" << endl;
          return false;
        }
        if (!this->GetSubArrCopy(D_A2_CornersTemp, I_A1_Ind_X, 0, D_A2_Out)){
          cout << "CFits::SortCoordinatesCounterClockWise:: ERROR: GetSubArrCopy(" << D_A2_CornersTemp << ", " << I_A1_Ind_X << ", 0) returned FALSE" << endl;
          return false;
        }
        I_A1_Where_Y.resize(I_A1_Ind_X.size());
        I_A1_Where_Y = where(fabs(D_A2_Out(Range::all(), 1) - max(D_A2_Out(Range::all(), 1))) < 0.000000001, 1, 0);
        if (!this->GetIndex(I_A1_Where_Y, I_NInd, I_A1_Ind_Y)){
          cout << "CFits::SortCoordinatesCounterClockWise: ERROR: GetIndex(I_A1_Where_Y=" << I_A1_Where_Y << ") returned FALSE" << endl;
          return false;
        }
        D_A1_Pix = D_A2_CornersTemp(I_A1_Ind_X(I_A1_Ind_Y(0)), Range::all());
        if (!this->Remove_Ith_RowFromArray(D_A2_CornersTemp, I_A1_Ind_X(I_A1_Ind_Y(0)))){
          cout << "CFits::SortCoordinatesCounterClockWise: ERROR: 4. Remove_Ith_ElementFromArray(D_A2_CornersTemp=" << D_A2_CornersTemp << ", " << I_A1_Ind_X(I_A1_Ind_Y(0)) << ") returned FALSE" << endl;
          return false;
        }
      }
      else{
        cout << "CFits::SortCoordinatesCounterClockWise: ERROR: No next corner found" << endl;
        return false;
      }**/
    }

    #ifdef __DEBUG_FITS_SORTCOORDSCCW__
      cout << "CFits::SortCoordinatesCounterClockWise: end while loop: D_A2_Corners_In = " << D_A2_Corners_In << endl;
      cout << "CFits::SortCoordinatesCounterClockWise: end while loop: D_A2_Corners = " << D_A2_Corners << endl;
      cout << "CFits::SortCoordinatesCounterClockWise: end while loop: D_A2_CornersTemp = " << D_A2_CornersTemp << endl;
    #endif
  } while (D_A2_CornersTemp.rows() > 1);
  #ifdef __DEBUG_FITS_SORTCOORDSCCW__
    cout << "CFits::SortCoordinatesCounterClockWise: I_NCorners_New = " << I_NCorners_New << endl;
  #endif
  if (I_NCorners_New < D_A2_Corners.rows())
    D_A2_Corners(I_NCorners_New, Range::all()) = D_A2_CornersTemp(0, Range::all());
  #ifdef __DEBUG_FITS_SORTCOORDSCCW__
    cout << "CFits::SortCoordinatesCounterClockWise: D_A2_Corners set to " << D_A2_Corners << endl;
  #endif

  D_A2_Corners_Out = D_A2_Corners;
  return true;
}

bool CFits::Remove_SubArrayFromArray(Array<int, 1> &A1_Array_InOut, const Array<int, 1> &A1_SubArray) const{
  Array<int, 1> A1_Array_Out(A1_Array_InOut.size());
  int I_NElements = 0;
  bool B_InSubArray = false;
  for (int i_orig=0; i_orig<A1_Array_InOut.size(); i_orig++){
    B_InSubArray = false;
    for (int i_sub=0; i_sub<A1_SubArray.size(); i_sub++){
      if (A1_Array_InOut(i_orig) == A1_SubArray(i_sub))
        B_InSubArray = true;
    }
    if (!B_InSubArray){
      A1_Array_Out(I_NElements) = A1_Array_InOut(i_orig);
      I_NElements++;
    }
  }
  A1_Array_InOut.resize(I_NElements);
  A1_Array_InOut = A1_Array_Out(Range(0, I_NElements-1));
  return true;
}

bool CFits::Remove_ElementsFromArray(Array<int, 1> &I_A1_InOut, const Array<int, 1> &I_A1_ElementIndicesToRemove_In) const{
  if (I_A1_ElementIndicesToRemove_In.size() >= I_A1_InOut.size()){
    cout << "CString::RemoveElementFromArray: ERROR: I_A1_ElementsToRemove_In.size()=" << I_A1_ElementIndicesToRemove_In.size() << " >= I_A1_InOut.size()=" << I_A1_InOut.size() << endl;
    return false;
  }
  Array<int, 1> I_A1_Temp(I_A1_InOut.size()-I_A1_ElementIndicesToRemove_In.size());
  int I_El = 0;
  bool B_Found = false;
  for (int i_el=0; i_el<I_A1_InOut.size(); i_el++){
    B_Found = false;
    for (int i_elrem=0; i_elrem<I_A1_ElementIndicesToRemove_In.size(); i_elrem++){
      if (i_el == I_A1_ElementIndicesToRemove_In(i_elrem)){
        B_Found = true;
      }
    }
    if (!B_Found){
      I_A1_Temp(I_El) = I_A1_InOut(i_el);
      I_El++;
    }
  }
  I_A1_InOut.resize(I_A1_Temp.size());
  I_A1_InOut = I_A1_Temp;
  return true;
}

bool CFits::Remove_ElementsFromArray(Array<double, 1> &D_A1_InOut, const Array<int, 1> &I_A1_ElementIndicesToRemove_In) const{
  if (I_A1_ElementIndicesToRemove_In.size() >= D_A1_InOut.size()){
    cout << "CString::RemoveElementFromArray: ERROR: I_A1_ElementsToRemove_In.size()=" << I_A1_ElementIndicesToRemove_In.size() << " >= D_A1_InOut.size()=" << D_A1_InOut.size() << endl;
    return false;
  }
  Array<double, 1> D_A1_Temp(D_A1_InOut.size()-I_A1_ElementIndicesToRemove_In.size());
  int I_El = 0;
  bool B_Found = false;
  for (int i_el=0; i_el<D_A1_InOut.size(); i_el++){
    B_Found = false;
    for (int i_elrem=0; i_elrem<I_A1_ElementIndicesToRemove_In.size(); i_elrem++){
      if (i_el == I_A1_ElementIndicesToRemove_In(i_elrem)){
        B_Found = true;
      }
    }
    if (!B_Found){
      D_A1_Temp(I_El) = D_A1_InOut(i_el);
      I_El++;
    }
  }
  D_A1_InOut.resize(D_A1_Temp.size());
  D_A1_InOut = D_A1_Temp;
  return true;
}

bool CFits::Remove_Ith_ElementFromArray(Array<double, 1> &D_A1_Array_InOut,
int I_Pos_In) const{
  if (I_Pos_In < 0 || I_Pos_In >= D_A1_Array_InOut.size())
    return false;
  Array<double, 1> D_A1_Temp(D_A1_Array_InOut.size()-1);
  if (I_Pos_In > 0){
    D_A1_Temp(Range(0,I_Pos_In-1)) = D_A1_Array_InOut(Range(0,I_Pos_In-1));
  }
  if (I_Pos_In < D_A1_Array_InOut.size()-1){
    D_A1_Temp(Range(I_Pos_In, D_A1_Temp.size()-1)) = D_A1_Array_InOut(Range(I_Pos_In+1, D_A1_Array_InOut.size()-1));
  }
  D_A1_Array_InOut.resize(D_A1_Temp.size());
  D_A1_Array_InOut = D_A1_Temp;
  return true;
}

bool CFits::Remove_Ith_ElementFromArray(Array<int, 1> &I_A1_Array_InOut,
int I_Pos_In) const{
  if (I_Pos_In < 0 || I_Pos_In >= I_A1_Array_InOut.size())
    return false;
  Array<int, 1> I_A1_Temp(I_A1_Array_InOut.size()-1);
  if (I_Pos_In > 0){
    I_A1_Temp(Range(0,I_Pos_In-1)) = I_A1_Array_InOut(Range(0,I_Pos_In-1));
  }
  if (I_Pos_In < I_A1_Array_InOut.size()-1){
    I_A1_Temp(Range(I_Pos_In, I_A1_Temp.size()-1)) = I_A1_Array_InOut(Range(I_Pos_In+1, I_A1_Array_InOut.size()-1));
  }
  I_A1_Array_InOut.resize(I_A1_Temp.size());
  I_A1_Array_InOut = I_A1_Temp;
  return true;
}

bool CFits::Remove_Ith_RowFromArray(Array<double, 2> &D_A2_Array_InOut,
int I_Row_In) const{
  if (I_Row_In < 0 || I_Row_In >= D_A2_Array_InOut.rows())
    return false;
  Array<double, 2> D_A2_Temp(D_A2_Array_InOut.rows()-1,D_A2_Array_InOut.cols());
  if (I_Row_In > 0){
    D_A2_Temp(Range(0,I_Row_In-1), Range::all()) = D_A2_Array_InOut(Range(0,I_Row_In-1), Range::all());
  }
  if (I_Row_In < D_A2_Array_InOut.rows()-1){
    D_A2_Temp(Range(I_Row_In, D_A2_Temp.rows()-1), Range::all()) = D_A2_Array_InOut(Range(I_Row_In+1, D_A2_Array_InOut.rows()-1), Range::all());
  }
  D_A2_Array_InOut.resize(D_A2_Temp.rows(), D_A2_Temp.cols());
  D_A2_Array_InOut = D_A2_Temp;
  return true;

}

bool CFits::Remove_Ith_RowFromArray(Array<int, 2> &I_A2_Array_InOut,
int I_Row_In) const{
  if (I_Row_In < 0 || I_Row_In >= I_A2_Array_InOut.rows())
    return false;
  Array<int, 2> I_A2_Temp(I_A2_Array_InOut.rows()-1,I_A2_Array_InOut.cols());
  if (I_Row_In > 0){
    I_A2_Temp(Range(0,I_Row_In-1), Range::all()) = I_A2_Array_InOut(Range(0,I_Row_In-1), Range::all());
  }
  if (I_Row_In < I_A2_Array_InOut.rows()-1){
    I_A2_Temp(Range(I_Row_In, I_A2_Temp.rows()-1), Range::all()) = I_A2_Array_InOut(Range(I_Row_In+1, I_A2_Array_InOut.rows()-1), Range::all());
  }
  I_A2_Array_InOut.resize(I_A2_Temp.rows(), I_A2_Temp.cols());
  I_A2_Array_InOut = I_A2_Temp;
  return true;

}

/**
 * Returns distance between two points in 2D coordinate system
 * **/
double CFits::Distance(const Array<double, 1> &D_A1_PointA_In,
                       const Array<double, 1> &D_A1_PointB_In) const{
  double D_SumSqr = 0;
  for (int i=0; i<D_A1_PointA_In.size(); i++)
    D_SumSqr += pow2(D_A1_PointA_In(i) - D_A1_PointB_In(i));
  return sqrt(D_SumSqr);
}

/**
 * Calculate end coordinate which extends the line from D_A1_StartPos_In through
 * D_A1_ThroughPos_In to length D_Length_In
 * **/
bool CFits::ExtendLineToLength(const Array<double, 1> &D_A1_StartPos_In,
                               const Array<double, 1> &D_A1_ThroughPos_In,
                               const double D_Length_In,
                               Array<double, 1> &D_A1_EndPos_Out) const{
  if ((D_A1_StartPos_In.size() != 2) || (D_A1_ThroughPos_In.size() != 2))
    return false;
  double D_Length = this->Distance(D_A1_StartPos_In, D_A1_ThroughPos_In);
  double D_Ratio = D_Length_In / D_Length;
  Array<double, 1> D_A1_ThroughPos_RelativeToStart(2);
  D_A1_ThroughPos_RelativeToStart = D_A1_ThroughPos_In - D_A1_StartPos_In;
  D_A1_EndPos_Out = D_A1_ThroughPos_RelativeToStart * D_Ratio;
  D_A1_EndPos_Out = D_A1_EndPos_Out + D_A1_StartPos_In;
  return true;
}

/**
 * Returns TRUE if point D_A1_PixCoords_In is in triangular area defined by
 * D_A2_Triag_In((x0,y0),(x1,y1),(x2,y2))
 * **/
bool CFits::PixelIsInTriangle(const Array<double, 1> &D_A1_PixCoords_In,
                              const Array<double, 2> &D_A2_Triag_In) const{
  if (D_A2_Triag_In.rows() != 3){
    cout << "CFits::PixelIsInTriangle: ERROR: D_A2_Triag_In does not contain 3 coordinates" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_PIXELISINTRIANGLE__
    cout << "CFits::PixelIsInTriangle: D_A1_PixCoords_In = " << D_A1_PixCoords_In <<  endl;
    cout << "CFits::PixelIsInTriangle: D_A2_Triag_In = " << D_A2_Triag_In << endl;
  #endif
  double D_Area_Triangle = 0.;
  double D_Area_Triangles = 0.;
  double D_Area_Temp = 0.;
  Array<double, 2> D_A2_Triag(3,2);
  if (!this->IntegralInTriangle(D_A2_Triag_In, D_Area_Triangle)){
    cout << "CFits::PixelIsInTriangle: ERROR: IntegralInClosedStructure returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_PIXELISINTRIANGLE__
    cout << "CFits::PixelIsInTriangle: D_Area_Triangle = " << D_Area_Triangle << endl;
  #endif
  for (int i=0; i<3; i++){
    D_A2_Triag(0,Range::all()) = D_A2_Triag_In(i,Range::all());
    if (i == 2)
      D_A2_Triag(1,Range::all()) = D_A2_Triag_In(0,Range::all());
    else
      D_A2_Triag(1,Range::all()) = D_A2_Triag_In(i+1,Range::all());
    D_A2_Triag(2,Range::all()) = D_A1_PixCoords_In;
    if (!this->IntegralInTriangle(D_A2_Triag, D_Area_Temp)){
      cout << "CFits::PixelIsInTriangle: i = " << i << ": ERROR: IntegralInClosedStructure returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_PIXELISINTRIANGLE__
      cout << "CFits::PixelIsInTriangle: i=" << i << ": D_Area_Temp = " << D_Area_Temp << endl;
    #endif
    D_Area_Triangles += D_Area_Temp;
    #ifdef __DEBUG_FITS_PIXELISINTRIANGLE__
      cout << "CFits::PixelIsInTriangle: i=" << i << ": D_Area_Triangles = " << D_Area_Triangles << endl;
    #endif
  }
  if (fabs(D_Area_Triangle - D_Area_Triangles) < D_Area_Triangle/100000000.){
    #ifdef __DEBUG_FITS_PIXELISINTRIANGLE__
      cout << "CFits::PixelIsInTriangle: Returning TRUE" << endl;
    #endif
    return true;
  }
  #ifdef __DEBUG_FITS_PIXELISINTRIANGLE__
    cout << "CFits::PixelIsInTriangle: D_Area_Triangle(=" << D_Area_Triangle << ") - D_Area_Triangles(=" << D_Area_Triangles << ") = " << D_Area_Triangle - D_Area_Triangles << endl;
    cout << "CFits::PixelIsInTriangle: Returning FALSE" << endl;
  #endif
  return false;
}

/**
 * Returns TRUE if point D_A1_PixCoords_In is in rectangular area defined by
 * D_A2_Rect_In(pix_lower_left(x0,y0)
 *              pix_lower_right(x1,y0)
 *              pix_upper_right(x1,y1)
 *              pix_upper_left(x0,y1))
 * **/
bool CFits::PixelIsInRectangle(const Array<double, 1> &D_A1_PixCoords_In,
                               const Array<double, 2> &D_A2_Rect_In) const{
  return ((D_A1_PixCoords_In(0) >= D_A2_Rect_In(0,0))
       && (D_A1_PixCoords_In(0) <= D_A2_Rect_In(1,0))
       && (D_A1_PixCoords_In(1) >= D_A2_Rect_In(0,1))
       && (D_A1_PixCoords_In(1) <= D_A2_Rect_In(2,1)));
}

/**
 * Returns TRUE if point D_A1_PixCoords_In is in area defined by
 * D_A2_Rect_In(pix_lower_left(x0,y0)
 *              pix_lower_right(x1,y0)
 *              pix_upper_right(x1,y1)
 *              pix_upper_left(x0,y1))
 * **/
bool CFits::PixelIsInFigure(const Array<double, 1> &D_A1_PixCoords_In,
                            const Array<double, 2> &D_A2_Rect_In) const{
  Array<double, 2> D_A2_Triag(3,2);
  D_A2_Triag(0,Range::all()) = D_A2_Rect_In(0,Range::all());
  for (int i=0; i<D_A2_Rect_In.rows()-2; i++){
    D_A2_Triag(1,Range::all()) = D_A2_Rect_In(i+1,Range::all());
    D_A2_Triag(2,Range::all()) = D_A2_Rect_In(i+2,Range::all());
    #ifdef __DEBUG_FITS_PIXELISINFIGURE__
      cout << "CFits::PixelIsInFigure: Starting PixelIsInTriangle(" << D_A1_PixCoords_In << ", " << D_A2_Triag << ")" << endl;
    #endif
    if (this->PixelIsInTriangle(D_A1_PixCoords_In, D_A2_Triag)){
      #ifdef __DEBUG_FITS_PIXELISINFIGURE__
        cout << "CFits::PixelIsInFigure: PixelIsInTriangle returned TRUE" << endl;
      #endif
      return true;
    }
    else{
      #ifdef __DEBUG_FITS_PIXELISINFIGURE__
        cout << "CFits::PixelIsInFigure: PixelIsInTriangle returned FALSE" << endl;
      #endif
    }
  }
  return false;
}

/**
 * Calculate m and n for line y=mx+n from 2 points D_A1_PointA_In(x,y) and
 * D_A1_PointB_In(x,y)
 * **/
bool CFits::CalculateLine(const Array<double, 1> &D_A1_PointA_In,
                          const Array<double, 1> &D_A1_PointB_In,
                          double &D_M_Out,
                          double &D_N_Out) const{
  if (fabs(D_A1_PointA_In(0) - D_A1_PointB_In(0)) < 0.000000000001)
    return false;
  D_M_Out = (D_A1_PointA_In(1) - D_A1_PointB_In(1)) / (D_A1_PointA_In(0) - D_A1_PointB_In(0));
  D_N_Out = D_A1_PointA_In(1) - (D_M_Out * D_A1_PointA_In(0));
  return true;
}

/**
 * Looks for crossing point of two given lines, defined by D_A2_LineA_In and
 * D_A2_LineB_In ((x1, y1)(x2,y2))
 * writes point to D_A1_Cross_Out and returns true, if found,
 * else returns false
 * **/
bool CFits::FindCrossPoint(const Array<double, 2> &D_A2_LineA_In,
                           const Array<double, 2> &D_A2_LineB_In,
                           Array<double, 1> &D_A1_Cross_Out) const{
  #ifdef __DEBUG_FITS_FINDCROSSPOINT____
    cout << "CFits::FindCrossPoint: D_A2_LineA_In = " << D_A2_LineA_In << endl;
    cout << "CFits::FindCrossPoint: D_A2_LineB_In = " << D_A2_LineB_In << endl;
  #endif
  if (D_A2_LineA_In.rows() != 2 || D_A2_LineA_In.cols() != 2 || D_A2_LineB_In.rows() != 2 || D_A2_LineB_In.cols() != 2){
    cout << "CFits::FindCrossPoint: ERROR: input lines don't have 2 rows and 2 columns" << endl;
    return false;
  }
  Array<double, 2> D_A2_LineA(2,2);
  Array<double, 2> D_A2_LineB(2,2);
  D_A1_Cross_Out.resize(2);
  D_A1_Cross_Out = 0.;

  /// sort points by x value
  if (D_A2_LineA_In(0,0) <= D_A2_LineA_In(1,0)){
    D_A2_LineA = D_A2_LineA_In;
  }
  else{
    D_A2_LineA(0,Range::all()) = D_A2_LineA_In(1,Range::all());
    D_A2_LineA(1,Range::all()) = D_A2_LineA_In(0,Range::all());
    #ifdef __DEBUG_FITS_CALCCROSSPOINT__
      cout << "CFits::FindCrossPoint: Swaped points for LineA" << endl;
    #endif
  }
  if (D_A2_LineB_In(0,0) <= D_A2_LineB_In(1,0)){
    D_A2_LineB = D_A2_LineB_In;
  }
  else{
    D_A2_LineB(0,Range::all()) = D_A2_LineB_In(1,Range::all());
    D_A2_LineB(1,Range::all()) = D_A2_LineB_In(0,Range::all());
    #ifdef __DEBUG_FITS_CALCCROSSPOINT__
      cout << "CFits::FindCrossPoint: Swaped points for LineB" << endl;
    #endif
  }
  //  if ((D_A2_LineA_In(0,0) > D_A2_LineB_In(1,0)) || (D_A2_LineA_In(1,0) < D_A2_LineB_In(0,0)) || (D_A2_LineA_In(0,1) ))
  double D_MA, D_NA, D_MB, D_NB;

  /// if vertical LineB => Swap LineA and LineB
  if (fabs(D_A2_LineB(0,0) - D_A2_LineB(1,0)) < 0.00000000001){
    Array<double, 2> D_A2_Temp(2,2);
    D_A2_Temp = D_A2_LineA;
    D_A2_LineA = D_A2_LineB;
    D_A2_LineB = D_A2_Temp;
    #ifdef __DEBUG_FITS_CALCCROSSPOINT__
      cout << "CFits::FindCrossPoint: LineA and LineB swapped" << endl;
    #endif
  }

  /// vertical LineA
  Array<double, 1> D_A1_Cross_Temp(2);
  Array<double, 1> D_A1_Temp(2);
  if (fabs(D_A2_LineA(0,0) - D_A2_LineA(1,0)) < 0.00000000001){
    if (D_A2_LineA(0,1) > D_A2_LineA(1,1)){
      D_A1_Temp = D_A2_LineA(0,Range::all());
      D_A2_LineA(0,Range::all()) = D_A2_LineA(1,Range::all());
      D_A2_LineA(1,Range::all()) = D_A1_Temp;
    }
    /// vertical LineA and LineB => no crossing POINT
    if (fabs(D_A2_LineB(0,0) - D_A2_LineB(1,0)) < 0.00000000001){
      #ifdef __DEBUG_FITS_FINDCROSSPOINT____
        cout << "CFits::FindCrossPoint: Both Lines vertical => Returning FALSE" << endl;
      #endif
      return false;
    }
    else{
      /// Calculate LineB
      if (!this->CalculateLine(D_A2_LineB(0,Range::all()), D_A2_LineB(1,Range::all()), D_MB, D_NB)){
        cout << "CFits::FindCrossPoint: WARNING: CalculateLine(D_A2_LineB=" << D_A2_LineB << ") returned FALSE" << endl;
        return false;
      }
      #ifdef __DEBUG_FITS_CALCCROSSPOINT__
        cout << "CFits::FindCrossPoint: yb = " << D_MB << "x + " << D_NB << endl;
      #endif

      /// Calculate where LineA hits LineB, if it does
      D_MA = D_MB * D_A2_LineA(0,0) + D_NB;
      #ifdef __DEBUG_FITS_CALCCROSSPOINT__
        cout << "CFits::FindCrossPoint: Lines cross at [" << D_A2_LineA(0,0) << ", " << D_MA << "]" << endl;
      #endif
      D_A1_Cross_Temp(0) = D_A2_LineA(0,0);
      D_A1_Cross_Temp(1) = D_MA;

      #ifdef __DEBUG_FITS_CALCCROSSPOINT__
        cout << "CFits::FindCrossPoint: D_A2_LineA = " << D_A2_LineA << endl;
        cout << "CFits::FindCrossPoint: D_A2_LineB = " << D_A2_LineB << endl;
        cout << "CFits::FindCrossPoint: D_A1_Cross_Temp = " << D_A1_Cross_Temp << endl;
      #endif
      D_A1_Temp = D_A1_Cross_Temp-D_A2_LineA(0,Range::all());
      #ifdef __DEBUG_FITS_CALCCROSSPOINT__
        cout << "CFits::FindCrossPoint: D_A1_Cross_Temp - D_A2_LineA(0,*) = " << D_A1_Temp << endl;
      #endif

      D_A1_Temp = D_A1_Cross_Temp-D_A2_LineA(1,Range::all());
      #ifdef __DEBUG_FITS_CALCCROSSPOINT__
        cout << "CFits::FindCrossPoint: D_A1_Cross_Temp - D_A2_LineA(1,*) = " << D_A1_Temp << endl;
      #endif

      D_A1_Temp = D_A1_Cross_Temp-D_A2_LineB(0,Range::all());
      #ifdef __DEBUG_FITS_CALCCROSSPOINT__
        cout << "CFits::FindCrossPoint: D_A1_Cross_Temp - D_A2_LineB(0,*) = " << D_A1_Temp << endl;
      #endif

      D_A1_Temp = D_A1_Cross_Temp-D_A2_LineB(1,Range::all());
      #ifdef __DEBUG_FITS_CALCCROSSPOINT__
        cout << "CFits::FindCrossPoint: D_A1_Cross_Temp - D_A2_LineB(1,*) = " << D_A1_Temp << endl;
      #endif
      if ((((D_A1_Cross_Temp(0) >= D_A2_LineB(0,0))
            && (D_A1_Cross_Temp(0) <= D_A2_LineB(1,0)))
           || ((D_A1_Cross_Temp(0) <= D_A2_LineB(0,0))
            && (D_A1_Cross_Temp(0) >= D_A2_LineB(1,0))))){
        if (((D_A1_Cross_Temp(1) >= D_A2_LineB(0,1))
              && (D_A1_Cross_Temp(1) <= D_A2_LineB(1,1)))
             || ((D_A1_Cross_Temp(1) <= D_A2_LineB(0,1))
              && (D_A1_Cross_Temp(1) >= D_A2_LineB(1,1)))){
          if (((D_A1_Cross_Temp(1) >= D_A2_LineA(0,1))
               && (D_A1_Cross_Temp(1) <= D_A2_LineA(1,1)))
              || ((D_A1_Cross_Temp(1) <= D_A2_LineA(0,1))
               && (D_A1_Cross_Temp(1) >= D_A2_LineA(1,1)))){
            D_A1_Cross_Out(0) = D_A1_Cross_Temp(0);
            D_A1_Cross_Out(1) = D_A1_Cross_Temp(1);
            #ifdef __DEBUG_FITS_CALCCROSSPOINT__
              cout << "CFits::FindCrossPoint: Crossing Point found at " << D_A1_Cross_Out << endl;
            #endif
            return true;
          }
          else{
            #ifdef __DEBUG_FITS_CALCCROSSPOINT__
              cout << "CFits::FindCrossPoint: Third test failed" << endl;
            #endif
          }
        }
        else{
          #ifdef __DEBUG_FITS_CALCCROSSPOINT__
            cout << "CFits::FindCrossPoint: Second test failed" << endl;
          #endif
        }
      }
      else{
        #ifdef __DEBUG_FITS_CALCCROSSPOINT__
          cout << "CFits::FindCrossPoint: First test failed" << endl;
        #endif
      }
      #ifdef __DEBUG_FITS_FINDCROSSPOINT____
        cout << "CFits::FindCrossPoint: LineA vertical: NO Crossing Point found " << endl;
      #endif
      return false;
    }
  }
  else{/// No line vertical
    if (!this->CalculateLine(D_A2_LineA(0,Range::all()), D_A2_LineA(1,Range::all()), D_MA, D_NA)){
      cout << "CFits::FindCrossPoint: WARNING: CalculateLine(D_A2_LineA=" << D_A2_LineA << ") returned FALSE";
      return false;
    }
    #ifdef __DEBUG_FITS_CALCCROSSPOINT__
      cout << "CFits::FindCrossPoint: y1 = " << D_MA << "x + " << D_NA << endl;
    #endif

    if (!this->CalculateLine(D_A2_LineB(0,Range::all()), D_A2_LineB(1,Range::all()), D_MB, D_NB)){
      cout << "CFits::FindCrossPoint: WARNING: CalculateLine(D_A2_LineB=" << D_A2_LineB << ") returned FALSE";
      return false;
    }
    #ifdef __DEBUG_FITS_FINDCROSSPOINT__
      cout << "CFits::FindCrossPoint: y2 = " << D_MB << "x + " << D_NB << endl;
    #endif
    D_A1_Cross_Out(0) = (D_NB - D_NA) / (D_MA - D_MB);
    D_A1_Cross_Out(1) = D_MA * D_A1_Cross_Out(0) + D_NA;
    #ifdef __DEBUG_FITS_CALCCROSSPOINT__
      cout << "CFits::FindCrossPoint: D_A1_Cross_Out = " << D_A1_Cross_Out << endl;
    #endif
    if ((D_A1_Cross_Out(0) >= D_A2_LineA(0,0))
        && (D_A1_Cross_Out(0) <= D_A2_LineA(1,0))
        && (D_A1_Cross_Out(0) >= D_A2_LineB(0,0))
        && (D_A1_Cross_Out(0) <= D_A2_LineB(1,0))){
      #ifdef __DEBUG_FITS_FINDCROSSPOINT____
        cout << "CFits::FindCrossPoint: Crossing Point found at " << D_A1_Cross_Out << endl;
      #endif
      return true;
    }
    else{
      D_A1_Cross_Out = 0.;
      #ifdef __DEBUG_FITS_FINDCROSSPOINT____
        cout << "CFits::FindCrossPoint: 2 normal lines: NO Crossing Point found" << endl;
      #endif
      return false;
    }
  }
}

/**
 * CalcOverlapFig
 * Calculates Figure from overlap of two given figures and writes its corner points
 * to D_A2_OverlapFig_Out
 * NOTE::Coordinates of both figures must be ordered counterclockwise
 * Returns TRUE if figures overlap, else returns FALSE
 * **/
bool CFits::CalcOverlapFig(const Array<double, 2> &D_A2_FigA_In,
                           const Array<double, 2> &D_A2_FigB_In,
                           Array<double, 2> &D_A2_OverlapFig_Out) const{
  if (D_A2_FigA_In.rows() < 3 || D_A2_FigB_In.rows() < 3){
    cout << "CFits::CalcOverlapFig: ERROR: Input figures have less than 3 data points" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
    cout << "CFits::CalcOverlapFig: D_A2_FigA_In = " << D_A2_FigA_In << endl;
    cout << "CFits::CalcOverlapFig: D_A2_FigB_In = " << D_A2_FigB_In << endl;
  #endif
  Array<double, 2> D_A2_Corners(D_A2_FigA_In.rows() + D_A2_FigB_In.rows(),2);
  Array<double, 2> D_A2_FigA(2,2);
  Array<double, 2> D_A2_FigB(2,2);
  Array<double, 2> D_A2_LineA(2,2);
  Array<double, 2> D_A2_LineB(2,2);
  Array<double, 1> D_A1_Pix(2);
  Array<double, 1> D_A1_PixA_A(2);
  Array<double, 1> D_A1_PixA_B(2);
  Array<double, 1> D_A1_PixB_A(2);
  Array<double, 1> D_A1_PixB_B(2);
  int I_NCorners_New=0;
  D_A2_Corners = 0.;
  bool B_LastCornerWasInside=false;
  for (int i_fig=0; i_fig<2; i_fig++){
    B_LastCornerWasInside = false;
    if (i_fig == 0){
      D_A2_FigA.resize(D_A2_FigA_In.rows(), 2);
      D_A2_FigA = D_A2_FigA_In;
      D_A2_FigB.resize(D_A2_FigB_In.rows(), 2);
      D_A2_FigB = D_A2_FigB_In;
    }
    else{
      D_A2_FigB.resize(D_A2_FigA_In.rows(), 2);
      D_A2_FigB = D_A2_FigA_In;
      D_A2_FigA.resize(D_A2_FigB_In.rows(), 2);
      D_A2_FigA = D_A2_FigB_In;
    }
    for (int i_corner=0; i_corner<=D_A2_FigA.rows(); i_corner++){
      if (i_corner < D_A2_FigA.rows())
        D_A1_Pix = D_A2_FigA(i_corner, Range::all());
      else
        D_A1_Pix = D_A2_FigA(0,Range::all());
      #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
        cout << "CFits::CalcOverlapFig: Starting PixelIsInFigure(" << D_A1_Pix << ", " << D_A2_FigB << ")" << endl;
      #endif
      if (this->PixelIsInFigure(D_A1_Pix, D_A2_FigB)){
        #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
          cout << "CFits::CalcOverlapFig: PixelIsInFigure returned TRUE" << endl;
        #endif
        if (i_corner < D_A2_FigA.rows()){
          D_A2_Corners(I_NCorners_New, Range::all()) = D_A1_Pix;
          I_NCorners_New++;
        }
        #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
          cout << "CFits::CalcOverlapFig:: I_NCorners_New=" << I_NCorners_New << ": D_A2_Corners set to " << D_A2_Corners << endl;
        #endif
        //if (i_fig == 1){
        //  D_A2_Corners(I_NCorners_New, Range::all()) = D_A1_Pix;
        //}
        if ((i_corner > 0) && (!B_LastCornerWasInside)){
          ///Calculate crossing point
          #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
            cout << "CFits::CalcOverlapFig: Calculating crossing point for line from previous pixel to this one" << endl;
          #endif
          if (i_corner < D_A2_FigA.rows()){
            D_A2_LineA(0, Range::all()) = D_A2_FigA(i_corner-1, Range::all());
            D_A2_LineA(1, Range::all()) = D_A2_FigA(i_corner, Range::all());
          }
          else{
            D_A2_LineA(0, Range::all()) = D_A2_FigA(i_corner-1, Range::all());
            D_A2_LineA(1, Range::all()) = D_A2_FigA(0, Range::all());
          }
          #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
            cout << "CFits::CalcOverlapFig: D_A2_LineA set to " << D_A2_LineA << endl;
          #endif
          for (int i_corner_b=0; i_corner_b<D_A2_FigB.rows(); i_corner_b++){
            if (i_corner_b == D_A2_FigB.rows()-1){
              D_A2_LineB(0, Range::all()) = D_A2_FigB(i_corner_b, Range::all());
              D_A2_LineB(1, Range::all()) = D_A2_FigB(0, Range::all());
            }
            else{
              D_A2_LineB(0, Range::all()) = D_A2_FigB(i_corner_b, Range::all());
              D_A2_LineB(1, Range::all()) = D_A2_FigB(i_corner_b+1, Range::all());
            }
            #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
              cout << "CFits::CalcOverlapFig: D_A2_LineB set to " << D_A2_LineB << endl;
            #endif
            if (!this->FindCrossPoint(D_A2_LineA, D_A2_LineB, D_A1_Pix)){
              #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
                cout << "CFits::CalcOverlapFig: i_fig = " << i_fig << ": i_corner = " << i_corner << ": FindCrossPoint(" << D_A2_LineA << ", " << D_A2_LineB << ") returned FALSE" << endl;
              #endif
//              return false;
            }
            else{
              if ((I_NCorners_New < 2) || (!this->PixIsInArray(D_A1_Pix, D_A2_Corners(Range(0,I_NCorners_New-1), Range::all())))){
                #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
                  cout << "CFits::CalcOverlapFig: D_A1_Pix = " << D_A1_Pix << endl;
                #endif
                D_A2_Corners(I_NCorners_New, Range::all()) = D_A2_Corners(I_NCorners_New-1, Range::all());
                #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
                  cout << "CFits::CalcOverlapFig: D_A2_Corners(I_NCorners_New = " << I_NCorners_New << ", *) set to " << D_A2_Corners(I_NCorners_New, Range::all()) << endl;
                #endif
                D_A2_Corners(I_NCorners_New-1, Range::all()) = D_A1_Pix;
                #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
                  cout << "CFits::CalcOverlapFig: D_A2_Corners set to " << D_A2_Corners << endl;
                #endif
                I_NCorners_New++;
              }
            }
          }
        }
        B_LastCornerWasInside = true;
        //I_NCorners_New++;
      }
      else{
        if ((i_corner > 0) && (B_LastCornerWasInside)){
          ///Calculate crossing point
          D_A2_LineA(0, Range::all()) = D_A2_FigA(i_corner-1, Range::all());
          if (i_corner < D_A2_FigA.rows()){
            D_A2_LineA(1, Range::all()) = D_A2_FigA(i_corner, Range::all());
          }
          else{
            D_A2_LineA(1, Range::all()) = D_A2_FigA(0, Range::all());
          }
          for (int i_corner_b=0; i_corner_b<D_A2_FigB.rows(); i_corner_b++){
            if (i_corner_b == D_A2_FigB.rows()-1){
              D_A2_LineB(0, Range::all()) = D_A2_FigB(i_corner_b, Range::all());
              D_A2_LineB(1, Range::all()) = D_A2_FigB(0, Range::all());
            }
            else{
              D_A2_LineB(0, Range::all()) = D_A2_FigB(i_corner_b, Range::all());
              D_A2_LineB(1, Range::all()) = D_A2_FigB(i_corner_b+1, Range::all());
            }
            if (this->FindCrossPoint(D_A2_LineA, D_A2_LineB, D_A1_Pix)){
              if ((I_NCorners_New < 2) || (!this->PixIsInArray(D_A1_Pix, D_A2_Corners(Range(0,I_NCorners_New-1), Range::all())))){
                D_A2_Corners(I_NCorners_New, Range::all()) = D_A1_Pix;
                #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
                  cout << "CFits::CalcOverlapFig: D_A2_Corners(I_NCorners_New = " << I_NCorners_New << ", *) set to " << D_A2_Corners(I_NCorners_New, Range::all()) << endl;
                  cout << "CFits::CalcOverlapFig: D_A2_Corners = " << D_A2_Corners << endl;
                #endif
                I_NCorners_New++;
              }
            }
          }
        }
        B_LastCornerWasInside = false;
      }
    }
  }
  D_A2_OverlapFig_Out.resize(I_NCorners_New, 2);
  D_A2_OverlapFig_Out = 0.;
  #ifdef __DEBUG_FITS_CALCOVERLAPFIG__
    cout << "CFits::CalcOverlapFig: I_NCorners_New = " << I_NCorners_New << endl;
  #endif
  if (!this->SortCoordinatesCounterClockWise(D_A2_Corners(Range(0, I_NCorners_New-1), Range::all()), D_A2_OverlapFig_Out)){
    cout << "CFits::CalcOverlapFig: SortCoordinatesCounterClockWise(" << D_A2_Corners(Range(0, I_NCorners_New-1), Range::all()) << ") returned FALSE" << endl;
    return false;
  }
  return true;
}

bool CFits::PixIsInArray(const Array<double, 1> &D_A1_Pix, const Array<double, 2> &D_A2_Corners) const{
  Array<int, 1> I_A1_Where(D_A2_Corners.rows());
  I_A1_Where = where(fabs(D_A2_Corners(Range::all(),0) - D_A1_Pix(0)) < 0.000001, 1, 0);
  if (sum(I_A1_Where) == 0)
    return false;
  int I_NInd;
  Array<int, 1> I_A1_Ind(2);
  if (!this->GetIndex(I_A1_Where, I_NInd, I_A1_Ind)){
    cout << "CFits::PixIsInArray: ERROR: GetIndex returned FALSE" << endl;
    return false;
  }
  I_A1_Where.resize(I_A1_Ind.size());
  Array<double, 1> D_A1_Y(2);
  if (!this->GetSubArrCopy(D_A2_Corners(Range::all(),1), I_A1_Ind, D_A1_Y)){
    cout << "CFits::PixIsInArray: ERROR: GetSubArrCopy returned FALSE" << endl;
    return false;
  }
  I_A1_Where = where(fabs(D_A1_Y - D_A1_Pix(1)) < 0.000001, 1, 0);
  if (sum(I_A1_Where) > 0)
    return true;
  return false;
}

void CFits::ResizeAndPreserve(Array<double, 1> &D_A1_Arr_InOut, int I_NewSize){
  Array<double, 1> D_A1_Temp(I_NewSize);
  D_A1_Temp = 0.;
  if (I_NewSize < D_A1_Arr_InOut.size()){
    D_A1_Temp = D_A1_Arr_InOut(Range(0,I_NewSize-1));
    D_A1_Arr_InOut.resize(I_NewSize);
    D_A1_Arr_InOut = D_A1_Temp;
  }
  else{
    D_A1_Temp(Range(0,D_A1_Arr_InOut.size()-1)) = D_A1_Arr_InOut;
    D_A1_Arr_InOut.resize(I_NewSize);
    D_A1_Arr_InOut = D_A1_Temp;
  }
  return;
}

void CFits::ResizeAndPreserve(Array<double, 2> &D_A2_Arr_InOut, int I_NewRows, int I_NewCols){
  Array<double, 2> D_A2_Temp(I_NewRows, I_NewCols);
  D_A2_Temp = 0.;
  if (I_NewRows < D_A2_Arr_InOut.rows()){
    if (I_NewCols < D_A2_Arr_InOut.cols()){
      D_A2_Temp = D_A2_Arr_InOut(Range(0,I_NewRows-1), Range(0,I_NewCols-1));
      D_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      D_A2_Arr_InOut = D_A2_Temp;
    }
    else{
      D_A2_Temp(Range::all(), Range(0,D_A2_Arr_InOut.cols()-1)) = D_A2_Arr_InOut(Range(0,I_NewRows-1), Range::all());
      D_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      D_A2_Arr_InOut = D_A2_Temp;
    }
  }
  else{
    if (I_NewCols < D_A2_Arr_InOut.cols()){
      D_A2_Temp(Range(0,D_A2_Arr_InOut.rows()-1), Range::all()) = D_A2_Arr_InOut(Range::all(), Range(0,I_NewCols-1));
      D_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      D_A2_Arr_InOut = D_A2_Temp;
    }
    else{
      D_A2_Temp(Range(0,D_A2_Arr_InOut.rows()-1), Range(0,D_A2_Arr_InOut.cols()-1)) = D_A2_Arr_InOut;
      D_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      D_A2_Arr_InOut = D_A2_Temp;
    }
  }
  return;
}

void CFits::ResizeAndPreserve(Array<int, 1> &I_A1_Arr_InOut, int I_NewSize){
  Array<int, 1> I_A1_Temp(I_NewSize);
  I_A1_Temp = 0;
  if (I_NewSize < I_A1_Arr_InOut.size()){
    I_A1_Temp = I_A1_Arr_InOut(Range(0,I_NewSize-1));
    I_A1_Arr_InOut.resize(I_NewSize);
    I_A1_Arr_InOut = I_A1_Temp;
  }
  else{
    I_A1_Temp(Range(0,I_A1_Arr_InOut.size()-1)) = I_A1_Arr_InOut;
    I_A1_Arr_InOut.resize(I_NewSize);
    I_A1_Arr_InOut = I_A1_Temp;
  }
  return;
}

void CFits::ResizeAndPreserve(Array<int, 2> &I_A2_Arr_InOut, int I_NewRows, int I_NewCols){
  Array<int, 2> I_A2_Temp(I_NewRows, I_NewCols);
  I_A2_Temp = 0;
  if (I_NewRows < I_A2_Arr_InOut.rows()){
    if (I_NewCols < I_A2_Arr_InOut.cols()){
      I_A2_Temp = I_A2_Arr_InOut(Range(0,I_NewRows-1), Range(0,I_NewCols-1));
      I_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      I_A2_Arr_InOut = I_A2_Temp;
    }
    else{
      I_A2_Temp(Range::all(), Range(0,I_A2_Arr_InOut.cols()-1)) = I_A2_Arr_InOut(Range(0,I_NewRows-1), Range::all());
      I_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      I_A2_Arr_InOut = I_A2_Temp;
    }
  }
  else{
    if (I_NewCols < I_A2_Arr_InOut.cols()){
      I_A2_Temp(Range(0,I_A2_Arr_InOut.rows()-1), Range::all()) = I_A2_Arr_InOut(Range::all(), Range(0,I_NewCols-1));
      I_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      I_A2_Arr_InOut = I_A2_Temp;
    }
    else{
      I_A2_Temp(Range(0,I_A2_Arr_InOut.rows()-1), Range(0,I_A2_Arr_InOut.cols()-1)) = I_A2_Arr_InOut;
      I_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      I_A2_Arr_InOut = I_A2_Temp;
    }
  }
  return;
}

void CFits::ResizeAndPreserve(Array<CString, 1> &CS_A1_Arr_InOut, int I_NewSize){
  Array<CString, 1> CS_A1_Temp(I_NewSize);
  CS_A1_Temp = CString(" ");
  if (I_NewSize < CS_A1_Arr_InOut.size()){
    CS_A1_Temp = CS_A1_Arr_InOut(Range(0,I_NewSize-1));
    CS_A1_Arr_InOut.resize(I_NewSize);
    CS_A1_Arr_InOut = CS_A1_Temp;
  }
  else{
    cout << "CFits::ResizeAndPreserve: CS_A1_Temp = " << CS_A1_Temp << endl;
    cout << "CFits::ResizeAndPreserve: CS_A1_Arr_InOut = " << CS_A1_Arr_InOut << endl;
    cout << "CFits::ResizeAndPreserve: CS_A1_Temp.size() = " << CS_A1_Temp.size() << ", CS_A1_Arr_InOut.size() = " << CS_A1_Arr_InOut.size() << endl;
    CS_A1_Temp(Range(0,CS_A1_Arr_InOut.size()-1)) = CS_A1_Arr_InOut;
    CS_A1_Arr_InOut.resize(I_NewSize);
    CS_A1_Arr_InOut = CS_A1_Temp;
  }
  return;
}

void CFits::ResizeAndPreserve(Array<CString, 2> &CS_A2_Arr_InOut, int I_NewRows, int I_NewCols){
  Array<CString, 2> CS_A2_Temp(I_NewRows, I_NewCols);
  CS_A2_Temp = CString(" ");
  if (I_NewRows < CS_A2_Arr_InOut.rows()){
    if (I_NewCols < CS_A2_Arr_InOut.cols()){
      CS_A2_Temp = CS_A2_Arr_InOut(Range(0,I_NewRows-1), Range(0,I_NewCols-1));
      CS_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      CS_A2_Arr_InOut = CS_A2_Temp;
    }
    else{
      CS_A2_Temp(Range::all(), Range(0,CS_A2_Arr_InOut.cols()-1)) = CS_A2_Arr_InOut(Range(0,I_NewRows-1), Range::all());
      CS_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      CS_A2_Arr_InOut = CS_A2_Temp;
    }
  }
  else{
    if (I_NewCols < CS_A2_Arr_InOut.cols()){
      CS_A2_Temp(Range(0,CS_A2_Arr_InOut.rows()-1), Range::all()) = CS_A2_Arr_InOut(Range::all(), Range(0,I_NewCols-1));
      CS_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      CS_A2_Arr_InOut = CS_A2_Temp;
    }
    else{
      CS_A2_Temp(Range(0,CS_A2_Arr_InOut.rows()-1), Range(0,CS_A2_Arr_InOut.cols()-1)) = CS_A2_Arr_InOut;
      CS_A2_Arr_InOut.resize(I_NewRows, I_NewCols);
      CS_A2_Arr_InOut = CS_A2_Temp;
    }
  }
return;
}

/**bool CFits::GetBias(&D_BiasValue_Out) const{
  if (!this->TraceFunctionsCalculated)
    return false;
  Array<double, 2> D_A2_Temp(this->NRows, this->NCols);
  D_A2_Temp = this->PixArray;
  if (!Set_ApertureDataToZero(D_A2_Temp, 1, 1))
    return false;
  Array<double, 1> D_A1_Temp(this->I_NRows * this->I_NCols);
  int i_pix=0;
  for (int i_row=0; i_row<this->I_NRows; i_row++){
    for (int i_col=0; i_col < this->I_NCols; i_col++){
      if (fabs(D_A2_Temp(i_row, i_col)) > 0.00000000000000001){
	D_A1_Temp(i_pix) = D_A2_Temp(i_row, i_col);
	i_pix++;
      }
    }
  }
  Array<double, 1> D_A1_Bias(i_pix-1);
  D_A1_Bias = D_A1_Temp(Range(0,i_pix-1));
  D_BiasValue_Out = mean(D_A1_Bias);
  return true;
}**/

bool CFits::CreateErrorImage()
{
  this->P_D_A2_ErrArray->resize(this->NRows, this->NCols);
  (*(this->P_D_A2_ErrArray)) = sqrt(((*(this->P_D_A2_PixArray)) / this->D_Gain) + pow2(this->D_ReadOutNoise));
  this->ErrorsRead = true;
  return true;
}

//Array<double, 2>* CFits::Transpose(Array<double, 2> &Arr) const{
//  Array<double, 2> *P_D_A2_Out = new Array<double, 2>(Arr.cols(), Arr.rows());
//
//}
/*
bool CFits::Get_Path(CString &CS_Path_Out) const{
  CString *P_CS_FileNameTemp = this->P_CS_FileName->SubString(0,this->P_CS_FileName->LastCharPos('/'));
  cout << "CFits::Get_Path: P_CS_FileNameTemp = " << *P_CS_FileNameTemp << endl;
  CS_Path_Out.Set(*P_CS_FileNameTemp);
  delete(P_CS_FileNameTemp);
  return true;
}
*/

bool CFits::AddHeaderToFitsFile(const CString &CS_FitsFileName_In, const CString &CS_HeaderFile_In) const{
  CFits CF_Temp;
  CString CS_Temp;
  fitsfile *P_FitsFile;
  FILE     *P_HeaderFile;
  int      Count,Status;
  int      FirstLinesRemoved = 0;
  int      BitPix, NElements;
  int      AnyNul, Extend, Simple, Pos, TempInt;
  int      NAxis, Width, LowInt, HighInt;
  double   TempDbl;
  long     PCount, GCount, NLines, TempLong;
  long     NAxes[2];
  long     FPixel, i, j;
  //  float * Array;
  float    NullVal;
  char     StrBuf[256];
  char     *P_FitsFileName;
  char     *P_HeaderFileName;
  char     *P_Pos;
  char     OneWord[255], LineCharArr[255], TempCharArr[255];
  char     *P_Line, *P_TempLine, *P_HeaderKeyWord, *P_HeaderKeyWordValue, *P_HeaderKeyWordComment;
  char     *P_TempStr;

  // --- allocate memory for Pointer variables
  P_HeaderKeyWord = (char*)malloc(sizeof(char) * 255);
  if (P_HeaderKeyWord == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_HeaderKeyWord\n");
    return false;
  }

  P_HeaderKeyWordValue = (char*)malloc(sizeof(char) * 255);
  if (P_HeaderKeyWordValue == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_HeaderKeyWordValue\n");
    return false;
  }

  P_HeaderKeyWordComment = (char*)malloc(sizeof(char) * 255);
  if (P_HeaderKeyWordComment == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_HeaderKeyWordComment\n");
    return false;
  }

  P_FitsFileName = (char*)malloc(sizeof(char) * 255);
  if (P_FitsFileName == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_FitsFileName\n");
    return false;
  }
  strcpy(P_FitsFileName, CS_FitsFileName_In.Get());

  P_HeaderFileName = (char*)malloc(sizeof(char) * 255);
  if (P_HeaderFileName == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_HeaderFileName\n");
    return false;
  }
  strcpy(P_HeaderFileName, CS_HeaderFile_In.Get());
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
  printf("CFits::AddHeaderToFitsFile: P_FitsFileName =<%s>\n", P_FitsFileName);
  printf("CFits::AddHeaderToFitsFile: P_HeaderFileName =<%s>\n", P_HeaderFileName);
#endif

  P_Line = (char*)malloc(sizeof(char) * 255);
  if (P_Line == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_Line\n");
    return false;
  }

  P_TempLine = (char*)malloc(sizeof(char) * 255);
  if (P_TempLine == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_TempLine\n");
    return false;
  }

  P_TempStr = (char*)malloc(sizeof(char) * 255);
  if (P_TempStr == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: ERROR: Cannot allocate memory for P_TempStr\n");
    return false;
  }

  // --- open fits file
  Status=0;

  fits_open_file(&P_FitsFile, P_FitsFileName, READWRITE, &Status);
  fits_read_imghdr(P_FitsFile, 2, &Simple , &BitPix, &NAxis, NAxes, &PCount, &GCount, &Extend, &Status);
  if (Status !=0)
  {
    printf("CFits::AddHeaderToFitsFile: Error %d in file %s\n", Status, P_FitsFileName);
    return false;
  }

  // --- Count lines of HeaderFile
  NLines = CF_Temp.CountLines( CString(P_HeaderFileName) );

  CString CS_Empty("");

  // --- open file <P_HeaderFile> with name <P_HeaderFileName> for reading
  P_HeaderFile = fopen(P_HeaderFileName, "r");
  if (P_HeaderFile == NULL)
  {
    printf("CFits::AddHeaderToFitsFile: Failed to open file P_HeaderFile (=<%s>)\n", P_HeaderFileName);
    return false;
  }

  for (i = 0; i < NLines; i++)
  {
    // --- Read Line
    P_Line = fgets(OneWord, 200, P_HeaderFile);
    if (P_Line != NULL)
    {
      strcpy(LineCharArr, P_Line);

      // --- Look for first HeaderKeyWord
      if (FirstLinesRemoved == 0)
      {
        while(CS_Temp.CharPosInCharArr(LineCharArr, '=') == -1 && P_Line != NULL)// && (strchr(P_Line, '=') == NULL || strchr(P_Line, '/') == NULL))
        ///while((CharPosInChArr(LineCharArr, '=') == -1 || CharPosInChArr(LineCharArr, '/') == -1) && P_Line != NULL)// && (strchr(P_Line, '=') == NULL || strchr(P_Line, '/') == NULL))
        {
          P_Line = fgets(OneWord, 200, P_HeaderFile);
          if (P_Line != NULL)
          {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
            printf("\nCFits::AddHeaderToFitsFile.while: P_Line =<%s>\n", P_Line);
#endif
            strcpy(LineCharArr, P_Line);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
            printf("\nCFits::AddHeaderToFitsFile.while: P_Line \t= <%s>\n", P_Line);
            printf("\nCFits::AddHeaderToFitsFile.while: LineCharArr \t= <%s>\n", LineCharArr);
            printf("\nCFits::AddHeaderToFitsFile.while: CharPosInChArr(LineCharArr, '=') = %d\n", CS_Temp.CharPosInCharArr(LineCharArr, '='));
            printf("\nCFits::AddHeaderToFitsFile.while: CharPosInChArr(LineCharArr, '/') = %d\n", CS_Temp.CharPosInCharArr(LineCharArr, '/'));
#endif
          }
          //      exit(0);
        }
        FirstLinesRemoved = 1;
      }
      if (P_Line != NULL)
      {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
        printf("\nCFits::AddHeaderToFitsFile: P_Line =<%s>\n", P_Line);
#endif
        strcpy(P_TempLine, P_Line);

        // --- Count Elements in P_Line
        NElements = 0;
        P_HeaderKeyWord = strtok(P_Line," =\t\n\0");
        printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord set to <%s>\n", P_HeaderKeyWord);
        if (P_HeaderKeyWord != NULL)
        {
          while (P_HeaderKeyWord != NULL)
          {
            P_HeaderKeyWord = strtok(NULL, "/\t\n\0");
            NElements++;
          }
        }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
        printf("CFits::AddHeaderToFitsFile: NElements =<%d>\n", NElements);
#endif

        // --- Read HeaderKeyWord
        strcpy(P_Line, P_TempLine);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
        printf("CFits::AddHeaderToFitsFile: P_Line =<%s>\n", P_Line);
#endif
        free(P_HeaderKeyWord);
        P_HeaderKeyWord = strtok(P_Line,"=\t\n\0");
        if (P_HeaderKeyWord != NULL)
        {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
          printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord =<%s>\n", P_HeaderKeyWord);
#endif
          // --- Trim HeaderKeyWord
          CS_Temp.Set(P_HeaderKeyWord);
          CS_Temp.Trim(2);
          P_HeaderKeyWord = CS_Temp.GetPChar();
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
          printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord =<%s>\n", P_HeaderKeyWord);
#endif
          // --- look if trimmed HeaderKeyWord is empty
          //        while (strcmp(P_HeaderKeyWord, "") == 0 && P_HeaderKeyWord != NULL)
          //        {
          // -- reread HeaderKeyWord
          //          P_HeaderKeyWord = strtok(P_Line,"=\t\n\0");
          //#ifdef __DEBUG_MADDHEADERTOFITSFILE__
          //          printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord =<%s>\n", P_HeaderKeyWord);
          //#endif
          // --- Trim reread HeaderKeyWord
          //          P_HeaderKeyWord = StrTrim(P_HeaderKeyWord, 2);
          //#ifdef __DEBUG_MADDHEADERTOFITSFILE__
          //          printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord =<%s>\n", P_HeaderKeyWord);
          //#endif
          //      }

          if (P_HeaderKeyWord != NULL)
          {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
            printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord = <%s>\n", P_HeaderKeyWord);
#endif
            // --- Read HeaderKeyWordValue
            CS_Temp.Set(P_HeaderKeyWord);
            CString *P_CS = CS_Temp.SubString(0, 6);
            if (CS_Temp.GetLength() > 6 && strcmp(P_CS->GetPChar(), "COMMENT") == 0)
            {
              if (strlen(P_HeaderKeyWordValue) > 0)
              {
                free (P_HeaderKeyWordValue);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWordValue set free\n");
#endif
              }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
              printf("CFits::AddHeaderToFitsFile: P_TempLine =<%s>\n", P_TempLine);
#endif
              CS_Temp.Set(P_TempLine);
              delete(P_CS);
              P_CS = CS_Temp.SubString(8, strlen(P_TempLine));
              P_HeaderKeyWordValue = P_CS->GetPChar();
              CS_Temp.Set(P_HeaderKeyWordValue);
              CS_Temp.TrimChar('\n', 1);
              P_HeaderKeyWordValue = CS_Temp.GetPChar();
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
              printf("CFits::AddHeaderToFitsFile: 1. P_HeaderKeyWordValue =<%s>\n", P_HeaderKeyWordValue);
#endif
              // --- Append HeaderComment to Fits file
              //fits_write_date(P_FitsFile, &Status);
              fits_write_comment(P_FitsFile, P_HeaderKeyWordValue, &Status);
              //fits_write_key_null(P_FitsFile, P_HeaderKeyWord, P_HeaderKeyWordValue, &Status);
              if (Status !=0)
              {
                printf("CFits::AddHeaderToFitsFile: Error %d while trying to add P_HeaderKeyWord %s to file %s\n", Status, P_HeaderKeyWord, P_FitsFileName);
                return false;
              }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
              printf("CFits::AddHeaderToFitsFile: HeaderComment <%s> inserted\n", P_HeaderKeyWordValue);
#endif
//              exit(0);
            }// end if (strcmp(P_HeaderKeyWord, "COMMENT") == 0)
            else
            {
              P_HeaderKeyWordValue = CS_Empty.Get();
              while (P_HeaderKeyWordValue != NULL && strcmp(P_HeaderKeyWordValue, "") == 0)
              {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                printf("CFits::AddHeaderToFitsFile: P_Line = <%s>\n", P_Line);
#endif
                P_HeaderKeyWordValue = strtok(NULL,"'");
                if (P_HeaderKeyWordValue != NULL)
                {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: 2. P_HeaderKeyWordValue =<%s>\n", P_HeaderKeyWordValue);
#endif
                }
                P_HeaderKeyWordValue = strtok(NULL,"/\t\n\0");
                if (P_HeaderKeyWordValue != NULL)
                {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: 2. P_HeaderKeyWordValue =<%s>\n", P_HeaderKeyWordValue);
#endif
                  // --- Trim HeaderKeyWordValue
                  CS_Temp.Set(P_HeaderKeyWordValue);
                  CS_Temp.TrimChar(' ', 2);
                  CS_Temp.TrimChar('\'', 2);
                  CS_Temp.TrimChar(' ', 2);
                  P_HeaderKeyWordValue = CS_Temp.GetPChar();
                  #ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: Trimmed P_HeaderKeyWordValue =<%s>\n", P_HeaderKeyWordValue);
#endif
                }
              }// end while (strcmp(P_HeaderKeyWordValue, "") == 0 && P_HeaderKeyWordValue != NULL)
              if (P_HeaderKeyWordValue != NULL)
              {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                printf("CFits::AddHeaderToFitsFile: 3. P_HeaderKeyWordValue =<%s>\n", P_HeaderKeyWordValue);
#endif
                CS_Temp.Set(P_HeaderKeyWordValue);
                CS_Temp.Trim(2);
                P_HeaderKeyWordValue = CS_Temp.GetPChar();
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                printf("CFits::AddHeaderToFitsFile: Trimmed P_HeaderKeyWordValue =<%s>\n", P_HeaderKeyWordValue);
#endif
                P_TempStr = CS_Empty.Get();
                P_HeaderKeyWordComment = CS_Empty.Get();
                while (P_HeaderKeyWordComment != NULL && strcmp(P_HeaderKeyWordComment, P_TempStr) == 0)
                {
                  P_HeaderKeyWordComment = strtok(NULL,"\t\n\0");
                  if (P_HeaderKeyWordComment != NULL)
                  {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWordComment =<%s>\n", P_HeaderKeyWordComment);
#endif
                  CS_Temp.Set(P_HeaderKeyWordComment);
                  CS_Temp.Trim(2);
                  P_HeaderKeyWordComment = CS_Temp.GetPChar();
                  if (CS_Temp.CharPos('/') >= 0)
                    CS_Temp.TrimChar('\'', 2);
                  CS_Temp.Trim(2);
                  P_HeaderKeyWordComment = CS_Temp.GetPChar();
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: Trimmed P_HeaderKeyWordComment =<%s>\n", P_HeaderKeyWordComment);
#endif
                  }
                }// end while (strcmp(P_HeaderKeyWordComment, "") == 0 && P_HeaderKeyWordComment != NULL)
                strcpy(TempCharArr, P_HeaderKeyWordValue);
                if (CS_Temp.StrPosInCharArr(LineCharArr, "'") >= 0)  // String
                {
                  fits_write_key(P_FitsFile, TSTRING, P_HeaderKeyWord, P_HeaderKeyWordValue, P_HeaderKeyWordComment, &Status);
                  if (Status !=0)
                  {
                    printf("CFits::AddHeaderToFitsFile: Error %d while trying to add P_HeaderKeyWord %s to file %s\n", Status, P_HeaderKeyWord, P_FitsFileName);
                    return false;
                  }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with STRING Value <%s> added to FitsFile\n", P_HeaderKeyWord, P_HeaderKeyWordValue, P_FitsFileName);
#endif
                }
                else if (CS_Temp.StrPosInCharArr(TempCharArr, ".") >= 0) // Double
                {
                  TempDbl = atof(P_HeaderKeyWordValue);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with DOUBLE Value of P_HeaderKeyWordValue(=<%s>) TempDbl = <%.7f> added to FitsFile %s\n", P_HeaderKeyWord, P_HeaderKeyWordValue, TempDbl, P_FitsFileName);
#endif
                  fits_write_key(P_FitsFile, TDOUBLE, P_HeaderKeyWord, &TempDbl, P_HeaderKeyWordComment, &Status);
                  if (Status !=0)
                  {
                    printf("CFits::AddHeaderToFitsFile: Error %d while trying to add P_HeaderKeyWord %s to file %s\n", Status, P_HeaderKeyWord, P_FitsFileName);
                    return false;
                  }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with DOUBLE Value <%s> added to FitsFile\n", P_HeaderKeyWord, P_HeaderKeyWordValue, P_FitsFileName);
#endif
                }
                else// Integer and Boolean
                {
                  if (CS_Temp.CharPosInCharArr(TempCharArr, 'T') == 0)
                  {
                    TempInt = 1;
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                    printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with BOOLEAN Value of P_HeaderKeyWordValue(=<%s>) TempInt = <%d> added to FitsFile %s\n", P_HeaderKeyWord, P_HeaderKeyWordValue, TempInt, P_FitsFileName);
#endif
                    fits_write_key(P_FitsFile, TLOGICAL, P_HeaderKeyWord, &TempInt, P_HeaderKeyWordComment, &Status);
                  }
                  else if (CS_Temp.CharPosInCharArr(TempCharArr, 'F') == 0)
                  {
                    TempInt = 0;
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                    printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with BOOLEAN Value of P_HeaderKeyWordValue(=<%s>) TempInt = <%d> added to FitsFile %s\n", P_HeaderKeyWord, P_HeaderKeyWordValue, TempInt, P_FitsFileName);
#endif
                    fits_write_key(P_FitsFile, TLOGICAL, P_HeaderKeyWord, &TempInt, P_HeaderKeyWordComment, &Status);
                  }
                  else
                  {
                    TempLong = atol(P_HeaderKeyWordValue);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                    printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with LONG Value of P_HeaderKeyWordValue(=<%s>) TempLong = <%d> added to FitsFile %s\n", P_HeaderKeyWord, P_HeaderKeyWordValue, TempLong, P_FitsFileName);
#endif
                    fits_write_key(P_FitsFile, TLONG, P_HeaderKeyWord, &TempLong, P_HeaderKeyWordComment, &Status);
                  }
                  if (Status !=0)
                  {
                    printf("CFits::AddHeaderToFitsFile: Error %d while trying to add P_HeaderKeyWord %s to file %s\n", Status, P_HeaderKeyWord, P_FitsFileName);
                    return false;
                  }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with LONG Value <%s> added to FitsFile\n", P_HeaderKeyWord, P_HeaderKeyWordValue, P_FitsFileName);
#endif
                }
/*                else // Long
                {
                  TempLong = atol(P_HeaderKeyWordValue);
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with LONG Value of P_HeaderKeyWordValue(=<%s>) TempLong = <%d> added to FitsFile %s\n", P_HeaderKeyWord, P_HeaderKeyWordValue, TempLong, P_FitsFileName);
#endif
                  fits_write_key(P_FitsFile, TLONG, P_HeaderKeyWord, &TempLong, P_HeaderKeyWordComment, &Status);
                  if (Status !=0)
                  {
                    printf("CFits::AddHeaderToFitsFile: Error %d while trying to add P_HeaderKeyWord %s to file %s\n", Status, P_HeaderKeyWord, P_FitsFileName);
                    return false;
                  }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
                  printf("CFits::AddHeaderToFitsFile: P_HeaderKeyWord <%s> with LONG Value <%s> added to FitsFile\n", P_HeaderKeyWord, P_HeaderKeyWordValue, P_FitsFileName);
#endif
              }*/
              }// end if (P_HeaderKeyWordValue != NULL)
            }// end else if (strcmp(P_HeaderKeyWord, "COMMENT") != 0)
            delete(P_CS);
          }// if (P_HeaderKeyWord != NULL)
        }// end else if (strchr(P_Line, '=') != NULL)
      }// end if (P_Line != NULL)
      else
      {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
        printf("CFits::AddHeaderToFitsFile: P_Line == NULL\n");
#endif
      }
    }// end if (P_Line != NULL)
    else
    {
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
      printf("CFits::AddHeaderToFitsFile: P_Line == NULL\n");
#endif
    }
#ifdef __DEBUG_MADDHEADERTOFITSFILE__
    printf("\n\n\nCFits::AddHeaderToFitsFile: P_Line read\n\n\n");
#endif

  }// end for (i = 0; i < NLines; i++)

  fclose(P_HeaderFile);
  fits_close_file(P_FitsFile, &Status);

  if (Status !=0)
  {
    printf("MPiskunov.ReadApertureData: Error %d in file %s\n", Status, P_FitsFileName);
    return false;
  }

//  TestBasis();

  return true;

}


bool CFits::WriteApertures(const CString &CS_FitsFileName_Out_Root, 
                           Array<CString, 1> &CS_A1_FileNames_Out) const{
  cout << "CFits::WriteApertures: this->I_NApertures = " << this->I_NApertures << endl;
  Array<int, 1> *P_I_A1_Apertures = this->IndGenArr(this->I_NApertures);
  Array<int, 1> I_A1_Apertures(P_I_A1_Apertures->size());
  I_A1_Apertures = (*P_I_A1_Apertures);
  cout << "CFits::WriteApertures: I_A1_Apertures set to " << I_A1_Apertures << endl;
  delete(P_I_A1_Apertures);
  return this->WriteApertures(CS_FitsFileName_Out_Root, CS_A1_FileNames_Out, I_A1_Apertures);
}

bool CFits::WriteApertures(const CString &CS_FitsFileName_Out_Root, 
                           Array<CString, 1> &CS_A1_FileNames_Out, 
                           const Array<int, 1> &I_A1_Apertures) const{
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::WriteApertures: ERROR: Trace Functions not calculated yet" << endl;
    return false;
  }
  Array<double, 1> D_A1_Ap(this->GetNCols());
  Array<double, 2> D_A2_Spec(1,1);
  int I_FirstSignal, I_LastSignal;
  CString* P_CS = new CString(" ");
  CString CS_FitsFileName_Out(" ");
  CS_A1_FileNames_Out.resize(I_A1_Apertures.size());
  CS_A1_FileNames_Out = CString(" ");
  #ifdef __DEBUG_FITS_WRITEAPS__
    cout << "CFits::WriteApertures: *(this->P_D_A1_YCenter) = " << *(this->P_D_A1_YCenter) << ", *(this->P_D_A1_YHigh) = " << *(this->P_D_A1_YHigh) << endl;
  #endif
//  return false;
//  int I_ArrPos = 0;
  for (int i_ap = 0; i_ap < I_A1_Apertures.size(); i_ap++){
    D_A1_Ap = 0.;
    D_A1_Ap = ((const_cast<CFits*>(this))->GetPixArray())(I_A1_Apertures(i_ap),Range::all());
    #ifdef __DEBUG_FITS_WRITEAPS__
      cout << "CFits::WriteApertures: i_ap = " << i_ap << ": I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": D_A1_Ap = " << D_A1_Ap << endl;
    #endif
    if (max(D_A1_Ap) > 0.0000000000000000001){
      I_FirstSignal = int((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)));
      ///I_FirstSignal = F_EcImage.FirstIndexWithValueGE(D_A1_Ap, 0.00000001);
      #ifdef __DEBUG_FITS_WRITEAPS__
        cout << "CFits::WriteApertures: i_ap = " << i_ap << ": I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": I_FirstSignal = " << I_FirstSignal << endl;
      #endif
      if (I_FirstSignal >= 0){
        I_LastSignal = int((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)));
        ///I_LastSignal = F_EcImage.LastIndexWithNonZeroValueBefore(D_A1_Ap, D_A1_Ap.size()-1);
        #ifdef __DEBUG_FITS_WRITEAPS__
          cout << "CFits::WriteApertures: i_ap = " << i_ap << ": I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) = " << (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) << ", (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) = " << (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) << endl;
          cout << "CFits::WriteApertures: i_ap = " << i_ap << ": I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": I_LastSignal = " << I_LastSignal << endl;
        #endif
        if (I_LastSignal >= 0){
          D_A2_Spec.resize(I_LastSignal - I_FirstSignal + 1,1);
          D_A2_Spec(Range::all(),0) = D_A1_Ap(Range(I_FirstSignal, I_LastSignal));

          #ifdef __DEBUG_FITS_WRITEAPS__
            cout << "CFits::WriteApertures: i_ap = " << i_ap << ": I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": D_A2_Spec = " << D_A2_Spec << endl;
          #endif

          CS_FitsFileName_Out.Set(CS_FitsFileName_Out_Root.GetPChar());
          CS_FitsFileName_Out += CString("_ap");
          delete(P_CS);
          P_CS = CS_FitsFileName_Out.IToA(I_A1_Apertures(i_ap));
          CS_FitsFileName_Out += *P_CS;
          CS_FitsFileName_Out += CString("_x");
          int I_YCenter = int((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) + ((*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) - (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)))/2.);
          cout << "CFits::WriteApertures: (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap=" << i_ap << ")=" << I_A1_Apertures(i_ap) << ") = " << (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) << endl;
          cout << "CFits::WriteApertures: (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap=" << i_ap << ")=" << I_A1_Apertures(i_ap) << ") = " << (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) << endl;
          cout << "CFits::WriteApertures: (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap=" << i_ap << ")=" << I_A1_Apertures(i_ap) << ") = " << (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) << endl;
          cout << "CFits::WriteApertures: I_YCenter = " << I_YCenter << endl;
          cout << "CFits::WriteApertures: P_D_A2_XCenters.rows() = " << P_D_A2_XCenters->rows() << ", P_D_A2_XCenters.cols() = " << P_D_A2_XCenters->cols() << endl;
          delete(P_CS);
          if (i_ap >= I_A1_Apertures.size()){
            cout << "CFits::WriteApertures: ERROR: i_ap=" << i_ap << " >= I_A1_Apertures.size()=" << I_A1_Apertures.size() << " => Returning FALSE" << endl;
            return false;
          }
          if (I_A1_Apertures(i_ap) >= this->P_D_A2_XCenters->rows()){
              cout << "CFits::WriteApertures:ERROR: I_A1_Apertures(i_ap)=" << I_A1_Apertures(i_ap) << " >= this->P_D_A2_XCenters->rows()=" << this->P_D_A2_XCenters->rows() << " => Returning FALSE" << endl;
              return false;
          }
          if (I_YCenter >= this->P_D_A2_XCenters->cols()){
              cout << "CFits::WriteApertures:ERROR: I_YCenter=" << I_YCenter << " >= this->P_D_A2_XCenters->cols()=" << this->P_D_A2_XCenters->cols() << " => Returning FALSE" << endl;
              return false;
          }
          P_CS = CS_FitsFileName_Out.IToA(int((*(this->P_D_A2_XCenters))(I_A1_Apertures(i_ap), I_YCenter)));
          CS_FitsFileName_Out += *P_CS;
          delete(P_CS);
          P_CS = CS_FitsFileName_Out.IToA(I_YCenter);
          CS_FitsFileName_Out += CString("_y");
          CS_FitsFileName_Out += *P_CS;
          CS_FitsFileName_Out += CString(".fits");
          this->WriteFits(&D_A2_Spec,CS_FitsFileName_Out);
          CS_A1_FileNames_Out(i_ap) = CS_FitsFileName_Out;
//          CS_A1_FileNames_Out(I_ArrPos) = CS_FitsFileName_Out;
//          I_ArrPos++;
        }
      }
    }
  }
//  Array<CString, 1> CS_A1_Temp(I_ArrPos);
//  CS_A1_Temp = CS_A1_FileNames_Out(Range(0,I_ArrPos-1));
//  CS_A1_FileNames_Out.resize(I_ArrPos);
//  CS_A1_FileNames_Out = CS_A1_Temp;
  return true;
}

bool CFits::WriteApCenters(const CString &CS_TextFileName_Out) const{
  Array<int, 1> *P_I_A1_Apertures = this->IndGenArr(this->I_NApertures);
  Array<int, 1> I_A1_Apertures(P_I_A1_Apertures->size());
  I_A1_Apertures = (*P_I_A1_Apertures);
  delete(P_I_A1_Apertures);
  return this->WriteApCenters(CS_TextFileName_Out, I_A1_Apertures);
}

bool CFits::WriteApCenters(const CString &CS_TextFileName_Out,
                           const Array<int, 1> &I_A1_Apertures) const{

  Array<double, 2> D_A2_ApCenters_Out(2,2);
  if (!this->GetApertureCenters(I_A1_Apertures, D_A2_ApCenters_Out)){
    cout << "CFits::WriteApCenters: ERROR: GetApertureCenters returned FALSE" << endl;
    return false;
  }

  if (!this->WriteArrayToFile(D_A2_ApCenters_Out, CS_TextFileName_Out, CString("ascii"))){
    cout << "CFits::WriteApCenters: ERROR: WriteArrayToFile returned false" << endl;
    return false;
  }
  return true;
}

bool CFits::WriteApCenters(const CString &CS_FitsFileName_In,
                           const CString &CS_DatabaseFileName_In,
                           const CString &CS_TextFileName_Out) const{
  Array<int, 1> *P_I_A1_Apertures = this->IndGenArr(this->I_NApertures);
  Array<int, 1> I_A1_Apertures(P_I_A1_Apertures->size());
  I_A1_Apertures = (*P_I_A1_Apertures);
  delete(P_I_A1_Apertures);
  return this->WriteApCenters(CS_FitsFileName_In, CS_DatabaseFileName_In, CS_TextFileName_Out, I_A1_Apertures);
}

bool CFits::WriteApCenters(const CString &CS_FitsFileName_In,
                           const CString &CS_DatabaseFileName_In,
                           const CString &CS_TextFileName_Out,
                           const Array<int, 1> &I_A1_Apertures) const{
  CFits F_Image;
  /// Set DatabaseFileName_In
  #ifdef __DEBUG_FITS_WRITEAPCENTERS__
    cout << "MWriteApCenters: Starting F_Image.SetFileName(" << CS_FitsFileName_In << ")" << endl;
  #endif
  if (!F_Image.SetFileName(CS_FitsFileName_In))
  {
    cout << "MWriteApCenters: ERROR: F_Image.SetFileName(" << CS_FitsFileName_In << ") returned FALSE!" << endl;
    return false;
  }

  if (!F_Image.ReadArray()){
    cout << "MWriteApCenters: ERROR: F_Image.ReadArray() returned FALSE!" << endl;
    return false;
  }

  #ifdef __DEBUG_FITS_WRITEAPCENTERS__
    cout << "MWriteApCenters: Starting F_Image.SetDatabaseFileName(" << CS_DatabaseFileName_In << ")" << endl;
  #endif
  if (!F_Image.SetDatabaseFileName(CS_DatabaseFileName_In))
  {
    cout << "MWriteApCenters: ERROR: F_Image.SetDatabaseFileName(" << CS_DatabaseFileName_In << ") returned FALSE!" << endl;
    return false;
  }

  /// Read DatabaseFileName_In
  #ifdef __DEBUG_FITS_WRITEAPCENTERS__
    cout << "MWriteApCenters: Starting F_Image.ReadDatabaseEntry()" << endl;
  #endif
  if (!F_Image.ReadDatabaseEntry())
  {
    cout << "MWriteApCenters: ERROR: F_Image.ReadDatabaseEntry() returned FALSE!" << endl;
    return false;
  }

  /// Calculate Trace Functions
  if (!F_Image.CalcTraceFunctions()){
    cout << "MWriteApCenters: ERROR: CalcTraceFunctions() returned FALSE" << endl;
    return false;
  }

  return F_Image.WriteApCenters(CS_TextFileName_Out,
                                I_A1_Apertures);

}

bool CFits::DispCorList(const Array<CString, 1>& CS_A1_TextFiles_Coeffs_In,
                        const Array<CString, 1>& CS_A1_TextFiles_EcD_Out,
                        const double D_MaxRMS_In){
  Array<int, 1> *P_I_A1_Apertures = this->IndGenArr(this->I_NApertures);
  Array<int, 1> I_A1_Apertures(P_I_A1_Apertures->size());
  I_A1_Apertures = *P_I_A1_Apertures;
  delete(P_I_A1_Apertures);
  return this->DispCorList(CS_A1_TextFiles_Coeffs_In, CS_A1_TextFiles_EcD_Out, D_MaxRMS_In, I_A1_Apertures);
}

bool CFits::DispCorList(const Array<CString, 1>& CS_A1_TextFiles_Coeffs_In,
                        const Array<CString, 1>& CS_A1_TextFiles_EcD_Out,
                        const double D_MaxRMS_In,
                        const Array<int, 1> &I_A1_Apertures){
  return this->DispCorList(CS_A1_TextFiles_Coeffs_In,
                           CS_A1_TextFiles_EcD_Out,
                           D_MaxRMS_In,
                           0.,
                           I_A1_Apertures);
}

/**
 * Apply pixel shift to original object spectra
 **/      
bool CFits::DispCorList(const Array<CString, 1>& CS_A1_TextFiles_Coeffs_In,
                        const Array<CString, 1>& CS_A1_TextFiles_EcD_Out,
                        const double D_MaxRMS_In,
                        const double D_PixShift_In,
                        const Array<int, 1> &I_A1_Apertures){

  if (!this->TraceFunctionsCalculated){
    cout << "CFits::DispCorList: ERROR: Trace functions not calculated yet" << endl;
    return false;
  }

  if (I_A1_Apertures.size() != CS_A1_TextFiles_EcD_Out.size()){
    cout << "CFits::DispCorList: ERROR: I_A1_Apertures.size(=" << I_A1_Apertures.size() << ") != CS_A1_TextFiles_EcD_Out(=" << CS_A1_TextFiles_EcD_Out << ").size(=" << CS_A1_TextFiles_EcD_Out.size() << ")" << endl;
    return false;
  }

  /// read aperture number of CS_A1_TextFiles_Coeffs_In
  Array<int, 1> I_A1_ApNums_Coeffs(CS_A1_TextFiles_Coeffs_In.size());
  CString *P_CS_ApNum;
  CString CS_UnderScore("_");
  int I_StrStart, I_StrEnd;
  for (int i=0; i < CS_A1_TextFiles_Coeffs_In.size(); i++){
    I_StrStart = (CS_A1_TextFiles_Coeffs_In(i)).StrPos(CString("_ap"))+3;
    if (I_StrStart < 4){
      cout << "CFits::DispCorList: i=" << i << ": ERROR: aperture number not found in filename " << CS_A1_TextFiles_Coeffs_In(i) << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_DISPCOR__
      cout << "CFits::DispCorList: i=" << i << ": I_StrStart = " << I_StrStart << endl;
    #endif

    I_StrEnd = (CS_A1_TextFiles_Coeffs_In(i)).StrPosFrom(CS_UnderScore.GetPChar(),I_StrStart)-1;
    if (I_StrEnd < 4){
      cout << "CFits::DispCorList: i=" << i << ": ERROR: aperture number not found in filename " << CS_A1_TextFiles_Coeffs_In(i) << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_DISPCOR__
      cout << "CFits::DispCorList: i=" << i << ": I_StrEnd = " << I_StrEnd << endl;
    #endif

    P_CS_ApNum = (CS_A1_TextFiles_Coeffs_In(i)).SubString(I_StrStart, I_StrEnd);
    I_A1_ApNums_Coeffs(i) = atoi(P_CS_ApNum->GetPChar());
    delete(P_CS_ApNum);
    #ifdef __DEBUG_FITS_DISPCOR__
      cout << "CFits::DispCorList: i=" << i << ": I_A1_ApNums_Coeffs(i) set to " << I_A1_ApNums_Coeffs(i) << endl;
    #endif
  }
  #ifdef __DEBUG_FITS_DISPCOR__
    cout << "CFits::DispCorList: I_A1_ApNums_Coeffs set to " << I_A1_ApNums_Coeffs << endl;
  #endif

  Array<CString, 1> CS_A1_Coeffs(2);
  int I_CoeffFileNo, I_NInd;
  Array<double, 1> D_A1_Spec(1);
  Array<double, 2> D_A2_SpecCalib_Out(2,2);
  Array<double, 1> D_A1_PolyFitCoeffs_In(2);
  double D_RMS_In;
  Array<int, 1> I_A1_Ind(I_A1_ApNums_Coeffs.size());
  Array<int, 1> *P_I_A1_IndPos;
  CString *P_CS_RMS;
  Array<double, 1> *P_D_A1_PixNum;
  Array<double, 1> *P_D_A1_WLen;
  Array<CString, 1> CS_A1_Spec(1);

  for (int i_ap=0; i_ap < I_A1_Apertures.size(); i_ap++){
    D_A1_Spec.resize((*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) - (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) + 1);
    D_A1_Spec = ((const_cast<CFits*>(this))->GetPixArray())(I_A1_Apertures(i_ap), Range((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)), (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap))));
    #ifdef __DEBUG_FITS_DISPCOR__
      cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": D_A1_Spec set to " << D_A1_Spec << endl;
    #endif
    /// check aperture number of coefficients files (I_A1_ApNums_Coeffs) for i_ap
    I_A1_Ind = where(I_A1_ApNums_Coeffs == I_A1_Apertures(i_ap),1,0);
    P_I_A1_IndPos = this->GetIndex(I_A1_Ind, I_NInd);
    #ifdef __DEBUG_FITS_DISPCOR__
      cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << " :P_I_A1_IndPos = " << *P_I_A1_IndPos << endl;
    #endif
    if (I_NInd != 1){
      cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": i_ap = " << i_ap << ": WARNING: I_A1_Apertures(i_ap) not found in coefficients files" << endl;
      delete(P_I_A1_IndPos);
    }
    else{
      I_CoeffFileNo = (*P_I_A1_IndPos)(0);
      delete(P_I_A1_IndPos);
      /// Read Polynomial coefficients
      #ifdef __DEBUG_FITS_DISPCOR__
        cout << "CFits::DispCorList: I_A1_Apertures(i_ap)=" << I_A1_Apertures(i_ap) << ": Reading coeff file " << CS_A1_TextFiles_Coeffs_In(I_CoeffFileNo) << endl;
      #endif
      if (!this->ReadFileLinesToStrArr(CS_A1_TextFiles_Coeffs_In(I_CoeffFileNo), CS_A1_Coeffs)){
        cout << "CFits::DispCorList: WARNING: ReadFileLinesToStrArr(" << CS_A1_TextFiles_Coeffs_In(I_CoeffFileNo) << ") returned FALSE" << endl;
      }
      else{
        #ifdef __DEBUG_FITS_DISPCOR__
          cout << "CFits::DispCorList: I_A1_Apertures(i_ap)=" << I_A1_Apertures(i_ap) << ": CS_A1_Coeffs = " << CS_A1_Coeffs << endl;
        #endif

        /// populate D_A1_PolyFitCoeffs_In array
        D_A1_PolyFitCoeffs_In.resize(CS_A1_Coeffs.size()-1);
        if (!CS_UnderScore.AToD(CS_A1_Coeffs(Range(0,CS_A1_Coeffs.size()-2)), D_A1_PolyFitCoeffs_In)){
          cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": ERROR: Could not convert CS_A1_Coeffs to double array" << endl;
          return false;
        }
        #ifdef __DEBUG_FITS_DISPCOR__
          cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": D_A1_PolyFitCoeffs_In set to " << D_A1_PolyFitCoeffs_In << endl;
        #endif

        /// Read RMS
        P_CS_RMS = (CS_A1_Coeffs(CS_A1_Coeffs.size()-1)).SubString(4);
        D_RMS_In = P_CS_RMS->AToD();
        delete(P_CS_RMS);
        #ifdef __DEBUG_FITS_DISPCOR__
          cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": D_RMS_In = " << D_RMS_In << endl;
        #endif

        if ((D_RMS_In <= D_MaxRMS_In) && (D_RMS_In >= 0.000001)){
//          P_D_A1_PixNum = F_Image.DIndGenArr(D_A1_Spec.size());
//          P_D_A1_WLen = F_Image.Poly(*P_D_A1_PixNum, D_A1_PolyFitCoeffs_In);
//          D_A2_SpecCalib_Out.resize(P_D_A1_WLen->size(),2);
//          D_A2_SpecCalib_Out(Range::all(),0) = *P_D_A1_WLen;
//          D_A2_SpecCalib_Out(Range::all(),1) = D_A1_Spec;
          #ifdef __DEBUG_FITS_DISPCOR__
            cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": D_A1_Spec = " << D_A1_Spec << endl;
          #endif
          if (!this->DispCor(D_A1_Spec, 
                             D_A1_PolyFitCoeffs_In, 
                             D_PixShift_In, 
                             D_A2_SpecCalib_Out)){
            cout << "CFits::DispCorList: ERROR: DispCor returned FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_DISPCOR__
            cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": D_A2_SpecCalib_Out = " << D_A2_SpecCalib_Out << endl;
            cout << "CFits::DispCorList: Writing CS_A1_TextFiles_EcD_Out(i_ap=" << i_ap << ") = <" << CS_A1_TextFiles_EcD_Out(i_ap) << ">" << endl;
          #endif
          if (!this->WriteArrayToFile(D_A2_SpecCalib_Out, CS_A1_TextFiles_EcD_Out(i_ap), CString("ascii"))){
            cout << "CFits::DispCorList: I_A1_Apertures(i_ap) = " << I_A1_Apertures(i_ap) << ": Error: Could not write " << CS_A1_TextFiles_EcD_Out(i_ap) << endl;
            return false;
          }
          if (i_ap >= I_A1_Apertures.size()){
              cout << "CFits::DispCorList: ERROR: i_ap=" << i_ap << " >= I_A1_Apertures.size()=" << I_A1_Apertures.size() << " => Returning FALSE" << endl;
              return false;
          }
          if (I_A1_Apertures(i_ap) >= this->P_D_A1_YCenter->size()){
              cout << "CFits::DispCorList: ERROR: I_A1_Apertures(i_ap)=" << I_A1_Apertures(i_ap) << " >= this->P_D_A1_YCenter->size()=" << this->P_D_A1_YCenter->size() << " => Returning FALSE" << endl;
              return false;
          }
          if (I_A1_Apertures(i_ap) >= this->P_D_A2_WLen->rows()){
              cout << "CFits::DispCorList: ERROR: I_A1_Apertures(i_ap)=" << I_A1_Apertures(i_ap) << " >= this->P_D_A2_WLen->rows()=" << this->P_D_A2_WLen->rows() << " => Returning FALSE" << endl;
              return false;
          }
          if (((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) < 0) || ((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) >= this->P_D_A2_WLen->cols())){
              cout << "CFits::DispCorList: ERROR: ((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap))(=" << (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) << ") + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap))(=" << (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) << ") = " << (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) << " < 0) || ((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap))=" << (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) << " >= this->P_D_A2_WLen->cols()=" << this->P_D_A2_WLen->cols() << ") => Returning FALSE" << endl;
              return false;
          }
          if (((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) < 0) || ((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) >= this->P_D_A2_WLen->cols())){
              cout << "CFits::DispCorList: ERROR: ((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap))(=" << (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) << ") + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap))(=" << (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) << ") = " << (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) << " < 0) || ((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap))=" << (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) << " >= this->P_D_A2_WLen->cols()=" << this->P_D_A2_WLen->cols() << ") => Returning FALSE" << endl;
              return false;
          }
          (*(this->P_D_A2_WLen))(I_A1_Apertures(i_ap), Range((*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)), (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)))) = D_A2_SpecCalib_Out(Range::all(), 0);
          #ifdef __DEBUG_FITS_DISPCOR__
            cout << "CFits::DispCorList: D_A2_SpecCalib_Out = " << D_A2_SpecCalib_Out << endl;
	    cout << "CFits::DispCorList: (*(this->P_D_A2_WLen))(I_A1_Apertures(i_ap), Range::all()) = " << (*(this->P_D_A2_WLen))(I_A1_Apertures(i_ap), Range::all()) << endl;
          #endif
//	  return false;
//          delete(P_D_A1_PixNum);
//          delete(P_D_A1_WLen);
        }
      }
    }
  }

  /// clean up

  return true;
}

bool CFits::RebinTextList(const Array<CString, 1> &CS_A1_TextFileNames_EcD_In,
                          const Array<CString, 1> &CS_A1_TextFileNames_EcDR_Out,
                          const CString &CS_FitsFileName_EcDR_Out,
                          double D_Lambda_Start,
                          double D_Lambda_End,
                          double D_DLambda) const{
  return this->RebinTextList(CS_A1_TextFileNames_EcD_In,
                             CS_A1_TextFileNames_EcDR_Out,
                             CS_FitsFileName_EcDR_Out,
                             D_Lambda_Start,
                             D_Lambda_End,
                             D_DLambda,
                             false);
}

bool CFits::RebinTextList(const Array<CString, 1> &CS_A1_TextFileNames_EcD_In,
                          const Array<CString, 1> &CS_A1_TextFileNames_EcDR_Out,
                          const CString &CS_FitsFileName_EcDR_Out,
                          double D_Lambda_Start,
                          double D_Lambda_End,
                          double D_DLambda,
                          bool B_PreserveFlux) const{
  CFits F_Image;

  if (CS_A1_TextFileNames_EcD_In.size() != CS_A1_TextFileNames_EcDR_Out.size()){
    cout << "CFits::RebinTextList: ERROR: CS_A1_TextFileNames_EcD_In.size(=" << CS_A1_TextFileNames_EcD_In.size() << ") != CS_A1_TextFileNames_EcDR_Out.size(=" << CS_A1_TextFileNames_EcDR_Out.size() << ")" << endl;
    return false;
  }

  Array<double, 2> D_A2_Spec(2,2);
  #ifdef __DEBUG_FITS_REBIN__
    cout << "CFits::RebinTextList: D_Lambda_Start = " << D_Lambda_Start << endl;
    cout << "CFits::RebinTextList: D_Lambda_End = " << D_Lambda_End << endl;
    cout << "CFits::RebinTextList: D_DLambda = " << D_DLambda << endl;
  #endif
  int I_NElements = int((D_Lambda_End - D_Lambda_Start) / D_DLambda);
  #ifdef __DEBUG_FITS_REBIN__
    cout << "CFits::RebinTextList: I_NElements = " << I_NElements << endl;
  #endif
  Array<double, 1> D_A1_Lambda(I_NElements);
  Array<double, 1> D_A1_SpecOut(1);
  D_A1_Lambda(0) = D_Lambda_Start;
  for (int i_pix=1; i_pix<I_NElements; i_pix++)
    D_A1_Lambda(i_pix) = D_A1_Lambda(i_pix-1) + D_DLambda;
  #ifdef __DEBUG_FITS_REBIN__
    cout << "CFits::RebinTextList: D_A1_Lambda = " << D_A1_Lambda << endl;
  #endif
  CString CS_TextFileName_EcD_In, CS_TextFileName_EcDR_Out;

  ///Adjust size of output fits file
  if (!F_Image.SetFileName(CS_FitsFileName_EcDR_Out)){
    cout << "CFits::RebinTextList: Error: F_Image.SetFileName(" << CS_FitsFileName_EcDR_Out << ") returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_REBIN__
    cout << "CFits::RebinTextList: F_Image.SetFileName(" << CS_FitsFileName_EcDR_Out << ") finished" << endl;
  #endif
  if (!F_Image.SetNRows(CS_A1_TextFileNames_EcD_In.size())){
    cout << "CFits::RebinTextList: Error: F_Image.SetNRows(" << CS_A1_TextFileNames_EcD_In.size() << ") returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_REBIN__
    cout << "CFits::RebinTextList: F_Image.SetNRows(" << CS_A1_TextFileNames_EcD_In.size() << ") finished" << endl;
    cout << "CFits::RebinTextList: CS_A1_TextFileNames_EcD_In.size() = " << CS_A1_TextFileNames_EcD_In.size() << endl;
  #endif
  if (!F_Image.Set_NApertures(CS_A1_TextFileNames_EcD_In.size())){
    cout << "CFits::RebinTextList: Error: F_Image.Set_NApertures(" << CS_A1_TextFileNames_EcD_In.size() << ") returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_REBIN__
    cout << "CFits::RebinTextList: F_Image.SetNApertures(" << CS_A1_TextFileNames_EcD_In.size() << ") finished" << endl;
  #endif
  if (!F_Image.SetNCols(I_NElements)){
    cout << "CFits::RebinTextList: Error: F_Image.SetNCols(" << I_NElements << ") returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_REBIN__
    cout << "CFits::RebinTextList: F_Image.SetNCols(" << I_NElements << ") finished" << endl;
  #endif
  if (F_Image.GetNRows() != CS_A1_TextFileNames_EcD_In.size()){
    cout << "CFits::RebinTextList: ERROR: F_Image.GetNRows(=" << F_Image.GetNRows() << ") != CS_A1_TextFileNames_EcD_In.size(=" << CS_A1_TextFileNames_EcD_In.size() << ") => Returning FALSE" << endl;
    return false;
  }
  F_Image.GetWavelengths().resize(CS_A1_TextFileNames_EcD_In.size(), I_NElements);
  #ifdef __DEBUG_FITS_REBIN__
    cout << "CFits::RebinTextList: F_Image.GetWavelengths().resize(" << CS_A1_TextFileNames_EcD_In.size() << ", " << I_NElements << ") finished" << endl;
  #endif
  if (F_Image.GetWavelengths().rows() != CS_A1_TextFileNames_EcD_In.size()){
    cout << "CFits::RebinTextList: ERROR: F_Image.GetWavelengths().rows(=" << F_Image.GetWavelengths().rows() << ") != CS_A1_TextFileNames_EcD_In.size(=" << CS_A1_TextFileNames_EcD_In.size() << ") => Returning FALSE" << endl;
    return false;
  }
  bool B_BadSpec = false;
  for (int i_file=0; i_file < CS_A1_TextFileNames_EcD_In.size(); i_file++){
    B_BadSpec = false;
    CS_TextFileName_EcD_In = CS_A1_TextFileNames_EcD_In(i_file);
    CS_TextFileName_EcDR_Out = CS_A1_TextFileNames_EcDR_Out(i_file);
    ///Read spectrum
    if (CS_TextFileName_EcD_In.FileAccess(CS_TextFileName_EcD_In)){
      if (!F_Image.ReadFileToDblArr(CS_TextFileName_EcD_In, D_A2_Spec, CString(" "))){
        cout << "CFits::RebinTextList: ERROR: ReadFileToDblArr(" << CS_TextFileName_EcD_In << ") returned FALSE" << endl;
        return false;
      }
      #ifdef __DEBUG_FITS_REBIN__
        cout << "CFits::RebinTextList: D_A2_Spec = " << D_A2_Spec << endl;
      #endif
      if ((min(D_A2_Spec(Range::all(), 0)) > D_Lambda_End) || (max(D_A2_Spec(Range::all(), 0)) < D_Lambda_Start)){
        cout << "CFits::RebinTextList: WARNING: (min(D_A2_Spec(Range::all(), 0))=" << min(D_A2_Spec(Range::all(), 0)) << " > D_Lambda_End=" << D_Lambda_End << ") || (max(D_A2_Spec(Range::all(), 0))=" << max(D_A2_Spec(Range::all(), 0)) << " < D_Lambda_Start=" << D_Lambda_Start << ") => Setting D_A1_SpecOut to 0" << endl;
        B_BadSpec = true;
      }
      ///Interpolate input spectrum
      if (!F_Image.InterPol(D_A2_Spec(Range::all(), 1), D_A2_Spec(Range::all(),0), D_A1_Lambda, D_A1_SpecOut, B_PreserveFlux)){
        cout << "CFits::RebinTextList: ERROR: InterPol returned FALSE" << endl;
        return false;
      }
      #ifdef __DEBUG_FITS_REBIN__
        cout << "CFits::RebinTextList: D_A1_SpecOut = " << D_A1_SpecOut << endl;
      #endif

      ///write calibrated spectrum as text file
      Array<double, 2> D_A2_SpecOut(D_A1_Lambda.size(),2);
      D_A2_SpecOut(Range::all(),0) = D_A1_Lambda;
      if (B_BadSpec){
        D_A2_SpecOut(Range::all(), 1) = 0.;
      }
      else{
        D_A2_SpecOut(Range::all(),1) = D_A1_SpecOut;
      }
      cout << "CFits::RebinTextList: Writing " << CS_TextFileName_EcDR_Out << endl;
      if (!F_Image.WriteArrayToFile(D_A2_SpecOut, CS_TextFileName_EcDR_Out, CString("ascii"))){
        cout << "CFits::RebinTextList: ERROR: WriteArrayToFile(spec) returned FALSE" << endl;
        return false;
      }

      ///write calibrated spectrum to according row in fits file
      if (F_Image.GetNCols() != D_A1_Lambda.size()){
	cout << "CFits::RebinTextList: ERROR: F_Image.GetNCols(=" << F_Image.GetNCols() << ") != D_A1_Lambda.size(=" << D_A1_Lambda.size() << ") => Returning FALSE" << endl;
	return false;
      }
      F_Image.GetPixArray()(i_file, Range::all()) = D_A1_SpecOut;
      if (F_Image.GetWavelengths().cols() != D_A1_Lambda.size()){
	cout << "CFits::RebinTextList: ERROR: F_Image.GetWavelengths().cols(=" << F_Image.GetWavelengths().cols() << ") != D_A1_Lambda.size(=" << D_A1_Lambda.size() << ") => Returning FALSE" << endl;
	return false;
      }
      F_Image.GetWavelengths()(i_file, Range::all()) = D_A1_Lambda;
    }
  }

  /// write output fits file
  if (!F_Image.WriteArray()){
    cout << "CFits::RebinTextList: Error: F_Image.WriteArray() returned FALSE" << endl;
    return false;
  }

  cout << "CFits::RebinTextList: Task finished" << endl;
  /// clean up
  return true;
}

bool CFits::CollapseSpectra(const Array<CString, 1> &CS_A1_TextFileNameList_ap_x_y_In,
                            const CString &CS_TextFileName_Out) const{
  Array<double, 2> D_A2_Spec(1,1);
  Array<double, 2> D_A2_Spectra(CS_A1_TextFileNameList_ap_x_y_In.size(), 4);
  D_A2_Spectra = 0.;
  int I_Ap = 0;
  int I_X = 0;
  int I_Y = 0;
  CString *P_CS_Temp = new CString(" ");
  int I_Pos_X = 0;
  int I_Pos_Y = 0;
  int I_Pos_End = 0;

  for (int i_row=0; i_row<CS_A1_TextFileNameList_ap_x_y_In.size(); i_row++){
    I_Pos_X = CS_A1_TextFileNameList_ap_x_y_In(i_row).LastStrPos(CString("_ap"))+3;
    P_CS_Temp->Set("_x");
    I_Pos_Y = CS_A1_TextFileNameList_ap_x_y_In(i_row).StrPosFrom(P_CS_Temp->Get(), I_Pos_X)+2;
    delete(P_CS_Temp);
    P_CS_Temp = CS_A1_TextFileNameList_ap_x_y_In(i_row).SubString(I_Pos_X, I_Pos_Y-3);
    I_Ap = P_CS_Temp->AToI();
    delete(P_CS_Temp);

    I_Pos_X = CS_A1_TextFileNameList_ap_x_y_In(i_row).LastStrPos(CString("_x"))+2;
    P_CS_Temp = CS_A1_TextFileNameList_ap_x_y_In(i_row).SubString(I_Pos_X, CS_A1_TextFileNameList_ap_x_y_In(i_row).LastStrPos(CString("_y"))-1);
//    cout << "CFits::CollapseSpectra: CS_A1_TextFileNameList_ap_x_y_In(" << i_row << ") = " << CS_A1_TextFileNameList_ap_x_y_In(i_row) << endl;
//    cout << "CFits::CollapseSpectra: *P_CS_Temp = " << *P_CS_Temp << endl;
    I_X = P_CS_Temp->AToI();
    P_CS_Temp->Set("_y");
    I_Pos_Y = CS_A1_TextFileNameList_ap_x_y_In(i_row).StrPosFrom(P_CS_Temp->Get(), I_Pos_X)+2;
//    delete(P_CS_Temp);
//    P_CS_Temp = CS_A1_TextFileNameList_ap_x_y_In(i_row).SubString(I_Pos_X, I_Pos_Y-3);
//    I_X = P_CS_Temp->AToI();

    P_CS_Temp->Set("_");
    I_Pos_End = CS_A1_TextFileNameList_ap_x_y_In(i_row).StrPosFrom(P_CS_Temp->Get(), I_Pos_Y);
    P_CS_Temp->Set(".");
    if (I_Pos_End < 0)
      I_Pos_End = CS_A1_TextFileNameList_ap_x_y_In(i_row).StrPosFrom(P_CS_Temp->Get(), I_Pos_Y);
    delete(P_CS_Temp);
    P_CS_Temp = CS_A1_TextFileNameList_ap_x_y_In(i_row).SubString(I_Pos_Y, I_Pos_End-1);
    I_Y = P_CS_Temp->AToI();
//    cout << "CFits::CollapseSpectra: I_X = " << I_X << ", I_Y = " << I_Y << endl;
//    return false;

    D_A2_Spectra(i_row, 0) = double(I_Ap);
    D_A2_Spectra(i_row, 1) = double(I_X);
    D_A2_Spectra(i_row, 2) = double(I_Y);
    if (P_CS_Temp->FileAccess(CS_A1_TextFileNameList_ap_x_y_In(i_row))){
      if (!P_CS_Temp->ReadFileToDblArr(CS_A1_TextFileNameList_ap_x_y_In(i_row), D_A2_Spec, CString(" "))){
        cout << "MCollapseSpectra: ERROR: ReadFileToDblArr(" << CS_A1_TextFileNameList_ap_x_y_In(i_row) << ") returned FALSE" << endl;
        return false;
      }
      D_A2_Spectra(i_row, 3) = sum(D_A2_Spec(Range::all(),1));
    }
    else{
      D_A2_Spectra(i_row, 3) = 0.;
    }
  }
  delete(P_CS_Temp);

  if (!this->WriteArrayToFile(D_A2_Spectra, CS_TextFileName_Out, CString("ascii"))){
    cout << "MCollapseSpectra: ERROR: WriteArrayToFile(spec) returned FALSE" << endl;
    return false;
  }

  return true;
}

bool CFits::FindApsInCircle(const int I_CenterX_In,
                            const int I_CenterY_In,
                            const int I_Radius_In,
                            Array<int, 1> &I_A1_Apertures_Out) const{
  Array<int, 1> I_A1_Area(4);
  I_A1_Area(0) = 0;
  I_A1_Area(1) = this->NCols-1;
  I_A1_Area(2) = 0;
  I_A1_Area(3) = this->NRows-1;
  return FindApsInCircle(I_CenterX_In,
                         I_CenterY_In,
                         I_Radius_In,
                         I_A1_Area,
                         I_A1_Apertures_Out);
}


bool CFits::FindApsInCircle(const int I_CenterX_In,
                            const int I_CenterY_In,
                            const int I_Radius_In,
                            const Array<int, 1> &I_A1_Area_In,
                            Array<int, 1> &I_A1_Apertures_Out) const{
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::FindApsInCircle: ERROR: Trace functions not calculated yet" << endl;
    return false;
  }
  Array<double, 1> D_A1_YCenter(this->P_D_A1_YCenter->size());
  D_A1_YCenter = (*(this->P_D_A1_YCenter)) + (*(this->P_D_A1_YLow)) + ((*(this->P_D_A1_YHigh)) + (*(this->P_D_A1_YLow))) / 2.;
  Array<double, 1> D_A1_XCenter(P_D_A1_YHigh->size());
  for (int i_ap=0; i_ap<P_D_A1_YCenter->size(); i_ap++)
    D_A1_XCenter(i_ap) = (*P_D_A2_XCenters)(i_ap,(int)(D_A1_YCenter(i_ap)));

  Array<int, 1> I_A1_IndicesInArea(D_A1_XCenter.size());
  I_A1_IndicesInArea = where((D_A1_XCenter >= I_A1_Area_In(0)) && (D_A1_XCenter <= I_A1_Area_In(1)) && (D_A1_YCenter >= I_A1_Area_In(2)) && (D_A1_YCenter <= I_A1_Area_In(3)), 1, 0);
  int I_NIndicesInArea = 0;
  Array<int, 1> *P_I_A1_IndicesInArea = this->GetIndex(I_A1_IndicesInArea, I_NIndicesInArea);
  Array<double, 1> D_A1_XCentersInArea(I_NIndicesInArea);
  if (!this->GetSubArrCopy(D_A1_XCenter, *P_I_A1_IndicesInArea, D_A1_XCentersInArea)){
    cout << "CFits::FindApsInCircle: ERROR: GetSubArrCopy(D_A1_XCenter, " << *P_I_A1_IndicesInArea << ") returned FALSE" << endl;
    return false;
  }
  Array<double, 1> D_A1_YCentersInArea(I_NIndicesInArea);
  if (!this->GetSubArrCopy(D_A1_YCenter, *P_I_A1_IndicesInArea, D_A1_YCentersInArea)){
    cout << "CFits::FindApsInCircle: ERROR: GetSubArrCopy(D_A1_YCenter, " << *P_I_A1_IndicesInArea << ") returned FALSE" << endl;
    return false;
  }
  
  Array<double, 1> D_A1_Radius(D_A1_YCentersInArea.size());
  D_A1_Radius = sqrt(pow2(D_A1_XCentersInArea - double(I_CenterX_In)) + pow2(D_A1_YCentersInArea - double(I_CenterY_In)));

  int I_NInd;
  Array<int, 1> I_A1_Where(D_A1_Radius.size());
  I_A1_Where = where(D_A1_Radius < double(I_Radius_In), 1, 0);
  Array<int, 1> *P_I_A1_Index = this->GetIndex(I_A1_Where, I_NInd);
  if (I_NInd < 0){
    cout << "CFits::FindApsInCircle: ERROR: I_NInd = " << I_NInd << endl;
    return false;
  }
  #ifdef __DEBUG_CFITS_FINDAPSINCIRCLE__
    cout << "CFits::FindApsInCircle: P_I_A1_Index = " << *P_I_A1_Index << endl;
  #endif
  I_A1_Apertures_Out.resize(I_NInd);
  if (!this->GetSubArrCopy((*P_I_A1_IndicesInArea), (*P_I_A1_Index), I_A1_Apertures_Out)){
    cout << "CFits::FindApsInCircle: ERROR: GetSubArrCopy(P_I_A1_IndicesInArea(=" << *P_I_A1_IndicesInArea << "), P_I_A1_Index(=" << *P_I_A1_Index << "), I_A1_Apertures_Out) returned FALSE" << endl;
    return false;
  }

//  if (!this->WriteArrayToFile(*P_I_A1_Index, CS_FileListName_Out, CString("ascii"))){
//    cout << "MFindApsInCirc: ERROR: WriteArrayToFile(P_I_A1_Index, " << CS_FileListName_Out << ") returned FALSE" << endl;
//    exit(EXIT_FAILURE);
//  }
  delete(P_I_A1_Index);
  delete(P_I_A1_IndicesInArea);
  return true;
}

bool CFits::FindApsInRing(const int I_CenterX_In,
                          const int I_CenterY_In,
                          const int I_InnerRadius_In,
                          const int I_OuterRadius_In,
                          Array<int, 1> &I_A1_Apertures_Out) const{
  Array<int, 1> I_A1_Area(4);
  I_A1_Area(0) = 0;
  I_A1_Area(1) = this->NCols-1;
  I_A1_Area(2) = 0;
  I_A1_Area(3) = this->NRows-1;
  return this->FindApsInRing(I_CenterX_In,
                             I_CenterY_In,
                             I_InnerRadius_In,
                             I_OuterRadius_In,
                             I_A1_Area,
                             I_A1_Apertures_Out);
}


bool CFits::FindApsInRing(const int I_CenterX_In,
                          const int I_CenterY_In,
                          const int I_InnerRadius_In,
                          const int I_OuterRadius_In,
                          const Array<int, 1> &I_A1_Area_In,
                          Array<int, 1> &I_A1_Apertures_Out) const{
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::FindApsInRing: ERROR: Trace functions not calculated yet" << endl;
    return false;
  }
  Array<double, 1> D_A1_YCenter(this->P_D_A1_YCenter->size());
  D_A1_YCenter = (*(this->P_D_A1_YCenter)) + (*(this->P_D_A1_YLow)) + ((*(this->P_D_A1_YHigh)) + (*(this->P_D_A1_YLow))) / 2.;
  Array<double, 1> D_A1_XCenter(P_D_A1_YHigh->size());
  for (int i_ap=0; i_ap<P_D_A1_YCenter->size(); i_ap++)
  D_A1_XCenter(i_ap) = (*P_D_A2_XCenters)(i_ap,(int)(D_A1_YCenter(i_ap)));
  
  Array<int, 1> I_A1_IndicesInArea(D_A1_XCenter.size());
  I_A1_IndicesInArea = where((D_A1_XCenter >= I_A1_Area_In(0)) && (D_A1_XCenter <= I_A1_Area_In(1)) && (D_A1_YCenter >= I_A1_Area_In(2)) && (D_A1_YCenter <= I_A1_Area_In(3)), 1, 0);
  int I_NIndicesInArea = 0;
  Array<int, 1> *P_I_A1_IndicesInArea = this->GetIndex(I_A1_IndicesInArea, I_NIndicesInArea);
  Array<double, 1> D_A1_XCentersInArea(I_NIndicesInArea);
  if (!this->GetSubArrCopy(D_A1_XCenter, *P_I_A1_IndicesInArea, D_A1_XCentersInArea)){
    cout << "CFits::FindApsInCircle: ERROR: GetSubArrCopy(D_A1_XCenter, " << *P_I_A1_IndicesInArea << ") returned FALSE" << endl;
    return false;
  }
  Array<double, 1> D_A1_YCentersInArea(I_NIndicesInArea);
  if (!this->GetSubArrCopy(D_A1_YCenter, *P_I_A1_IndicesInArea, D_A1_YCentersInArea)){
    cout << "CFits::FindApsInCircle: ERROR: GetSubArrCopy(D_A1_YCenter, " << *P_I_A1_IndicesInArea << ") returned FALSE" << endl;
    return false;
  }
  
  Array<double, 1> D_A1_Radius(D_A1_YCentersInArea.size());
  D_A1_Radius = sqrt(pow2(D_A1_XCentersInArea - double(I_CenterX_In)) + pow2(D_A1_YCentersInArea - double(I_CenterY_In)));

  int I_NInd;
  Array<int, 1> I_A1_Where(D_A1_Radius.size());
  I_A1_Where = where(D_A1_Radius > double(I_InnerRadius_In) && D_A1_Radius < double(I_OuterRadius_In), 1, 0);
  Array<int, 1> *P_I_A1_Index = this->GetIndex(I_A1_Where, I_NInd);
  if (I_NInd < 0){
    cout << "CFits::FindApsInRing: ERROR: I_NInd = " << I_NInd << endl;
    return false;
  }
  #ifdef __DEBUG_CFITS_FINDAPSINRING__
    cout << "CFits::FindApsInRing: P_I_A1_Index = " << *P_I_A1_Index << endl;
  #endif
  I_A1_Apertures_Out.resize(P_I_A1_Index->size());
  if (!this->GetSubArrCopy(*P_I_A1_IndicesInArea, *P_I_A1_Index, I_A1_Apertures_Out)){
    cout << "CFits::FindApsInRing: ERROR: GetSubArrCopy(P_I_A1_IndicesInArea(=" << *P_I_A1_IndicesInArea << "), P_I_A1_Index(=" << *P_I_A1_Index << "), I_A1_Apretures_Out) returned FALSE" << endl;
    return false;
  }
//  if (!F_Image.WriteArrayToFile(*P_I_A1_Index, CS_FileListName_Out, CString("ascii"))){
//    cout << "MFindApsInRing: ERROR: WriteArrayToFile(P_I_A1_Index, " << CS_FileListName_Out << ") returned FALSE" << endl;
//    exit(EXIT_FAILURE);
//  }
  delete(P_I_A1_Index);
  delete(P_I_A1_IndicesInArea);
  return true;
}

bool CFits::Reverse(Array<double, 1> D_A1_InOut) const{
  if (D_A1_InOut.size() < 1){
    cout << "CFits::Reverse: ERROR: D_A1_InOut.size(=" << D_A1_InOut.size() << ") < 1 => Returning FALSE" << endl;
    return false;
  }
  Array<double, 1> D_A1_Out(D_A1_InOut.size());
  for (int i=0; i<D_A1_InOut.size(); i++){
    D_A1_Out(i) = D_A1_InOut(D_A1_InOut.size() - i - 1);
  }
  D_A1_InOut = D_A1_Out;
  return true;
}

bool CFits::Reverse(Array<double, 2> D_A2_InOut) const{
  if (D_A2_InOut.rows() < 1){
    cout << "CFits::Reverse: ERROR: D_A2_InOut.rows(=" << D_A2_InOut.rows() << ") < 1 => Returning FALSE" << endl;
    return false;
  }
  Array<double, 2> D_A2_Out(D_A2_InOut.rows(), D_A2_InOut.cols());
  if (D_A2_InOut.rows() > 1){
    for (int i=0; i<D_A2_InOut.rows(); i++){
      D_A2_Out(i, Range::all()) = D_A2_InOut(D_A2_InOut.rows() - i - 1, Range::all());
    }
    D_A2_InOut = D_A2_Out;
  }
  else{
    Array<double, 1> D_A1_Out(D_A2_InOut.cols());
    D_A1_Out = D_A2_InOut(0, Range::all());
    this->Reverse(D_A1_Out);
    D_A2_InOut(0, Range::all()) = D_A1_Out;
  }
  return true;
}

/// converts Number of Photons vs Wavelength to Flux vs Wavelength
bool CFits::PhotonsToFlux(const Array<double, 2> &D_A2_WLen_NPhotons,
	 	 	  const double D_ExpTime,
			  const double D_ATel,
			  Array<double, 2> &D_A2_WLen_Erg_Out) const{
  if ((D_A2_WLen_NPhotons.rows() != 2) && (D_A2_WLen_NPhotons.cols() != 2)){
    cout << "CFits::PhotonsToFlux: ERROR: D_A2_WLen_NPhotons does not have 2 columns or rows => Returning FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_PHOTONSTOFLUX__
    cout << "CFits::PhotonsToFlux: D_A2_WLen_NPhotons = " << D_A2_WLen_NPhotons << endl;
    cout << "CFits::PhotonsToFlux: D_ExpTime = " << D_ExpTime << endl;
    cout << "CFits::PhotonsToFlux: D_ATel = " << D_ATel << endl;
  #endif
  int I_Len = 0;
  Array<double, 1> D_A1_WLen(1);
  Array<double, 1> D_A1_NPhotons(1);
  if (D_A2_WLen_NPhotons.cols() == 2){
    I_Len = D_A2_WLen_NPhotons.rows();
    D_A1_WLen.resize(I_Len);
    D_A1_NPhotons.resize(I_Len);

    D_A1_WLen = D_A2_WLen_NPhotons(Range::all(), 0);
    D_A1_NPhotons = D_A2_WLen_NPhotons(Range::all(), 1);
  }
  else{
    I_Len = D_A2_WLen_NPhotons.cols();
    D_A1_WLen.resize(I_Len);
    D_A1_NPhotons.resize(I_Len);

    D_A1_WLen = D_A2_WLen_NPhotons(0, Range::all());
    D_A1_NPhotons = D_A2_WLen_NPhotons(1, Range::all());
  }

  Array<double, 1> D_A1_DWLen(D_A1_WLen.size());
  D_A1_DWLen = 0.;
  D_A1_DWLen(0) = D_A1_WLen(1) - D_A1_WLen(0);
  D_A1_DWLen(D_A1_DWLen.size()-1) = D_A1_WLen(D_A1_WLen.size() - 1) - D_A1_WLen(D_A1_WLen.size() - 2);
  for (int i_pix=1; i_pix<D_A1_WLen.size()-1; i_pix++){
    #ifdef __DEBUG_FITS_PHOTONSTOFLUX__
      cout << "CFits::PhotonsToFlux: i_pix = " << i_pix << ": D_A1_WLen(i_pix-1) = " << D_A1_WLen(i_pix-1) << ", D_A1_WLen(i_pix) = " << D_A1_WLen(i_pix) << ", D_A1_WLen(i_pix+1) = " << D_A1_WLen(i_pix+1) << endl;
    #endif
    D_A1_DWLen(i_pix) = ((D_A1_WLen(i_pix) - D_A1_WLen(i_pix-1))/2.) + ((D_A1_WLen(i_pix+1) - D_A1_WLen(i_pix))/2.);
    #ifdef __DEBUG_FITS_PHOTONSTOFLUX__
      cout << "CFits::PhotonsToFlux: D_A1_DWLen(i_pix) = " << D_A1_DWLen(i_pix) << endl;
    #endif
  }
  #ifdef __DEBUG_FITS_PHOTONSTOFLUX__
    cout << "CFits::PhotonsToFlux: D_A1_WLen = " << D_A1_WLen << endl;
    cout << "CFits::PhotonsToFlux: D_A1_DWLen = " << D_A1_DWLen << endl;
  #endif
  if (fabs(D_ExpTime) < 0.0000001){
    cout << "CFits::PhotonsToFlux: ERROR: D_ExpTime == 0 => Returning FALSE" << endl;
    return false;
  }
  Array<double, 1> D_A1_PhotonsPerSecPerDWLen(D_A1_WLen.size());
  D_A1_PhotonsPerSecPerDWLen = D_A1_NPhotons / (D_ExpTime * D_A1_DWLen); /// # / s / Ang
  #ifdef __DEBUG_FITS_PHOTONSTOFLUX__
    cout << "CFits::PhotonsToFlux: D_A1_PhotonsPerSecPerDWLen = " << D_A1_PhotonsPerSecPerDWLen << endl;
  #endif
  Array<double, 1> D_A1_EnergyPerPhoton(D_A1_WLen.size());
  D_A1_EnergyPerPhoton = D_H_C;                              /// erg Ang
  D_A1_EnergyPerPhoton = D_A1_EnergyPerPhoton / D_A1_WLen;   /// erg
  #ifdef __DEBUG_FITS_PHOTONSTOFLUX__
    cout << "CFits::PhotonsToFlux: D_A1_EnergyPerPhoton = " << D_A1_EnergyPerPhoton << endl;
  #endif
  Array<double, 1> D_A1_Energy(D_A1_WLen.size());
  if (fabs(D_ATel) < 0.0000001){
    cout << "CFits::PhotonsToFlux: ERROR: D_ATel == 0 => Returning FALSE" << endl;
    return false;
  }
  D_A1_Energy = D_A1_PhotonsPerSecPerDWLen * D_A1_EnergyPerPhoton / D_ATel; /// erg / s / Ang / cm^2
  #ifdef __DEBUG_FITS_PHOTONSTOFLUX__
    cout << "CFits::PhotonsToFlux: D_A1_Energy = " << D_A1_Energy << endl;
  #endif
  if (D_A2_WLen_NPhotons.cols() == 2){
    D_A2_WLen_Erg_Out.resize(D_A1_WLen.size(), 2);
    D_A2_WLen_Erg_Out(Range::all(), 0) = D_A1_WLen;
    D_A2_WLen_Erg_Out(Range::all(), 1) = D_A1_Energy;
  }
  else{
    D_A2_WLen_Erg_Out.resize(2, D_A1_WLen.size());
    D_A2_WLen_Erg_Out(0, Range::all()) = D_A1_WLen;
    D_A2_WLen_Erg_Out(1, Range::all()) = D_A1_Energy;
  }
  #ifdef __DEBUG_FITS_PHOTONSTOFLUX__
    cout << "CFits::PhotonsToFlux: D_A2_WLen_Erg_Out = " << D_A2_WLen_Erg_Out << endl;
  #endif
  return true;
}

bool CFits::PhotonsToFlux(const Array<double, 2> &D_A2_NPhotons_In, /// NAps x NRows
			  const double D_ExpTime_In,                /// Exposure time
			  const double D_ATel_In,                   /// Telescope effective surface
			  const Array<int, 1> &I_A1_Apertures_In,   /// Apertures to convert
			  Array<double, 2> &D_A2_Flux_Out){         /// NAps x NRows
  D_A2_Flux_Out.resize(D_A2_NPhotons_In.rows(), D_A2_NPhotons_In.cols());
  D_A2_Flux_Out = 0.;
  Array<double, 2> D_A2_WLen_NPhotons(D_A2_NPhotons_In.cols(), 2);
  Array<double, 2> D_A2_WLen_Flux(D_A2_NPhotons_In.cols(), 2);
  for (int i_ap=0; i_ap<I_A1_Apertures_In.size(); i_ap++){
    D_A2_WLen_NPhotons.resize((*(this->P_D_A1_YHigh))(I_A1_Apertures_In(i_ap)) - (*(this->P_D_A1_YLow))(I_A1_Apertures_In(i_ap)) + 1, 2);
    D_A2_WLen_Flux.resize((*(this->P_D_A1_YHigh))(I_A1_Apertures_In(i_ap)) - (*(this->P_D_A1_YLow))(I_A1_Apertures_In(i_ap)) + 1, 2);
    cout << "CFits::PhotonsToFlux: i_ap = " << i_ap << ": P_D_A2_WLen( " << I_A1_Apertures_In(i_ap) << ",*) = " << (*(this->P_D_A2_WLen))(I_A1_Apertures_In(i_ap), Range((*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures_In(i_ap)), (*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures_In(i_ap)))) << endl;
    D_A2_WLen_NPhotons(Range::all(),0) = (*(this->P_D_A2_WLen))(I_A1_Apertures_In(i_ap), Range((*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures_In(i_ap)), (*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures_In(i_ap))));
    D_A2_WLen_NPhotons(Range::all(),1) = D_A2_NPhotons_In(I_A1_Apertures_In(i_ap), Range((*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures_In(i_ap)), (*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures_In(i_ap))));
    cout << "CFits::PhotonsToFlux: i_ap = " << i_ap << ": D_A2_WLen_NPhotons set to " << D_A2_WLen_NPhotons << endl;
    if (!this->PhotonsToFlux(D_A2_WLen_NPhotons, D_ExpTime_In, D_ATel_In, D_A2_WLen_Flux)){
      cout << "CFits::PhotonsToFlux: ERROR: PhotonsToFlux(WLen_Photons, exptime, ATel, WLen_Erg) returned FALSE" << endl;
      return false;
    }
    D_A2_Flux_Out(I_A1_Apertures_In(i_ap), Range((*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures_In(i_ap)), (*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures_In(i_ap)))) = D_A2_WLen_Flux(Range::all(), 1);
    cout << "CFits::PhotonsToFlux: D_A2_Flux_Out(" << I_A1_Apertures_In(i_ap) << ", *) set to " << D_A2_Flux_Out(I_A1_Apertures_In(i_ap), Range((*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures_In(i_ap)), (*(this->P_D_A1_YCenter))(I_A1_Apertures_In(i_ap)) + (*(this->P_D_A1_YHigh))(I_A1_Apertures_In(i_ap)))) << endl;
  }
  return true;
}

#ifdef __WITH_PLOTS__
  bool CFits::ArrayToMGLArray(const Array<double, 1> &D_A1_Array_In, mglData *P_D_A1_MGLArray_Out) const{
//    if (P_D_A1_MGLArray_Out != NULL)
//      delete(P_D_A1_MGLArray_Out);
    P_D_A1_MGLArray_Out = new mglData(D_A1_Array_In.size());
    for (int i_pos=0; i_pos<D_A1_Array_In.size(); i_pos++)
      (*P_D_A1_MGLArray_Out)[i_pos] = D_A1_Array_In(i_pos);
    return true;
  }

  bool CFits::ArrayToMGLArray(const Array<double, 2> &D_A2_Array_In, mglData *P_D_A2_MGLArray_Out) const{
    cout << "CFits::ArrayToMGLArray: D_A2_Array_In = " << D_A2_Array_In << endl;
//    if (P_D_A2_MGLArray_Out != NULL)
//      delete(P_D_A2_MGLArray_Out);
    P_D_A2_MGLArray_Out = new mglData(D_A2_Array_In.rows(), D_A2_Array_In.cols());
    for (int i_row=0; i_row<D_A2_Array_In.rows(); i_row++){
      for (int i_col=0; i_col<D_A2_Array_In.cols(); i_col++){
        (*P_D_A2_MGLArray_Out)[i_row + D_A2_Array_In.rows() * i_col] = D_A2_Array_In(i_row, i_col);
      }
    }
    cout << "CFits::ArrayToMGLArray: *P_D_A2_MGLArray_Out = " << P_D_A2_MGLArray_Out->PrintInfo() << endl;

    return true;
  }
#endif


/*bool CFits::FitGaussianArea(const Array<double, 1> &D_A1_X_In,
                            const Array<double, 1> &D_A1_Y_In,
                            const Array<double, 1> &D_A1_SigY_In,
                            const Array<double, 1> &D_A1_Guess_In,//with constant background: (background, mean, sigma, area)
                                                                  //without background: (mean, sigma, area)
                            bool B_WithBackground,
                            Array<double, 1> &D_A1_Coeffs_Out) const{
  int I_NParams = D_A1_Guess_In.size();
  int I_NPoints = D_A1_X_In.size();
  double D_StepScale =  0.001;
  double D_ChiCut   = 0.01;
  double D_StepDown = 0.1;                                          //step down the gradient in Gradls
  double D_Lambda   = 0.001;                                        // for Marquardt fitMethod only
  double D_ChiSqr, D_ChiOld;
  int    I_Trial, j, m;

  if (D_A1_Y_In.size() != I_NPoints){
    cout << "CFits::FitGaussianArea: ERROR: D_A1_X_In and D_A1_Y_In must have same size" << endl;
    return false;
  }
  if (D_A1_SigY_In.size() != I_NPoints){
    cout << "CFits::FitGaussianArea: ERROR: D_A1_X_In and D_A1_SigY_In must have same size" << endl;
    return false;
  }
  if (B_WithBackground){
    if (D_A1_Guess_In.size() != 4){
      cout << "CFits::FitGaussianArea: ERROR: Fit with constant background: D_A1_Guess_In must have 4 elements (background, mean, sigma, area)" << endl;
      return false;
    }
    D_A1_Coeffs_Out.resize(4);
    D_A1_Coeffs_Out = 0.;
    ChooseFunction('E', 'a');
  }
  else{
    if (D_A1_Guess_In.size() != 3){
      cout << "CFits::FitGaussianArea: ERROR: Fit without background: D_A1_Guess_In must have 3 elements (mean, sigma, area)" << endl;
      return false;
    }
    D_A1_Coeffs_Out.resize(3);
    D_A1_Coeffs_Out = 0.;
    ChooseFunction('G', 'a');
  }

  SetLinear(false);
  if (!PutNPts(I_NPoints)){
    cout << "CFits::FitGaussianArea: ERROR: PutNPts(" << I_NPoints << ") returned FALSE" << endl;
    return false;
  }

  if (!SetFitParams(D_A1_Guess_In, D_StepScale)){
    cout << "CFits::FitGaussianArea: ERROR: SetFitParams(" << D_A1_Guess_In << ", " << D_StepScale << ") returned FALSE" << endl;
    return false;
  }
  if (!SetFitData(D_A1_X_In, D_A1_Y_In, D_A1_SigY_In)){
    cout << "CFits::FitGaussianArea: ERROR: SetFitData(" << D_A1_X_In << ", " << D_A1_Y_In << ", " << D_A1_SigY_In << ") returned FALSE" << endl;
    return false;
  }
  m = GetNParams();

  I_Trial   = 0;
  D_ChiSqr  = CalcChiSq();
  do
  {
    D_ChiOld = D_ChiSqr;
    cout << "D_ChiOld = " << D_ChiOld << endl;
    cout <<"Trial #  "<< setw(4) << I_Trial <<" D_ChiSq= " << setw(10 ) << setprecision(4) << setiosflags( ios::right ) << D_ChiSqr;
    for (j = 0; j < m; j++)
      cout << setprecision(4) << setw(8) << GetParam(j) ;
    cout << endl;
    Marquardt(D_ChiSqr, D_ChiCut, D_Lambda);
    cout << "D_ChiSqr = " << D_ChiSqr << endl;
    I_Trial++;
  } while (fabs(D_ChiOld-D_ChiSqr) >= D_ChiCut);

  FillYarray();
  D_ChiSqr = CalcChiSq();

  for (int i_par=0; i_par<m; i_par++)
    D_A1_Coeffs_Out(i_par) = GetParam(i_par);

  return true;

}*/

bool CFits::GaussExtract(const Array<double, 2> &D_A2_ArrayToExtract_In,
                         bool B_WithBackground_In,
                         const double D_ApertureOffset_In){
  int I_NParams = 3;
  int I_NPix = 0;
  int I_XLow = 0;
  int I_XHigh = 0;
  int I_Ind = 0;
  double D_Integral = 0.;
  if (B_WithBackground_In){
    I_NParams = 4;
    I_Ind = 1;
  }
  if (D_ApertureOffset_In != 0.){
    if (!this->Set_ApCenterOffset(D_ApertureOffset_In)){
      cout << "CFits::GaussExtract: ERROR: this->Set_ApCenterOffset(" << D_ApertureOffset_In << ") returned FALSE" << endl;
      return false;
    }
  }
  Array<double, 1> D_A1_X(1);
  Array<double, 1> D_A1_Y(1);
  Array<double, 1> D_A1_YTemp(1);
  Array<double, 1> D_A1_SigY(1);
  Array<double, 1> D_A1_Guess(I_NParams);
  Array<double, 1> D_A1_Coeffs(I_NParams);
  Array<double, 1> *P_D_A1_Ind;
  Array<double, 1> D_A1_XInt(2);
  for (int i_ap=0; i_ap<this->I_NApertures; i_ap++){
    for (int i_row = (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YLow))(i_ap); i_row <= (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YHigh))(i_ap); i_row++){
      I_XLow = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap));
      I_XHigh = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap));
      I_NPix = I_XHigh - I_XLow + 1;
      D_A1_X.resize(I_NPix);
      D_A1_Y.resize(I_NPix);
      D_A1_SigY.resize(I_NPix);
      D_A1_YTemp.resize(I_NPix);
      P_D_A1_Ind = this->DIndGenArr(I_NPix);
      D_A1_X = (*P_D_A1_Ind) + I_XLow;
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::GaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_X = " << D_A1_X << endl;
      #endif
      delete(P_D_A1_Ind);
      D_A1_Y = D_A2_ArrayToExtract_In(i_row, Range(I_XLow, I_XHigh));
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::GaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_Y = " << D_A1_Y << endl;
      #endif
      if (this->ErrorsRead){
        D_A1_SigY = (*(this->P_D_A2_ErrArray))(i_row, Range(I_XLow, I_XHigh));
      }
      else{
        D_A1_SigY = sqrt(D_A1_Y);
      }
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::GaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_SigY = " << D_A1_SigY << endl;
      #endif
      if (B_WithBackground_In){
        D_A1_Guess(0) = min(D_A1_Y);
        D_A1_YTemp = D_A1_Y - D_A1_Guess(0);
      }
      else{
        D_A1_YTemp = D_A1_Y;
      }
      D_A1_XInt(0) = D_A1_X(0);
      D_A1_XInt(1) = D_A1_X(I_NPix-1);
      D_A1_Guess(I_Ind) = this->Round(D_A1_XInt(0) - (*(this->P_D_A1_XLow))(i_ap));
      D_A1_Guess(I_Ind+1) = I_NPix / 5.;
      if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
        cout << "CFits::GaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
        return false;
      }
      D_A1_Guess(I_Ind+2) = D_Integral;
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::GaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_Guess = " << D_A1_Guess << endl;
        cout << "CFits::GaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_XInt = " << D_A1_XInt << endl;
      #endif
//      if (!this->FitGaussianArea(D_A1_X, D_A1_Y, D_A1_SigY, D_A1_Guess, B_WithBackground_In, D_A1_Coeffs)){
//        cout << "CFits::GaussExtract: ERROR: FitGaussianArea returned FALSE" << endl;
//        return false;
//      }

      cout << "CFits::GaussExtract: ERROR: Still need to implement MPFitGaussLim(...)" << endl;/*const Array<double, 1> &D_A1_X_In,
                   const Array<double, 1> &D_A1_Y_In,
                   const Array<double, 1> &D_A1_EY_In,
                   const Array<double, 1> &D_A1_Guess_In,
                   const Array<int, 2> &I_A2_Limited,
                   const Array<double, 2> &D_A2_Limits,
                   const bool B_WithConstantBackground,
                   const bool B_FitArea,
                   Array<double, 1> &D_A1_Coeffs_Out,
                   Array< double, 1 >& D_A1_ECoeffs_Out*/
      return false;




      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::GaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_Coeffs = " << D_A1_Coeffs << endl;
      #endif
      if (((D_A1_Coeffs(D_A1_Coeffs.size()-3) - D_A1_Guess(D_A1_Guess.size()-3)) > D_A1_Guess(D_A1_Guess.size()-2)) ||
        (D_A1_Coeffs(D_A1_Coeffs.size()-2) > (2. * D_A1_Guess(D_A1_Guess.size()-2))) ||
        (D_A1_Coeffs(D_A1_Coeffs.size()-2) < (0.2 * D_A1_Guess(D_A1_Guess.size()-2))))
        D_A1_Coeffs(D_A1_Coeffs.size()-1) = 0.;
      (*(this->P_D_A2_LastExtracted))(i_ap, i_row) = D_A1_Coeffs(D_A1_Coeffs.size()-1);
    }
  }
  return true;
}

bool CFits::Set_ApCenterOffset(double D_Offset){
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::Set_ApCenterOffset: ERROR: Trace Functions not calculated yet" << endl;
    return false;
  }
  (*(this->P_D_A2_XCenters)) = (*(this->P_D_A2_XCenters)) + D_Offset;
  for (int i_row=0; i_row<this->NRows; i_row++){
    for (int i_col=0; i_col<this->NCols; i_col++){
      if ((*(this->P_D_A2_XCenters))(i_row, i_col) < 0.)
        (*(this->P_D_A2_XCenters))(i_row, i_col) = 0.;
      else if ((*(this->P_D_A2_XCenters))(i_row, i_col) >= this->NCols)
        (*(this->P_D_A2_XCenters))(i_row, i_col) = this->NCols - 1;
    }
  }
  return true;
}

bool CFits::MPFitGaussExtract(const Array<double, 2> &D_A2_ArrayToExtract_In,
                              const Array<double, 1> &D_A1_SDevLimits_In,
                              const Array<double, 1> &D_A1_MeanLimits_In,
                              const bool B_WithBackground_In){
  (*(this->P_D_A2_Errors_Ec)) = 0.;
  (*(this->P_D_A2_Errors_EcFit)) = 0.;
  (*(this->P_D_A2_LastExtracted)) = 0.;
  (*(this->P_D_A2_Sky)) = 0.;
  (*(this->P_D_A2_SkyError)) = 0.;
  (*(this->P_D_A2_SkyFit)) = 0.;
  (*(this->P_D_A2_SkyFitError)) = 0.;
  (*(this->P_D_A2_RecArray)) = 0.;
  (*(this->P_D_A2_RecFitArray)) = 0.;
  (*(this->P_D_A2_RecSkyArray)) = 0.;
  (*(this->P_D_A2_RecSkyFitArray)) = 0.;
  
  int I_NParams = 3;
  int I_NPix = 0;
  int I_XLow = 0;
  int I_XHigh = 0;
  int I_Ind = 0;
  double D_Integral = 0.;
  if (B_WithBackground_In){
    I_NParams = 4;
    I_Ind = 1;
  }
  Array<double, 1> D_A1_X(1);
  Array<double, 1> D_A1_Y(1);
  Array<double, 1> D_A1_YTemp(1);
  Array<double, 1> D_A1_SigY(1);
  Array<double, 1> D_A1_Guess(I_NParams);
  Array<int, 2> I_A2_ParLimited(I_NParams, 2);
  Array<double, 2> D_A2_ParLimits(I_NParams, 2);
  if (B_WithBackground_In){
    I_A2_ParLimited(0,0) = 1;
    I_A2_ParLimited(0,1) = 1;
  }
  I_A2_ParLimited(I_Ind,0) = 1;
  I_A2_ParLimited(I_Ind,1) = 1;
  I_A2_ParLimited(I_Ind+1,0) = 1;
  I_A2_ParLimited(I_Ind+1,1) = 1;
  I_A2_ParLimited(I_Ind+2,0) = 1;
  I_A2_ParLimited(I_Ind+2,1) = 1;
  D_A2_ParLimits(I_Ind, 0) = 0.;
  #ifdef __DEBUG_FITS_GAUSSEXTRACT__
    cout << "CFits::MPFitGaussExtract: I_A2_ParLimited = " << I_A2_ParLimited << endl;
  #endif
  Array<double, 1> D_A1_Coeffs(I_NParams);
  D_A1_Coeffs = 0.;
  Array<double, 1> D_A1_ECoeffs(I_NParams);
  D_A1_ECoeffs = 0.;
  Array<double, 1> *P_D_A1_Ind;
  Array<double, 1> D_A1_XInt(2);
  Array<double, 1> D_A1_YGauss(1);
  for (int i_ap=0; i_ap<this->I_NApertures; i_ap++){
    for (int i_row = (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YLow))(i_ap); i_row <= (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YHigh))(i_ap); i_row++){
      I_XLow = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap));
      I_XHigh = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap));
      I_NPix = I_XHigh - I_XLow + 1;
      D_A1_X.resize(I_NPix);
      D_A1_Y.resize(I_NPix);
      D_A1_SigY.resize(I_NPix);
      D_A1_YTemp.resize(I_NPix);
      P_D_A1_Ind = this->DIndGenArr(I_NPix);
      D_A1_X = (*P_D_A1_Ind) + I_XLow;
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::MPFitGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_X = " << D_A1_X << endl;
      #endif
      delete(P_D_A1_Ind);
      D_A1_Y = D_A2_ArrayToExtract_In(i_row, Range(I_XLow, I_XHigh));
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::MPFitGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_Y = " << D_A1_Y << endl;
      #endif
      if (this->ErrorsRead){
        D_A1_SigY = (*(this->P_D_A2_ErrArray))(i_row, Range(I_XLow, I_XHigh));
      }
      else{
        D_A1_SigY = sqrt(fabs(D_A1_Y));
      }
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::MPFitGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_SigY = " << D_A1_SigY << endl;
      #endif
      if (B_WithBackground_In){
        D_A1_Guess(0) = min(D_A1_Y);
        D_A1_YTemp = D_A1_Y - D_A1_Guess(0);
      }
      else{
        D_A1_YTemp = D_A1_Y;
      }
      D_A1_XInt(0) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap);
      D_A1_XInt(1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap);
      D_A1_Guess(I_Ind+1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + ((D_A1_MeanLimits_In(1) - D_A1_MeanLimits_In(0))/2.);
      D_A1_Guess(I_Ind+2) = D_A1_SDevLimits_In(0) + ((D_A1_SDevLimits_In(1) - D_A1_SDevLimits_In(0))/2.);
      if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
        cout << "CFits::MPFitGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
        return false;
      }
      D_A1_Guess(I_Ind) = D_Integral;
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::MPFitGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_XInt = " << D_A1_XInt << endl;
        cout << "CFits::MPFitGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_Guess = " << D_A1_Guess << endl;
      #endif
      if (B_WithBackground_In){
        D_A2_ParLimits(0,0) = 0;
        D_A2_ParLimits(0,1) = 2. * D_A1_Guess(0);
      }
      D_A2_ParLimits(I_Ind, 1) = 2. * D_A1_Guess(I_Ind);
      D_A2_ParLimits(I_Ind+1, 0) = D_A1_Guess(I_Ind+1) + D_A1_MeanLimits_In(0);
      D_A2_ParLimits(I_Ind+1, 1) = D_A1_Guess(I_Ind+1) + D_A1_MeanLimits_In(1);
      D_A2_ParLimits(I_Ind+2, 0) = D_A1_SDevLimits_In(0);
      D_A2_ParLimits(I_Ind+2, 1) = D_A1_SDevLimits_In(1);
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::MPFitGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A2_ParLimits = " << D_A2_ParLimits << endl;
      #endif

      if (!MPFitGaussLim(D_A1_X,
                         D_A1_Y,
                         D_A1_SigY,
                         D_A1_Guess,
                         I_A2_ParLimited,
                         D_A2_ParLimits,
                         B_WithBackground_In,
                         true,
                         D_A1_Coeffs,
                         D_A1_ECoeffs)){
        cout << "CFits::MPFitGaussExtract: ERROR: MPFitGaussLim returned FALSE" << endl;
        return false;
      }
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::MPFitGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_Coeffs = " << D_A1_Coeffs << endl;
      #endif
//      if (((D_A1_Coeffs(D_A1_Coeffs.size()-3) - D_A1_Guess(D_A1_Guess.size()-3)) > D_A1_Guess(D_A1_Guess.size()-2)) ||
//        (D_A1_Coeffs(D_A1_Coeffs.size()-2) > (2. * D_A1_Guess(D_A1_Guess.size()-2))) ||
//        (D_A1_Coeffs(D_A1_Coeffs.size()-2) < (0.2 * D_A1_Guess(D_A1_Guess.size()-2))))
//        D_A1_Coeffs(D_A1_Coeffs.size()-1) = 0.;
      (*(this->P_D_A2_LastExtracted))(i_ap, i_row) = D_A1_Coeffs(I_Ind);
      (*(this->P_D_A2_Errors_Ec))(i_ap, i_row) = D_A1_ECoeffs(I_Ind);
      (*(this->P_D_A2_Errors_EcFit))(i_ap, i_row) = D_A1_ECoeffs(I_Ind);
      if (B_WithBackground_In){
        (*(this->P_D_A2_Sky))(i_ap, i_row) = D_A1_Coeffs(0);
        (*(this->P_D_A2_SkyFit))(i_ap, i_row) = D_A1_Coeffs(0);
        (*(this->P_D_A2_SkyError))(i_ap, i_row) = D_A1_ECoeffs(0);
        (*(this->P_D_A2_SkyFitError))(i_ap, i_row) = D_A1_ECoeffs(0);
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitGaussExtract: (*(this->P_D_A2_SkyFit))(" << i_ap << ", " << i_row << ") set to " << (*(this->P_D_A2_SkyFit))(i_ap, i_row) << endl;
        #endif
        (*(this->P_D_A2_RecSkyArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                   int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)))) = D_A1_Coeffs(0);
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitGaussExtract: (*(this->P_D_A2_RecSkyArray))(" << i_row << ", Range(" << int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)) << ", " << int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)) << ")) set to " << (*(this->P_D_A2_RecSkyArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)))) << endl;
        #endif
      }
      Array<double, 1> *P_D_A1_XGauss = this->DIndGenArr(int((*(this->P_D_A1_XHigh))(i_ap) - (*(this->P_D_A1_XLow))(i_ap)) + 1);
      *P_D_A1_XGauss = *P_D_A1_XGauss + (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap);
      for (int i_xpix=0; i_xpix<P_D_A1_XGauss->size(); i_xpix++)
        (*P_D_A1_XGauss)(i_xpix) = double(int((*P_D_A1_XGauss)(i_xpix)));
      D_A1_YGauss.resize(P_D_A1_XGauss->size());
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::MPFitGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_XGauss set to " << *P_D_A1_XGauss << endl;
        cout << "CFits::MPFitGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_Coeffs set to " << D_A1_Coeffs << endl;
      #endif
      Array<double, 1> D_A1_CoeffsGaussTemp(D_A1_Coeffs.size());
      D_A1_CoeffsGaussTemp = D_A1_Coeffs;
      D_A1_CoeffsGaussTemp(I_Ind) = 1.;
      if (!this->GaussArea(*P_D_A1_XGauss,
                           D_A1_CoeffsGaussTemp(Range(I_Ind, I_Ind+2)),
                           D_A1_YGauss)){
        cout << "CFits::MPFitGaussExtract: ERROR: GaussArea(" << *P_D_A1_XGauss << ", " << D_A1_Coeffs << ", D_A1_YGauss) returned FALSE" << endl;
        return false;
      }
      #ifdef __DEBUG_FITS_GAUSSEXTRACT__
        cout << "CFits::MPFitGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_YGauss set to " << D_A1_YGauss << endl;
      #endif
//        return false;
      (*(this->P_D_A2_ProfArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                               int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
      = (*(this->P_D_A2_ProfArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                 int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
        + (D_A1_YGauss);
      (*(this->P_D_A2_RecFitArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                 int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
      = (*(this->P_D_A2_RecFitArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                   int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
        + (D_A1_YGauss * D_A1_Coeffs(I_Ind));
      delete(P_D_A1_XGauss);
//      return false;
    }
  }
  return true;
}

bool CFits::MPFitTwoGaussExtract(const Array<double, 2> &D_A2_ArrayToExtract_In,
                                 const Array<double, 1> &D_A1_SDevLimits_In,
                                 const Array<double, 1> &D_A1_MeanLimits_In,
                                 const bool B_WithBackground_In){
  Array<CString, 1> CS_A1_KeyWords(1);
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  CS_A1_KeyWords = CString(" ");
  return this->MPFitTwoGaussExtract(D_A2_ArrayToExtract_In,
                                    D_A1_SDevLimits_In,
                                    D_A1_MeanLimits_In,
                                    B_WithBackground_In,
                                    CS_A1_KeyWords,
                                    PP_Args);
}

  /// D_A1_SDevLimits_In(0) = minimum standard deviation of Gauss curve
  /// D_A1_SDevLimits_In(1) = maximum standard deviation of Gauss curve
  /// D_A1_MeanLimits_In(0) = maximum difference to the left of aperture center
  /// D_A1_MeanLimits_In(1) = maximum difference to the right of aperture center
bool CFits::MPFitTwoGaussExtract(const Array<double, 2> &D_A2_ArrayToExtract_In,
                                 const Array<double, 1> &D_A1_SDevLimits_In,
                                 const Array<double, 1> &D_A1_MeanLimits_In,
                                 const bool B_WithBackground_In,
                                 const Array<CString, 1> &CS_A1_Args_In,
                                 void *ArgV_In[]){
  int I_Pos = 0;
  int I_XMin = 0;
  int I_XMax = D_A2_ArrayToExtract_In.cols()-1;
  int I_YMin = 0;
  int I_YMax = D_A2_ArrayToExtract_In.rows()-1;
  Array<int, 1> *P_I_A1_AperturesToExtract = this->IndGenArr(this->I_NApertures);
  
  (*(this->P_D_A2_Errors_Ec)) = 0.;
  (*(this->P_D_A2_Errors_EcFit)) = 0.;
  (*(this->P_D_A2_LastExtracted)) = 0.;
  (*(this->P_D_A2_Sky)) = 0.;
  (*(this->P_D_A2_SkyError)) = 0.;
  (*(this->P_D_A2_SkyFit)) = 0.;
  (*(this->P_D_A2_SkyFitError)) = 0.;
  (*(this->P_D_A2_RecArray)) = 0.;
  (*(this->P_D_A2_RecFitArray)) = 0.;
  (*(this->P_D_A2_RecSkyArray)) = 0.;
  (*(this->P_D_A2_RecSkyFitArray)) = 0.;
  
  ///Area to extract
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("AREA"));
  if (I_Pos >= 0)
  {
    Array<int, 1> I_A1_Area(4);
    I_A1_Area = *(Array<int, 1>*)ArgV_In[I_Pos];
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MPFitTwoGaussExtract: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
      (*P_OFS_Log) << "CFits::MPFitTwoGaussExtract: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
    #endif
    I_XMin = I_A1_Area(0);
    I_XMax = I_A1_Area(1);
    I_YMin = I_A1_Area(2);
    I_YMax = I_A1_Area(3);
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MPFitTwoGaussExtract: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
      (*P_OFS_Log) << "CFits::MPFitTwoGaussExtract: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
    #endif
    //      return false;
  }
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("APERTURES"))) >= 0)
  {
    delete(P_I_A1_AperturesToExtract);
    P_I_A1_AperturesToExtract = (Array<int, 1>*)ArgV_In[I_Pos];
  }
  int I_NParamsOne = 3;
  int I_NParamsTwo = 5;
  int I_NPix = 0;
  int I_XLow = 0;
  int I_XHigh = 0;
  int I_Ind = 0;
  double D_Integral = 0.;
  if (B_WithBackground_In){
    I_NParamsOne = 4;
    I_NParamsTwo = 6;
    I_Ind = 1;
  }
  Array<double, 1> D_A1_CoeffsGauss(I_NParamsOne);
  Array<double, 1> D_A1_ECoeffsGauss(I_NParamsOne);
  Array<double, 1> D_A1_X(1);
  Array<double, 1> D_A1_Y(1);
  Array<double, 1> D_A1_YTemp(1);
  Array<double, 1> D_A1_SigY(1);
  Array<double, 1> D_A1_GuessOne(I_NParamsOne);
  Array<int, 2> I_A2_ParLimitedOne(I_NParamsOne, 2);
  Array<double, 2> D_A2_ParLimitsOne(I_NParamsOne, 2);
  Array<double, 1> D_A1_GuessTwo(I_NParamsTwo);
  Array<int, 2> I_A2_ParLimitedTwo(I_NParamsTwo, 2);
  Array<double, 2> D_A2_ParLimitsTwo(I_NParamsTwo, 2);
  if (B_WithBackground_In){
    I_A2_ParLimitedOne(0,0) = 1;
    I_A2_ParLimitedOne(0,1) = 1;
    I_A2_ParLimitedTwo(0,0) = 1;
    I_A2_ParLimitedTwo(0,1) = 1;
  }
  I_A2_ParLimitedOne(I_Ind,0) = 1;
  I_A2_ParLimitedOne(I_Ind,1) = 1;
  I_A2_ParLimitedOne(I_Ind+1,0) = 1;
  I_A2_ParLimitedOne(I_Ind+1,1) = 1;
  I_A2_ParLimitedOne(I_Ind+2,0) = 1;
  I_A2_ParLimitedOne(I_Ind+2,1) = 1;
  I_A2_ParLimitedTwo(I_Ind,0) = 1;
  I_A2_ParLimitedTwo(I_Ind,1) = 1;
  I_A2_ParLimitedTwo(I_Ind+1,0) = 1;
  I_A2_ParLimitedTwo(I_Ind+1,1) = 1;
  I_A2_ParLimitedTwo(I_Ind+2,0) = 1;
  I_A2_ParLimitedTwo(I_Ind+2,1) = 1;
  I_A2_ParLimitedTwo(I_Ind+3,0) = 1;
  I_A2_ParLimitedTwo(I_Ind+3,1) = 1;
  I_A2_ParLimitedTwo(I_Ind+4,0) = 1;
  I_A2_ParLimitedTwo(I_Ind+4,1) = 1;
//  I_A2_ParLimitedTwo(I_Ind+5,0) = 1;
//  I_A2_ParLimitedTwo(I_Ind+5,1) = 1;
  D_A2_ParLimitsOne(I_Ind, 0) = 0.;
  D_A2_ParLimitsTwo(I_Ind, 0) = 0.;
  D_A2_ParLimitsTwo(I_Ind+3, 0) = 0.;
  #ifdef __DEBUG_FITS_GAUSSEXTRACT__
    cout << "CFits::MPFitTwoGaussExtract: I_A2_ParLimitedOne = " << I_A2_ParLimitedOne << endl;
    cout << "CFits::MPFitTwoGaussExtract: I_A2_ParLimitedTwo = " << I_A2_ParLimitedTwo << endl;
  #endif
  Array<double, 1> D_A1_CoeffsOne(I_NParamsOne);
  Array<double, 1> D_A1_CoeffsTwo(I_NParamsTwo);
  D_A1_CoeffsOne = 0.;
  D_A1_CoeffsTwo = 0.;
  Array<double, 1> D_A1_ECoeffsOne(I_NParamsOne);
  Array<double, 1> D_A1_ECoeffsTwo(I_NParamsTwo);
  D_A1_ECoeffsOne = 0.;
  D_A1_ECoeffsTwo = 0.;
  Array<double, 1> *P_D_A1_Ind;
  Array<double, 1> *P_D_A1_XGauss;
  Array<double, 1> D_A1_YGauss(1);
  Array<double, 1> D_A1_XInt(2);
  int I_ApNumWithCrossTalk = -1;
  int I_NApsWithCrossTalk = 0;
  bool B_CrossTalkToTheLeft = false;
  bool B_CrossTalk = false;
  int iap, i_ap, i_apt;
  for (iap=0; iap < P_I_A1_AperturesToExtract->size(); iap++){
    i_ap = (*P_I_A1_AperturesToExtract)(iap);
    #ifdef __DEBUG_FITS_GAUSSEXTRACT__
      cout << "CFits::MPFitTwoGaussExtract: Aperture " << i_ap << ": (*(this->P_D_A1_XCenter))(i_ap) = " << (*(this->P_D_A1_XCenter))(i_ap) << endl;
      cout << "CFits::MPFitTwoGaussExtract: Aperture " << i_ap << ": (*(this->P_D_A1_YCenter))(i_ap) = " << (*(this->P_D_A1_YCenter))(i_ap) << endl;
      cout << "CFits::MPFitTwoGaussExtract: Aperture " << i_ap << ": (*(this->P_D_A1_YLow))(i_ap) = " << (*(this->P_D_A1_YLow))(i_ap) << endl;
      cout << "CFits::MPFitTwoGaussExtract: Aperture " << i_ap << ": (*(this->P_D_A1_YHigh))(i_ap) = " << (*(this->P_D_A1_YHigh))(i_ap) << endl;
    #endif
    if (((*(this->P_D_A1_XCenter))(i_ap) >= I_XMin)
        && ((*(this->P_D_A1_XCenter))(i_ap) <= I_XMax)
        && ((((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YLow))(i_ap) >= I_YMin)
        && ((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YLow))(i_ap) <= I_YMax))
        || (((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YHigh))(i_ap) >= I_YMin)
        && ((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YHigh))(i_ap) <= I_YMax)))){
      cout << "CFits::MPFitTwoGaussExtract: Extracting Aperture " << iap << endl;
      for (int i_row = (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YLow))(i_ap); i_row <= (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YHigh))(i_ap); i_row++){
        /// Search for aperture causing cross-talk
        B_CrossTalk = false;
        B_CrossTalkToTheLeft = false;
        I_ApNumWithCrossTalk = -1;
        I_NApsWithCrossTalk = 0;
        for (int i_apt=0; i_apt<this->I_NApertures; i_apt++){
          if (i_apt == i_ap)
            i_apt++;
          if ((i_row >= ((*(this->P_D_A1_YCenter))(i_apt) + (*(this->P_D_A1_YLow))(i_apt))) &&
              (i_row <= ((*(this->P_D_A1_YCenter))(i_apt) + (*(this->P_D_A1_YHigh))(i_apt)))){
            if ((int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)) < int((*(this->P_D_A2_XCenters))(i_apt, i_row) + (*(this->P_D_A1_XHigh))(i_apt))) &&
                (int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)) > int((*(this->P_D_A2_XCenters))(i_apt, i_row) + (*(this->P_D_A1_XLow))(i_apt)))){
              I_ApNumWithCrossTalk = i_apt;
              B_CrossTalkToTheLeft = true;
              B_CrossTalk = true;
              I_NApsWithCrossTalk++;
              #ifdef __DEBUG_FITS_GAUSSEXTRACT__
                cout << "CFits::MPFitTwoGaussExtract: i_ap = " << i_ap << ": I_ApNumWithCrossTalk = " << I_ApNumWithCrossTalk << endl;
              #endif
            }
            else if ((int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)) > int((*(this->P_D_A2_XCenters))(i_apt, i_row) + (*(this->P_D_A1_XLow))(i_apt))) &&
                     (int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)) < int((*(this->P_D_A2_XCenters))(i_apt, i_row) + (*(this->P_D_A1_XHigh))(i_apt)))){
              I_ApNumWithCrossTalk = i_apt;
              B_CrossTalkToTheLeft = false;
              B_CrossTalk = true;
              I_NApsWithCrossTalk++;
              #ifdef __DEBUG_FITS_GAUSSEXTRACT__
                cout << "CFits::MPFitTwoGaussExtract: i_ap = " << i_ap << ": I_ApNumWithCrossTalk = " << I_ApNumWithCrossTalk << endl;
              #endif
            }
          }
          if (I_NApsWithCrossTalk > 1){
            cout << "CFits::MPFitTwoGaussExtract: I_NApsWithCrossTalk = " << I_NApsWithCrossTalk << " > 1" << endl;
            return false;
          }
        }

        if (!B_CrossTalk){
          I_XLow = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap));
          I_XHigh = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap));
        }
        else{/// With CrossTalk
          if (B_CrossTalkToTheLeft){
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitTwoGaussExtract: B_CrossTalkToTheLeft == true" << endl;
            #endif
            I_XLow = int((*(this->P_D_A2_XCenters))(I_ApNumWithCrossTalk, i_row) + (*(this->P_D_A1_XLow))(I_ApNumWithCrossTalk));
            I_XHigh = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap));
          }
          else{
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitTwoGaussExtract: B_CrossTalkToTheLeft == false" << endl;
            #endif
            I_XLow = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap));
            I_XHigh = int((*(this->P_D_A2_XCenters))(I_ApNumWithCrossTalk, i_row) + (*(this->P_D_A1_XHigh))(I_ApNumWithCrossTalk));
          }
        }
        I_NPix = I_XHigh - I_XLow + 1;
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitTwoGaussExtract: I_XLow = " << I_XLow << ", I_XHigh = " << I_XHigh << ": I_NPix = " << I_NPix << endl;
        #endif
        D_A1_X.resize(I_NPix);
        D_A1_Y.resize(I_NPix);
        D_A1_SigY.resize(I_NPix);
        D_A1_YTemp.resize(I_NPix);
        P_D_A1_Ind = this->DIndGenArr(I_NPix);
        D_A1_X = (*P_D_A1_Ind) + I_XLow;
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_X = " << D_A1_X << endl;
        #endif
        delete(P_D_A1_Ind);
        D_A1_Y = D_A2_ArrayToExtract_In(i_row, Range(I_XLow, I_XHigh));
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_Y = " << D_A1_Y << endl;
        #endif
        if (this->ErrorsRead){
          D_A1_SigY = (*(this->P_D_A2_ErrArray))(i_row, Range(I_XLow, I_XHigh));
        }
        else{
          D_A1_SigY = sqrt(D_A1_Y);
        }
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_SigY = " << D_A1_SigY << endl;
        #endif
        if (B_WithBackground_In){
          if (B_CrossTalk){
            D_A1_GuessTwo(0) = min(D_A1_Y);
            D_A1_YTemp = D_A1_Y - D_A1_GuessTwo(0);
          }
          else{
            D_A1_GuessOne(0) = min(D_A1_Y);
            D_A1_YTemp = D_A1_Y - D_A1_GuessOne(0);
          }
        }
        else{
          D_A1_YTemp = D_A1_Y;
        }
        if (B_CrossTalk){
          D_A1_GuessTwo(I_Ind+1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + ((D_A1_MeanLimits_In(1) - D_A1_MeanLimits_In(0))/2.);
          D_A1_GuessTwo(I_Ind+2) = D_A1_SDevLimits_In(0) + ((D_A1_SDevLimits_In(1) - D_A1_SDevLimits_In(0))/2.);
          D_A1_GuessTwo(I_Ind+4) = (*(this->P_D_A2_XCenters))(I_ApNumWithCrossTalk, i_row) + ((D_A1_MeanLimits_In(1) - D_A1_MeanLimits_In(0))/2.);
//          D_A1_GuessTwo(I_Ind+5) = D_A1_SDevLimits_In(0) + ((D_A1_SDevLimits_In(1) - D_A1_SDevLimits_In(0))/2.);

          D_A1_XInt(0) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap);
          D_A1_XInt(1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap);
          if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
            return false;
          }
          D_A1_GuessTwo(I_Ind) = D_Integral;

          D_A1_XInt(0) = (*(this->P_D_A2_XCenters))(I_ApNumWithCrossTalk, i_row) + (*(this->P_D_A1_XLow))(I_ApNumWithCrossTalk);
          D_A1_XInt(1) = (*(this->P_D_A2_XCenters))(I_ApNumWithCrossTalk, i_row) + (*(this->P_D_A1_XHigh))(I_ApNumWithCrossTalk);
          if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
            return false;
          }
          D_A1_GuessTwo(I_Ind+3) = D_Integral;

          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_XInt = " << D_A1_XInt << endl;
            cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_GuessTwo = " << D_A1_GuessTwo << endl;
          #endif
          if (B_WithBackground_In){
            D_A2_ParLimitsTwo(0,0) = 0;
            D_A2_ParLimitsTwo(0,1) = 2. * D_A1_GuessTwo(0);
            if (D_A2_ParLimitsTwo(0,1) < D_A2_ParLimitsTwo(0,0)){
              cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsTwo(0,1) < D_A2_ParLimitsTwo(0,0)" << endl;
              return false;
            }
          }
          D_A2_ParLimitsTwo(I_Ind, 1) = 2. * D_A1_GuessTwo(I_Ind);
          if (D_A2_ParLimitsTwo(I_Ind,1) < D_A2_ParLimitsTwo(I_Ind,0)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind << ",1) < D_A2_ParLimitsTwo(" << I_Ind << ",0)" << endl;
            return false;
          }
          D_A2_ParLimitsTwo(I_Ind+1, 0) = D_A1_GuessTwo(I_Ind+1) + D_A1_MeanLimits_In(0);
          D_A2_ParLimitsTwo(I_Ind+1, 1) = D_A1_GuessTwo(I_Ind+1) + D_A1_MeanLimits_In(1);
          if (D_A2_ParLimitsTwo(I_Ind+1,1) < D_A2_ParLimitsTwo(I_Ind+1,0)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+1 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+1 << ",0)" << endl;
            return false;
          }
          D_A2_ParLimitsTwo(I_Ind+2, 0) = D_A1_SDevLimits_In(0);
          D_A2_ParLimitsTwo(I_Ind+2, 1) = D_A1_SDevLimits_In(1);
          if (D_A2_ParLimitsTwo(I_Ind+2,1) < D_A2_ParLimitsTwo(I_Ind+2,0)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+2 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+2 << ",0)" << endl;
            return false;
          }
          D_A2_ParLimitsTwo(I_Ind+3, 1) = 2. * D_A1_GuessTwo(I_Ind+3);
          if (D_A2_ParLimitsTwo(I_Ind+3,1) < D_A2_ParLimitsTwo(I_Ind+3,0)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+3 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+3 << ",0)" << endl;
            return false;
          }
          D_A2_ParLimitsTwo(I_Ind+4, 0) = D_A1_GuessTwo(I_Ind+4) + D_A1_MeanLimits_In(0);
          D_A2_ParLimitsTwo(I_Ind+4, 1) = D_A1_GuessTwo(I_Ind+4) + D_A1_MeanLimits_In(1);
          if (D_A2_ParLimitsTwo(I_Ind+4,1) < D_A2_ParLimitsTwo(I_Ind+4,0)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+4 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+4 << ",0)" << endl;
            return false;
          }
          //          D_A2_ParLimitsTwo(I_Ind+5, 0) = D_A1_SDevLimits_In(0);
//          D_A2_ParLimitsTwo(I_Ind+5, 1) = D_A1_SDevLimits_In(1);
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A2_ParLimitsTwo = " << D_A2_ParLimitsTwo << endl;
          #endif

          if (!MPFitTwoGaussLim(D_A1_X,
                                D_A1_Y,
                                D_A1_SigY,
                                D_A1_GuessTwo,
                                I_A2_ParLimitedTwo,
                                D_A2_ParLimitsTwo,
                                B_WithBackground_In,
                                true,
                                D_A1_CoeffsTwo,
                                D_A1_ECoeffsTwo)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: MPFitTwoGaussLim returned FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_CoeffsTwo = " << D_A1_CoeffsTwo << endl;
          #endif
          D_A1_CoeffsGauss = D_A1_CoeffsTwo(Range(0, I_NParamsOne-1));
          D_A1_ECoeffsGauss = D_A1_ECoeffsTwo(Range(0, I_NParamsOne-1));
          //      if (((D_A1_Coeffs(D_A1_Coeffs.size()-3) - D_A1_Guess(D_A1_Guess.size()-3)) > D_A1_Guess(D_A1_Guess.size()-2)) ||
//        (D_A1_Coeffs(D_A1_Coeffs.size()-2) > (2. * D_A1_Guess(D_A1_Guess.size()-2))) ||
//        (D_A1_Coeffs(D_A1_Coeffs.size()-2) < (0.2 * D_A1_Guess(D_A1_Guess.size()-2))))
//        D_A1_Coeffs(D_A1_Coeffs.size()-1) = 0.;
//      return false;
        }
        else{
          D_A1_GuessOne(I_Ind+1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + ((D_A1_MeanLimits_In(1) - D_A1_MeanLimits_In(0))/2.);
          D_A1_GuessOne(I_Ind+2) = D_A1_SDevLimits_In(0) + ((D_A1_SDevLimits_In(1) - D_A1_SDevLimits_In(0))/2.);

          D_A1_XInt(0) = D_A1_X(0);
          D_A1_XInt(1) = D_A1_X(I_NPix-1);
          if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
            return false;
          }
          D_A1_GuessOne(I_Ind) = D_Integral;

          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_XInt = " << D_A1_XInt << endl;
            cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_GuessOne = " << D_A1_GuessOne << endl;
          #endif
          if (B_WithBackground_In){
            D_A2_ParLimitsOne(0,0) = 0;
            D_A2_ParLimitsOne(0,1) = 2. * D_A1_GuessOne(0);
            if (D_A2_ParLimitsOne(0,1) < D_A2_ParLimitsOne(0,0)){
              cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsOne(0,1) < D_A2_ParLimitsOne(0,0)" << endl;
              return false;
            }
          }
          D_A2_ParLimitsOne(I_Ind, 1) = 2. * D_A1_GuessOne(I_Ind);
          if (D_A2_ParLimitsOne(I_Ind,1) < D_A2_ParLimitsOne(I_Ind,0)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsOne(" << I_Ind << ",1) < D_A2_ParLimitsOne(" << I_Ind << ",0)" << endl;
            return false;
          }
          D_A2_ParLimitsOne(I_Ind+1, 0) = D_A1_GuessOne(I_Ind+1) + D_A1_MeanLimits_In(0);
          D_A2_ParLimitsOne(I_Ind+1, 1) = D_A1_GuessOne(I_Ind+1) + D_A1_MeanLimits_In(1);
          if (D_A2_ParLimitsOne(I_Ind+1,1) < D_A2_ParLimitsOne(I_Ind+1,0)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsOne(" << I_Ind+1 << ",1) < D_A2_ParLimitsOne(" << I_Ind+1 << ",0)" << endl;
            return false;
          }
          D_A2_ParLimitsOne(I_Ind+2, 0) = D_A1_SDevLimits_In(0);
          D_A2_ParLimitsOne(I_Ind+2, 1) = D_A1_SDevLimits_In(1);
          if (D_A2_ParLimitsOne(I_Ind+2,1) < D_A2_ParLimitsOne(I_Ind+2,0)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: D_A2_ParLimitsOne(" << I_Ind+2 << ",1) < D_A2_ParLimitsOne(" << I_Ind+2 << ",0)" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A2_ParLimitsOne = " << D_A2_ParLimitsOne << endl;
          #endif

          if (!MPFitGaussLim(D_A1_X,
                             D_A1_Y,
                             D_A1_SigY,
                             D_A1_GuessOne,
                             I_A2_ParLimitedOne,
                             D_A2_ParLimitsOne,
                             B_WithBackground_In,
                             true,
                             D_A1_CoeffsOne,
                             D_A1_ECoeffsOne)){
            cout << "CFits::MPFitTwoGaussExtract: ERROR: MPFitGaussLim returned FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitTwoGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_CoeffsOne = " << D_A1_CoeffsOne << endl;
          #endif
          D_A1_CoeffsGauss = D_A1_CoeffsOne;
          D_A1_ECoeffsGauss = D_A1_ECoeffsOne;
          //      if (((D_A1_Coeffs(D_A1_Coeffs.size()-3) - D_A1_Guess(D_A1_Guess.size()-3)) > D_A1_Guess(D_A1_Guess.size()-2)) ||
//        (D_A1_Coeffs(D_A1_Coeffs.size()-2) > (2. * D_A1_Guess(D_A1_Guess.size()-2))) ||
//        (D_A1_Coeffs(D_A1_Coeffs.size()-2) < (0.2 * D_A1_Guess(D_A1_Guess.size()-2))))
//        D_A1_Coeffs(D_A1_Coeffs.size()-1) = 0.;
          //      return false;
        }
        (*(this->P_D_A2_LastExtracted))(i_ap, i_row) = D_A1_CoeffsGauss(I_Ind);
        (*(this->P_D_A2_Errors_Ec))(i_ap, i_row) = D_A1_ECoeffsGauss(I_Ind);
        (*(this->P_D_A2_Errors_EcFit))(i_ap, i_row) = D_A1_ECoeffsGauss(I_Ind);
        if (B_WithBackground_In){
          (*(this->P_D_A2_Sky))(i_ap, i_row) = D_A1_CoeffsGauss(0);
          (*(this->P_D_A2_SkyFit))(i_ap, i_row) = D_A1_CoeffsGauss(0);
          (*(this->P_D_A2_SkyError))(i_ap, i_row) = D_A1_ECoeffsGauss(0);
          (*(this->P_D_A2_SkyFitError))(i_ap, i_row) = D_A1_ECoeffsGauss(0);
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitGaussExtract: (*(this->P_D_A2_SkyFit))(" << i_ap << ", " << i_row << ") set to " << (*(this->P_D_A2_SkyFit))(i_ap, i_row) << endl;
          #endif
          (*(this->P_D_A2_RecSkyArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                     int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)))) = D_A1_CoeffsGauss(0);
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitGaussExtract: (*(this->P_D_A2_RecSkyArray))(" << i_row << ", Range(" << int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)) << ", " << int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)) << ")) set to " << (*(this->P_D_A2_RecSkyArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)))) << endl;
          #endif
        }
        P_D_A1_XGauss = this->DIndGenArr(int((*(this->P_D_A1_XHigh))(i_ap) - (*(this->P_D_A1_XLow))(i_ap)) + 1);
        *P_D_A1_XGauss = *P_D_A1_XGauss + (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap);
        for (int i_xpix=0; i_xpix<P_D_A1_XGauss->size(); i_xpix++)
          (*P_D_A1_XGauss)(i_xpix) = double(int((*P_D_A1_XGauss)(i_xpix)));
        D_A1_YGauss.resize(P_D_A1_XGauss->size());
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_XGauss set to " << *P_D_A1_XGauss << endl;
          cout << "CFits::MPFitGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_CoeffsGauss set to " << D_A1_CoeffsGauss << endl;
        #endif
        Array<double, 1> D_A1_CoeffsGaussTemp(D_A1_CoeffsGauss.size());
        D_A1_CoeffsGaussTemp = D_A1_CoeffsGauss;
        D_A1_CoeffsGaussTemp(I_Ind) = 1.;
        if (!this->GaussArea(*P_D_A1_XGauss,
                             D_A1_CoeffsGaussTemp(Range(I_Ind, I_Ind+2)),
                             D_A1_YGauss)){
          cout << "CFits::MPFitGaussExtract: ERROR: GaussArea(" << *P_D_A1_XGauss << ", " << D_A1_CoeffsGauss << ", D_A1_YGauss) returned FALSE" << endl;
          return false;
        }
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_YGauss set to " << D_A1_YGauss << endl;
        #endif
//        return false;
        (*(this->P_D_A2_ProfArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                 int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
        = (*(this->P_D_A2_ProfArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                   int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
          + (D_A1_YGauss);
        (*(this->P_D_A2_RecFitArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                   int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
        = (*(this->P_D_A2_RecFitArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                     int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
          + (D_A1_YGauss * D_A1_CoeffsGauss(I_Ind));
        delete(P_D_A1_XGauss);
      }
    }
  }
  return true;
}

bool CFits::MPFitThreeGaussExtract(const Array<double, 2> &D_A2_ArrayToExtract_In,
                                   const Array<double, 1> &D_A1_SDevLimits_In,
                                   const Array<double, 1> &D_A1_MeanLimits_In,
                                   const bool B_WithBackground_In){
  Array<CString, 1> CS_A1_KeyWords(1);
  void **PP_Args = (void**)malloc(sizeof(void*) * 1);
  CS_A1_KeyWords = CString(" ");
  return this->MPFitThreeGaussExtract(D_A2_ArrayToExtract_In,
                                      D_A1_SDevLimits_In,
                                      D_A1_MeanLimits_In,
                                      B_WithBackground_In,
                                      CS_A1_KeyWords,
                                      PP_Args);
}

  /// D_A1_SDevLimits_In(0) = minimum standard deviation of Gauss curve
  /// D_A1_SDevLimits_In(1) = maximum standard deviation of Gauss curve
  /// D_A1_MeanLimits_In(0) = maximum difference to the left of aperture center
  /// D_A1_MeanLimits_In(1) = maximum difference to the right of aperture center
bool CFits::MPFitThreeGaussExtract(const Array<double, 2> &D_A2_ArrayToExtract_In,
                                   const Array<double, 1> &D_A1_SDevLimits_In,
                                   const Array<double, 1> &D_A1_MeanLimits_In,
                                   const bool B_WithBackground_In,
                                   const Array<CString, 1> &CS_A1_Args_In,
                                   void *ArgV_In[]){
  int I_Pos = 0;
  int I_XMin = 0;
  int I_XMax = D_A2_ArrayToExtract_In.cols()-1;
  int I_YMin = 0;
  int I_YMax = D_A2_ArrayToExtract_In.rows()-1;
  Array<int, 1> *P_I_A1_AperturesToExtract = this->IndGenArr(this->I_NApertures);
  (*(this->P_D_A2_ProfArray)) = 0.;
  (*(this->P_D_A2_RecFitArray)) = 0.;
  (*(this->P_D_A2_Sky)) = 0.;
  (*(this->P_D_A2_SkyFit)) = 0.;
  (*(this->P_D_A2_RecSkyArray)) = 0.;
  (*(this->P_D_A2_LastExtracted)) = 0.;
  (*(this->P_D_A2_Errors_Ec)) = 0.;  
  (*(this->P_D_A2_Errors_EcFit)) = 0.;  
  (*(this->P_D_A2_SkyError)) = 0.;  
  (*(this->P_D_A2_SkyFitError)) = 0.;  
  
  ///Area to extract
  I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("AREA"));
  if (I_Pos >= 0)
  {
    Array<int, 1> I_A1_Area(4);
    I_A1_Area = *(Array<int, 1>*)ArgV_In[I_Pos];
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MPFitThreeGaussExtract: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
      (*P_OFS_Log) << "CFits::MPFitThreeGaussExtract: KeyWord_Set(AREA): I_A1_Area set to " << I_A1_Area << endl;
    #endif
    I_XMin = I_A1_Area(0);
    I_XMax = I_A1_Area(1);
    I_YMin = I_A1_Area(2);
    I_YMax = I_A1_Area(3);
    #ifdef __DEBUG_FITS_MKSLITFUNC__
      cout << "CFits::MPFitThreeGaussExtract: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
      (*P_OFS_Log) << "CFits::MPFitThreeGaussExtract: KeyWord_Set(AREA): I_XMin set to " << I_XMin << ", I_XMax set to " << I_XMax << ", I_YMin set to " << I_YMin << ", I_YMax set to " << I_YMax << endl;
    #endif
    //      return false;
  }
  if ((I_Pos = this->KeyWord_Set(CS_A1_Args_In, CString("APERTURES"))) >= 0)
  {
    delete(P_I_A1_AperturesToExtract);
    P_I_A1_AperturesToExtract = (Array<int, 1>*)ArgV_In[I_Pos];
  }
  int I_NParamsOne = 3;
  int I_NParamsTwo = 5;
  int I_NParamsThree = 7;
  int I_NPix = 0;
  int I_XLow = 0;
  int I_XHigh = 0;
  int I_Ind = 0;
  double D_Integral = 0.;
  if (B_WithBackground_In){
    I_NParamsOne = 4;
    I_NParamsTwo = 6;
    I_NParamsThree = 8;
    I_Ind = 1;
  }
  Array<double, 1> D_A1_X(1);
  Array<double, 1> D_A1_Y(1);
  Array<double, 1> D_A1_YTemp(1);
  Array<double, 1> D_A1_SigY(1);
  Array<double, 1> D_A1_GuessOne(I_NParamsOne);
  Array<int, 2> I_A2_ParLimitedOne(I_NParamsOne, 2);
  Array<double, 2> D_A2_ParLimitsOne(I_NParamsOne, 2);
  Array<double, 1> D_A1_GuessTwo(I_NParamsTwo);
  Array<int, 2> I_A2_ParLimitedTwo(I_NParamsTwo, 2);
  Array<double, 2> D_A2_ParLimitsTwo(I_NParamsTwo, 2);
  Array<double, 1> D_A1_GuessThree(I_NParamsThree);
  Array<int, 2> I_A2_ParLimitedThree(I_NParamsThree, 2);
  Array<double, 2> D_A2_ParLimitsThree(I_NParamsThree, 2);
  if (B_WithBackground_In){
    I_A2_ParLimitedOne(0,0) = 1;
    I_A2_ParLimitedOne(0,1) = 1;
    I_A2_ParLimitedTwo(0,0) = 1;
    I_A2_ParLimitedTwo(0,1) = 1;
    I_A2_ParLimitedThree(0,0) = 1;
    I_A2_ParLimitedThree(0,1) = 1;
  }
  I_A2_ParLimitedOne(I_Ind,0) = 1;
  I_A2_ParLimitedOne(I_Ind,1) = 1;
  I_A2_ParLimitedOne(I_Ind+1,0) = 1;
  I_A2_ParLimitedOne(I_Ind+1,1) = 1;
  I_A2_ParLimitedOne(I_Ind+2,0) = 1;
  I_A2_ParLimitedOne(I_Ind+2,1) = 1;
  I_A2_ParLimitedTwo(I_Ind,0) = 1;
  I_A2_ParLimitedTwo(I_Ind,1) = 1;
  I_A2_ParLimitedTwo(I_Ind+1,0) = 1;
  I_A2_ParLimitedTwo(I_Ind+1,1) = 1;
  I_A2_ParLimitedTwo(I_Ind+2,0) = 1;
  I_A2_ParLimitedTwo(I_Ind+2,1) = 1;
  I_A2_ParLimitedTwo(I_Ind+3,0) = 1;
  I_A2_ParLimitedTwo(I_Ind+3,1) = 1;
  I_A2_ParLimitedTwo(I_Ind+4,0) = 1;
  I_A2_ParLimitedTwo(I_Ind+4,1) = 1;
//  I_A2_ParLimitedTwo(I_Ind+5,0) = 1;
//  I_A2_ParLimitedTwo(I_Ind+5,1) = 1;
  I_A2_ParLimitedThree(I_Ind,0) = 1;
  I_A2_ParLimitedThree(I_Ind,1) = 1;
  I_A2_ParLimitedThree(I_Ind+1,0) = 1;
  I_A2_ParLimitedThree(I_Ind+1,1) = 1;
  I_A2_ParLimitedThree(I_Ind+2,0) = 1;
  I_A2_ParLimitedThree(I_Ind+2,1) = 1;
  I_A2_ParLimitedThree(I_Ind+3,0) = 1;
  I_A2_ParLimitedThree(I_Ind+3,1) = 1;
  I_A2_ParLimitedThree(I_Ind+4,0) = 1;
  I_A2_ParLimitedThree(I_Ind+4,1) = 1;
  I_A2_ParLimitedThree(I_Ind+5,0) = 1;
  I_A2_ParLimitedThree(I_Ind+5,1) = 1;
  I_A2_ParLimitedThree(I_Ind+6,0) = 1;
  I_A2_ParLimitedThree(I_Ind+6,1) = 1;

  D_A2_ParLimitsOne(I_Ind, 0) = 0.;
  D_A2_ParLimitsTwo(I_Ind, 0) = 0.;
  D_A2_ParLimitsTwo(I_Ind+3, 0) = 0.;
  D_A2_ParLimitsThree(I_Ind, 0) = 0.;
  D_A2_ParLimitsThree(I_Ind+3, 0) = 0.;
  D_A2_ParLimitsThree(I_Ind+5, 0) = 0.;
  #ifdef __DEBUG_FITS_GAUSSEXTRACT__
    cout << "CFits::MPFitThreeGaussExtract: I_A2_ParLimitedOne = " << I_A2_ParLimitedOne << endl;
    cout << "CFits::MPFitThreeGaussExtract: I_A2_ParLimitedTwo = " << I_A2_ParLimitedTwo << endl;
    cout << "CFits::MPFitThreeGaussExtract: I_A2_ParLimitedThree = " << I_A2_ParLimitedThree << endl;
  #endif
  Array<double, 1> D_A1_CoeffsOne(I_NParamsOne);
  Array<double, 1> D_A1_CoeffsTwo(I_NParamsTwo);
  Array<double, 1> D_A1_CoeffsThree(I_NParamsThree);
  D_A1_CoeffsOne = 0.;
  D_A1_CoeffsTwo = 0.;
  D_A1_CoeffsThree = 0.;
  Array<double, 1> D_A1_ECoeffsOne(I_NParamsOne);
  Array<double, 1> D_A1_ECoeffsTwo(I_NParamsTwo);
  Array<double, 1> D_A1_ECoeffsThree(I_NParamsThree);
  D_A1_ECoeffsOne = 0.;
  D_A1_ECoeffsTwo = 0.;
  D_A1_ECoeffsThree = 0.;
  Array<double, 1> *P_D_A1_Ind;
  Array<double, 1> D_A1_XInt(2);
  Array<int, 1> I_A1_ApNumsWithCrossTalk(5);
  I_A1_ApNumsWithCrossTalk = -1;
  int I_NApsWithCrossTalk = 0;
  Array<bool, 1> B_A1_CrossTalkToTheLeft(2);
  B_A1_CrossTalkToTheLeft = false;
  Array<bool, 1> B_A1_CrossTalkToTheRight(2);
  Array<double, 1> *P_D_A1_XGauss;
  Array<double, 1> D_A1_YGauss(1);
  Array<double, 1> D_A1_CoeffsGauss(I_Ind+3);
  Array<double, 1> D_A1_ECoeffsGauss(I_Ind+3);
  Array<double, 1> D_A1_GaussSigma(1);
  Array<double, 1> D_A1_GaussMean(1);
  Array<double, 1> D_A1_MeanFit(1);
  B_A1_CrossTalkToTheRight = false;
  bool B_CrossTalk = false;
  bool B_LastRow1 = false;
  bool B_LastRow2 = false;
  bool B_LastRow3 = false;
  int iap, i_ap, i_apt, i_row_rel;
  double D_GaussSigma;
  for (iap=0; iap < P_I_A1_AperturesToExtract->size(); iap++){
    i_ap = (*P_I_A1_AperturesToExtract)(iap);
    D_A1_GaussSigma.resize((*(this->P_D_A1_YHigh))(i_ap) - (*(this->P_D_A1_YLow))(i_ap) + 1);
    D_A1_GaussMean.resize((*(this->P_D_A1_YHigh))(i_ap) - (*(this->P_D_A1_YLow))(i_ap) + 1);
    #ifdef __DEBUG_FITS_GAUSSEXTRACT__
      cout << "CFits::MPFitThreeGaussExtract: Aperture " << i_ap << ": (*(this->P_D_A1_XCenter))(i_ap) = " << (*(this->P_D_A1_XCenter))(i_ap) << endl;
      cout << "CFits::MPFitThreeGaussExtract: Aperture " << i_ap << ": (*(this->P_D_A1_YCenter))(i_ap) = " << (*(this->P_D_A1_YCenter))(i_ap) << endl;
      cout << "CFits::MPFitThreeGaussExtract: Aperture " << i_ap << ": (*(this->P_D_A1_YLow))(i_ap) = " << (*(this->P_D_A1_YLow))(i_ap) << endl;
      cout << "CFits::MPFitThreeGaussExtract: Aperture " << i_ap << ": (*(this->P_D_A1_YHigh))(i_ap) = " << (*(this->P_D_A1_YHigh))(i_ap) << endl;
    #endif
    if (((*(this->P_D_A1_XCenter))(i_ap) >= I_XMin)
        && ((*(this->P_D_A1_XCenter))(i_ap) <= I_XMax)
        && ((((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YLow))(i_ap) >= I_YMin)
        && ((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YLow))(i_ap) <= I_YMax))
        || (((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YHigh))(i_ap) >= I_YMin)
        && ((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YHigh))(i_ap) <= I_YMax)))){
      cout << "CFits::MPFitThreeGaussExtract: Extracting Aperture " << iap << "(" << i_ap << ")" << endl;
      for (int i_run = 0; i_run < 2; i_run++){
      for (int i_row = (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YLow))(i_ap); i_row <= (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YHigh))(i_ap); i_row++){
        /// Search for aperture causing cross-talk
        B_CrossTalk = false;
        B_A1_CrossTalkToTheLeft = false;
        B_A1_CrossTalkToTheRight = false;
        I_A1_ApNumsWithCrossTalk = -1;
        I_NApsWithCrossTalk = 0;
        i_row_rel = i_row - (*(this->P_D_A1_YCenter))(i_ap) - (*(this->P_D_A1_YLow))(i_ap);
        for (int i_apt=0; i_apt<this->I_NApertures; i_apt++){
          if (i_apt == i_ap)
            i_apt++;
          if ((i_row >= ((*(this->P_D_A1_YCenter))(i_apt) + (*(this->P_D_A1_YLow))(i_apt))) &&
              (i_row <= ((*(this->P_D_A1_YCenter))(i_apt) + (*(this->P_D_A1_YHigh))(i_apt)))){
            if ((int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)) < int((*(this->P_D_A2_XCenters))(i_apt, i_row) + (*(this->P_D_A1_XHigh))(i_apt))) &&
                (int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)) > int((*(this->P_D_A2_XCenters))(i_apt, i_row) + (*(this->P_D_A1_XLow))(i_apt)))){
              I_A1_ApNumsWithCrossTalk(I_NApsWithCrossTalk) = i_apt;
              B_A1_CrossTalkToTheLeft(I_NApsWithCrossTalk) = true;
              B_CrossTalk = true;
              I_NApsWithCrossTalk++;
              #ifdef __DEBUG_FITS_GAUSSEXTRACT__
                cout << "CFits::MPFitThreeGaussExtract: i_ap = " << i_ap << ": I_A1_ApNumsWithCrossTalk = " << I_A1_ApNumsWithCrossTalk << endl;
              #endif
            }
            else if ((int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)) > int((*(this->P_D_A2_XCenters))(i_apt, i_row) + (*(this->P_D_A1_XLow))(i_apt))) &&
                     (int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)) < int((*(this->P_D_A2_XCenters))(i_apt, i_row) + (*(this->P_D_A1_XHigh))(i_apt)))){
              I_A1_ApNumsWithCrossTalk(I_NApsWithCrossTalk) = i_apt;
              B_A1_CrossTalkToTheRight(I_NApsWithCrossTalk) = true;
              B_CrossTalk = true;
              I_NApsWithCrossTalk++;
              #ifdef __DEBUG_FITS_GAUSSEXTRACT__
                cout << "CFits::MPFitThreeGaussExtract: i_ap = " << i_ap << ": I_A1_ApNumsWithCrossTalk = " << I_A1_ApNumsWithCrossTalk << endl;
              #endif
            }
          }
          if (I_NApsWithCrossTalk > 2){
            cout << "CFits::MPFitThreeGaussExtract: I_NApsWithCrossTalk = " << I_NApsWithCrossTalk << " > 2" << endl;
            return false;
          }
        }

//        if (!B_CrossTalk){
          I_XLow = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap));
          I_XHigh = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap));
//        }
        if (B_CrossTalk){/// With CrossTalk
          for (int i_c=0; i_c<I_NApsWithCrossTalk; i_c++){
//            if (B_A1_CrossTalkToTheLeft(i_c)){
//              cout << "CFits::MPFitThreeGaussExtract: B_A1_CrossTalkToTheLeft(" << i_c << ") == true" << endl;
            if (I_XLow > int((*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(i_c), i_row) + (*(this->P_D_A1_XLow))(I_A1_ApNumsWithCrossTalk(i_c))))
              I_XLow = int((*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(i_c), i_row) + (*(this->P_D_A1_XLow))(I_A1_ApNumsWithCrossTalk(i_c)));
            if (I_XHigh < int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)))
              I_XHigh = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap));
//            }
//            else{
//              cout << "CFits::MPFitThreeGaussExtract: B_CrossTalkToTheLeft == false" << endl;
//              I_XLow = int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap));
//              I_XHigh = int((*(this->P_D_A2_XCenters))(I_A1_ApNumWithCrossTalk, i_row) + (*(this->P_D_A1_XHigh))(I_A1_ApNumWithCrossTalk));
//            }
          }
        }
        I_NPix = I_XHigh - I_XLow + 1;
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitThreeGaussExtract: I_XLow = " << I_XLow << ", I_XHigh = " << I_XHigh << ": I_NPix = " << I_NPix << endl;
        #endif
        D_A1_X.resize(I_NPix);
        D_A1_Y.resize(I_NPix);
        D_A1_SigY.resize(I_NPix);
        D_A1_YTemp.resize(I_NPix);
        P_D_A1_Ind = this->DIndGenArr(I_NPix);
        D_A1_X = (*P_D_A1_Ind) + I_XLow;
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_X = " << D_A1_X << endl;
        #endif
        delete(P_D_A1_Ind);
        D_A1_Y = D_A2_ArrayToExtract_In(i_row, Range(I_XLow, I_XHigh));
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_Y = " << D_A1_Y << endl;
        #endif
        if (this->ErrorsRead){
          D_A1_SigY = (*(this->P_D_A2_ErrArray))(i_row, Range(I_XLow, I_XHigh));
        }
        else{
          D_A1_SigY = sqrt(fabs(D_A1_Y));
        }
        #ifdef __DEBUG_FITS_GAUSSEXTRACT__
          cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_SigY = " << D_A1_SigY << endl;
        #endif
        if (B_WithBackground_In){
          if (B_CrossTalk){
            if (I_NApsWithCrossTalk == 1){
              D_A1_GuessTwo(0) = min(D_A1_Y) + this->D_ReadOutNoise;
              if (D_A1_GuessTwo(0) < 0)
                D_A1_GuessTwo(0) = this->D_ReadOutNoise / 2.;
              D_A1_YTemp = D_A1_Y - D_A1_GuessTwo(0);
            }
            else{
              D_A1_GuessThree(0) = min(D_A1_Y) + this->D_ReadOutNoise;
              if (D_A1_GuessThree(0) < 0)
                D_A1_GuessThree(0) = this->D_ReadOutNoise / 2.;
              D_A1_YTemp = D_A1_Y - D_A1_GuessThree(0);
            }
          }
          else{
            D_A1_GuessOne(0) = min(D_A1_Y) + this->D_ReadOutNoise;
            if (D_A1_GuessOne(0) < 0)
              D_A1_GuessOne(0) = this->D_ReadOutNoise / 2.;
            D_A1_YTemp = D_A1_Y - D_A1_GuessOne(0);
          }
        }
        else{
          D_A1_YTemp = D_A1_Y;
        }
        if (B_CrossTalk){
          if (I_NApsWithCrossTalk == 1){
            if (i_run == 0){
              D_A1_GuessTwo(I_Ind+1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + ((D_A1_MeanLimits_In(1) + D_A1_MeanLimits_In(0))/2.);
              D_A1_GuessTwo(I_Ind+2) = D_A1_SDevLimits_In(0) + ((D_A1_SDevLimits_In(1) - D_A1_SDevLimits_In(0))/2.);
            }
            else{
              if (D_A1_MeanFit.size() <= i_row_rel){
                cout << "CFits::MPFitThreeGaussExtract: Error: D_A1_MeanFit.size(=" << D_A1_MeanFit.size() << ") <= i_row_rel(=" << i_row_rel << ")" << endl;
                return false;
              }
              D_A1_GuessTwo(I_Ind+1) = D_A1_MeanFit(i_row_rel);
              D_A1_GuessTwo(I_Ind+2) = D_GaussSigma;
            }
            D_A1_GuessTwo(I_Ind+4) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(0), i_row) + ((D_A1_MeanLimits_In(1) + D_A1_MeanLimits_In(0))/2.);
            //          D_A1_GuessTwo(I_Ind+5) = D_A1_SDevLimits_In(0) + ((D_A1_SDevLimits_In(1) - D_A1_SDevLimits_In(0))/2.);

            D_A1_XInt(0) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap);
            D_A1_XInt(1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap);
            if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
              return false;
            }
            if (D_Integral < 0.)
              D_Integral = 0.1;
            D_A1_GuessTwo(I_Ind) = D_Integral;

            D_A1_XInt(0) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(0), i_row) + (*(this->P_D_A1_XLow))(I_A1_ApNumsWithCrossTalk(0));
            D_A1_XInt(1) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(0), i_row) + (*(this->P_D_A1_XHigh))(I_A1_ApNumsWithCrossTalk(0));
            if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
              return false;
            }
            if (D_Integral < 0.)
              D_Integral = 0.1;
            D_A1_GuessTwo(I_Ind+3) = D_Integral;

            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_XInt = " << D_A1_XInt << endl;
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_GuessTwo = " << D_A1_GuessTwo << endl;
            #endif
            if (B_WithBackground_In){
              D_A2_ParLimitsTwo(0,0) = 0;
              D_A2_ParLimitsTwo(0,1) = 2. * D_A1_GuessTwo(0);
              if (D_A2_ParLimitsTwo(0,1) < D_A2_ParLimitsTwo(0,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsTwo(0,1) < D_A2_ParLimitsTwo(0,0)" << endl;
                return false;
              }
            }
            D_A2_ParLimitsTwo(I_Ind, 1) = 2. * D_A1_GuessTwo(I_Ind);
            if (D_A2_ParLimitsTwo(I_Ind,1) < D_A2_ParLimitsTwo(I_Ind,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind << ",1) < D_A2_ParLimitsTwo(" << I_Ind << ",0)" << endl;
              return false;
            }
            D_A2_ParLimitsTwo(I_Ind+3, 1) = 2. * D_A1_GuessTwo(I_Ind+3);
            if (D_A2_ParLimitsTwo(I_Ind+3,1) < D_A2_ParLimitsTwo(I_Ind+3,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+3 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+3 << ",0)" << endl;
              return false;
            }
            D_A2_ParLimitsTwo(I_Ind+4, 0) = D_A1_GuessTwo(I_Ind+4) + D_A1_MeanLimits_In(0);
            D_A2_ParLimitsTwo(I_Ind+4, 1) = D_A1_GuessTwo(I_Ind+4) + D_A1_MeanLimits_In(1);
            if (D_A2_ParLimitsTwo(I_Ind+4,1) < D_A2_ParLimitsTwo(I_Ind+4,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+4 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+4 << ",0)" << endl;
              return false;
            }
            if (i_run == 0){
              D_A2_ParLimitsTwo(I_Ind+1, 0) = D_A1_GuessTwo(I_Ind+1) + D_A1_MeanLimits_In(0);
              D_A2_ParLimitsTwo(I_Ind+1, 1) = D_A1_GuessTwo(I_Ind+1) + D_A1_MeanLimits_In(1);
              if (D_A2_ParLimitsTwo(I_Ind+1,1) < D_A2_ParLimitsTwo(I_Ind+1,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+1 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+1 << ",0)" << endl;
                return false;
              }
              D_A2_ParLimitsTwo(I_Ind+2, 0) = D_A1_SDevLimits_In(0);
              D_A2_ParLimitsTwo(I_Ind+2, 1) = D_A1_SDevLimits_In(1);
              if (D_A2_ParLimitsTwo(I_Ind+2,1) < D_A2_ParLimitsTwo(I_Ind+2,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+2 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+2 << ",0)" << endl;
                return false;
              }
            }
            else{
              if (D_A1_MeanFit.size() <= i_row_rel){
                cout << "CFits::MPFitThreeGaussExtract: Error: D_A1_MeanFit.size(=" << D_A1_MeanFit.size() << ") <= i_row_rel(=" << i_row_rel << ")" << endl;
                return false;
              }
              D_A2_ParLimitsTwo(I_Ind+1, 0) = D_A1_MeanFit(i_row_rel) - 0.01;
              D_A2_ParLimitsTwo(I_Ind+1, 1) = D_A1_MeanFit(i_row_rel) + 0.01;
              if (D_A2_ParLimitsTwo(I_Ind+1,1) < D_A2_ParLimitsTwo(I_Ind+1,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+1 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+1 << ",0)" << endl;
                return false;
              }
              D_A2_ParLimitsTwo(I_Ind+2, 0) = D_GaussSigma - (D_GaussSigma / 4.);
              D_A2_ParLimitsTwo(I_Ind+2, 1) = D_GaussSigma + (D_GaussSigma / 2.);
              if (D_A2_ParLimitsTwo(I_Ind+2,1) < D_A2_ParLimitsTwo(I_Ind+2,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsTwo(" << I_Ind+2 << ",1) < D_A2_ParLimitsTwo(" << I_Ind+2 << ",0)" << endl;
                return false;
              }
            }
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": I_A2_ParLimitedTwo = " << I_A2_ParLimitedTwo << endl;
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A2_ParLimitsTwo = " << D_A2_ParLimitsTwo << endl;
            #endif

            if (!MPFitTwoGaussLim(D_A1_X,
                                  D_A1_Y,
                                  D_A1_SigY,
                                  D_A1_GuessTwo,
                                  I_A2_ParLimitedTwo,
                                  D_A2_ParLimitsTwo,
                                  B_WithBackground_In,
                                  true,
                                  D_A1_CoeffsTwo,
                                  D_A1_ECoeffsTwo)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: MPFitTwoGaussLim returned FALSE" << endl;
              return false;
            }
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_run = " << i_run << ": i_row=" << i_row << ": i_row_rel = " << i_row_rel << ": D_A1_CoeffsTwo = " << D_A1_CoeffsTwo << endl;
            #endif
            D_A1_CoeffsGauss = D_A1_CoeffsTwo(Range(0, I_Ind + 2));
            D_A1_ECoeffsGauss = D_A1_ECoeffsTwo(Range(0, I_Ind + 2));
            if (i_run == 0){
              #ifdef __DEBUG_FITS_GAUSSEXTRACT__
                cout << "CFits::MPFitThreeGaussExtract: i_row = " << i_row << ": i_row_rel = " << i_row_rel << endl;
              #endif
//              return false;
              if ((i_row_rel < 0) || (i_row_rel >= D_A1_GaussMean.size())){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: i_row_rel = " << i_row_rel << " out of bounds" << endl;
                return false;
              }
              D_A1_GaussMean(i_row_rel) = D_A1_CoeffsGauss(I_Ind+1);
              D_A1_GaussSigma(i_row_rel) = D_A1_CoeffsGauss(I_Ind+2);
            }
            B_LastRow1 = false;
            B_LastRow2 = true;
            B_LastRow3 = false;
          }
          else{
            if (i_run == 0){
              D_A1_GuessThree(I_Ind+1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + ((D_A1_MeanLimits_In(1) + D_A1_MeanLimits_In(0))/2.);
              D_A1_GuessThree(I_Ind+2) = D_A1_SDevLimits_In(0) + ((D_A1_SDevLimits_In(1) - D_A1_SDevLimits_In(0))/2.);
            }
            else{
              if (D_A1_MeanFit.size() <= i_row_rel){
                cout << "CFits::MPFitThreeGaussExtract: Error: D_A1_MeanFit.size(=" << D_A1_MeanFit.size() << ") <= i_row_rel(=" << i_row_rel << ")" << endl;
                return false;
              }
              D_A1_GuessThree(I_Ind+1) = D_A1_MeanFit(i_row_rel);
              D_A1_GuessThree(I_Ind+2) = D_GaussSigma;
            }
            D_A1_GuessThree(I_Ind+4) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(0), i_row) + ((D_A1_MeanLimits_In(1) + D_A1_MeanLimits_In(0))/2.);
            D_A1_GuessThree(I_Ind+6) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(1), i_row) + ((D_A1_MeanLimits_In(1) + D_A1_MeanLimits_In(0))/2.);

            D_A1_XInt(0) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap);
            D_A1_XInt(1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap);
            if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
              return false;
            }
            if (D_Integral < 0.)
              D_Integral = 0.1;
            D_A1_GuessThree(I_Ind) = D_Integral;

            D_A1_XInt(0) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(0), i_row) + (*(this->P_D_A1_XLow))(I_A1_ApNumsWithCrossTalk(0));
            D_A1_XInt(1) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(0), i_row) + (*(this->P_D_A1_XHigh))(I_A1_ApNumsWithCrossTalk(0));
            if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
              return false;
            }
            if (D_Integral < 0.)
              D_Integral = 0.1;
            D_A1_GuessThree(I_Ind+3) = D_Integral;

            D_A1_XInt(0) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(1), i_row) + (*(this->P_D_A1_XLow))(I_A1_ApNumsWithCrossTalk(1));
            D_A1_XInt(1) = (*(this->P_D_A2_XCenters))(I_A1_ApNumsWithCrossTalk(1), i_row) + (*(this->P_D_A1_XHigh))(I_A1_ApNumsWithCrossTalk(1));
            if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
              return false;
            }
            if (D_Integral < 0.)
              D_Integral = 0.1;
            D_A1_GuessThree(I_Ind+5) = D_Integral;

            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_XInt = " << D_A1_XInt << endl;
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_GuessThree = " << D_A1_GuessThree << endl;
            #endif
            if (B_WithBackground_In){
              D_A2_ParLimitsThree(0,0) = 0;
              D_A2_ParLimitsThree(0,1) = 2. * D_A1_GuessThree(0);
              if (D_A2_ParLimitsThree(0,1) < D_A2_ParLimitsThree(0,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(0,1) < D_A2_ParLimitsThree(0,0)" << endl;
                return false;
              }
            }
            D_A2_ParLimitsThree(I_Ind, 1) = 2. * D_A1_GuessThree(I_Ind);
            if (D_A2_ParLimitsThree(I_Ind,1) < D_A2_ParLimitsThree(I_Ind,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind << ",1) < D_A2_ParLimitsThree(" << I_Ind << ",0)" << endl;
              return false;
            }
            D_A2_ParLimitsThree(I_Ind+3, 1) = 2. * D_A1_GuessThree(I_Ind+3);
            if (D_A2_ParLimitsThree(I_Ind+3,1) < D_A2_ParLimitsThree(I_Ind+3,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind+3 << ",1) < D_A2_ParLimitsThree(" << I_Ind+3 << ",0)" << endl;
              return false;
            }
            D_A2_ParLimitsThree(I_Ind+4, 0) = D_A1_GuessThree(I_Ind+4) + D_A1_MeanLimits_In(0);
            D_A2_ParLimitsThree(I_Ind+4, 1) = D_A1_GuessThree(I_Ind+4) + D_A1_MeanLimits_In(1);
            if (D_A2_ParLimitsThree(I_Ind+4,1) < D_A2_ParLimitsThree(I_Ind+4,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind+4 << ",1) < D_A2_ParLimitsThree(" << I_Ind+4 << ",0)" << endl;
              return false;
            }
            D_A2_ParLimitsThree(I_Ind+5, 1) = 2. * D_A1_GuessThree(I_Ind+5);
            if (D_A2_ParLimitsThree(I_Ind+5,1) < D_A2_ParLimitsThree(I_Ind+5,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind+5 << ",1) < D_A2_ParLimitsThree(" << I_Ind+5 << ",0)" << endl;
              return false;
            }
            D_A2_ParLimitsThree(I_Ind+6, 0) = D_A1_GuessThree(I_Ind+6) + D_A1_MeanLimits_In(0);
            D_A2_ParLimitsThree(I_Ind+6, 1) = D_A1_GuessThree(I_Ind+6) + D_A1_MeanLimits_In(1);
            if (D_A2_ParLimitsThree(I_Ind+6,1) < D_A2_ParLimitsThree(I_Ind+6,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind+6 << ",1) < D_A2_ParLimitsThree(" << I_Ind+6 << ",0)" << endl;
              return false;
            }
            if (i_run == 0){
              D_A2_ParLimitsThree(I_Ind+1, 0) = D_A1_GuessThree(I_Ind+1) + D_A1_MeanLimits_In(0);
              D_A2_ParLimitsThree(I_Ind+1, 1) = D_A1_GuessThree(I_Ind+1) + D_A1_MeanLimits_In(1);
              if (D_A2_ParLimitsThree(I_Ind+1,1) < D_A2_ParLimitsThree(I_Ind+1,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind+1 << ",1) < D_A2_ParLimitsThree(" << I_Ind+1 << ",0)" << endl;
                return false;
              }
              D_A2_ParLimitsThree(I_Ind+2, 0) = D_A1_SDevLimits_In(0);
              D_A2_ParLimitsThree(I_Ind+2, 1) = D_A1_SDevLimits_In(1);
              if (D_A2_ParLimitsThree(I_Ind+2,1) < D_A2_ParLimitsThree(I_Ind+2,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind+2 << ",1) < D_A2_ParLimitsThree(" << I_Ind+2 << ",0)" << endl;
                return false;
              }
            }
            else{
              if (D_A1_MeanFit.size() <= i_row_rel){
                cout << "CFits::MPFitThreeGaussExtract: Error: D_A1_MeanFit.size(=" << D_A1_MeanFit.size() << ") <= i_row_rel(=" << i_row_rel << ")" << endl;
                return false;
              }
              D_A2_ParLimitsThree(I_Ind+1, 0) = D_A1_MeanFit(i_row_rel) - 0.01;
              D_A2_ParLimitsThree(I_Ind+1, 1) = D_A1_MeanFit(i_row_rel) + 0.01;
              if (D_A2_ParLimitsThree(I_Ind+1,1) < D_A2_ParLimitsThree(I_Ind+1,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind+1 << ",1) < D_A2_ParLimitsThree(" << I_Ind+1 << ",0)" << endl;
                return false;
              }
              D_A2_ParLimitsThree(I_Ind+2, 0) = D_GaussSigma - (D_GaussSigma / 4.);
              D_A2_ParLimitsThree(I_Ind+2, 1) = D_GaussSigma + (D_GaussSigma / 2.);
              if (D_A2_ParLimitsThree(I_Ind+2,1) < D_A2_ParLimitsThree(I_Ind+2,0)){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsThree(" << I_Ind+2 << ",1) < D_A2_ParLimitsThree(" << I_Ind+2 << ",0)" << endl;
                return false;
              }
            }
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A2_ParLimitsThree = " << D_A2_ParLimitsThree << endl;
            #endif

            if (!MPFitThreeGaussLim(D_A1_X,
                                    D_A1_Y,
                                    D_A1_SigY,
                                    D_A1_GuessThree,
                                    I_A2_ParLimitedThree,
                                    D_A2_ParLimitsThree,
                                    B_WithBackground_In,
                                    true,
                                    D_A1_CoeffsThree,
                                    D_A1_ECoeffsThree)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: MPFitThreeGaussLim returned FALSE" << endl;
              return false;
            }
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_run = " << i_run << ": i_row=" << i_row << ": i_row_rel = " << i_row_rel << ": D_A1_CoeffsThree = " << D_A1_CoeffsThree << endl;
            #endif
            D_A1_CoeffsGauss = D_A1_CoeffsThree(Range(0, I_Ind + 2));
            D_A1_ECoeffsGauss = D_A1_ECoeffsThree(Range(0, I_Ind + 2));
            if (i_run == 0){
              #ifdef __DEBUG_FITS_GAUSSEXTRACT__
                cout << "CFits::MPFitThreeGaussExtract: i_row = " << i_row << ": i_row_rel = " << i_row_rel << endl;
              #endif
              if ((i_row_rel < 0) || (i_row_rel >= D_A1_GaussMean.size())){
                cout << "CFits::MPFitThreeGaussExtract: ERROR: i_row_rel = " << i_row_rel << " out of bounds" << endl;
                return false;
              }
              D_A1_GaussMean(i_row_rel) = D_A1_CoeffsGauss(I_Ind+1);
              D_A1_GaussSigma(i_row_rel) = D_A1_CoeffsGauss(I_Ind+2);
            }
//            else
//              return false;
            B_LastRow1 = false;
            B_LastRow2 = false;
            B_LastRow3 = true;
          }//end else if I_NApsWithCrossTalk == 2
        }
        else{/// No CrossTalk
          if (i_run == 0){
            D_A1_GuessOne(I_Ind+1) = (*(this->P_D_A2_XCenters))(i_ap, i_row) + ((D_A1_MeanLimits_In(1) + D_A1_MeanLimits_In(0))/2.);
            D_A1_GuessOne(I_Ind+2) = D_A1_SDevLimits_In(0) + ((D_A1_SDevLimits_In(1) - D_A1_SDevLimits_In(0))/2.);
          }
          else{
            if (D_A1_MeanFit.size() <= i_row_rel){
              cout << "CFits::MPFitThreeGaussExtract: Error: D_A1_MeanFit.size(=" << D_A1_MeanFit.size() << ") <= i_row_rel(=" << i_row_rel << ")" << endl;
              return false;
            }
            D_A1_GuessOne(I_Ind+1) = D_A1_MeanFit(i_row_rel);
            D_A1_GuessOne(I_Ind+2) = D_GaussSigma;
          }

          D_A1_XInt(0) = D_A1_X(0);
          D_A1_XInt(1) = D_A1_X(I_NPix-1);
          if (!this->IntegralUnderCurve(D_A1_X, D_A1_YTemp, D_A1_XInt, D_Integral)){
            cout << "CFits::MPFitThreeGaussExtract: ERROR: IntegralUnderCurve(" << D_A1_X << ", " << D_A1_Y << ", " << D_A1_XInt << ", D_Integral) returned FALSE" << endl;
            return false;
          }
          D_A1_GuessOne(I_Ind) = D_Integral;

          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_XInt = " << D_A1_XInt << endl;
            cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A1_GuessOne = " << D_A1_GuessOne << endl;
          #endif
          if (B_WithBackground_In){
            D_A2_ParLimitsOne(0,0) = 0;
            D_A2_ParLimitsOne(0,1) = D_A1_GuessOne(0) + (10. * this->D_ReadOutNoise);
            if (D_A2_ParLimitsOne(0,1) < D_A2_ParLimitsOne(0,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsOne(0,1) < D_A2_ParLimitsOne(0,0)" << endl;
              return false;
            }
          }
          D_A2_ParLimitsOne(I_Ind, 1) = 2. * D_A1_GuessOne(I_Ind);
          if (D_A2_ParLimitsOne(I_Ind, 1) < 0.)
            if (max(D_A1_Y) > 0.){
              D_A2_ParLimitsOne(I_Ind, 1) = 2. * max(D_A1_Y) * D_A1_GuessOne(I_Ind+2) * sqrt(2. * D_PI);
            }
            else{
              D_A2_ParLimitsOne(I_Ind, 1) = 0.0001;
            }
          if (D_A2_ParLimitsOne(I_Ind,1) < D_A2_ParLimitsOne(I_Ind,0)){
            cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsOne(" << I_Ind << ",1)=" << D_A2_ParLimitsOne(I_Ind,1) << " < D_A2_ParLimitsOne(" << I_Ind << ",0)=" << D_A2_ParLimitsOne(I_Ind,0) << ", max(D_A1_Y) = " << max(D_A1_Y) << ", D_A1_GuessOne(I_Ind=" << I_Ind << "), sqrt(2*Pi)=" << sqrt(2. * D_PI) << endl;
            return false;
          }
          if (i_run == 0){
            D_A2_ParLimitsOne(I_Ind+1, 0) = D_A1_GuessOne(I_Ind+1) + D_A1_MeanLimits_In(0);
            D_A2_ParLimitsOne(I_Ind+1, 1) = D_A1_GuessOne(I_Ind+1) + D_A1_MeanLimits_In(1);
            if (D_A2_ParLimitsOne(I_Ind+1,1) < D_A2_ParLimitsOne(I_Ind+1,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsOne(I_Ind+1=" << I_Ind+1 << ",1)=" << D_A2_ParLimitsOne(I_Ind+1,1) << " < D_A2_ParLimitsOne(" << I_Ind+1 << ",0)=" << D_A2_ParLimitsOne(I_Ind+1,0) << endl;
              return false;
            }
            D_A2_ParLimitsOne(I_Ind+2, 0) = D_A1_SDevLimits_In(0);
            D_A2_ParLimitsOne(I_Ind+2, 1) = D_A1_SDevLimits_In(1);
            if (D_A2_ParLimitsOne(I_Ind+2,1) < D_A2_ParLimitsOne(I_Ind+2,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsOne(" << I_Ind+2 << ",1) < D_A2_ParLimitsOne(" << I_Ind+2 << ",0)" << endl;
              return false;
            }
          }
          else{
            if (D_A1_MeanFit.size() <= i_row_rel){
              cout << "CFits::MPFitThreeGaussExtract: Error: D_A1_MeanFit.size(=" << D_A1_MeanFit.size() << ") <= i_row_rel(=" << i_row_rel << ")" << endl;
              return false;
            }
            D_A2_ParLimitsOne(I_Ind+1, 0) = D_A1_MeanFit(i_row_rel) - 0.01;
            D_A2_ParLimitsOne(I_Ind+1, 1) = D_A1_MeanFit(i_row_rel) + 0.01;
            if (D_A2_ParLimitsOne(I_Ind+1,1) < D_A2_ParLimitsOne(I_Ind+1,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsOne(I_Ind+1=" << I_Ind+1 << ",1)=" <<  D_A2_ParLimitsOne(I_Ind+1,1) << " < D_A2_ParLimitsOne(I_Ind+1=" << I_Ind+1 << ",0)=" << D_A2_ParLimitsOne(I_Ind+1,0) << endl;
              return false;
            }
            D_A2_ParLimitsOne(I_Ind+2, 0) = D_GaussSigma - (D_GaussSigma / 4.);
            D_A2_ParLimitsOne(I_Ind+2, 1) = D_GaussSigma + (D_GaussSigma / 2.);
            if (D_A2_ParLimitsOne(I_Ind+2,1) < D_A2_ParLimitsOne(I_Ind+2,0)){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: D_A2_ParLimitsOne(" << I_Ind+2 << ",1) < D_A2_ParLimitsOne(" << I_Ind+2 << ",0)" << endl;
              return false;
            }
          }
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_row=" << i_row << ": D_A2_ParLimitsOne = " << D_A2_ParLimitsOne << endl;
          #endif

          if (!MPFitGaussLim(D_A1_X,
                             D_A1_Y,
                             D_A1_SigY,
                             D_A1_GuessOne,
                             I_A2_ParLimitedOne,
                             D_A2_ParLimitsOne,
                             B_WithBackground_In,
                             true,
                             D_A1_CoeffsOne,
                             D_A1_ECoeffsOne)){
            cout << "CFits::MPFitThreeGaussExtract: ERROR: MPFitGaussLim returned FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitThreeGaussExtract: i_ap=" << i_ap << ": i_run = " << i_run << ": i_row=" << i_row << ": i_row_rel = " << i_row_rel << ": D_A1_CoeffsOne = " << D_A1_CoeffsOne << endl;
          #endif
          D_A1_CoeffsGauss = D_A1_CoeffsOne(Range(0, I_Ind + 2));
          D_A1_ECoeffsGauss = D_A1_ECoeffsOne(Range(0, I_Ind + 2));
          if (i_run == 0){
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: i_row = " << i_row << ": i_row_rel = " << i_row_rel << endl;
            #endif
            if ((i_row_rel < 0) || (i_row_rel >= D_A1_GaussMean.size())){
              cout << "CFits::MPFitThreeGaussExtract: ERROR: i_row_rel = " << i_row_rel << " out of bounds" << endl;
              return false;
            }
            D_A1_GaussMean(i_row_rel) = D_A1_CoeffsGauss(I_Ind+1);
            D_A1_GaussSigma(i_row_rel) = D_A1_CoeffsGauss(I_Ind+2);
          }
//          else{
//            if (B_LastRow2 && i_row == 1013)
//              return false;
//          }
          B_LastRow1 = true;
          B_LastRow2 = false;
          B_LastRow3 = false;
        }/// end else if no cross talk


        if (i_run == 0){
          if (i_row_rel == D_A1_GaussMean.size()-1){
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: D_A1_GaussSigma = " << D_A1_GaussSigma << endl;
            #endif
            D_GaussSigma = this->Median(D_A1_GaussSigma);
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: D_GaussSigma = " << D_GaussSigma << endl;
            #endif
            ///    YFIT=yfit: Array<double, 1>(D_A1_X_In.size()): out
            Array<double, 1> *P_D_A1_Row = this->DIndGenArr(D_A1_GaussMean.size());
            Array<CString, 1> CS_A1_PolyFit_KeyWords(1);
            CS_A1_PolyFit_KeyWords(0) = CString("YFIT");
            void **PP_Args_PolyFit = (void**)malloc(sizeof(void*));
            D_A1_MeanFit.resize(D_A1_GaussMean.size());
            PP_Args_PolyFit[0] = &D_A1_MeanFit;
            Array<double, 1> *P_D_A1_PolyFitCoeffs = new Array<double, 1>(4);
            if (!this->PolyFit(*P_D_A1_Row,
                               D_A1_GaussMean,
                               3,
                               CS_A1_PolyFit_KeyWords,
                               PP_Args_PolyFit,
                               P_D_A1_PolyFitCoeffs)){
              cout << "CFite::MPFitThreeGaussExtract: ERROR: PolyFit returned FALSE" << endl;
              return false;
            }
            delete(P_D_A1_Row);
            delete(P_D_A1_PolyFitCoeffs);
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: D_A1_GaussMean = " << D_A1_GaussMean << endl;
              cout << "CFits::MPFitThreeGaussExtract: D_A1_MeanFit = " << D_A1_MeanFit << endl;
            #endif
//            return false;
          }
        }/// end if (i_run == 0){
        else{
          (*(this->P_D_A2_LastExtracted))(i_ap, i_row) = D_A1_CoeffsGauss(I_Ind);
          (*(this->P_D_A2_Errors_Ec))(i_ap, i_row) = D_A1_ECoeffsGauss(I_Ind);
          (*(this->P_D_A2_Errors_EcFit))(i_ap, i_row) = D_A1_ECoeffsGauss(I_Ind);
          if (B_WithBackground_In){
            (*(this->P_D_A2_Sky))(i_ap, i_row) = D_A1_CoeffsGauss(0);
            (*(this->P_D_A2_SkyFit))(i_ap, i_row) = D_A1_CoeffsGauss(0);
            (*(this->P_D_A2_SkyError))(i_ap, i_row) = D_A1_ECoeffsGauss(0);
            (*(this->P_D_A2_SkyFitError))(i_ap, i_row) = D_A1_ECoeffsGauss(0);
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: (*(this->P_D_A2_SkyFit))(" << i_ap << ", " << i_row << ") set to " << (*(this->P_D_A2_SkyFit))(i_ap, i_row) << endl;
            #endif
            (*(this->P_D_A2_RecSkyArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                       int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)))) = D_A1_CoeffsGauss(0);
            #ifdef __DEBUG_FITS_GAUSSEXTRACT__
              cout << "CFits::MPFitThreeGaussExtract: (*(this->P_D_A2_RecSkyArray))(" << i_row << ", Range(" << int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)) << ", " << int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)) << ")) set to " << (*(this->P_D_A2_RecSkyArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap)))) << endl;
            #endif
          }
          P_D_A1_XGauss = this->DIndGenArr(int((*(this->P_D_A1_XHigh))(i_ap) - (*(this->P_D_A1_XLow))(i_ap)) + 1);
          *P_D_A1_XGauss = *P_D_A1_XGauss + (*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap);
          for (int i_xpix=0; i_xpix<P_D_A1_XGauss->size(); i_xpix++)
            (*P_D_A1_XGauss)(i_xpix) = double(int((*P_D_A1_XGauss)(i_xpix)));
          D_A1_YGauss.resize(P_D_A1_XGauss->size());
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitThreeGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_XGauss set to " << *P_D_A1_XGauss << endl;
            cout << "CFits::MPFitThreeGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_CoeffsGauss set to " << D_A1_CoeffsGauss << endl;
          #endif
          Array<double, 1> D_A1_CoeffsGaussTemp(D_A1_CoeffsGauss.size());
          D_A1_CoeffsGaussTemp = D_A1_CoeffsGauss;
          D_A1_CoeffsGaussTemp(I_Ind) = 1.;
          if (!this->GaussArea(*P_D_A1_XGauss,
                               D_A1_CoeffsGaussTemp(Range(I_Ind, I_Ind+2)),
                               D_A1_YGauss)){
            cout << "CFits::MPFitThreeGaussExtract: ERROR: GaussArea(" << *P_D_A1_XGauss << ", " << D_A1_CoeffsGauss << ", D_A1_YGauss) returned FALSE" << endl;
            return false;
          }
          #ifdef __DEBUG_FITS_GAUSSEXTRACT__
            cout << "CFits::MPFitThreeGaussExtract: i_ap = " << i_ap << ": i_row = " << i_row << ": D_A1_YGauss set to " << D_A1_YGauss << endl;
          #endif
//        return false;
          (*(this->P_D_A2_ProfArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                   int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
          = (*(this->P_D_A2_ProfArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                     int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
            + (D_A1_YGauss);
          (*(this->P_D_A2_RecFitArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                     int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
          = (*(this->P_D_A2_RecFitArray))(i_row, Range(int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XLow))(i_ap)),
                                                       int((*(this->P_D_A2_XCenters))(i_ap, i_row) + (*(this->P_D_A1_XHigh))(i_ap))))
            + (D_A1_YGauss * D_A1_CoeffsGauss(I_Ind));
          delete(P_D_A1_XGauss);
        }/// end else if (i_run == 1){
      }/// end for (int i_row = (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YLow))(i_ap); i_row <= (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YHigh))(i_ap); i_row++){
      }/// end for (int i_run = 0; i_run < 2; i_run++){
    }/// end if (((*(this->P_D_A1_XCenter))(i_ap) >= I_XMin)
     ///   && ((*(this->P_D_A1_XCenter))(i_ap) <= I_XMax)
     ///   && ((((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YLow))(i_ap) >= I_YMin)
     ///   && ((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YLow))(i_ap) <= I_YMax))
     ///   || (((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YHigh))(i_ap) >= I_YMin)
     ///   && ((*(this->P_D_A1_YCenter))(i_ap)+(*(this->P_D_A1_YHigh))(i_ap) <= I_YMax)))){
//    return false;
//    if (i_ap == 861)
//      return false;
  }/// end for (iap=0; iap < P_I_A1_AperturesToExtract->size(); iap++){
  return true;
}

bool CFits::ShiftApertures(double D_Shift_In){
  (*(this->P_D_A1_XCenter)) += D_Shift_In;
  (*(this->P_D_A2_XCenters)) += D_Shift_In;
  (*(this->P_D_A2_Coeffs))(Range::all(), 0) += D_Shift_In;
  return true;
}

bool CFits::CalculateLensletCorners(Array<double, 3> &D_A3_LensletCorners_Out){
  if (!this->TraceFunctionsCalculated){
    cout << "CFits::CalculateLensletCorners: ERROR: Trace functions not calculated yet" << endl;
    return false;
  }

  Array<double, 2> D_A2_ApCenters(this->I_NApertures,2);
  Array<double, 1> D_A1_YCenter(this->I_NApertures);
  Array<double, 1> D_A1_XCenter(this->I_NApertures);
  for (int i_ap=0; i_ap<this->I_NApertures; i_ap++){
    D_A1_YCenter(i_ap) = (*(this->P_D_A1_YCenter))(i_ap) + (*(this->P_D_A1_YLow))(i_ap) + (((*(this->P_D_A1_YHigh))(i_ap) - (*(this->P_D_A1_YLow))(i_ap)) / 2.);
    D_A1_XCenter(i_ap) = (*(this->P_D_A2_XCenters))(i_ap, (int)(D_A1_YCenter)(i_ap));
  }
  D_A2_ApCenters(Range::all(),0) = D_A1_XCenter;
  D_A2_ApCenters(Range::all(),1) = D_A1_YCenter;

  Array<double, 1> D_A1_Coords(2);
  //  Array<double, 1> D_A1_NearestNeighbour(2);
  Array<double, 2> D_A2_LensletPos(this->I_NApertures,2);
  int I_Pos;
  //  cout << "CFits::CalculateLensletCorners: D_A2_PredApCenters_In = " << D_A2_PredApCenters_In << endl;
  //  cout << "CFits::CalculateLensletCorners: D_A2_PredApCenters = " << D_A2_PredApCenters << endl;
  CString *P_CS_Ap;
  CString CS_FileName;
  CString CS_Underscore("_");
  int I_FileProblem;
  Array<double, 2> D_A2_Lenslet_Ap(this->I_NApertures,2);
  for (int I_Ap=0; I_Ap<this->I_NApertures; I_Ap++){
    ///Find Aperture Number
//    D_A2_Lenslet_Ap(I_Ap, 0) = i_file;
//    D_A2_Lenslet_Ap(i_file, 1) = I_Ap;

    ///Find nearest neighbour in conversion file
    D_A1_Coords = D_A2_ApCenters(I_Ap,Range::all());

    D_A2_LensletPos(I_Ap,Range(0,1)) = D_A1_Coords;
  }
//  F_Image.WriteArrayToFile(D_A2_Lenslet_Ap, CString("lenslet_ap.list"), CString("ascii"));
  #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
    cout << "CFits::CalculateLensletCorners: D_A2_LensletPos = " << D_A2_LensletPos << endl;
  #endif
  double D_XMin, D_XMax, D_YMin, D_YMax;
  D_XMin = min(D_A2_LensletPos(Range::all(),0));
  D_XMax = max(D_A2_LensletPos(Range::all(),0));
  D_YMin = min(D_A2_LensletPos(Range::all(),1));
  D_YMax = max(D_A2_LensletPos(Range::all(),1));
  #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
  cout << "CFits::CalculateLensletCorners: D_XMin = " << D_XMin << ", D_XMax = " << D_XMax << ", D_X=YMin = " << D_YMin << ", D_YMax = " << D_YMax << endl;
  #endif

  Array<double, 2> D_A2_LensletPos_CCD(D_A2_LensletPos.rows(), 2);
  D_A2_LensletPos_CCD = D_A2_LensletPos(Range::all(), Range(0,1));

  ///find D_LensletDist_in_Pixels
  D_A1_Coords = D_A2_LensletPos_CCD(int(D_A2_LensletPos_CCD.rows()/2.),Range::all());
  //D_A1_Coords = D_A2_ApCenters_In(int(D_A2_ApCenters_In.rows()/2.),Range::all());
  cout << "CFits::CalculateLensletCorners: trying to find D_LensletDist_in_Pixels: D_A1_Coords = " << D_A1_Coords << endl;
  int I_NNearestNeighbours = 4;
  Array<double, 2> D_A2_NearestNeighbours(I_NNearestNeighbours, 2);
  Array<int, 1> I_A1_PosInLensletPos_CCD_Array(I_NNearestNeighbours);
  if (!this->FindNearestNeighbours(D_A1_Coords,
                                   D_A2_LensletPos_CCD,
                                   I_NNearestNeighbours,
                                   D_A2_NearestNeighbours,
                                   I_A1_PosInLensletPos_CCD_Array)){
    cout << "CFits::CalculateLensletCorners: ERROR: FindNearestNeighbours to determine lenslet size in pixels returned FALSE" << endl;
    return false;
  }
  #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
    cout << "CFits::CalculateLensletCorners: D_A2_NearestNeighbours = " << D_A2_NearestNeighbours << endl;
    cout << "CFits::CalculateLensletCorners: I_A1_PosInLensletPos_CCD_Array = " << I_A1_PosInLensletPos_CCD_Array << endl;
  #endif

  Array<double, 1> D_A1_Dist(I_NNearestNeighbours);
  for (int i=0; i<I_NNearestNeighbours; i++){
    #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
      cout << "CFits::CalculateLensletCorners: D_A2_LensletPos_CCD(I_A1_PosInLensletPos_CCD_Array(i),Range::all()) = " << D_A2_LensletPos_CCD(I_A1_PosInLensletPos_CCD_Array(i), Range::all()) << endl;
    #endif
    D_A1_Dist(i) = sqrt(pow2(D_A2_NearestNeighbours(i,0) - D_A1_Coords(0)) + pow2(D_A2_NearestNeighbours(i,1) - D_A1_Coords(1)));
  }
  #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
    cout << "CFits::CalculateLensletCorners: D_A1_Dist set to " << D_A1_Dist << endl;
  #endif
  double D_LensletDist_in_Pixels = D_A1_Dist(I_NNearestNeighbours-1);
  #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
    cout << "CFits::CalculateLensletCorners: D_LensletDist_in_Pixels set to " << D_LensletDist_in_Pixels << endl;
  #endif

  /// Find the six corner points for all lenslets
  I_NNearestNeighbours = 7;
  #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
    cout << "CFits::CalculateLensletCorners: I_NNearestNeighbours set to " << I_NNearestNeighbours << endl;
  #endif
  D_A2_NearestNeighbours.resize(I_NNearestNeighbours, 2);
  I_A1_PosInLensletPos_CCD_Array.resize(I_NNearestNeighbours);
  double D_MinDist;
  D_A1_Dist.resize(I_NNearestNeighbours);
  Array<double, 3> D_A3_NearestNeighbours_Coords(D_A2_LensletPos_CCD.rows(), I_NNearestNeighbours-1, 2);
  D_A3_NearestNeighbours_Coords = 0.;
  Array<double, 3> D_A3_NearestNeighbours_HalfWay(D_A2_LensletPos_CCD.rows(), I_NNearestNeighbours-1, 2);
  D_A3_NearestNeighbours_Coords = 0.;
  int N_Neighbours;
  Array<double, 2> D_A2_Coords_Sorted(6,2);
  Array<double, 1> D_A1_PixA(2);
  Array<double, 1> D_A1_PixB(2);
  double D_Length_A, D_Length_B, D_Length;
  Array<double, 1> D_A1_PixHalf(2);
  D_A3_LensletCorners_Out.resize(D_A2_LensletPos_CCD.rows(),6,2);
  Array<double, 1> D_A1_CornerPoint(2);
  CString *P_CS_Lenslet;
  CString CS_FName(" ");
  D_A3_LensletCorners_Out = 0.;
  Array<double, 2> D_A2_Corners_Sorted(6,2);
  CString CS_CornerFile_Out("");
  CString *P_CS_Temp;

  for (int i_lenslet=0; i_lenslet < D_A2_LensletPos_CCD.rows(); i_lenslet++){
    if (!this->FindNearestNeighbours(D_A2_LensletPos_CCD(i_lenslet,Range::all()),
                                     D_A2_LensletPos_CCD,
                                     I_NNearestNeighbours,
                                     D_A2_NearestNeighbours,
                                     I_A1_PosInLensletPos_CCD_Array)){
      cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": ERROR: FindNearestNeighbours returned FALSE" << endl;
      return false;
    }
    #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
      cout << "CFits::CalculateLensletCorners: i_lenslet=" << i_lenslet << ": D_A2_Coords=" << D_A2_LensletPos_CCD(i_lenslet,Range::all()) << " D_A2_NearestNeighbours = " << D_A2_NearestNeighbours << endl;
    #endif

    ///Remove nearest neighbours which are further than 1.8 times the distance to THE nearest neighbour away <= probably misidentification close to a border of a rectangular pixel
    D_A1_Dist = sqrt(pow2(D_A2_LensletPos_CCD(i_lenslet, 0) - D_A2_NearestNeighbours(Range::all(),0)) + pow2(D_A2_LensletPos_CCD(i_lenslet, 1) - D_A2_NearestNeighbours(Range::all(),1)));
    #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
      cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": D_A1_Dist = " << D_A1_Dist << endl;
    #endif

    D_MinDist = min(D_A1_Dist(Range(1,I_NNearestNeighbours-1)));
    #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
      cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": D_MinDist = " << D_MinDist << endl;
    #endif

    N_Neighbours = 0;
    for (int i=1; i<I_NNearestNeighbours; i++){
      if (D_A1_Dist(i) < 1.8 * D_MinDist){
        D_A3_NearestNeighbours_Coords(i_lenslet, N_Neighbours, Range::all()) = D_A2_NearestNeighbours(i,Range::all());

        D_A3_NearestNeighbours_HalfWay(i_lenslet, N_Neighbours, 0) = D_A2_LensletPos_CCD(i_lenslet, 0) + ((D_A2_NearestNeighbours(i,0) - D_A2_LensletPos_CCD(i_lenslet, 0)) / 2.);

        D_A3_NearestNeighbours_HalfWay(i_lenslet, N_Neighbours, 1) = D_A2_LensletPos_CCD(i_lenslet, 1) + ((D_A2_NearestNeighbours(i,1) - D_A2_LensletPos_CCD(i_lenslet, 1)) / 2.);

        N_Neighbours++;
      }
    }
    #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
      cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": D_A3_NearestNeighbours_Coords(i_lenslet,*,*) = " << D_A3_NearestNeighbours_Coords(i_lenslet, Range::all(), Range::all()) << endl;
      cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": D_A3_NearestNeighbours_HalfWay(i_lenslet,*,*) = " << D_A3_NearestNeighbours_HalfWay(i_lenslet, Range::all(), Range::all()) << endl;
    #endif
    if ((max(D_A1_Dist) < D_LensletDist_in_Pixels*3.)){
      /// Sort Nearest Neighbours to create hexagon
      if (this->SortCoordinatesToCreateHexagon(D_A3_NearestNeighbours_HalfWay(i_lenslet, Range::all(), Range::all()), D_A2_Coords_Sorted)){
        #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
          cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": D_A2_Coords_Sorted = " << D_A2_Coords_Sorted << endl;
        #endif

        /// Calculate corner points of hexagon
        for (int i_corner=0; i_corner<D_A2_Coords_Sorted.rows(); i_corner++){
          D_A1_PixA = D_A2_Coords_Sorted(i_corner,Range::all());
          if (i_corner < D_A2_Coords_Sorted.rows()-1)
            D_A1_PixB = D_A2_Coords_Sorted(i_corner+1,Range::all());
          else
            D_A1_PixB = D_A2_Coords_Sorted(0,Range::all());
          D_Length_A = this->Distance(D_A2_LensletPos_CCD(i_lenslet, Range::all()), D_A1_PixA) / cos(D_PI/6.);
          D_Length_B = this->Distance(D_A2_LensletPos_CCD(i_lenslet, Range::all()), D_A1_PixB) / cos(D_PI/6.);
          #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
            cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": D_Length_A = " << D_Length_A << ", D_Length_B = " << D_Length_B << endl;
            if (fabs(D_Length_A - D_Length_B) > D_Length_A * 0.05){
              cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": WARNING: D_Length_A and D_Length_B disagree by more than 5%" << endl;
            }
          #endif

          D_Length = (D_Length_A + D_Length_B) / 2.;
          D_A1_PixHalf(0) = D_A1_PixA(0) + ((D_A1_PixB(0) - D_A1_PixA(0)) / 2.);
          D_A1_PixHalf(1) = D_A1_PixA(1) + ((D_A1_PixB(1) - D_A1_PixA(1)) / 2.);
          #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
            cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": D_A1_PixHalf = " << D_A1_PixHalf << endl;
          #endif
          if (!this->ExtendLineToLength(D_A2_LensletPos_CCD(i_lenslet, Range::all()),
                                        D_A1_PixHalf,
                                        D_Length,
                                        D_A1_CornerPoint)){
            cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": ERROR: ExtendLineToLength returned FALSE" << endl;
            return false;;
          }
          if (min(D_A1_CornerPoint) < 0.){
            cout << "CFits::CalculateLensletCorners: WARNING: D_A1_CornerPoint = " << D_A1_CornerPoint << " < 0" << endl;
//            return false;
          }
          else{
            D_A3_LensletCorners_Out(i_lenslet, i_corner, Range::all()) = D_A1_CornerPoint;
            #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
              cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": D_A1_CornerPoint = " << D_A1_CornerPoint << endl;
            #endif
          }
        }/// end for (int i_corner=0; i_corner<D_A2_Coords_Sorted.rows(); i_corner++)

//        CS_CornerFile_Out.Set("corners_aperture");
//        P_CS_Temp = CS_CornerFile_Out.DToA(D_A2_Lenslet_Ap(i_lenslet, 1),0);
//        //        cout << "CFits::CalculateLensletCorners: double = " << D_A2_Lenslet_Ap(i_lenslet,1) << ": P_CS_Temp = " << *P_CS_Temp << endl;
//        //        exit(EXIT_FAILURE);
//        CS_CornerFile_Out.Add(*P_CS_Temp);
//        delete(P_CS_Temp);
//        CS_CornerFile_Out.Add(CString(".dat"));
//        if (!this->WriteArrayToFile(D_A3_CornerPoints(i_lenslet,Range::all(), Range::all()), CS_CornerFile_Out, CString("ascii"))){
//          cout << "CFits::CalculateLensletCorners: ERROR: WriteArrayToFile(" << CS_CornerFile_Out << ") returned FALSE" << endl;
//          return false;
//        }
            //        P_CS_Lenslet = CS_Area.IToA(i_lenslet);
            //        F_Image.SortCoordinatesToCreateHexagon(D_A3_CornerPoints(i_lenslet, Range::all(), Range::all()), D_A2_Corners_Sorted);
            //        cout << "CFits::CalculateLensletCorners: i_lenslet=" << i_lenslet << ": D_A2_Corners_Sorted = " << D_A2_Corners_Sorted << endl;
            //        CS_FName.Set("/home/azuri/spectra/SEDIFU/corners_lenslet_");
            //        CS_FName += *P_CS_Lenslet;
            //        CS_FName += CString(".dat");
            //        F_Image.WriteArrayToFile(D_A2_Corners_Sorted, CS_FName, CString("ascii"));
            //        delete(P_CS_Lenslet);
            //      if (i_lenslet == 250)
            //        exit(EXIT_FAILURE);
      }
      else{
        cout << "CFits::CalculateLensletCorners: i_lenslet = " << i_lenslet << ": WARNING: SortCoordinatesToCreateHexagon returned FALSE" << endl;
        //exit(EXIT_FAILURE);
      }
      //      if (int(D_A2_Lenslet_Ap(i_lenslet, 1)) == 1452)
      //        exit(EXIT_FAILURE);
    }/// end if ((max(D_A1_Dist) < D_LensletDist_in_Pixels*1.1))
    else{
      cout << "CFits::CalculateLensletCorners: i_lenslet=" << i_lenslet << ": WARNING: max(D_A1_Dist)=" << max(D_A1_Dist) << " >= D_LensletDist_in_Pixels*1.5=" << D_LensletDist_in_Pixels*1.5 << " => ignoring" << endl;
      //      if (i_lenslet == 250)
      //        exit(EXIT_FAILURE);
    }
  }/// end for (int i_lenslet=0; i_lenslet < D_A2_LensletPos_CCD.rows(); i_lenslet++)
  #ifdef __DEBUG_FITS_CALCULATELENSLETCORNERS__
    cout << "CFits::CalculateLensletCorners: D_A3_LensletCorners_Out = " << D_A3_LensletCorners_Out << endl;
  #endif
  return true;
}


bool CFits::Fit2DGaussianCB(const Array<double, 1> &D_A1_X_In,
                            const Array<double, 1> &D_A1_Y_In,
                            const Array<double, 1> &D_A1_Z_In,
                            const Array<double, 1> &D_A1_Guess_In,//(background, peak, mean_x, mean_y, sigma)
                            const Array<double, 2> &D_A2_Limits_In,//(background, peak, mean_x, mean_y, sigma)
                            Array<double, 1> &D_A1_Coeffs_Out) const{
  /*
   *bool MPFit2DGaussLim(const Array< double, 1 >& D_A1_X_In,
                     const Array< double, 1 >& D_A1_Y_In,
                     const Array< double, 1 >& D_A1_Z_In,
                     const Array< double, 1 >& D_A1_Guess_In,
                     const Array<int, 2> &I_A2_Limited,
                     const Array<double, 2> &D_A2_Limits,
                     Array< double, 1 >& D_A1_Coeffs_Out,
                     Array< double, 1 >& D_A1_ECoeffs_Out)
                     */
  Array<int, 2> I_A2_Limited(D_A1_Guess_In.size(), 2);
  I_A2_Limited = 1;
  Array<double, 1> D_A1_ECoeffs(D_A1_Guess_In.size());
  D_A1_ECoeffs = 1.;
  return MPFit2DGaussLim(D_A1_X_In,
                         D_A1_Y_In,
                         D_A1_Z_In,
                         D_A1_Guess_In,
                         I_A2_Limited,
                         D_A2_Limits_In,
                         D_A1_Coeffs_Out,
                         D_A1_ECoeffs);
}

bool CFits::Rebin2D(const Array<double, 2> &D_A2_XYZ_In,///(NPoints, 3)
                    const Array<double, 1> &D_A1_XNew_In,///(NPointsNew)
                    const Array<double, 1> &D_A1_YNew_In,///(NPointsNew)
                    Array<double, 2> &D_A2_XYZ_Out,
                    int I_NNearestNeighbours) const{///(NPointsNew, 3)
  int dim_cspace = 2;
  double pred, var, D_Z;
  double i_a, i_b;
  const size_t num_samples = I_NNearestNeighbours;
  Array<double, 1> D_A1_RefPoint(2);
  Array<double, 2> D_A2_XY(D_A2_XYZ_In.rows(),2);
  D_A2_XYZ_Out.resize(D_A1_XNew_In.size(), 3);
  D_A2_XYZ_Out(Range::all(), 0) = D_A1_XNew_In;
  D_A2_XYZ_Out(Range::all(), 1) = D_A1_YNew_In;
  Array<double, 2> D_A2_Neighbours(3,3);

  for (int i_pt=0; i_pt<D_A2_XYZ_In.rows(); i_pt++){
    D_A2_XY(i_pt, 0) = D_A2_XYZ_In(i_pt, 0);
    D_A2_XY(i_pt, 1) = D_A2_XYZ_In(i_pt, 1);
  }

  Array<int, 1> I_A1_Pos(3);
  Array<double, 2> D_A2_NearestNeighbours_Out(I_NNearestNeighbours,2);
  for (int i_pt=0; i_pt<D_A1_XNew_In.size(); i_pt++){
    D_A1_RefPoint(0) = D_A1_XNew_In(i_pt);
    D_A1_RefPoint(1) = D_A1_YNew_In(i_pt);

    if (!this->FindNearestNeighbours(D_A1_RefPoint,
                                     D_A2_XY,
                                     I_NNearestNeighbours,
                                     D_A2_NearestNeighbours_Out,
                                     I_A1_Pos)){
      cout << "CFits::Rebin2D: WARNING: Could not find " << I_NNearestNeighbours << " nearest neighbours for point " << D_A1_RefPoint << endl;
    }
    else{
      D_A2_Neighbours.resize(I_A1_Pos.size(), 3);
      for (int i_n=0; i_n<I_A1_Pos.size(); i_n++){
        D_A2_Neighbours(i_n, Range::all()) = D_A2_XYZ_In(I_A1_Pos(i_n), Range::all());
      }
      if (!this->InterPol3D(D_A2_Neighbours, D_A1_RefPoint, D_Z)){
        cout << "CFits::Rebin2D: WARNING: InterPol3D returned FALSE" << endl;
        D_A2_XYZ_Out(i_pt, 2) = D_A2_XYZ_In(I_A1_Pos(0), 2);
      }
      else{
        D_A2_XYZ_Out(i_pt, 2) = D_Z;
        cout << "CFits::Rebin2D: D_A2_Neighbours = " << D_A2_Neighbours << endl;
        cout << "CFits::Rebin2D: D_A1_RefPoint = " << D_A1_RefPoint << endl;
        cout << "CFits::D_A2_XYZ_Out(i_pt, *) = " << D_A2_XYZ_Out(i_pt, Range::all()) << endl;
//        return false;
      }
/*      // kriging predictor
      CGeostat krig;

      // initialize kriging predictor
      krig.initialize(num_samples, dim_cspace);

      //
      // define a doCFits::CalcScatterKriging of control space
      //
      gsl_vector *lower = gsl_vector_alloc(dim_cspace);
      gsl_vector *upper = gsl_vector_alloc(dim_cspace);
      //
      //control parameter c1 : 0 <= c1 <= 4.0
      gsl_vector_set(lower, 0, 0.0);
      gsl_vector_set(upper, 0, max(D_A2_XY(Range::all(), 0)));
      //
      // control parameter c2 : 0 <= c2 <= 5.0
      gsl_vector_set(lower, 1, 0.0);
      gsl_vector_set(upper, 1, max(D_A2_XY(Range::all(), 1)));
      //
      // set doCFits::CalcScatterKriging
//      cout << "CFits::CalcScatterKriging: starting kriging setDoCFits::CalcScatterKriging" << endl;
      krig.setDomain(lower, upper);
      //
      gsl_vector_free(lower);
      gsl_vector_free(upper);

      //
      // sample data
      //
//      cout << "CFits::CalcScatterKriging: starting gsl_vector_alloc *c" << endl;
      gsl_vector *c = gsl_vector_alloc(dim_cspace);

//      cout << "CFits::CalcScatterKriging: starting kriging setData for loop" << endl;
      for (int i = 0; i < num_samples; i++){
        i_a = D_A2_NearestNeighbours_Out(i,0);
        i_b = D_A2_NearestNeighbours_Out(i,1);
        cout << "i_a = " << i_a << ", i_b = " << i_b << ": D_A2_XYZ_In" << I_A1_Pos(i) << ", 2) = " << D_A2_XYZ_In(I_A1_Pos(i), 2) << endl;
        gsl_vector_set(c, 0, i_a);
        gsl_vector_set(c, 1, i_b);
        //
        // coordinate of i-th sample
        krig.setCoordinate(i, c);
        krig.setData(i, D_A2_XYZ_In(I_A1_Pos(i), 2));
      }

      //
      // precomputation of statistical analysis
      //
      //  using Spherical variogram model
      //  power coefficient = 0 (only use for stable variogram model)
      //  step width (h_step = 0.1)
      //krig.estimate(CVariogram::VARIO_SPH, 0, 0.1);
      cout << "CFits::CalcScatterKriging: starting kriging estimate" << endl;
      krig.estimate(CVariogram::VARIO_SPH, 0, 1.);

      cout << "CFits::CalcScatterKriging: starting kriging prediction" << endl;
      // target parameter c1
      gsl_vector_set(c, 0, D_A1_RefPoint(0));
      gsl_vector_set(c, 1, D_A1_RefPoint(1));

      // predictive value and estimate variance at parameter c
      krig.getPredictData(pred, var, c);
      D_A2_XYZ_Out(i_pt, 2) = pred;

      gsl_vector_free(c);
*/
    }
  }
  return true;
}


bool CFits::InterPol3D(const Array<double, 2> &D_A2_RefPoints,///(NPoints=3, 3)
                       const Array<double, 1> &D_A1_XY_In,
                       double &D_Z_Out) const{
  Array<double, 2> D_A2_RefPoints_XY(3,2);
  D_A2_RefPoints_XY = D_A2_RefPoints(Range::all(), Range(0,1));
  if (!this->PixelIsInTriangle(D_A1_XY_In, D_A2_RefPoints_XY)){
    cout << "CFits::InterPol3D: ERROR: D_A1_XY_In = " << D_A1_XY_In << " is not in triangle " << D_A2_RefPoints_XY << endl;
    return false;
  }
  Array<double, 1> D_A1_Dist(3);
  D_Z_Out = 0.;
  for (int i_pt=0; i_pt<3; i_pt++){
    D_A1_Dist(i_pt) = this->Distance(D_A1_XY_In, D_A2_RefPoints_XY(i_pt, Range::all()));
    if (fabs(D_A1_Dist(i_pt)) < 0.0001)
      D_A1_Dist(i_pt) = 0.1;
    D_Z_Out += D_A2_RefPoints(i_pt,2) / D_A1_Dist(i_pt);
  }
  D_Z_Out /= sum(1. / D_A1_Dist);
  cout << "CFits::InterPol3D: D_A2_RefPoints = " << D_A2_RefPoints << endl;
  cout << "CFits::InterPol3D: D_A1_XY_In = " << D_A1_XY_In << endl;
  cout << "CFits::InterPol3D: D_A1_Dist = " << D_A1_Dist << endl;
  cout << "CFits::InterPol3D: D_Z_Out = " << D_Z_Out << endl;
  return true;
}

bool CFits::CrossCorrelate2D(const Array<double, 2> &D_A2_Static,
                             const Array<double, 2> &D_A2_Moving,
                             //const int &I_NPixMaxShift_X_Left,
                             //const int &I_NPixMaxShift_X_Right,
                             //const int &I_NPixMaxShift_Y_Down,
                             //const int &I_NPixMaxShift_Y_Up,
                             //const int &I_NSteps_X,
                             //const int &I_NSteps_Y,
                             int &I_XCor_X_Out,
                             int &I_XCor_Y_Out) const{
  Array<double, 2> D_A2_Moving_Temp(D_A2_Static.rows(), D_A2_Static.cols());

  ///TODO: include I_NPixMaxShift_Y_Down and I_NPixMaxShift_Y_Up

  //  Array<double, 2> D_A2_ChiSquare(D_A2_Moving.rows()-D_A2_Static.rows()+1, D_A2_Moving.cols()-D_A2_Static.cols()+1);
  double D_ChiSquare = 0.;
  double D_ChiSquare_Min = 0.;
  for (int i_x=0; i_x<=D_A2_Moving.cols()-D_A2_Static.cols(); i_x++){
    for (int i_y=0; i_y<=D_A2_Moving.rows()-D_A2_Static.rows(); i_y++){
      D_A2_Moving_Temp = D_A2_Moving(Range(i_y, i_y+D_A2_Static.rows()-1), Range(i_x, i_x+D_A2_Static.cols()-1));
      D_ChiSquare = sum(pow2(D_A2_Moving_Temp - D_A2_Static));
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        Array<double, 2> D_A2_Temp(D_A2_Moving_Temp.rows(), D_A2_Moving_Temp.cols());
        D_A2_Temp = D_A2_Moving_Temp - D_A2_Static;
        CString CS_FNameTemp("XCor2D_ix");
        CString *P_CS_IToA = CS_FNameTemp.IToA(i_x);
        CS_FNameTemp.Add(*P_CS_IToA);
        CS_FNameTemp.Add(CString("_iy"));
        delete(P_CS_IToA);
        P_CS_IToA = CS_FNameTemp.IToA(i_y);
        CS_FNameTemp.Add(*P_CS_IToA);
        CS_FNameTemp.Add(CString(".fits"));
        delete(P_CS_IToA);
        this->WriteFits(&D_A2_Temp, CS_FNameTemp);
      #endif
      if (i_x == 0 && i_y == 0){
        I_XCor_X_Out = 0;
        I_XCor_Y_Out = 0;
        D_ChiSquare_Min = D_ChiSquare;
      }
      else{
        if (D_ChiSquare < D_ChiSquare_Min){
          I_XCor_X_Out = i_x;
          I_XCor_Y_Out = i_y;
          D_ChiSquare_Min = D_ChiSquare;
        }
      }
      #ifdef __DEBUG_FITS_CROSSCORRELATE__
        cout << "CFits::CrossCorrelate2D: i_x = " << i_x << ", i_y = " << i_y << ": D_ChiSquare = " << D_ChiSquare << ", D_ChiSquare_Min = " << D_ChiSquare_Min << endl;
      #endif
    }
  }
/*  Array<double, 2> D_A2_Static_Temp(2,2);
  Array<double, 2> D_A2_Moving_Temp(2,2);
  Array<double, 1> D_A1_Moving_X_Temp(D_A2_Moving.cols());
  Array<double, 1> D_A1_Moving_X(D_A2_Moving.cols());
  Array<double, 1> D_A1_Moving_Y_Temp(D_A2_Moving.rows());
  Array<double, 1> D_A1_Moving_Y(D_A2_Moving.rows());
  double D_Start_X_Moving, D_End_X_Moving, D_Start_Y_Moving, D_End_Y_Moving;
  int I_Start_X_Static, I_End_X_Static, I_Start_Y_Static, I_End_Y_Static;
  int I_NPix_Static_X = D_A2_Static.cols();
  int I_NPix_Static_Y = D_A2_Static.rows();
  int I_NPix_Moving_X = D_A2_Moving.cols();
  int I_NPix_Moving_Y = D_A2_Moving.rows();
  int I_NPix_Moving_X_Temp, I_NPix_Moving_Y_Temp;
  double D_Shift_X, D_Shift_Y;
  int i_pix;
  for (int i_x=0; i_x<I_NSteps_X; i_x++){
    D_Shift_X = 0. - double(I_NPixMaxShift_X_Left) + (double(I_NPixMaxShift_X_Left + I_NPixMaxShift_X_Right)) * double(i_x) / double(I_NSteps_X-1);
    cout << "CFits::CrossCorrelate2D: i_x = " << i_x << ": D_Shift_X = " << D_Shift_X << endl;
    D_Start_X_Moving = 0. + D_Shift_X;
    if (D_Start_X_Moving < 0.)
      D_Start_X_Moving = 0. + (D_Start_X_Moving - double(int(D_Start_X_Moving)));
    cout << "CFits::CrossCorrelate2D: i_x = " << i_x << ": D_Start_X_Moving = " << D_Start_X_Moving << endl;
//    D_End_X_Moving = D_Start_X_Moving + double(I_NPix_Static_X);
//    if (D_End_X_Moving < 1){
//      cout << "CFits::CrossCorrelate2D: ERROR: D_End_X_Moving < 1" << endl;
//      return false;
//    }
    I_NPix_Moving_X_Temp = 1;
    D_A1_Moving_X_Temp(0) = D_Start_X_Moving;
    i_pix = 1;
    D_End_X_Moving = D_Start_X_Moving;
    I_End_X_Static = 0;
    while ((D_End_X_Moving + 1 < double(I_NPix_Moving_X)) && (D_End_X_Moving + 1 < double(I_NPix_Static_X))){//(int(double(i_pix) - D_Shift_X) < I_NPix_Moving_X) && (i_pix < I_NPix_Static_X)){
      D_A1_Moving_X_Temp(i_pix) = D_A1_Moving_X_Temp(i_pix-1) + 1.;
      D_End_X_Moving += 1.;
      I_End_X_Static += 1;
      i_pix++;
    }
    cout << "CFits::CrossCorrelate2D: i_x = " << i_x << ": i_pix = i_pix, D_End_X_Moving = " << D_End_X_Moving << ", I_End_X_Static = " << I_End_X_Static << endl;
    D_A1_Moving_X.resize(i_pix);
    D_A1_Moving_X = D_A1_Moving_X_Temp(Range(0, i_pix));
    cout << "CFits::CrossCorrelate2D: D_A1_Moving_X = " << D_A1_Moving_X << endl;
//    return false;
    for (int i_y=0; i_y<I_NSteps_Y; i_y++){
      D_Shift_Y = 0. - double(I_NPixMaxShift_Y_Down) + (double(I_NPixMaxShift_Y_Down + I_NPixMaxShift_Y_Up)) * double(i_y) / double(I_NSteps_Y-1);
      cout << "CFits::CrossCorrelate2D: i_y = " << i_y << ": D_Shift_Y = " << D_Shift_Y << endl;
      D_Start_Y_Moving = 0. + D_Shift_Y;
      if (D_Start_Y_Moving < 0.)
        D_Start_Y_Moving = 0. + (D_Start_Y_Moving - double(int(D_Start_Y_Moving)));
      cout << "CFits::CrossCorrelate2D: i_y = " << i_y << ": D_Start_Y_Moving = " << D_Start_Y_Moving << endl;
      D_End_Y_Moving = D_Start_Y_Moving + double(I_NPix_Static_Y);
      if (D_End_Y_Moving < 1){
        cout << "CFits::CrossCorrelate2D: ERROR: D_End_Y_Moving < 1" << endl;
        return false;
      }
      I_NPix_Moving_Y_Temp = 1;
      D_A1_Moving_Y_Temp(0) = D_Start_Y_Moving;
      i_pix = 1;
      D_End_Y_Moving = D_Start_Y_Moving;
      I_End_Y_Static = 0;
      while ((i_pix < I_NPix_Moving_Y) && (i_pix < I_NPix_Static_Y)){
        D_A1_Moving_Y_Temp(i_pix) = D_A1_Moving_Y_Temp(i_pix-1) + 1.;
        D_End_Y_Moving += 1.;
        I_End_Y_Static += 1;
        i_pix++;
      }
      cout << "CFits::CrossCorrelate2D: i_y = " << i_y << ": i_pix = i_pix, D_End_Y_Moving = " << D_End_Y_Moving << ", I_End_Y_Static = " << I_End_Y_Static << endl;
      D_A1_Moving_Y.resize(i_pix);
      D_A1_Moving_Y = D_A1_Moving_Y_Temp(Range(0, i_pix));
      cout << "CFits::CrossCorrelate2D: D_A1_Moving_Y = " << D_A1_Moving_Y << endl;
      D_A2_Moving_Temp.resize(D_A1_Moving_Y.size(), D_A1_Moving_X.size());
      D_A2_Static_Temp.resize(D_A1_Moving_Y.size(), D_A1_Moving_X.size());

      return false;
    }
  }*/
  return true;
}

bool CFits::GetApertureCenters(Array<double, 2> &D_A2_ApCenters_Out) const{
  Array<int, 1> *P_I_A1_Apertures = this->IndGenArr(this->Get_NApertures());
  if (!this->GetApertureCenters(*P_I_A1_Apertures, D_A2_ApCenters_Out)){
    cout << "CFits::GetApertureCenters(Array<double, 2>&): ERROR: GetApertureCenters((*P_I_A1_Apertures) = " << *P_I_A1_Apertures << "), Array<double, 2>&) returned FALSE" << endl;
    return false;
  }
  return true;
}

bool CFits::GetApertureCenters(const Array<int, 1> &I_A1_Apertures,
                               Array<double, 2> &D_A2_ApCenters_Out) const{
  if (I_A1_Apertures.size() < 1){
    cout << "CFits::GetApertureCenters: ERROR: I_A1_Apertures.size() < 1" << endl;
    return false;
  }
//  cout << "CFits::GetApertureCenters: this->P_D_A2_XCenters = " << (*(this->P_D_A2_XCenters)) << endl;
//  return false;
  D_A2_ApCenters_Out.resize(I_A1_Apertures.size(),2);
  Array<double, 1> D_A1_YCenter(I_A1_Apertures.size());
  Array<double, 1> D_A1_XCenter(I_A1_Apertures.size());
  ///  D_A1_YCenter = (*P_D_A1_YCenter) + (*P_D_A1_YLow) + (((*P_D_A1_YHigh) - (*P_D_A1_YLow)) / 2.);
  for (int i_ap=0; i_ap<I_A1_Apertures.size(); i_ap++){
    if ((I_A1_Apertures(i_ap) < 0) || (I_A1_Apertures(i_ap) >= this->Get_NApertures())){
      cout << "CFits::GetApertureCenters: ERROR: (I_A1_Apertures(i_ap=" << i_ap << ")=" << I_A1_Apertures(i_ap) << " < 0) || (I_A1_Apertures(i_ap) >= this->Get_NApertures()=" << this->Get_NApertures() << endl;
      return false;
    }
    D_A1_YCenter(i_ap) = (*(this->P_D_A1_YCenter))(I_A1_Apertures(i_ap)) + (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap)) + (((*(this->P_D_A1_YHigh))(I_A1_Apertures(i_ap)) - (*(this->P_D_A1_YLow))(I_A1_Apertures(i_ap))) / 2.);
    D_A1_XCenter(i_ap) = (*(this->P_D_A2_XCenters))(I_A1_Apertures(i_ap), (int)(D_A1_YCenter)(i_ap));
  }
  D_A2_ApCenters_Out(Range::all(),0) = D_A1_XCenter;
  D_A2_ApCenters_Out(Range::all(),1) = D_A1_YCenter;

  return true;
}

/**
 * Returns -1 if D_A1_Array_In is monotonically decreasing
 *         0  if D_A1_Array_In is non monotonic
 *         +1 if D_A1_Array_In is monotonically increasing
 */
int CFits::IsMonotonic(const Array<double, 1> &D_A1_Array_In) const{
  int I_M = 0;
  if (D_A1_Array_In.size() < 2)
      return I_M;
  double D_DA = D_A1_Array_In(1) - D_A1_Array_In(0);
  if (D_DA < 0)
      I_M = -1;
  else if (D_DA > 0)
      I_M = 1;
  if (D_A1_Array_In.size() < 3)
      return I_M;
  for (int i_pos=2; i_pos<D_A1_Array_In.size(); i_pos++){
      D_DA = D_A1_Array_In(i_pos) - D_A1_Array_In(i_pos-1);
      if ((D_DA < 0) && (I_M == 1))
          return 0;
      if ((D_DA > 0) && (I_M == -1))
          return 0;
      if (I_M == 0){
        if (D_DA < 0)
            I_M = -1;
        else if (D_DA > 0)
            I_M = 1;
      }
  }
  return I_M;
}

      
/**
  * Calculates aperture minimum pixel, central position, and maximum pixel for aperture number I_Aperture_In,
  * and writes result to I_A2_MinCenMax_Out
 **/
bool CFits::CalcMinCenMax(const int I_Aperture_In,
	 	  	  Array<int, 2> &I_A2_MinCenMax_Out) const{
  if ((I_Aperture_In < 0) || (I_Aperture_In >= this->I_NApertures)){
    cout << "CFits::CalcMinCenMax: ERROR: I_Aperture_In = " << I_Aperture_In << " out of range" << endl;
    return false;
  }
  Array<double, 1> D_A1_XCenters(this->NRows);
  D_A1_XCenters = (*(this->P_D_A2_XCenters))(I_Aperture_In, Range::all()) + 0.5;
  #ifdef __DEBUG_FITS_MINCENMAX__
    cout << "CFits::CalcMinCenMax: I_Aperture_In = " << I_Aperture_In << ": D_A1_XCenters = " << D_A1_XCenters << endl;
  #endif
  Array<int, 1> *P_I_A1_XC = this->Fix(D_A1_XCenters);
  I_A2_MinCenMax_Out.resize(this->NRows, 3);
  I_A2_MinCenMax_Out = 0;
  
  I_A2_MinCenMax_Out(Range::all(), 1) = (*P_I_A1_XC);
  
  #ifdef __DEBUG_FITS_MINCENMAX__
    cout << "CFits::CalcMinCenMax: I_Aperture_In = " << I_Aperture_In << ": I_A2_MinCenMax_Out(*,1) = " << I_A2_MinCenMax_Out(Range::all(), 1) << endl;
  #endif
  delete P_I_A1_XC;
  Array<double, 1> D_A1_TempXMin(D_A1_XCenters.size());
  D_A1_TempXMin = D_A1_XCenters + (*(this->P_D_A1_XLow))(I_Aperture_In);
  Array<int, 1> *P_I_A1_Temp = this->Fix(D_A1_TempXMin);
  
  I_A2_MinCenMax_Out(Range::all(), 0) = (*P_I_A1_Temp);// - I_NPixCut_Left;///(*P_I_A1_Temp); /// Left column of order

  #ifdef __DEBUG_FITS_MINCENMAX__
    cout << "CFits::CalcMinCenMax: I_Aperture_In = " << I_Aperture_In << ": I_A2_MinCenMax_Out(*,0) = " << I_A2_MinCenMax_Out(Range::all(), 0) << endl;
  #endif
  delete(P_I_A1_Temp);
  Array<double, 1> D_A1_IMax(I_A2_MinCenMax_Out.rows());
  D_A1_IMax = D_A1_XCenters+(*(this->P_D_A1_XHigh))(I_Aperture_In);
  P_I_A1_Temp = this->Fix(D_A1_IMax);
  
  I_A2_MinCenMax_Out(Range::all(), 2) = (*P_I_A1_Temp);
  
  #ifdef __DEBUG_FITS_MINCENMAX__
    cout << "CFits::CalcMinCenMax: I_Aperture_In = " << I_Aperture_In << ": I_A2_MinCenMax_Out(*,2) = " << I_A2_MinCenMax_Out(Range::all(), 2) << endl;
  #endif
  delete(P_I_A1_Temp);
  Array<int, 1> I_A1_NPixLeft(I_A2_MinCenMax_Out.rows());
  I_A1_NPixLeft = I_A2_MinCenMax_Out(Range::all(),1) - I_A2_MinCenMax_Out(Range::all(),0);
  Array<int, 1> I_A1_NPixRight(I_A2_MinCenMax_Out.rows());
  I_A1_NPixRight = I_A2_MinCenMax_Out(Range::all(),2) - I_A2_MinCenMax_Out(Range::all(),1);
  #ifdef __DEBUG_FITS_MINCENMAX__
    cout << "CFits::CalcMinCenMax: I_A1_NPixLeft(=" << I_A1_NPixLeft << endl;
    cout << "CFits::CalcMinCenMax: I_A1_NPixRight(=" << I_A1_NPixRight << endl;
  #endif
  Array<int, 1> I_A1_I_NPixX(I_A2_MinCenMax_Out.rows());
  I_A1_I_NPixX = I_A2_MinCenMax_Out(Range::all(), 2) - I_A2_MinCenMax_Out(Range::all(), 0) + 1;
  #ifdef __DEBUG_FITS_MINCENMAX__
    cout << "CFits::CalcMinCenMax: I_A1_I_NPixX = " << I_A1_I_NPixX << endl;
  #endif

  int I_MaxPixLeft = max(I_A1_NPixLeft);
  int I_MaxPixRight = max(I_A1_NPixRight);
  int I_MinPixLeft = min(I_A1_NPixLeft);
  int I_MinPixRight = min(I_A1_NPixRight);
  
  int I_NPixCut_Left = 1;
  int I_NPixCut_Right = 1;

  if (I_MaxPixLeft > I_MinPixLeft)
    I_A2_MinCenMax_Out(Range::all(),0) = I_A2_MinCenMax_Out(Range::all(),1) - I_MaxPixLeft + I_NPixCut_Left;

  if (I_MaxPixRight > I_MinPixRight)
    I_A2_MinCenMax_Out(Range::all(),2) = I_A2_MinCenMax_Out(Range::all(),1) + I_MaxPixRight - I_NPixCut_Right;
  #ifdef __DEBUG_FITS_MINCENMAX__
    cout << "CFits::CalcMinCenMax: I_A2_MinCenMax_Out = " << I_A2_MinCenMax_Out << endl;
  #endif

  return true;
}


/**
 * Calculates Slit Function for each pixel in an aperture row from oversampled Slit Function D_A1_OSF_In,
 * and writes result to D_A1_SF_Out
 **/
bool CFits::CalcSF(const int I_Aperture_In,
                   const int I_Row_In,
                   const Array<double, 1> &D_A1_OSF_In,
                   Array<double, 1> &D_A1_SF_Out) const{
  if ((I_Aperture_In < 0) || (I_Aperture_In >= this->I_NApertures)){
    cout << "CFits::CalcSF: ERROR: I_Aperture_In=" << I_Aperture_In << " outside range" << endl;
    return false;
  }
  if ((I_Row_In < 0) || (I_Row_In >= this->NRows)){
    cout << "CFits::CalcSF: ERROR: I_Row_In=" << I_Row_In << " outside range" << endl;
    return false;
  }
  
  firstIndex i;
  int I_NXSF = (*(this->P_D_A1_XHigh))(I_Aperture_In) - (*(this->P_D_A1_XLow))(I_Aperture_In) + 1;

  Array<double, 1> XVecArr(D_A1_OSF_In.size());
  XVecArr = (i + 0.5) / double(I_OverSample) - 1.;
  double D_XCenMXC = (*(this->P_D_A2_XCenters))(I_Aperture_In, I_Row_In) - this->Fix((*(this->P_D_A2_XCenters))(I_Aperture_In, I_Row_In));
  XVecArr += D_XCenMXC;
  
  Array<double, 1> D_A1_Range(2);
  
  D_A1_SF_Out.resize(I_NXSF);
  for (int i_col=0; i_col<I_NXSF; i_col++){
    D_A1_Range(0) = i_col;
    D_A1_Range(1) = i_col+1;
    if (!this->IntegralUnderCurve(XVecArr, D_A1_OSF_In, D_A1_Range, D_A1_SF_Out(i_col))){
      cout << "CFits::CalcSF: I_Aperture_In = " << I_Aperture_In << ": I_Row_In = " << I_Row_In << ": ERROR: IntegralUnderCurve returned FALSE" << endl;
      return false;
    }
  }
  
  return true;  
}
            
                  
bool CFits::RemoveAtmosphericExtinction(const Array<double, 2> &D_A2_Spec_In,
                                        const double &D_AirMass,
                                        const Array<double, 2> &D_A2_Extinction_In,
                                        Array<double, 2> &D_A2_Spec_Out) const{
  Array<double, 1> D_A1_Extinction(D_A2_Spec_In.rows());
  if (!this->InterPol(D_A2_Extinction_In(Range::all(), 1), 
                      D_A2_Extinction_In(Range::all(), 0), 
                      D_A2_Spec_In(Range::all(), 0), 
                      D_A1_Extinction)){
    cout << "CFits::RemoveAtmosphericExtinction: ERROR: InterPol(extinction) returned FALSE" << endl;
    return false;
  }
  Array<double, 1> D_A1_ExtFactor(D_A1_Extinction.size());
  D_A1_ExtFactor = pow(10.,(0.4 * D_A1_Extinction * D_AirMass));
  D_A2_Spec_Out.resize(D_A2_Spec_In.rows(), D_A2_Spec_In.cols());
  D_A2_Spec_Out(Range::all(), 0) = D_A2_Spec_In(Range::all(), 0);
  D_A2_Spec_Out(Range::all(), 1) = D_A2_Spec_In(Range::all(), 1) * D_A1_ExtFactor;
  return true;
}

/* Calculate Airmass using Hardie Function
 * D_A1_ZenithDist_Deg_In: input zenith distances in degrees
 * */
bool CFits::AirMass_Hardie_Deg(const Array<double, 1> &D_A1_ZenithDist_Deg_In,
                               Array<double, 1> &D_A1_AirMass_Out) const{
  double D_Rad = 180./D_PI;
  Array<double, 1> D_A1_ZenithDist_Rad(D_A1_ZenithDist_Deg_In.size());
  D_A1_ZenithDist_Rad = (90. - D_A1_ZenithDist_Deg_In) / D_Rad;
  return AirMass_Hardie_Rad(D_A1_ZenithDist_Rad, D_A1_AirMass_Out);
}
                               
/* Calculate Airmass using Hardie Function
 * D_A1_ZenithDist_Rad_In: input zenith distances in radians
 * */
bool CFits::AirMass_Hardie_Rad(const Array<double, 1> &D_A1_ZenithDist_Rad_In,
                               Array<double, 1> &D_A1_AirMass_Out) const{
  Array<double, 1> D_A1_SecZ(D_A1_ZenithDist_Rad_In.size());
  D_A1_SecZ = 1./cos(D_A1_ZenithDist_Rad_In);
  
  D_A1_AirMass_Out.resize(D_A1_ZenithDist_Rad_In.size());
  D_A1_AirMass_Out = D_A1_SecZ - (0.0018167 * (D_A1_SecZ - 1)) - (0.002875 * (D_A1_SecZ - 1) * (D_A1_SecZ - 1)) - (0.0008083 * (D_A1_SecZ - 1) * (D_A1_SecZ - 1) * (D_A1_SecZ - 1));
  
  return true;
}
                    
/**
  * Calculates positive roots for a given polynomial
  * D_A1_PolyCoeffs_In: Coefficients for the polynomial
  * D_Y_In:             y value to find x
  * D_XStart_In:        x value to start search
  * D_XStep_In:         initial step for search (<0: go left, >0: go right)
  * CS_Function_In:     [Poly,Chebyshev,Legendre]
  * **/
bool CFits::PolyRoot(const Array<double, 1> &D_A1_PolyCoeffs_In,
                     const double &D_Y_In,
                     const double &D_XStart_In,
                     const double &D_XStep_In,
                     const double &D_MaxDist_In,
                     const CString &CS_Function_In,
                     double &D_X_Out) const{
  bool B_Run = true;
  double D_X = D_XStart_In;
  double D_X_Old = D_X;
  double D_X_New = D_X + D_XStep_In;
  double D_XStep = D_XStep_In;
  double D_Y = 0.;
  double D_Y_Old = 0.;
  double D_Y_New = 0.;
  CString CS_Poly("Poly");
  CString CS_Cheb("Chebyshev");
  CString CS_Leg("Legendre");
  do{
    if (CS_Function_In.EqualValue(CS_Poly)){
      D_Y_Old = this->Poly(D_X_Old, D_A1_PolyCoeffs_In);
      D_Y_New = this->Poly(D_X_New, D_A1_PolyCoeffs_In);
      D_X_Old = D_X_New;
      if (((D_Y_Old < D_Y_In) && (D_Y_New >= D_Y_In)) || ((D_Y_Old > D_Y_In) && (D_Y_New <= D_Y_In))){
        D_XStep = 0. - (D_XStep / 2.);
      }
      else if (fabs(D_Y_Old - D_Y_In) < fabs(D_Y_New - D_Y_In))
        D_XStep = 0. - D_XStep;
      D_X_New = D_X_Old + D_XStep;
      if (fabs(D_Y_New - D_Y_In) < fabs(D_MaxDist_In))
        B_Run = false;
    }
    else if (CS_Function_In.EqualValue(CS_Cheb)){
      cout << "CFits::PolyRoot: ERROR: CS_Function_In=" << CS_Function_In << " is not yet implemented" << endl;
      return false;
    }
    else if (CS_Function_In.EqualValue(CS_Leg)){
      cout << "CFits::PolyRoot: ERROR: CS_Function_In=" << CS_Function_In << " is not yet implemented" << endl;
      return false;
    }
    else{
      cout << "CFits::PolyRoot: ERROR: CS_Function_In=" << CS_Function_In << " not known" << endl;
      return false;
    }
  } while(B_Run);
  D_X_Out = D_X_Old;
  return true;
}

/*bool CFits::CalculateScatteredLightBiSpline(const Array<double, 2> &D_A2_PixArray_In,
                                            const int I_NKnots_X_In,
                                            const int I_NKnots_Y_In,
                                            const int I_Opt_In,
                                            const double D_Smooth_In,
                                            Array<double, 2> &D_A2_ScatteredLight_Out) const{
  Array<double, 2> D_A2_ApsZero(D_A2_PixArray_In.rows(), D_A2_PixArray_In.cols());
  D_A2_ApsZero = D_A2_PixArray_In;
  if (!this->Set_ApertureDataToZero(D_A2_ApsZero, 1, 1)){
    cout << "CFits::CalculateScatteredLightBiSpline: ERROR: Set_ApertureDataToZero returned FALSE" << endl;
    return false;
  }
  
  std::vector<
}*/
                                     
template bool CFits::Uniq(const blitz::Array<int, 1> &IA1_In, blitz::Array<int, 1> &IA1_Result);
template bool CFits::Uniq(const blitz::Array<long, 1> &IA1_In, blitz::Array<int, 1> &IA1_Result);
template bool CFits::Uniq(const blitz::Array<float, 1> &IA1_In, blitz::Array<int, 1> &IA1_Result);
template bool CFits::Uniq(const blitz::Array<double, 1> &IA1_In, blitz::Array<int, 1> &IA1_Result);
