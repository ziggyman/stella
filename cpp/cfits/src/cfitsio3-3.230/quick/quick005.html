<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="quick.css">
<TITLE>CFITSIO Routines</TITLE>
</HEAD>
<BODY >
<A HREF="quick004.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="quick006.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H2 CLASS="section"><A NAME="htoc4">4</A>&#XA0;&#XA0;CFITSIO Routines</H2><P>This chapter describes the main CFITSIO routines that can be used to
perform the most common types of operations on FITS files.</P><H3 CLASS="subsection"><A NAME="toc1"></A><A NAME="htoc5"><B>4.1</B></A><B>&#XA0;&#XA0;Error Reporting</B></H3><PRE CLASS="verbatim">void fits_report_error(FILE *stream, int status)
void fits_get_errstatus(int status, char *err_text)
float fits_get_version(float *version)
</PRE><P>The first routine prints out information about any error that
has occurred. Whenever any CFITSIO routine encounters an error it
usually writes a message describing the nature of the error to an
internal error message stack and then returns with a positive integer
status value. Passing the error status value to this routine will
cause a generic description of the error and all the messages
from the internal CFITSIO error stack to be printed to the specified
stream. The <TT>stream</TT> parameter is usually set equal to
<TT>"stdout"</TT> or <TT>"stderr"</TT>.</P><P>The second routine simply returns a 30-character descriptive
error message corresponding to the input status value.</P><P>The last routine returns the current CFITSIO library version number.</P><H3 CLASS="subsection"><A NAME="toc2"></A><A NAME="htoc6"><B>4.2</B></A><B>&#XA0;&#XA0;File Open/Close Routines</B></H3><PRE CLASS="verbatim">int fits_open_file( fitsfile **fptr, char *filename, int mode, int *status)
int fits_open_data( fitsfile **fptr, char *filename, int mode, int *status)
int fits_open_table(fitsfile **fptr, char *filename, int mode, int *status)
int fits_open_image(fitsfile **fptr, char *filename, int mode, int *status)

int fits_create_file(fitsfile **fptr, char *filename, int *status)
int fits_close_file(fitsfile *fptr, int *status)
</PRE><P>These routines open or close a file. The first <TT>fitsfile</TT>
parameter in these and nearly every other CFITSIO routine is a pointer
to a structure that CFITSIO uses to store relevant parameters about
each opened file. You should never directly read or write any
information in this structure. Memory for this structure is allocated
automatically when the file is opened or created, and is freed when the
file is closed.</P><P>The <TT>mode</TT> parameter in the <TT>fits_open_xxxx</TT> set of routines
can be set to either <TT>READONLY</TT> or <TT>READWRITE</TT> to select the
type of file access that will be allowed. These symbolic constants are
defined in <TT>fitsio.h</TT>.</P><P>The <TT>fits_open_file</TT> routine opens the file and positions the internal
file pointer to the beginning of the file, or to the specified
extension if an extension name or number is appended to the file name
(see the later section on &#X201C;CFITSIO File Names and Filters&#X201D; for a
description of the syntax). <TT>fits_open_data</TT> behaves similarly except
that it will move to the first HDU containing significant data if a HDU
name or number to open is not explicitly specified as part of the
filename. It will move to the first IMAGE HDU with NAXIS greater than
0, or the first table that does not contain the strings &#X2018;GTI&#X2019; (a Good
Time Interval extension) or &#X2018;OBSTABLE&#X2019; in the EXTNAME keyword value.
The <TT>fits_open_table</TT> and <TT>fits_open_image</TT> routines are similar
except that they will move to the first significant table HDU or image
HDU, respectively if a HDU name of number is not specified as part of
the input file name.</P><P>When opening an existing file, the <TT>filename</TT> can include optional
arguments, enclosed in square brackets that specify filtering
operations that should be applied to the input file. For example,
</P><PRE CLASS="verbatim">   myfile.fit[EVENTS][counts &gt; 0]
</PRE><P>opens the table in the EVENTS extension and creates a virtual table by
selecting only those rows where the COUNTS column value is greater than
0. See section 5 for more examples of these powerful filtering
capabilities.</P><P>In <TT>fits_create_file</TT>, the <TT>filename</TT> is simply the root name of
the file to be created. You can overwrite an existing file by
prefixing the name with a &#X2018;!&#X2019; character (on the Unix command line this
must be prefixed with a backslash, as in <CODE>`\!file.fit'</CODE>). 
If the file name ends with <TT>.gz</TT> the file will be compressed
using the gzip algorithm. If the
filename is <TT>stdout</TT> or <TT>"-"</TT> (a single dash character)
then the output file will be piped to the stdout stream. You can
chain several tasks together by writing the output from the first task
to <TT>stdout</TT> and then reading the input file in the 2nd task from
<TT>stdin</TT> or <TT>"-"</TT>.</P><H3 CLASS="subsection"><A NAME="toc3"></A><A NAME="htoc7"><B>4.3</B></A><B>&#XA0;&#XA0;HDU-level Routines</B></H3><P>The routines listed in this section operate on Header-Data Units (HDUs) in a file.</P><PRE CLASS="verbatim">_______________________________________________________________
int fits_get_num_hdus(fitsfile *fptr, int *hdunum, int *status)
int fits_get_hdu_num(fitsfile *fptr,  int *hdunum)
</PRE><P>The first routines returns the total number of HDUs in the FITS file,
and the second routine returns the position of the currently opened HDU in
the FITS file (starting with 1, not 0).</P><PRE CLASS="verbatim">__________________________________________________________________________
int fits_movabs_hdu(fitsfile *fptr, int hdunum, int *hdutype, int *status)
int fits_movrel_hdu(fitsfile *fptr, int nmove,  int *hdutype, int *status)
int fits_movnam_hdu(fitsfile *fptr, int hdutype, char *extname,
                    int extver, int *status)
</PRE><P>These routines enable you to move to a different HDU in the file.
Most of the CFITSIO functions which read or write keywords or data
operate only on the currently opened HDU in the file. The first
routine moves to the specified absolute HDU number in the FITS
file (the first HDU = 1), whereas the second routine moves a relative
number of HDUs forward or backward from the currently open HDU. The
<TT>hdutype</TT> parameter returns the type of the newly opened HDU, and will
be equal to one of these symbolic constant values: <TT>IMAGE_HDU,
ASCII_TBL, or BINARY_TBL</TT>. <TT>hdutype</TT> may be set to NULL
if it is not needed. The third routine moves to the (first) HDU
that matches the input extension type, name, and version number,
as given by the <TT>XTENSION, EXTNAME</TT> (or <TT>HDUNAME</TT>) and <TT>EXTVER</TT> keywords.
If the input value of <TT>extver</TT> = 0, then the version number will
be ignored when looking for a matching HDU.</P><PRE CLASS="verbatim">_________________________________________________________________
int fits_get_hdu_type(fitsfile *fptr,  int *hdutype, int *status)
</PRE><P>Get the type of the current HDU in the FITS file: <TT>IMAGE_HDU,
ASCII_TBL, or BINARY_TBL</TT>.</P><PRE CLASS="verbatim">____________________________________________________________________
int fits_copy_hdu(fitsfile *infptr, fitsfile *outfptr, int morekeys,
                  int *status)
int fits_copy_file(fitsfile *infptr, fitsfile *outfptr, int previous,
                  int current, int following, &gt; int *status)
</PRE><P>The first routine copies the current HDU from the FITS file associated
with infptr and appends it to the end of the FITS file associated with
outfptr. Space may be reserved for <TT>morekeys</TT> additional keywords
in the output header. The second routine copies any HDUs previous
to the current HDU, and/or the current HDU, and/or any HDUs following the
current HDU, depending on the value (True or False) of <TT>previous,
current</TT>, and <TT>following</TT>, respectively. For example,
</P><PRE CLASS="verbatim">  fits_copy_file(infptr, outfptr, 0, 1, 1, &amp;status);
</PRE><P>will copy the current HDU and any HDUs that follow it from the input
to the output file, but it will not copy any HDUs preceding the 
current HDU.</P><H3 CLASS="subsection"><A NAME="toc4"></A><A NAME="htoc8">4.4</A>&#XA0;&#XA0;Image I/O Routines</H3><P>This section lists the more important CFITSIO routines which operate on
FITS images.</P><PRE CLASS="verbatim">_______________________________________________________________
int fits_get_img_type(fitsfile *fptr, int *bitpix, int *status)
int fits_get_img_dim( fitsfile *fptr, int *naxis,  int *status)
int fits_get_img_size(fitsfile *fptr, int maxdim,  long *naxes,
                      int *status)
int fits_get_img_param(fitsfile *fptr, int maxdim,  int *bitpix,
                       int *naxis, long *naxes, int *status)
</PRE><P>Get information about the currently opened image HDU. The first routine
returns the datatype of the image as (defined by the <TT>BITPIX</TT>
keyword), which can have the following symbolic constant values: 
</P><PRE CLASS="verbatim">    BYTE_IMG   =   8   ( 8-bit byte pixels, 0 - 255)
    SHORT_IMG  =  16   (16 bit integer pixels)
    LONG_IMG   =  32   (32-bit integer pixels)
    FLOAT_IMG  = -32   (32-bit floating point pixels)
    DOUBLE_IMG = -64   (64-bit floating point pixels)
</PRE><P>The second and third routines return the number of dimensions in the
image (from the <TT>NAXIS</TT> keyword), and the sizes of each dimension
(from the <TT>NAXIS1, NAXIS2</TT>, etc. keywords). The last routine
simply combines the function of the first 3 routines. The input <TT>maxdim</TT> parameter in this routine gives the maximum number dimensions
that may be returned (i.e., the dimension of the <TT>naxes</TT>
array)</P><PRE CLASS="verbatim">__________________________________________________________
int fits_create_img(fitsfile *fptr, int bitpix, int naxis, 
                    long *naxes, int *status)
</PRE><P>Create an image HDU by writing the required keywords which define the
structure of the image. The 2nd through 4th parameters specified the
datatype, the number of dimensions, and the sizes of the dimensions.
The allowed values of the <TT>bitpix</TT> parameter are listed above in
the description of the <TT>fits_get_img_type</TT> routine. If the FITS
file pointed to by <TT>fptr</TT> is empty (previously created with
<TT>fits_create_file</TT>) then this routine creates a primary array in
the file, otherwise a new IMAGE extension is appended to end of the
file following the other HDUs in the file.</P><PRE CLASS="verbatim">______________________________________________________________
int fits_write_pix(fitsfile *fptr, int datatype, long *fpixel,
               long nelements, void *array, int *status);

int fits_write_pixnull(fitsfile *fptr, int datatype, long *fpixel,
               long nelements, void *array, void *nulval, int *status);

int fits_read_pix(fitsfile *fptr, int  datatype, long *fpixel, 
                  long nelements, void *nulval, void *array, 
                  int *anynul, int *status)
</PRE><P>Read or write all or part of the FITS image. There are 2 different
&#X2019;write&#X2019; pixel routines: The first simply writes the input array of pixels
to the FITS file. The second is similar, except that it substitutes
the appropriate null pixel value in the FITS file for any pixels 
which have a value equal to <TT>*nulval</TT> (note that this parameter
gives the address of the null pixel value, not the value itself).
Similarly, when reading an image, CFITSIO will substitute the value
given by <TT>nulval</TT> for any undefined pixels in the image, unless
<TT>nulval = NULL</TT>, in which case no checks will be made for undefined
pixels when reading the FITS image.</P><P>The <TT>fpixel</TT> parameter in these routines is an array which gives
the coordinate in each dimension of the first pixel to be read or
written, and <TT>nelements</TT> is the total number of pixels to read or
write. <TT>array</TT> is the address of an array which either contains
the pixel values to be written, or will hold the values of the pixels
that are read. When reading, <TT>array</TT> must have been allocated
large enough to hold all the returned pixel values. These routines
starts at the <TT>fpixel</TT> location and then read or write the <TT>nelements</TT> pixels, continuing on successive rows of the image if
necessary. For example, to write an entire 2D image, set <TT>fpixel[0] = fpixel[1] = 1</TT>, and <TT>nelements = NAXIS1 * NAXIS2</TT>. Or
to read just the 10th row of the image, set <TT>fpixel[0] = 1,
fpixel[1] = 10</TT>, and <TT>nelements = NAXIS1</TT>. The <TT>datatype</TT>
parameter specifies the datatype of the C <TT>array</TT> in the program,
which need not be the same as the datatype of the FITS image itself.
If the datatypes differ then CFITSIO will convert the data as it is
read or written. The following symbolic constants are allowed for the
value of <TT>datatype</TT>:
</P><PRE CLASS="verbatim">  TBYTE     unsigned char
  TSBYTE    signed char
  TSHORT    signed short
  TUSHORT   unsigned short
  TINT      signed int
  TUINT     unsigned int
  TLONG     signed long
  TLONGLONG signed 8-byte integer
  TULONG    unsigned long
  TFLOAT    float
  TDOUBLE   double
</PRE><PRE CLASS="verbatim">_________________________________________________________________
int fits_write_subset(fitsfile *fptr, int datatype, long *fpixel,
             long *lpixel, DTYPE *array, &gt; int *status)

int fits_read_subset(fitsfile *fptr, int  datatype, long *fpixel,
             long *lpixel, long *inc, void *nulval,  void *array,
             int *anynul, int *status)
</PRE><P>Read or write a rectangular section of the FITS image. These are very
similar to <TT>fits_write_pix</TT> and <TT>fits_read_pix</TT> except that
you specify the last pixel coordinate (the upper right corner of the
section) instead of the number of pixels to be read. The read routine
also has an <TT>inc</TT> parameter which can be used to read only every
<TT>inc-th</TT> pixel along each dimension of the image. Normally <TT>inc[0] = inc[1] = 1</TT> to read every pixel in a 2D image. To read every
other pixel in the entire 2D image, set
</P><PRE CLASS="verbatim">    fpixel[0] = fpixel[1] = 1
    lpixel[0] = {NAXIS1}
    lpixel[1] = {NAXIS2}  
    inc[0] = inc[1] = 2  
</PRE><P>Or, to read the 8th row of a 2D image, set 
</P><PRE CLASS="verbatim">    fpixel[0] = 1
    fpixel[1] = 8
    lpixel[0] = {NAXIS1}
    lpixel[1] = 8
    inc[0] = inc[1] = 1
</PRE><H3 CLASS="subsection"><A NAME="toc5"></A><A NAME="htoc9">4.5</A>&#XA0;&#XA0;Table I/O Routines</H3><P>This section lists the most important CFITSIO routines which operate on
FITS tables.</P><PRE CLASS="verbatim">__________________________________________________________________________
int fits_create_tbl(fitsfile *fptr, int tbltype, long nrows, int tfields,
    char *ttype[],char *tform[], char *tunit[], char *extname, int *status)
</PRE><P>Create a new table extension by writing the required keywords that
define the table structure. The required null primary array
will be created first if the file is initially completely empty. <TT>tbltype</TT> defines the type of table and can have values of <TT>ASCII_TBL or BINARY_TBL</TT>. Binary tables are generally preferred
because they are more efficient and support a greater range of column
datatypes than ASCII tables.</P><P>The <TT>nrows</TT> parameter gives the initial number of empty rows to be
allocated for the table; this should normally be set to 0. The <TT>tfields</TT>
parameter gives the number of columns in the table (maximum = 999).
The <TT>ttype, tform</TT>, and <TT>tunit</TT> parameters give the name, datatype, and
physical units of each column, and <TT>extname</TT> gives the name for the
table (the value of the <TT>EXTNAME</TT> keyword). 
The FITS Standard recommends that only
letters, digits, and the underscore character be used in column names
with no embedded spaces. It is recommended that all the column names
in a given table be unique within the first 8 characters.</P><P>The following table
shows the TFORM column format values that are allowed in ASCII tables
and in binary tables:
</P><PRE CLASS="verbatim">        ASCII Table Column Format Codes
        -------------------------------
        (w = column width, d = no. of decimal places to display)
            Aw   - character string
            Iw   - integer
            Fw.d - fixed floating point
            Ew.d - exponential floating point
            Dw.d - exponential floating point

        Binary Table Column Format Codes
        --------------------------------
        (r = vector length, default = 1)
            rA  - character string
            rAw - array of strings, each of length w
            rL  - logical
            rX  - bit
            rB  - unsigned byte
            rS  - signed byte **
            rI  - signed 16-bit integer
            rU  - unsigned 16-bit integer **
            rJ  - signed 32-bit integer
            rV  - unsigned 32-bit integer **
            rK  - 64-bit integer ***
            rE  - 32-bit floating point
            rD  - 64-bit floating point
            rC  - 32-bit complex pair
            rM  - 64-bit complex pair

     ** The S, U and V format codes are not actual legal TFORMn values.
        CFITSIO substitutes the somewhat more complicated set of
        keywords that are used to represent unsigned integers or
        signed bytes.

    *** The 64-bit integer format is experimental and is not 
        officially recognized in the FITS Standard.
</PRE><P>The <TT>tunit</TT> and <TT>extname</TT> parameters are optional and
may be set to NULL
if they are not needed. </P><P>Note that it may be easier to create a new table by copying the
header from another existing table with <TT>fits_copy_header</TT> rather
than calling this routine.</P><PRE CLASS="verbatim">_______________________________________________________________
int fits_get_num_rows(fitsfile *fptr, long *nrows, int *status)
int fits_get_num_cols(fitsfile *fptr, int  *ncols, int *status)
</PRE><P>Get the number of rows or columns in the current FITS table. The
number of rows is given by the <TT>NAXIS2</TT> keyword and the number of columns
is given by the <TT>TFIELDS</TT> keyword in the header of the table.</P><PRE CLASS="verbatim">_______________________________________________________________
int fits_get_colnum(fitsfile *fptr, int casesen, char *template,
                    int *colnum, int *status)
int fits_get_colname(fitsfile *fptr, int casesen, char *template,
                    char *colname, int *colnum, int *status)
</PRE><P>Get the column number (starting with 1, not 0) of the column whose
name matches the specified template name. The only difference in
these 2 routines is that the 2nd one also returns the name of the
column that matched the template string.</P><P>Normally, <TT>casesen</TT> should
be set to <TT>CASEINSEN</TT>, but it may be set to <TT>CASESEN</TT> to force
the name matching to be case-sensitive.</P><P>The input <TT>template</TT> string gives the name of the desired column and
may include wildcard characters: a &#X2018;*&#X2019; matches any sequence of
characters (including zero characters), &#X2018;?&#X2019; matches any single
character, and &#X2018;#&#X2019; matches any consecutive string of decimal digits
(0-9). If more than one column name in the table matches the template
string, then the first match is returned and the status value will be
set to <TT>COL_NOT_UNIQUE</TT> as a warning that a unique match was not
found. To find the next column that matches the template, call this
routine again leaving the input status value equal to <TT>COL_NOT_UNIQUE</TT>. Repeat this process until <TT>status =
COL_NOT_FOUND</TT> is returned.</P><PRE CLASS="verbatim">_______________________________________________________________
int fits_get_coltype(fitsfile *fptr, int colnum, int *typecode,
                     long *repeat, long *width, int *status)

int fits_get_eqcoltype(fitsfile *fptr, int colnum, int *typecode,
                     long *repeat, long *width, int *status)
</PRE><P>Return the datatype, vector repeat count, and the width in bytes of a
single column element for column number <TT>colnum</TT>. Allowed values
for the returned datatype in ASCII tables are: <TT>TSTRING, TSHORT,
TLONG, TFLOAT, and TDOUBLE</TT>. Binary tables support these additional
types: <TT>TLOGICAL, TBIT, TBYTE, TINT32BIT, TCOMPLEX and TDBLCOMPLEX</TT>. The
negative of the datatype code value is returned if it is a variable
length array column.</P><P>These 2 routines are similar, except that in the case of scaled
integer columns the 2nd routine, fit_get_eqcoltype, returns the
&#X2019;equivalent&#X2019; datatype that is needed to store the scaled values, which
is not necessarily the same as the physical datatype of the unscaled values
as stored in the FITS table. For example if a &#X2019;1I&#X2019; column in a binary
table has TSCALn = 1 and TZEROn = 32768, then this column effectively
contains unsigned short integer values, and thus the returned value of
typecode will be TUSHORT, not TSHORT. Or, if TSCALn or TZEROn are not
integers, then the equivalent datatype will be returned as TFLOAT or
TDOUBLE, depending on the size of the integer.</P><P>The repeat count is always 1 in ASCII tables.
The &#X2019;repeat&#X2019; parameter returns the vector repeat count on the binary
table TFORMn keyword value. (ASCII table columns always have repeat
= 1). The &#X2019;width&#X2019; parameter returns the width in bytes of a single
column element (e.g., a &#X2019;10D&#X2019; binary table column will have width =
8, an ASCII table &#X2019;F12.2&#X2019; column will have width = 12, and a binary
table&#X2019;60A&#X2019; character string column will have width = 60); Note that
this routine supports the local convention for specifying arrays of
fixed length strings within a binary table character column using
the syntax TFORM = &#X2019;rAw&#X2019; where &#X2019;r&#X2019; is the total number of
characters (= the width of the column) and &#X2019;w&#X2019; is the width of a
unit string within the column. Thus if the column has TFORM =
&#X2019;60A12&#X2019; then this means that each row of the table contains
5 12-character substrings within the 60-character field, and thus 
in this case this routine will return typecode = TSTRING, repeat =
60, and width = 12. The number of substings in any binary table
character string field can be calculated by (repeat/width). 
A null pointer may be given for any of the output parameters that
are not needed.</P><PRE CLASS="verbatim">____________________________________________________________________________
int fits_insert_rows(fitsfile *fptr, long firstrow, long nrows, int *status)
int fits_delete_rows(fitsfile *fptr, long firstrow, long nrows, int *status)
int fits_delete_rowrange(fitsfile *fptr, char *rangelist, int *status)
int fits_delete_rowlist(fitsfile *fptr, long *rowlist, long nrows, int *stat)
</PRE><P>Insert or delete rows in a table. The blank rows are inserted
immediately following row <TT>frow</TT>. Set <TT>frow</TT> = 0 to insert rows
at the beginning of the table. The first &#X2019;delete&#X2019; routine deletes <TT>nrows</TT> rows beginning with row <TT>firstrow</TT>. The 2nd delete routine
takes an input string listing the rows or row ranges to be deleted
(e.g., &#X2019;2,4-7, 9-12&#X2019;). The last delete routine takes an input long
integer array that specifies each individual row to be deleted. The
row lists must be sorted in ascending order. All these routines update
the value of the <TT>NAXIS2</TT> keyword to reflect the new number of rows
in the table.</P><PRE CLASS="verbatim">_________________________________________________________________________
int fits_insert_col(fitsfile *fptr, int colnum, char *ttype, char *tform,
                    int *status)
int fits_insert_cols(fitsfile *fptr, int colnum, int ncols, char **ttype,
                     char **tform, int *status)

int fits_delete_col(fitsfile *fptr, int colnum, int *status)
</PRE><P>Insert or delete columns in a table. <TT>colnum</TT> gives the position
of the column to be inserted or deleted (where the first column of the
table is at position 1). <TT>ttype</TT> and <TT>tform</TT> give the column
name and column format, where the allowed format codes are listed above
in the description of the <TT>fits_create_table</TT> routine. The 2nd
&#X2019;insert&#X2019; routine inserts multiple columns, where <TT>ncols</TT> is the
number of columns to insert, and <TT>ttype</TT> and <TT>tform</TT> are
arrays of string pointers in this case.</P><PRE CLASS="verbatim">____________________________________________________________________
int fits_copy_col(fitsfile *infptr, fitsfile *outfptr, int incolnum,
        int outcolnum, int create_col, int *status);
</PRE><P>Copy a column from one table HDU to another. If <TT>create_col</TT> = TRUE (i.e., not equal to zero),
then a new column will be inserted in the output table at position
<TT>outcolumn</TT>, otherwise the values in the existing output column will be
overwritten. </P><PRE CLASS="verbatim">__________________________________________________________________________
int fits_write_col(fitsfile *fptr, int datatype, int colnum, long firstrow,
                  long firstelem, long nelements, void *array, int *status)
int fits_write_colnull(fitsfile *fptr, int datatype, int colnum, 
                  long firstrow, long firstelem, long nelements, 
                  void *array, void *nulval, int *status)
int fits_write_col_null(fitsfile *fptr, int colnum, long firstrow,
                  long firstelem, long nelements, int *status)

int fits_read_col(fitsfile *fptr, int datatype, int colnum, long firstrow,
       long firstelem, long nelements, void *nulval, void *array, 
       int *anynul, int *status)

</PRE><P>Write or read elements in column number <TT>colnum</TT>, starting with row
<TT>firstsrow</TT> and element <TT>firstelem</TT> (if it is a vector
column). <TT>firstelem</TT> is ignored if it is a scalar column. The <TT>nelements</TT> number of elements are read or written continuing on
successive rows of the table if necessary. <TT>array</TT> is the address
of an array which either contains the values to be written, or will
hold the returned values that are read. When reading, <TT>array</TT> must
have been allocated large enough to hold all the returned values.</P><P>There are 3 different &#X2019;write&#X2019; column routines: The first simply writes
the input array into the column. The second is similar, except that it
substitutes the appropriate null pixel value in the column for any
input array values which are equal to <TT>*nulval</TT> (note that this
parameter gives the address of the null pixel value, not the value
itself). The third write routine sets the specified table elements
to a null value. New rows will be automatical added to the table
if the write operation extends beyond the current size of the table.</P><P>When reading a column, CFITSIO will substitute the value given by <TT>nulval</TT> for any undefined elements in the FITS column, unless <TT>nulval</TT> or <TT>*nulval = NULL</TT>, in which case no checks will be made
for undefined values when reading the column.</P><P><TT>datatype</TT> specifies the datatype of the C <TT>array</TT> in the program,
which need not be the same as the intrinsic datatype of the column in
the FITS table. The following symbolic constants are allowed for the
value of <TT>datatype</TT>:</P><PRE CLASS="verbatim">  TSTRING   array of character string pointers
  TBYTE     unsigned char
  TSHORT    signed short
  TUSHORT   unsigned short
  TINT      signed int
  TUINT     unsigned int
  TLONG     signed long
  TLONGLONG signed 8-byte integer
  TULONG    unsigned long
  TFLOAT    float
  TDOUBLE   double
</PRE><P>Note that <TT>TSTRING</TT> corresponds to the C <TT>char**</TT> datatype, i.e., a pointer to an array of pointers to an array
of characters.</P><P>Any column, regardless of it&#X2019;s intrinsic datatype, may be read as a
<TT>TSTRING</TT> character string. The display format of the returned
strings will be determined by the <TT>TDISPn</TT> keyword, if it exists,
otherwise a default format will be used depending on the datatype of
the column. The <TT>tablist</TT> example utility program (available from
the CFITSIO web site) uses this feature to display all the values in a
FITS table.</P><PRE CLASS="verbatim">_____________________________________________________________________
int fits_select_rows(fitsfile *infptr, fitsfile *outfptr, char *expr,
                     int *status)
int fits_calculator(fitsfile *infptr, char *expr, fitsfile *outfptr,
                    char *colname, char *tform, int *status) 
</PRE><P>These are 2 of the most powerful routines in the CFITSIO library. (See
the full CFITSIO Reference Guide for a description of several related
routines). These routines can perform complicated transformations on
tables based on an input arithmetic expression which is evaluated for
each row of the table. The first routine will select or copy rows of
the table for which the expression evaluates to TRUE (i.e., not equal
to zero). The second routine writes the value of the expression to a
column in the output table. Rather than supplying the expression
directly to these routines, the expression may also be written to a
text file (continued over multiple lines if necessary) and the name of
the file, prepended with a &#X2019;@&#X2019; character, may be supplied as the value
of the &#X2019;expr&#X2019; parameter (e.g. &#X2019;@filename.txt&#X2019;).</P><P>The arithmetic expression may be a function of any column or keyword in
the input table as shown in these examples:</P><PRE CLASS="verbatim">Row Selection Expressions:
   counts &gt; 0                          uses COUNTS column value
   sqrt( X**2 + Y**2) &lt; 10.            uses X and Y column values
   (X &gt; 10) || (X &lt; -10) &amp;&amp; (Y == 0)   used 'or' and 'and' operators  
   gtifilter()                         filter on Good Time Intervals
   regfilter("myregion.reg")           filter using a region file
   @select.txt                         reads expression from a text file
Calculator Expressions:
   #row % 10                        modulus of the row number
   counts/#exposure                 Fn of COUNTS column and EXPOSURE keyword
   dec &lt; 85 ? cos(dec * #deg) : 0   Conditional expression: evaluates to
                                      cos(dec) if dec &lt; 85, else 0
   (count{-1}+count+count{+1})/3.   running mean of the count values in the
                                      previous, current, and next rows
   max(0, min(X, 1000))             returns a value between 0 - 1000
   @calc.txt                        reads expression from a text file
</PRE><P>Most standard mathematical operators and functions are supported. If
the expression includes the name of a column, than the value in the
current row of the table will be used when evaluating the expression on
each row. An offset to an adjacent row can be specified by including
the offset value in curly brackets after the column name as shown in
one of the examples. Keyword values can be included in the expression
by preceding the keyword name with a &#X2018;#&#X2019; sign. See Section 5 of this
document for more discussion of the expression syntax.</P><P><TT>gtifilter</TT> is a special function which tests whether the <TT>TIME</TT> column value in the input table falls within one or more Good
Time Intervals. By default, this function looks for a &#X2019;GTI&#X2019; extension
in the same file as the input table. The &#X2019;GTI&#X2019; table contains <TT>START</TT> 
and <TT>STOP</TT> columns which define the range of
each good time interval. See section 5.4.3 for more details.</P><P><TT>regfilter</TT> is another special function which selects rows based on
whether the spatial position associated with each row is located within
in a specified region of the sky. By default, the <TT>X</TT> and <TT>Y</TT>
columns in the input table are assumed to give the position of each row.
The spatial region is defined in an ASCII text file whose name is given
as the argument to the <TT>regfilter</TT> function. See section 5.4.4 for
more details.</P><P>The <TT>infptr</TT> and <TT>outfptr</TT> parameters in these routines may
point to the same table or to different tables. In <TT>fits_select_rows</TT>, if the input and output tables are the same then
the rows that do not satisfy the selection expression will be deleted
from the table. Otherwise, if the output table is different from the
input table then the selected rows will be copied from the input table
to the output table.</P><P>The output column in <TT>fits_calculator</TT> may or may not already
exist. If it exists then the calculated values will be written to that
column, overwriting the existing values. If the column doesn&#X2019;t exist
then the new column will be appended to the output table. The <TT>tform</TT>
parameter can be used to specify the datatype of the new column (e.g.,
the <TT>TFORM</TT> keyword value as in <TT>&#X2019;1E&#X2019;, or &#X2019;1J&#X2019;</TT>). If <TT>tform</TT> = NULL then a default datatype will be used, depending on the
expression.</P><PRE CLASS="verbatim">_____________________________________________________________________
int fits_read_tblbytes(fitsfile *fptr, long firstrow, long firstchar,
                     long nchars, unsigned char *array, int *status)
int fits_write_tblbytes (fitsfile *fptr, long firstrow, long firstchar,
                     long nchars, unsigned char *array, int *status)
</PRE><P>These 2 routines provide low-level access to tables and are mainly
useful as an efficient way to copy rows of a table from one file to
another. These routines simply read or write the specified number of
consecutive characters (bytes) in a table, without regard for column
boundaries. For example, to read or write the first row of a table,
set <TT>firstrow = 1, firstchar = 1</TT>, and <TT>nchars = NAXIS1</TT> where
the length of a row is given by the value of the <TT>NAXIS1</TT> header
keyword. When reading a table, <TT>array</TT> must have been declared at
least <TT>nchars</TT> bytes long to hold the returned string of bytes.</P><H3 CLASS="subsection"><A NAME="toc6"></A><A NAME="htoc10">4.6</A>&#XA0;&#XA0;Header Keyword I/O Routines</H3><P>
The following routines read and write header keywords in the current HDU.
</P><PRE CLASS="verbatim">____________________________________________________________________
int fits_get_hdrspace(fitsfile *fptr, int *keysexist, int *morekeys,
                      int *status)
</PRE><P>Return the number of existing keywords (not counting the mandatory END
keyword) and the amount of empty space currently available for more
keywords. The <TT>morekeys</TT> parameter may be set to NULL if it&#X2019;s value is
not needed.</P><PRE CLASS="verbatim">___________________________________________________________________________
int fits_read_record(fitsfile *fptr, int keynum, char *record, int *status)
int fits_read_card(fitsfile *fptr, char *keyname, char *record, int *status)
int fits_read_key(fitsfile *fptr, int datatype, char *keyname,
                  void *value, char *comment, int *status)

int fits_find_nextkey(fitsfile *fptr, char **inclist, int ninc,
                      char **exclist, int nexc, char *card, int *status)

int fits_read_key_unit(fitsfile *fptr, char *keyname, char *unit, 
                       int *status)
</PRE><P>These routines all read a header record in the current HDU. The first
routine reads keyword number <TT>keynum</TT> (where the first keyword is
at position 1). This routine is most commonly used when sequentially
reading every record in the header from beginning to end. The 2nd and
3rd routines read the named keyword and return either the whole
record, or the keyword value and comment string. In each case any 
non-significant trailing blank characters in the strings are truncated.</P><P>Wild card characters (*, ?, and #) may be used when specifying the name
of the keyword to be read, in which case the first matching keyword is
returned.</P><P>The <TT>datatype</TT> parameter specifies the C datatype of the returned
keyword value and can have one of the following symbolic constant
values: <TT>TSTRING, TLOGICAL</TT> (== int), <TT>TBYTE</TT>, <TT>TSHORT</TT>,
<TT>TUSHORT</TT>, <TT>TINT</TT>, <TT>TUINT</TT>, <TT>TLONG</TT>, <TT>TULONG</TT>, <TT>TFLOAT</TT>, <TT>TDOUBLE</TT>, <TT>TCOMPLEX</TT>, and <TT>TDBLCOMPLEX</TT>. Data
type conversion will be performed for numeric values if the intrinsic
FITS keyword value does not have the same datatype. The <TT>comment</TT>
parameter may be set equal to NULL if the comment string is not
needed.</P><P>The 4th routine provides an easy way to find all the keywords in the
header that match one of the name templates in <TT>inclist</TT> and do not
match any of the name templates in <TT>exclist</TT>. <TT>ninc</TT> and <TT>nexc</TT> are the number of template strings in <TT>inclist</TT> and <TT>exclist</TT>, respectively. Wild cards (*, ?, and #) may be used in the
templates to match multiple keywords. Each time this routine is called
it returns the next matching 80-byte keyword record. It returns status
= <TT>KEY_NO_EXIST</TT> if there are no more matches.</P><P>The 5th routine returns the keyword value units string, if any.
The units are recorded at the beginning of the keyword comment field
enclosed in square brackets.
</P><PRE CLASS="verbatim">_______________________________________________________________
int fits_write_key(fitsfile *fptr, int datatype, char *keyname, 
        void *value, char *comment, int *status)
int fits_update_key(fitsfile *fptr, int datatype, char *keyname,
        void *value, char *comment, int *status)
int fits_write_record(fitsfile *fptr, char *card, int *status)

int fits_modify_comment(fitsfile *fptr, char *keyname, char *comment,
        int *status)
int fits_write_key_unit(fitsfile *fptr, char *keyname, char *unit,
        int *status)

</PRE><P>Write or modify a keyword in the header of the current HDU. The
first routine appends the new keyword to the end of the header, whereas
the second routine will update the value and comment fields of the
keyword if it already exists, otherwise it behaves like the first
routine and appends the new keyword. Note that <TT>value</TT> gives the
address to the value and not the value itself. The <TT>datatype</TT>
parameter specifies the C datatype of the keyword value and may have
any of the values listed in the description of the keyword reading
routines, above. A NULL may be entered for the comment parameter, in
which case the keyword comment field will be unmodified or left
blank.</P><P>The third routine is more primitive and simply writes the 80-character
<TT>card</TT> record to the header. It is the programmer&#X2019;s responsibility
in this case to ensure that the record conforms to all the FITS format
requirements for a header record.</P><P>The fourth routine modifies the comment string in an existing keyword,
and the last routine writes or updates the keyword units string for an
existing keyword. (The units are recorded at the beginning of the
keyword comment field enclosed in square brackets).</P><PRE CLASS="verbatim">___________________________________________________________________
int fits_write_comment(fitsfile *fptr, char *comment,  int *status)
int fits_write_history(fitsfile *fptr, char *history,  int *status)
int fits_write_date(fitsfile *fptr,  int *status)
</PRE><P>Write a <TT>COMMENT, HISTORY</TT>, or <TT>DATE</TT> keyword to the current
header. The <TT>COMMENT</TT> keyword is typically used to write a comment
about the file or the data. The <TT>HISTORY</TT> keyword is typically
used to provide information about the history of the processing
procedures that have been applied to the data. The <TT>comment</TT> or
<TT>history</TT> string will be continued over multiple keywords if it is
more than 70 characters long.</P><P>The <TT>DATE</TT> keyword is used to record the date and time that the
FITS file was created. Note that this file creation date is usually
different from the date of the observation which obtained the data in
the FITS file. The <TT>DATE</TT> keyword value is a character string in
&#X2019;yyyy-mm-ddThh:mm:ss&#X2019; format. If a <TT>DATE</TT> keyword already exists in
the header, then this routine will update the value with the current
system date.</P><PRE CLASS="verbatim">___________________________________________________________________
int fits_delete_record(fitsfile *fptr, int keynum,  int *status)
int fits_delete_key(fitsfile *fptr, char *keyname,  int *status)
</PRE><P>Delete a keyword record. The first routine deletes a keyword at a
specified position (the first keyword is at position 1, not 0),
whereas the second routine deletes the named keyword.</P><PRE CLASS="verbatim">_______________________________________________________________________
int fits_copy_header(fitsfile *infptr, fitsfile *outfptr,  int *status)
</PRE><P>Copy all the header keywords from the current HDU associated with
infptr to the current HDU associated with outfptr. If the current
output HDU is not empty, then a new HDU will be appended to the output
file. The output HDU will then have the identical structure as the
input HDU, but will contain no data.</P><H3 CLASS="subsection"><A NAME="toc7"></A><A NAME="htoc11">4.7</A>&#XA0;&#XA0;Utility Routines</H3><P>This section lists the most important CFITSIO general utility routines.</P><PRE CLASS="verbatim">___________________________________________________________________
int fits_write_chksum( fitsfile *fptr, int *status)
int fits_verify_chksum(fitsfile *fptr, int *dataok, int *hduok, int *status)
</PRE><P>These routines compute or validate the checksums for the currenrt
HDU. The <TT>DATASUM</TT> keyword is used to store the numerical value of
the 32-bit, 1&#X2019;s complement checksum for the data unit alone. The <TT>CHECKSUM</TT> keyword is used to store the ASCII encoded COMPLEMENT of the
checksum for the entire HDU. Storing the complement, rather than the
actual checksum, forces the checksum for the whole HDU to equal zero.
If the file has been modified since the checksums were computed, then
the HDU checksum will usually not equal zero.</P><P>The returned <TT>dataok</TT> and <TT>hduok</TT> parameters will have a value
= 1 if the data or HDU is verified correctly, a value = 0 if the
<TT>DATASUM</TT> or <TT>CHECKSUM</TT> keyword is not present, or value = -1 if the
computed checksum is not correct.</P><PRE CLASS="verbatim">___________________________________________________________________
int fits_parse_value(char *card, char *value, char *comment, int *status)
int fits_get_keytype(char *value, char *dtype, int *status)
int fits_get_keyclass(char *card)
int fits_parse_template(char *template, char *card, int *keytype, int *status)

</PRE><P><TT>fits_parse_value</TT> parses the input 80-chararacter header keyword record, returning
the value (as a literal character string) and comment strings. If the
keyword has no value (columns 9-10 not equal to &#X2019;= &#X2019;), then a null
value string is returned and the comment string is set equal to column
9 - 80 of the input string.</P><P><TT>fits_get_keytype</TT> parses the keyword value string to determine its
datatype. <TT>dtype</TT> returns with a value of &#X2019;C&#X2019;, &#X2019;L&#X2019;, &#X2019;I&#X2019;, &#X2019;F&#X2019; or
&#X2019;X&#X2019;, for character string, logical, integer, floating point, or
complex, respectively.</P><P><TT>fits_get_keyclass</TT> returns a classification code that indicates
the classification type of the input keyword record (e.g., a required
structural keyword, a TDIM keyword, a WCS keyword, a comment keyword,
etc. See the CFITSIO Reference Guide for a list of the different
classification codes.</P><P><TT>fits_parse_template</TT> takes an input free format keyword template
string and returns a formatted 80*char record that satisfies all the
FITS requirements for a header keyword record. The template should
generally contain 3 tokens: the keyword name, the keyword value, and
the keyword comment string. The returned <TT>keytype</TT> parameter
indicates whether the keyword is a COMMENT keyword or not. See the
CFITSIO Reference Guide for more details.</P><HR>
<A HREF="quick004.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="quick006.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
